<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Visual Computing Library: vcl::comp::AdjacentEdges&lt; Edge, N, ElementType, optional &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
       <script type="text/javascript">
           DoxygenAwesomeDarkModeToggle.init()
       </script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Visual Computing Library
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classvcl_1_1comp_1_1AdjacentEdges.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="classvcl_1_1comp_1_1AdjacentEdges-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">vcl::comp::AdjacentEdges&lt; Edge, N, ElementType, optional &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>The <a class="el" href="classvcl_1_1comp_1_1AdjacentEdges.html" title="The AdjacentEdges class is a container of Edge references. It could be used by any Element to save ad...">AdjacentEdges</a> class is a container of <a class="el" href="classvcl_1_1Edge.html">Edge</a> references. It could be used by any <a class="el" href="classvcl_1_1Element.html">Element</a> to save adjacencies information (also the <a class="el" href="classvcl_1_1Edge.html">Edge</a> element itself).  
 <a href="classvcl_1_1comp_1_1AdjacentEdges.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="mesh_2components_2adjacent__edges_8h_source.html">adjacent_edges.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for vcl::comp::AdjacentEdges&lt; Edge, N, ElementType, optional &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classvcl_1_1comp_1_1AdjacentEdges__inherit__graph.png" border="0" usemap="#avcl_1_1comp_1_1AdjacentEdges_3_01Edge_00_01N_00_01ElementType_00_01optional_01_4_inherit__map" alt="Inheritance graph"/></div>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for vcl::comp::AdjacentEdges&lt; Edge, N, ElementType, optional &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classvcl_1_1comp_1_1AdjacentEdges__coll__graph.png" border="0" usemap="#avcl_1_1comp_1_1AdjacentEdges_3_01Edge_00_01N_00_01ElementType_00_01optional_01_4_coll__map" alt="Collaboration graph"/></div>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a5e301e37f8864b2d371cb54f91113df7"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1comp_1_1AdjacentEdges.html#a5e301e37f8864b2d371cb54f91113df7">DataValueType</a> = typename <a class="el" href="classvcl_1_1RandomAccessContainer.html">Base::DataValueType</a></td></tr>
<tr class="separator:a5e301e37f8864b2d371cb54f91113df7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeec8fd4c7ac55e0404a6dd91b201839b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1comp_1_1AdjacentEdges.html#aeec8fd4c7ac55e0404a6dd91b201839b">AdjacentEdgesComponent</a> = <a class="el" href="classvcl_1_1comp_1_1AdjacentEdges.html">ThisType</a></td></tr>
<tr class="separator:aeec8fd4c7ac55e0404a6dd91b201839b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae651c8fb80b01a4ceb446b64aa22ed40"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1comp_1_1AdjacentEdges.html#ae651c8fb80b01a4ceb446b64aa22ed40">AdjacentEdgeType</a> = <a class="el" href="classvcl_1_1Edge.html">Edge</a></td></tr>
<tr class="separator:ae651c8fb80b01a4ceb446b64aa22ed40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af61e59b3299d00e08e9fd72c416e6a6a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1comp_1_1AdjacentEdges.html#af61e59b3299d00e08e9fd72c416e6a6a">AdjacentEdgeIterator</a> = typename Base::Iterator</td></tr>
<tr class="separator:af61e59b3299d00e08e9fd72c416e6a6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adff732312c835c4481a838f87d6e8418"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1comp_1_1AdjacentEdges.html#adff732312c835c4481a838f87d6e8418">ConstAdjacentEdgeIterator</a> = typename Base::ConstIterator</td></tr>
<tr class="separator:adff732312c835c4481a838f87d6e8418"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ca344a9855ca8ff1f48816fa5ce7fda"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1comp_1_1AdjacentEdges.html#a7ca344a9855ca8ff1f48816fa5ce7fda">AdjacentEdgeView</a> = <a class="el" href="classvcl_1_1View.html">vcl::View</a>&lt; <a class="el" href="classvcl_1_1comp_1_1AdjacentEdges.html#af61e59b3299d00e08e9fd72c416e6a6a">AdjacentEdgeIterator</a> &gt;</td></tr>
<tr class="separator:a7ca344a9855ca8ff1f48816fa5ce7fda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12fdb621ee8008c1f1dd0d9c7470b209"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1comp_1_1AdjacentEdges.html#a12fdb621ee8008c1f1dd0d9c7470b209">ConstAdjacentEdgeView</a> = <a class="el" href="classvcl_1_1View.html">vcl::View</a>&lt; <a class="el" href="classvcl_1_1comp_1_1AdjacentEdges.html#adff732312c835c4481a838f87d6e8418">ConstAdjacentEdgeIterator</a> &gt;</td></tr>
<tr class="separator:a12fdb621ee8008c1f1dd0d9c7470b209"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a1dcd43e2827d2cd4c7dc579d67c77003"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1comp_1_1AdjacentEdges.html#a1dcd43e2827d2cd4c7dc579d67c77003">init</a> ()</td></tr>
<tr class="separator:a1dcd43e2827d2cd4c7dc579d67c77003"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25e05af749183e8ed9661403bcf3c743"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1comp_1_1AdjacentEdges.html#a25e05af749183e8ed9661403bcf3c743">isEnabled</a> () const</td></tr>
<tr class="separator:a25e05af749183e8ed9661403bcf3c743"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bca7ba5837c8843283c756a0c8ddbac"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1comp_1_1AdjacentEdges.html#a9bca7ba5837c8843283c756a0c8ddbac">isAdjEdgesEnabled</a> () const</td></tr>
<tr class="separator:a9bca7ba5837c8843283c756a0c8ddbac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac92e829ef4a594b60249c038c9cf2de7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1comp_1_1AdjacentEdges.html#ac92e829ef4a594b60249c038c9cf2de7">adjEdgesNumber</a> () const</td></tr>
<tr class="memdesc:ac92e829ef4a594b60249c038c9cf2de7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of adjacent edges of this element.  <br /></td></tr>
<tr class="separator:ac92e829ef4a594b60249c038c9cf2de7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac605d2bba4f65ec036507d0e00661871"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Edge.html">Edge</a> *&amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1comp_1_1AdjacentEdges.html#ac605d2bba4f65ec036507d0e00661871">adjEdge</a> (<a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> i)</td></tr>
<tr class="memdesc:ac605d2bba4f65ec036507d0e00661871"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference of the pointer to the i-th adjacent edge of this element.  <br /></td></tr>
<tr class="separator:ac605d2bba4f65ec036507d0e00661871"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a076d6a42a84f38b8bee21e2dc1d61c69"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classvcl_1_1Edge.html">Edge</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1comp_1_1AdjacentEdges.html#a076d6a42a84f38b8bee21e2dc1d61c69">adjEdge</a> (<a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> i) const</td></tr>
<tr class="memdesc:a076d6a42a84f38b8bee21e2dc1d61c69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const pointer to the i-th adjacent edge of this element.  <br /></td></tr>
<tr class="separator:a076d6a42a84f38b8bee21e2dc1d61c69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14d39acb59790c07f5aedd8efafdddb2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Edge.html">Edge</a> *&amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1comp_1_1AdjacentEdges.html#a14d39acb59790c07f5aedd8efafdddb2">adjEdgeMod</a> (int i)</td></tr>
<tr class="memdesc:a14d39acb59790c07f5aedd8efafdddb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference of the pointer to the i-th adjacent edge of this element but using as index the module between i and the number of adjacent edges. You can use this function if you need to get the "next adjacent edge after position k", without check if it is less than the number of adj edges. Works also for negative numbers:  <br /></td></tr>
<tr class="separator:a14d39acb59790c07f5aedd8efafdddb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a326df62e6586fe1bb4e0a6280811eb96"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classvcl_1_1Edge.html">Edge</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1comp_1_1AdjacentEdges.html#a326df62e6586fe1bb4e0a6280811eb96">adjEdgeMod</a> (int i) const</td></tr>
<tr class="memdesc:a326df62e6586fe1bb4e0a6280811eb96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same of adjEdgeMod, but returns a const Pointer to the adjacent edge.  <br /></td></tr>
<tr class="separator:a326df62e6586fe1bb4e0a6280811eb96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65a5e04482eed7904724f77d7df8b5fb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1comp_1_1AdjacentEdges.html#a65a5e04482eed7904724f77d7df8b5fb">setAdjEdge</a> (<a class="el" href="classvcl_1_1Edge.html">Edge</a> *f, <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> i)</td></tr>
<tr class="memdesc:a65a5e04482eed7904724f77d7df8b5fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the i-th adjacent edge of this element.  <br /></td></tr>
<tr class="separator:a65a5e04482eed7904724f77d7df8b5fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91c4872f665dac1956d04a8fdc13fc52"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1comp_1_1AdjacentEdges.html#a91c4872f665dac1956d04a8fdc13fc52">setAdjEdges</a> (const std::vector&lt; <a class="el" href="classvcl_1_1Edge.html">Edge</a> * &gt; &amp;list)</td></tr>
<tr class="memdesc:a91c4872f665dac1956d04a8fdc13fc52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets all the adjacent edges of this element.  <br /></td></tr>
<tr class="separator:a91c4872f665dac1956d04a8fdc13fc52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd6210bbf859464f51db70ae2df91a9c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1comp_1_1AdjacentEdges.html#abd6210bbf859464f51db70ae2df91a9c">containsAdjEdge</a> (const <a class="el" href="classvcl_1_1Edge.html">Edge</a> *e) const</td></tr>
<tr class="separator:abd6210bbf859464f51db70ae2df91a9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeeffb7f81b0e6e5aed1e2ab5540c5be2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1comp_1_1AdjacentEdges.html#af61e59b3299d00e08e9fd72c416e6a6a">AdjacentEdgeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1comp_1_1AdjacentEdges.html#aeeffb7f81b0e6e5aed1e2ab5540c5be2">findAdjEdge</a> (const <a class="el" href="classvcl_1_1Edge.html">Edge</a> *e)</td></tr>
<tr class="separator:aeeffb7f81b0e6e5aed1e2ab5540c5be2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdc3bcd8d618a158f97ca5dd5204c68a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1comp_1_1AdjacentEdges.html#adff732312c835c4481a838f87d6e8418">ConstAdjacentEdgeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1comp_1_1AdjacentEdges.html#afdc3bcd8d618a158f97ca5dd5204c68a">findAdjEdge</a> (const <a class="el" href="classvcl_1_1Edge.html">Edge</a> *e) const</td></tr>
<tr class="separator:afdc3bcd8d618a158f97ca5dd5204c68a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4899624c9ab68fbfc5e701db6b01095e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1comp_1_1AdjacentEdges.html#a4899624c9ab68fbfc5e701db6b01095e">indexOfAdjEdge</a> (const <a class="el" href="classvcl_1_1Edge.html">Edge</a> *e) const</td></tr>
<tr class="separator:a4899624c9ab68fbfc5e701db6b01095e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3be18acabf4e2f5478e050d0d975accd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1comp_1_1AdjacentEdges.html#a3be18acabf4e2f5478e050d0d975accd">resizeAdjEdges</a> (<a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> n)</td></tr>
<tr class="memdesc:a3be18acabf4e2f5478e050d0d975accd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resize the container of the adjacent edges to the given size.  <br /></td></tr>
<tr class="separator:a3be18acabf4e2f5478e050d0d975accd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2825367ad9f8f33d8f107da270331f1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1comp_1_1AdjacentEdges.html#aa2825367ad9f8f33d8f107da270331f1">pushAdjEdge</a> (<a class="el" href="classvcl_1_1Edge.html">Edge</a> *e)</td></tr>
<tr class="separator:aa2825367ad9f8f33d8f107da270331f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a9657dcce5de9e571e211e2336e4e99"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1comp_1_1AdjacentEdges.html#a4a9657dcce5de9e571e211e2336e4e99">insertAdjEdge</a> (<a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> i, <a class="el" href="classvcl_1_1Edge.html">Edge</a> *e)</td></tr>
<tr class="separator:a4a9657dcce5de9e571e211e2336e4e99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa06d54270ca8713cd12424d6d936568e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1comp_1_1AdjacentEdges.html#aa06d54270ca8713cd12424d6d936568e">eraseAdjEdge</a> (<a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> i)</td></tr>
<tr class="separator:aa06d54270ca8713cd12424d6d936568e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35bf380dbf59c895370bae8b32635abf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1comp_1_1AdjacentEdges.html#a35bf380dbf59c895370bae8b32635abf">clearAdjEdges</a> ()</td></tr>
<tr class="separator:a35bf380dbf59c895370bae8b32635abf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91a78417a635a8a4111dea33cdf68c64"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1comp_1_1AdjacentEdges.html#af61e59b3299d00e08e9fd72c416e6a6a">AdjacentEdgeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1comp_1_1AdjacentEdges.html#a91a78417a635a8a4111dea33cdf68c64">adjEdgeBegin</a> ()</td></tr>
<tr class="separator:a91a78417a635a8a4111dea33cdf68c64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29c4cb934e5ceb041b5f0377b8507903"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1comp_1_1AdjacentEdges.html#af61e59b3299d00e08e9fd72c416e6a6a">AdjacentEdgeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1comp_1_1AdjacentEdges.html#a29c4cb934e5ceb041b5f0377b8507903">adjEdgeEnd</a> ()</td></tr>
<tr class="separator:a29c4cb934e5ceb041b5f0377b8507903"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf552f5554587309de23f97131655c56"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1comp_1_1AdjacentEdges.html#adff732312c835c4481a838f87d6e8418">ConstAdjacentEdgeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1comp_1_1AdjacentEdges.html#acf552f5554587309de23f97131655c56">adjEdgeBegin</a> () const</td></tr>
<tr class="separator:acf552f5554587309de23f97131655c56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9ad9feb73d7fcbf70b909ac4174e518"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1comp_1_1AdjacentEdges.html#adff732312c835c4481a838f87d6e8418">ConstAdjacentEdgeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1comp_1_1AdjacentEdges.html#ae9ad9feb73d7fcbf70b909ac4174e518">adjEdgeEnd</a> () const</td></tr>
<tr class="separator:ae9ad9feb73d7fcbf70b909ac4174e518"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a532602617ac191b5217b7d8636f6a527"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1comp_1_1AdjacentEdges.html#a7ca344a9855ca8ff1f48816fa5ce7fda">AdjacentEdgeView</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1comp_1_1AdjacentEdges.html#a532602617ac191b5217b7d8636f6a527">adjEdges</a> ()</td></tr>
<tr class="separator:a532602617ac191b5217b7d8636f6a527"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c5157ecaaa0a9abc7dd8036517e6cbd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1comp_1_1AdjacentEdges.html#a12fdb621ee8008c1f1dd0d9c7470b209">ConstAdjacentEdgeView</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1comp_1_1AdjacentEdges.html#a9c5157ecaaa0a9abc7dd8036517e6cbd">adjEdges</a> () const</td></tr>
<tr class="separator:a9c5157ecaaa0a9abc7dd8036517e6cbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a621ae71ab92519ea81f049d9434c9648"><td class="memItemLeft" align="right" valign="top">static const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1comp_1_1AdjacentEdges.html#a621ae71ab92519ea81f049d9434c9648">IS_VERTICAL</a> = !std::is_same_v&lt;<a class="el" href="namespacevcl.html#ad79a41a614e99b6f2382637b8376123a">ElementType</a>, void&gt;</td></tr>
<tr class="separator:a621ae71ab92519ea81f049d9434c9648"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad116d81ccff4ff9a935801c481f340da"><td class="memItemLeft" align="right" valign="top">static const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1comp_1_1AdjacentEdges.html#ad116d81ccff4ff9a935801c481f340da">IS_OPTIONAL</a> = optional</td></tr>
<tr class="separator:ad116d81ccff4ff9a935801c481f340da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86ad1783442be1b0e61c4c6dc81d81cc"><td class="memItemLeft" align="right" valign="top">static const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1comp_1_1AdjacentEdges.html#a86ad1783442be1b0e61c4c6dc81d81cc">ADJ_EDGE_NUMBER</a> = Base::CONTAINER_SIZE</td></tr>
<tr class="separator:a86ad1783442be1b0e61c4c6dc81d81cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a8d3cf6f95653f5c9edc31f474e9d573f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1comp_1_1AdjacentEdges.html#a8d3cf6f95653f5c9edc31f474e9d573f">updateReferences</a> (const <a class="el" href="classvcl_1_1Edge.html">Edge</a> *oldBase, const <a class="el" href="classvcl_1_1Edge.html">Edge</a> *newBase)</td></tr>
<tr class="separator:a8d3cf6f95653f5c9edc31f474e9d573f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac07e4241d1c20928a48a64ab991c9e1d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1comp_1_1AdjacentEdges.html#ac07e4241d1c20928a48a64ab991c9e1d">updateReferencesAfterCompact</a> (const <a class="el" href="classvcl_1_1Edge.html">Edge</a> *base, const std::vector&lt; int &gt; &amp;newIndices)</td></tr>
<tr class="separator:ac07e4241d1c20928a48a64ab991c9e1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcc0f022976be29aec4b9f7b625b31c4"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="classvcl_1_1Element.html">Element</a> &gt; </td></tr>
<tr class="memitem:afcc0f022976be29aec4b9f7b625b31c4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvcl_1_1comp_1_1AdjacentEdges.html#afcc0f022976be29aec4b9f7b625b31c4">importFrom</a> (const <a class="el" href="classvcl_1_1Element.html">Element</a> &amp;e)</td></tr>
<tr class="separator:afcc0f022976be29aec4b9f7b625b31c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2897f9f77c0d72089f74bd226530f7cd"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="classvcl_1_1Element.html">Element</a> , typename ElEType &gt; </td></tr>
<tr class="memitem:a2897f9f77c0d72089f74bd226530f7cd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvcl_1_1comp_1_1AdjacentEdges.html#a2897f9f77c0d72089f74bd226530f7cd">importReferencesFrom</a> (const <a class="el" href="classvcl_1_1Element.html">Element</a> &amp;e, <a class="el" href="classvcl_1_1Edge.html">Edge</a> *base, const ElEType *ebase)</td></tr>
<tr class="separator:a2897f9f77c0d72089f74bd226530f7cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename <a class="el" href="classvcl_1_1Edge.html">Edge</a>, int N, typename <a class="el" href="namespacevcl.html#ad79a41a614e99b6f2382637b8376123a">ElementType</a> = void, bool optional = false&gt;<br />
class vcl::comp::AdjacentEdges&lt; Edge, N, ElementType, optional &gt;</div><p>The <a class="el" href="classvcl_1_1comp_1_1AdjacentEdges.html" title="The AdjacentEdges class is a container of Edge references. It could be used by any Element to save ad...">AdjacentEdges</a> class is a container of <a class="el" href="classvcl_1_1Edge.html">Edge</a> references. It could be used by any <a class="el" href="classvcl_1_1Element.html">Element</a> to save adjacencies information (also the <a class="el" href="classvcl_1_1Edge.html">Edge</a> element itself). </p>
<p>It is a random access container having static or dynamic size, depending on the value of N (a negative number means dynamic).</p>
<p>The member functions of this class will be available in the instance of any <a class="el" href="classvcl_1_1Element.html">Element</a> that will contain this component.</p>
<p>For example, if you have a <a class="el" href="classvcl_1_1Vertex.html">Vertex</a> <a class="el" href="classvcl_1_1Element.html">Element</a> <code>v</code> that has the <a class="el" href="classvcl_1_1comp_1_1AdjacentEdges.html" title="The AdjacentEdges class is a container of Edge references. It could be used by any Element to save ad...">AdjacentEdges</a> component, you'll be able to access to this component member functions from <code>v</code>:</p>
<div class="fragment"><div class="line">v.adjEdgesNumber();</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>If this component is part of a <a class="el" href="classvcl_1_1Face.html">Face</a> <a class="el" href="classvcl_1_1Element.html">Element</a>, the number of Adjacent Edges is tied to the <a class="el" href="classvcl_1_1Vertex.html">Vertex</a> Number of the <a class="el" href="classvcl_1_1Face.html">Face</a>, therefore all the members that allows to modify the number of Adjacent Edges in case of dynamic size won't be available on <a class="el" href="classvcl_1_1Face.html">Face</a> Elements. </dd></dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="af61e59b3299d00e08e9fd72c416e6a6a" name="af61e59b3299d00e08e9fd72c416e6a6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af61e59b3299d00e08e9fd72c416e6a6a">&#9670;&#160;</a></span>AdjacentEdgeIterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classvcl_1_1Edge.html">Edge</a> , int N, typename <a class="el" href="namespacevcl.html#ad79a41a614e99b6f2382637b8376123a">ElementType</a>  = void, bool optional = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classvcl_1_1comp_1_1AdjacentEdges.html">vcl::comp::AdjacentEdges</a>&lt; <a class="el" href="classvcl_1_1Edge.html">Edge</a>, N, <a class="el" href="namespacevcl.html#ad79a41a614e99b6f2382637b8376123a">ElementType</a>, optional &gt;::AdjacentEdgeIterator =  typename Base::Iterator</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aeec8fd4c7ac55e0404a6dd91b201839b" name="aeec8fd4c7ac55e0404a6dd91b201839b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeec8fd4c7ac55e0404a6dd91b201839b">&#9670;&#160;</a></span>AdjacentEdgesComponent</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classvcl_1_1Edge.html">Edge</a> , int N, typename <a class="el" href="namespacevcl.html#ad79a41a614e99b6f2382637b8376123a">ElementType</a>  = void, bool optional = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classvcl_1_1comp_1_1AdjacentEdges.html">vcl::comp::AdjacentEdges</a>&lt; <a class="el" href="classvcl_1_1Edge.html">Edge</a>, N, <a class="el" href="namespacevcl.html#ad79a41a614e99b6f2382637b8376123a">ElementType</a>, optional &gt;::AdjacentEdgesComponent =  <a class="el" href="classvcl_1_1comp_1_1AdjacentEdges.html">ThisType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae651c8fb80b01a4ceb446b64aa22ed40" name="ae651c8fb80b01a4ceb446b64aa22ed40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae651c8fb80b01a4ceb446b64aa22ed40">&#9670;&#160;</a></span>AdjacentEdgeType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classvcl_1_1Edge.html">Edge</a> , int N, typename <a class="el" href="namespacevcl.html#ad79a41a614e99b6f2382637b8376123a">ElementType</a>  = void, bool optional = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classvcl_1_1comp_1_1AdjacentEdges.html">vcl::comp::AdjacentEdges</a>&lt; <a class="el" href="classvcl_1_1Edge.html">Edge</a>, N, <a class="el" href="namespacevcl.html#ad79a41a614e99b6f2382637b8376123a">ElementType</a>, optional &gt;::AdjacentEdgeType =  <a class="el" href="classvcl_1_1Edge.html">Edge</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7ca344a9855ca8ff1f48816fa5ce7fda" name="a7ca344a9855ca8ff1f48816fa5ce7fda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ca344a9855ca8ff1f48816fa5ce7fda">&#9670;&#160;</a></span>AdjacentEdgeView</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classvcl_1_1Edge.html">Edge</a> , int N, typename <a class="el" href="namespacevcl.html#ad79a41a614e99b6f2382637b8376123a">ElementType</a>  = void, bool optional = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classvcl_1_1comp_1_1AdjacentEdges.html">vcl::comp::AdjacentEdges</a>&lt; <a class="el" href="classvcl_1_1Edge.html">Edge</a>, N, <a class="el" href="namespacevcl.html#ad79a41a614e99b6f2382637b8376123a">ElementType</a>, optional &gt;::AdjacentEdgeView =  <a class="el" href="classvcl_1_1View.html">vcl::View</a>&lt;<a class="el" href="classvcl_1_1comp_1_1AdjacentEdges.html#af61e59b3299d00e08e9fd72c416e6a6a">AdjacentEdgeIterator</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="adff732312c835c4481a838f87d6e8418" name="adff732312c835c4481a838f87d6e8418"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adff732312c835c4481a838f87d6e8418">&#9670;&#160;</a></span>ConstAdjacentEdgeIterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classvcl_1_1Edge.html">Edge</a> , int N, typename <a class="el" href="namespacevcl.html#ad79a41a614e99b6f2382637b8376123a">ElementType</a>  = void, bool optional = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classvcl_1_1comp_1_1AdjacentEdges.html">vcl::comp::AdjacentEdges</a>&lt; <a class="el" href="classvcl_1_1Edge.html">Edge</a>, N, <a class="el" href="namespacevcl.html#ad79a41a614e99b6f2382637b8376123a">ElementType</a>, optional &gt;::ConstAdjacentEdgeIterator =  typename Base::ConstIterator</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a12fdb621ee8008c1f1dd0d9c7470b209" name="a12fdb621ee8008c1f1dd0d9c7470b209"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12fdb621ee8008c1f1dd0d9c7470b209">&#9670;&#160;</a></span>ConstAdjacentEdgeView</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classvcl_1_1Edge.html">Edge</a> , int N, typename <a class="el" href="namespacevcl.html#ad79a41a614e99b6f2382637b8376123a">ElementType</a>  = void, bool optional = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classvcl_1_1comp_1_1AdjacentEdges.html">vcl::comp::AdjacentEdges</a>&lt; <a class="el" href="classvcl_1_1Edge.html">Edge</a>, N, <a class="el" href="namespacevcl.html#ad79a41a614e99b6f2382637b8376123a">ElementType</a>, optional &gt;::ConstAdjacentEdgeView =  <a class="el" href="classvcl_1_1View.html">vcl::View</a>&lt;<a class="el" href="classvcl_1_1comp_1_1AdjacentEdges.html#adff732312c835c4481a838f87d6e8418">ConstAdjacentEdgeIterator</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5e301e37f8864b2d371cb54f91113df7" name="a5e301e37f8864b2d371cb54f91113df7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e301e37f8864b2d371cb54f91113df7">&#9670;&#160;</a></span>DataValueType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classvcl_1_1Edge.html">Edge</a> , int N, typename <a class="el" href="namespacevcl.html#ad79a41a614e99b6f2382637b8376123a">ElementType</a>  = void, bool optional = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classvcl_1_1comp_1_1AdjacentEdges.html">vcl::comp::AdjacentEdges</a>&lt; <a class="el" href="classvcl_1_1Edge.html">Edge</a>, N, <a class="el" href="namespacevcl.html#ad79a41a614e99b6f2382637b8376123a">ElementType</a>, optional &gt;::DataValueType =  typename <a class="el" href="classvcl_1_1RandomAccessContainer.html">Base::DataValueType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ac605d2bba4f65ec036507d0e00661871" name="ac605d2bba4f65ec036507d0e00661871"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac605d2bba4f65ec036507d0e00661871">&#9670;&#160;</a></span>adjEdge() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classvcl_1_1Edge.html">Edge</a> , int N, typename El , bool o&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Edge.html">Edge</a> *&amp; <a class="el" href="classvcl_1_1comp_1_1AdjacentEdges.html">vcl::comp::AdjacentEdges</a>&lt; <a class="el" href="classvcl_1_1Edge.html">Edge</a>, N, El, o &gt;::adjEdge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a reference of the pointer to the i-th adjacent edge of this element. </p>
<p>You can use this function to set the i-th adjacent edge:</p>
<div class="fragment"><div class="line">e.adjEdge(2) = &amp;m.edge(k); <span class="comment">// the second adj edge of e will point to the k-th edge of the mesh.</span></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>the position of the required adjacent edge in the container; the value must be between 0 and the number of adj edges. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The pointer to the i-th adjacent edge of this element. </dd></dl>

</div>
</div>
<a id="a076d6a42a84f38b8bee21e2dc1d61c69" name="a076d6a42a84f38b8bee21e2dc1d61c69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a076d6a42a84f38b8bee21e2dc1d61c69">&#9670;&#160;</a></span>adjEdge() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classvcl_1_1Edge.html">Edge</a> , int N, typename El , bool o&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classvcl_1_1Edge.html">Edge</a> * <a class="el" href="classvcl_1_1comp_1_1AdjacentEdges.html">vcl::comp::AdjacentEdges</a>&lt; <a class="el" href="classvcl_1_1Edge.html">Edge</a>, N, El, o &gt;::adjEdge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a const pointer to the i-th adjacent edge of this element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>the position of the required adjacent edge in the container; the value must be between 0 and the number of adj edges. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The pointer to the i-th adjacent edge of this element. </dd></dl>

</div>
</div>
<a id="a91a78417a635a8a4111dea33cdf68c64" name="a91a78417a635a8a4111dea33cdf68c64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91a78417a635a8a4111dea33cdf68c64">&#9670;&#160;</a></span>adjEdgeBegin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classvcl_1_1Edge.html">Edge</a> , int N, typename El , bool o&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1comp_1_1AdjacentEdges.html">AdjacentEdges</a>&lt; <a class="el" href="classvcl_1_1Edge.html">Edge</a>, N, El, o &gt;<a class="el" href="classvcl_1_1comp_1_1AdjacentEdges.html#af61e59b3299d00e08e9fd72c416e6a6a">::AdjacentEdgeIterator</a> <a class="el" href="classvcl_1_1comp_1_1AdjacentEdges.html">vcl::comp::AdjacentEdges</a>&lt; <a class="el" href="classvcl_1_1Edge.html">Edge</a>, N, El, o &gt;::adjEdgeBegin</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acf552f5554587309de23f97131655c56" name="acf552f5554587309de23f97131655c56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf552f5554587309de23f97131655c56">&#9670;&#160;</a></span>adjEdgeBegin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classvcl_1_1Edge.html">Edge</a> , int N, typename El , bool o&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1comp_1_1AdjacentEdges.html">AdjacentEdges</a>&lt; <a class="el" href="classvcl_1_1Edge.html">Edge</a>, N, El, o &gt;<a class="el" href="classvcl_1_1comp_1_1AdjacentEdges.html#adff732312c835c4481a838f87d6e8418">::ConstAdjacentEdgeIterator</a> <a class="el" href="classvcl_1_1comp_1_1AdjacentEdges.html">vcl::comp::AdjacentEdges</a>&lt; <a class="el" href="classvcl_1_1Edge.html">Edge</a>, N, El, o &gt;::adjEdgeBegin</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a29c4cb934e5ceb041b5f0377b8507903" name="a29c4cb934e5ceb041b5f0377b8507903"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29c4cb934e5ceb041b5f0377b8507903">&#9670;&#160;</a></span>adjEdgeEnd() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classvcl_1_1Edge.html">Edge</a> , int N, typename El , bool o&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1comp_1_1AdjacentEdges.html">AdjacentEdges</a>&lt; <a class="el" href="classvcl_1_1Edge.html">Edge</a>, N, El, o &gt;<a class="el" href="classvcl_1_1comp_1_1AdjacentEdges.html#af61e59b3299d00e08e9fd72c416e6a6a">::AdjacentEdgeIterator</a> <a class="el" href="classvcl_1_1comp_1_1AdjacentEdges.html">vcl::comp::AdjacentEdges</a>&lt; <a class="el" href="classvcl_1_1Edge.html">Edge</a>, N, El, o &gt;::adjEdgeEnd</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae9ad9feb73d7fcbf70b909ac4174e518" name="ae9ad9feb73d7fcbf70b909ac4174e518"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9ad9feb73d7fcbf70b909ac4174e518">&#9670;&#160;</a></span>adjEdgeEnd() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classvcl_1_1Edge.html">Edge</a> , int N, typename El , bool o&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1comp_1_1AdjacentEdges.html">AdjacentEdges</a>&lt; <a class="el" href="classvcl_1_1Edge.html">Edge</a>, N, El, o &gt;<a class="el" href="classvcl_1_1comp_1_1AdjacentEdges.html#adff732312c835c4481a838f87d6e8418">::ConstAdjacentEdgeIterator</a> <a class="el" href="classvcl_1_1comp_1_1AdjacentEdges.html">vcl::comp::AdjacentEdges</a>&lt; <a class="el" href="classvcl_1_1Edge.html">Edge</a>, N, El, o &gt;::adjEdgeEnd</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a14d39acb59790c07f5aedd8efafdddb2" name="a14d39acb59790c07f5aedd8efafdddb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14d39acb59790c07f5aedd8efafdddb2">&#9670;&#160;</a></span>adjEdgeMod() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classvcl_1_1Edge.html">Edge</a> , int N, typename El , bool o&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Edge.html">Edge</a> *&amp; <a class="el" href="classvcl_1_1comp_1_1AdjacentEdges.html">vcl::comp::AdjacentEdges</a>&lt; <a class="el" href="classvcl_1_1Edge.html">Edge</a>, N, El, o &gt;::adjEdgeMod </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a reference of the pointer to the i-th adjacent edge of this element but using as index the module between i and the number of adjacent edges. You can use this function if you need to get the "next adjacent edge after position k", without check if it is less than the number of adj edges. Works also for negative numbers: </p>
<div class="fragment"><div class="line">k = pos; <span class="comment">// some position of an adjacent edge</span></div>
<div class="line"><span class="keyword">auto</span>* next = e.adjEdgeMod(k+1); <span class="comment">// the adj edge next to k, that may also be at pos 0</span></div>
<div class="line"><span class="keyword">auto</span>* last = e.adjEdgeMod(-1); <span class="comment">// the adj edge in position adjEdgeNumber()-1</span></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>the position of the required adjacent edge in the container, w.r.t. the position 0; value is modularized on adjEdgeNumber(). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The pointer to the required adjacent edge of this element. </dd></dl>

</div>
</div>
<a id="a326df62e6586fe1bb4e0a6280811eb96" name="a326df62e6586fe1bb4e0a6280811eb96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a326df62e6586fe1bb4e0a6280811eb96">&#9670;&#160;</a></span>adjEdgeMod() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classvcl_1_1Edge.html">Edge</a> , int N, typename El , bool o&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classvcl_1_1Edge.html">Edge</a> * <a class="el" href="classvcl_1_1comp_1_1AdjacentEdges.html">vcl::comp::AdjacentEdges</a>&lt; <a class="el" href="classvcl_1_1Edge.html">Edge</a>, N, El, o &gt;::adjEdgeMod </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same of adjEdgeMod, but returns a const Pointer to the adjacent edge. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>the position of the required adjacent edge in the container, w.r.t. the position 0; value is modularized on adjEdgeNumber(). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The pointer to the required adjacent edge of this element. </dd></dl>

</div>
</div>
<a id="a532602617ac191b5217b7d8636f6a527" name="a532602617ac191b5217b7d8636f6a527"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a532602617ac191b5217b7d8636f6a527">&#9670;&#160;</a></span>adjEdges() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classvcl_1_1Edge.html">Edge</a> , int N, typename El , bool o&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1comp_1_1AdjacentEdges.html">AdjacentEdges</a>&lt; <a class="el" href="classvcl_1_1Edge.html">Edge</a>, N, El, o &gt;<a class="el" href="classvcl_1_1comp_1_1AdjacentEdges.html#a7ca344a9855ca8ff1f48816fa5ce7fda">::AdjacentEdgeView</a> <a class="el" href="classvcl_1_1comp_1_1AdjacentEdges.html">vcl::comp::AdjacentEdges</a>&lt; <a class="el" href="classvcl_1_1Edge.html">Edge</a>, N, El, o &gt;::adjEdges</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9c5157ecaaa0a9abc7dd8036517e6cbd" name="a9c5157ecaaa0a9abc7dd8036517e6cbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c5157ecaaa0a9abc7dd8036517e6cbd">&#9670;&#160;</a></span>adjEdges() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classvcl_1_1Edge.html">Edge</a> , int N, typename El , bool o&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1comp_1_1AdjacentEdges.html">AdjacentEdges</a>&lt; <a class="el" href="classvcl_1_1Edge.html">Edge</a>, N, El, o &gt;<a class="el" href="classvcl_1_1comp_1_1AdjacentEdges.html#a12fdb621ee8008c1f1dd0d9c7470b209">::ConstAdjacentEdgeView</a> <a class="el" href="classvcl_1_1comp_1_1AdjacentEdges.html">vcl::comp::AdjacentEdges</a>&lt; <a class="el" href="classvcl_1_1Edge.html">Edge</a>, N, El, o &gt;::adjEdges</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac92e829ef4a594b60249c038c9cf2de7" name="ac92e829ef4a594b60249c038c9cf2de7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac92e829ef4a594b60249c038c9cf2de7">&#9670;&#160;</a></span>adjEdgesNumber()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classvcl_1_1Edge.html">Edge</a> , int N, typename El , bool o&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> <a class="el" href="classvcl_1_1comp_1_1AdjacentEdges.html">vcl::comp::AdjacentEdges</a>&lt; <a class="el" href="classvcl_1_1Edge.html">Edge</a>, N, El, o &gt;::adjEdgesNumber</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of adjacent edges of this element. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of adjacent edges of this element. </dd></dl>

</div>
</div>
<a id="a35bf380dbf59c895370bae8b32635abf" name="a35bf380dbf59c895370bae8b32635abf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35bf380dbf59c895370bae8b32635abf">&#9670;&#160;</a></span>clearAdjEdges()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classvcl_1_1Edge.html">Edge</a> , int N, typename El , bool o&gt; <br />
requires (N &lt; 0)</div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classvcl_1_1comp_1_1AdjacentEdges.html">vcl::comp::AdjacentEdges</a>&lt; <a class="el" href="classvcl_1_1Edge.html">Edge</a>, N, El, o &gt;::clearAdjEdges</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abd6210bbf859464f51db70ae2df91a9c" name="abd6210bbf859464f51db70ae2df91a9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd6210bbf859464f51db70ae2df91a9c">&#9670;&#160;</a></span>containsAdjEdge()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classvcl_1_1Edge.html">Edge</a> , int N, typename El , bool o&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classvcl_1_1comp_1_1AdjacentEdges.html">vcl::comp::AdjacentEdges</a>&lt; <a class="el" href="classvcl_1_1Edge.html">Edge</a>, N, El, o &gt;::containsAdjEdge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvcl_1_1Edge.html">Edge</a> *&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa06d54270ca8713cd12424d6d936568e" name="aa06d54270ca8713cd12424d6d936568e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa06d54270ca8713cd12424d6d936568e">&#9670;&#160;</a></span>eraseAdjEdge()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classvcl_1_1Edge.html">Edge</a> , int N, typename El , bool o&gt; <br />
requires (N &lt; 0)</div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classvcl_1_1comp_1_1AdjacentEdges.html">vcl::comp::AdjacentEdges</a>&lt; <a class="el" href="classvcl_1_1Edge.html">Edge</a>, N, El, o &gt;::eraseAdjEdge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aeeffb7f81b0e6e5aed1e2ab5540c5be2" name="aeeffb7f81b0e6e5aed1e2ab5540c5be2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeeffb7f81b0e6e5aed1e2ab5540c5be2">&#9670;&#160;</a></span>findAdjEdge() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classvcl_1_1Edge.html">Edge</a> , int N, typename El , bool o&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1comp_1_1AdjacentEdges.html">AdjacentEdges</a>&lt; <a class="el" href="classvcl_1_1Edge.html">Edge</a>, N, El, o &gt;<a class="el" href="classvcl_1_1comp_1_1AdjacentEdges.html#af61e59b3299d00e08e9fd72c416e6a6a">::AdjacentEdgeIterator</a> <a class="el" href="classvcl_1_1comp_1_1AdjacentEdges.html">vcl::comp::AdjacentEdges</a>&lt; <a class="el" href="classvcl_1_1Edge.html">Edge</a>, N, El, o &gt;::findAdjEdge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvcl_1_1Edge.html">Edge</a> *&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afdc3bcd8d618a158f97ca5dd5204c68a" name="afdc3bcd8d618a158f97ca5dd5204c68a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdc3bcd8d618a158f97ca5dd5204c68a">&#9670;&#160;</a></span>findAdjEdge() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classvcl_1_1Edge.html">Edge</a> , int N, typename El , bool o&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1comp_1_1AdjacentEdges.html">AdjacentEdges</a>&lt; <a class="el" href="classvcl_1_1Edge.html">Edge</a>, N, El, o &gt;<a class="el" href="classvcl_1_1comp_1_1AdjacentEdges.html#adff732312c835c4481a838f87d6e8418">::ConstAdjacentEdgeIterator</a> <a class="el" href="classvcl_1_1comp_1_1AdjacentEdges.html">vcl::comp::AdjacentEdges</a>&lt; <a class="el" href="classvcl_1_1Edge.html">Edge</a>, N, El, o &gt;::findAdjEdge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvcl_1_1Edge.html">Edge</a> *&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afcc0f022976be29aec4b9f7b625b31c4" name="afcc0f022976be29aec4b9f7b625b31c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcc0f022976be29aec4b9f7b625b31c4">&#9670;&#160;</a></span>importFrom()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classvcl_1_1Edge.html">Edge</a> , int N, typename El , bool o&gt; </div>
<div class="memtemplate">
template&lt;typename <a class="el" href="classvcl_1_1Element.html">Element</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classvcl_1_1comp_1_1AdjacentEdges.html">vcl::comp::AdjacentEdges</a>&lt; <a class="el" href="classvcl_1_1Edge.html">Edge</a>, N, El, o &gt;::importFrom </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvcl_1_1Element.html">Element</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2897f9f77c0d72089f74bd226530f7cd" name="a2897f9f77c0d72089f74bd226530f7cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2897f9f77c0d72089f74bd226530f7cd">&#9670;&#160;</a></span>importReferencesFrom()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classvcl_1_1Edge.html">Edge</a> , int N, typename El , bool o&gt; </div>
<div class="memtemplate">
template&lt;typename <a class="el" href="classvcl_1_1Element.html">Element</a> , typename ElEType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classvcl_1_1comp_1_1AdjacentEdges.html">vcl::comp::AdjacentEdges</a>&lt; <a class="el" href="classvcl_1_1Edge.html">Edge</a>, N, El, o &gt;::importReferencesFrom </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvcl_1_1Element.html">Element</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Edge.html">Edge</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ElEType *&#160;</td>
          <td class="paramname"><em>ebase</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4899624c9ab68fbfc5e701db6b01095e" name="a4899624c9ab68fbfc5e701db6b01095e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4899624c9ab68fbfc5e701db6b01095e">&#9670;&#160;</a></span>indexOfAdjEdge()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classvcl_1_1Edge.html">Edge</a> , int N, typename El , bool o&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classvcl_1_1comp_1_1AdjacentEdges.html">vcl::comp::AdjacentEdges</a>&lt; <a class="el" href="classvcl_1_1Edge.html">Edge</a>, N, El, o &gt;::indexOfAdjEdge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvcl_1_1Edge.html">Edge</a> *&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1dcd43e2827d2cd4c7dc579d67c77003" name="a1dcd43e2827d2cd4c7dc579d67c77003"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dcd43e2827d2cd4c7dc579d67c77003">&#9670;&#160;</a></span>init()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classvcl_1_1Edge.html">Edge</a> , int N, typename El , bool o&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classvcl_1_1comp_1_1AdjacentEdges.html">vcl::comp::AdjacentEdges</a>&lt; <a class="el" href="classvcl_1_1Edge.html">Edge</a>, N, El, o &gt;::init</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4a9657dcce5de9e571e211e2336e4e99" name="a4a9657dcce5de9e571e211e2336e4e99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a9657dcce5de9e571e211e2336e4e99">&#9670;&#160;</a></span>insertAdjEdge()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classvcl_1_1Edge.html">Edge</a> , int N, typename El , bool o&gt; <br />
requires (N &lt; 0)</div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classvcl_1_1comp_1_1AdjacentEdges.html">vcl::comp::AdjacentEdges</a>&lt; <a class="el" href="classvcl_1_1Edge.html">Edge</a>, N, El, o &gt;::insertAdjEdge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Edge.html">Edge</a> *&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9bca7ba5837c8843283c756a0c8ddbac" name="a9bca7ba5837c8843283c756a0c8ddbac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bca7ba5837c8843283c756a0c8ddbac">&#9670;&#160;</a></span>isAdjEdgesEnabled()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classvcl_1_1Edge.html">Edge</a> , int N, typename El , bool o&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classvcl_1_1comp_1_1AdjacentEdges.html">vcl::comp::AdjacentEdges</a>&lt; <a class="el" href="classvcl_1_1Edge.html">Edge</a>, N, El, o &gt;::isAdjEdgesEnabled</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a25e05af749183e8ed9661403bcf3c743" name="a25e05af749183e8ed9661403bcf3c743"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25e05af749183e8ed9661403bcf3c743">&#9670;&#160;</a></span>isEnabled()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classvcl_1_1Edge.html">Edge</a> , int N, typename El , bool o&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classvcl_1_1comp_1_1AdjacentEdges.html">vcl::comp::AdjacentEdges</a>&lt; <a class="el" href="classvcl_1_1Edge.html">Edge</a>, N, El, o &gt;::isEnabled</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa2825367ad9f8f33d8f107da270331f1" name="aa2825367ad9f8f33d8f107da270331f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2825367ad9f8f33d8f107da270331f1">&#9670;&#160;</a></span>pushAdjEdge()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classvcl_1_1Edge.html">Edge</a> , int N, typename El , bool o&gt; <br />
requires (N &lt; 0)</div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classvcl_1_1comp_1_1AdjacentEdges.html">vcl::comp::AdjacentEdges</a>&lt; <a class="el" href="classvcl_1_1Edge.html">Edge</a>, N, El, o &gt;::pushAdjEdge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Edge.html">Edge</a> *&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3be18acabf4e2f5478e050d0d975accd" name="a3be18acabf4e2f5478e050d0d975accd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3be18acabf4e2f5478e050d0d975accd">&#9670;&#160;</a></span>resizeAdjEdges()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classvcl_1_1Edge.html">Edge</a> , int N, typename El , bool o&gt; <br />
requires (N &lt; 0)</div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classvcl_1_1comp_1_1AdjacentEdges.html">vcl::comp::AdjacentEdges</a>&lt; <a class="el" href="classvcl_1_1Edge.html">Edge</a>, N, El, o &gt;::resizeAdjEdges </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a>&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resize the container of the adjacent edges to the given size. </p>
<dl class="section note"><dt>Note</dt><dd>This function is available only if the container of the Adjacent Edges is has dynamic size. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a65a5e04482eed7904724f77d7df8b5fb" name="a65a5e04482eed7904724f77d7df8b5fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65a5e04482eed7904724f77d7df8b5fb">&#9670;&#160;</a></span>setAdjEdge()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classvcl_1_1Edge.html">Edge</a> , int N, typename El , bool o&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classvcl_1_1comp_1_1AdjacentEdges.html">vcl::comp::AdjacentEdges</a>&lt; <a class="el" href="classvcl_1_1Edge.html">Edge</a>, N, El, o &gt;::setAdjEdge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Edge.html">Edge</a> *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a>&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the i-th adjacent edge of this element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">e</td><td>The pointer to the adjacent edge to set to this element. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>the position in the container on which set the adj edge; the value must be between 0 and the number of adj edges. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a91c4872f665dac1956d04a8fdc13fc52" name="a91c4872f665dac1956d04a8fdc13fc52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91c4872f665dac1956d04a8fdc13fc52">&#9670;&#160;</a></span>setAdjEdges()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classvcl_1_1Edge.html">Edge</a> , int N, typename El , bool o&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classvcl_1_1comp_1_1AdjacentEdges.html">vcl::comp::AdjacentEdges</a>&lt; <a class="el" href="classvcl_1_1Edge.html">Edge</a>, N, El, o &gt;::setAdjEdges </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classvcl_1_1Edge.html">Edge</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets all the adjacent edges of this element. </p>
<p>If the size of the container is static, the size of the input vector must be the same one of the container.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">list</td><td>vector of adjacent edges to set. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8d3cf6f95653f5c9edc31f474e9d573f" name="a8d3cf6f95653f5c9edc31f474e9d573f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d3cf6f95653f5c9edc31f474e9d573f">&#9670;&#160;</a></span>updateReferences()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classvcl_1_1Edge.html">Edge</a> , int N, typename El , bool o&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classvcl_1_1comp_1_1AdjacentEdges.html">vcl::comp::AdjacentEdges</a>&lt; <a class="el" href="classvcl_1_1Edge.html">Edge</a>, N, El, o &gt;::updateReferences </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvcl_1_1Edge.html">Edge</a> *&#160;</td>
          <td class="paramname"><em>oldBase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvcl_1_1Edge.html">Edge</a> *&#160;</td>
          <td class="paramname"><em>newBase</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac07e4241d1c20928a48a64ab991c9e1d" name="ac07e4241d1c20928a48a64ab991c9e1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac07e4241d1c20928a48a64ab991c9e1d">&#9670;&#160;</a></span>updateReferencesAfterCompact()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classvcl_1_1Edge.html">Edge</a> , int N, typename El , bool o&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classvcl_1_1comp_1_1AdjacentEdges.html">vcl::comp::AdjacentEdges</a>&lt; <a class="el" href="classvcl_1_1Edge.html">Edge</a>, N, El, o &gt;::updateReferencesAfterCompact </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvcl_1_1Edge.html">Edge</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>newIndices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a86ad1783442be1b0e61c4c6dc81d81cc" name="a86ad1783442be1b0e61c4c6dc81d81cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86ad1783442be1b0e61c4c6dc81d81cc">&#9670;&#160;</a></span>ADJ_EDGE_NUMBER</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classvcl_1_1Edge.html">Edge</a> , int N, typename <a class="el" href="namespacevcl.html#ad79a41a614e99b6f2382637b8376123a">ElementType</a>  = void, bool optional = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const int <a class="el" href="classvcl_1_1comp_1_1AdjacentEdges.html">vcl::comp::AdjacentEdges</a>&lt; <a class="el" href="classvcl_1_1Edge.html">Edge</a>, N, <a class="el" href="namespacevcl.html#ad79a41a614e99b6f2382637b8376123a">ElementType</a>, optional &gt;::ADJ_EDGE_NUMBER = Base::CONTAINER_SIZE</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Static size of the container. If the container is dynamic, this value will be negative and you should use the <a class="el" href="classvcl_1_1comp_1_1AdjacentEdges.html#ac92e829ef4a594b60249c038c9cf2de7" title="Returns the number of adjacent edges of this element.">adjEdgesNumber()</a> member function. </p>

</div>
</div>
<a id="ad116d81ccff4ff9a935801c481f340da" name="ad116d81ccff4ff9a935801c481f340da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad116d81ccff4ff9a935801c481f340da">&#9670;&#160;</a></span>IS_OPTIONAL</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classvcl_1_1Edge.html">Edge</a> , int N, typename <a class="el" href="namespacevcl.html#ad79a41a614e99b6f2382637b8376123a">ElementType</a>  = void, bool optional = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const bool <a class="el" href="classvcl_1_1comp_1_1AdjacentEdges.html">vcl::comp::AdjacentEdges</a>&lt; <a class="el" href="classvcl_1_1Edge.html">Edge</a>, N, <a class="el" href="namespacevcl.html#ad79a41a614e99b6f2382637b8376123a">ElementType</a>, optional &gt;::IS_OPTIONAL = optional</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a621ae71ab92519ea81f049d9434c9648" name="a621ae71ab92519ea81f049d9434c9648"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a621ae71ab92519ea81f049d9434c9648">&#9670;&#160;</a></span>IS_VERTICAL</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classvcl_1_1Edge.html">Edge</a> , int N, typename <a class="el" href="namespacevcl.html#ad79a41a614e99b6f2382637b8376123a">ElementType</a>  = void, bool optional = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const bool <a class="el" href="classvcl_1_1comp_1_1AdjacentEdges.html">vcl::comp::AdjacentEdges</a>&lt; <a class="el" href="classvcl_1_1Edge.html">Edge</a>, N, <a class="el" href="namespacevcl.html#ad79a41a614e99b6f2382637b8376123a">ElementType</a>, optional &gt;::IS_VERTICAL = !std::is_same_v&lt;<a class="el" href="namespacevcl.html#ad79a41a614e99b6f2382637b8376123a">ElementType</a>, void&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/runner/work/vclib/vclib/include/vclib/mesh/components/<a class="el" href="mesh_2components_2adjacent__edges_8h_source.html">adjacent_edges.h</a></li>
<li>/home/runner/work/vclib/vclib/include/vclib/mesh/components/<a class="el" href="adjacent__edges_8cpp.html">adjacent_edges.cpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacevcl.html">vcl</a></li><li class="navelem"><a class="el" href="namespacevcl_1_1comp.html">comp</a></li><li class="navelem"><a class="el" href="classvcl_1_1comp_1_1AdjacentEdges.html">AdjacentEdges</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6 </li>
  </ul>
</div>
</body>
</html>
