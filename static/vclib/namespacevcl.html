<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Visual Computing Library: vcl Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
       <script type="text/javascript">
           DoxygenAwesomeDarkModeToggle.init()
       </script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Visual Computing Library
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('namespacevcl.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#concepts">Concepts</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">vcl Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacevcl_1_1comp"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl_1_1comp.html">comp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacevcl_1_1dcel"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl_1_1dcel.html">dcel</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacevcl_1_1edge"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl_1_1edge.html">edge</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacevcl_1_1edgemesh"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl_1_1edgemesh.html">edgemesh</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacevcl_1_1face"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl_1_1face.html">face</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacevcl_1_1hedge"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl_1_1hedge.html">hedge</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacevcl_1_1io"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl_1_1io.html">io</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacevcl_1_1mesh"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl_1_1mesh.html">mesh</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacevcl_1_1pointcloud"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl_1_1pointcloud.html">pointcloud</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacevcl_1_1polymesh"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl_1_1polymesh.html">polymesh</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacevcl_1_1str"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl_1_1str.html">str</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacevcl_1_1trimesh"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl_1_1trimesh.html">trimesh</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacevcl_1_1Ui"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl_1_1Ui.html">Ui</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacevcl_1_1vert"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl_1_1vert.html">vert</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacevcl_1_1views"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl_1_1views.html">views</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1AbstractGrid.html">AbstractGrid</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classvcl_1_1AbstractGrid.html" title="The AbstractGrid class describes a generic Spatial Data Structure organized on a regular grid,...">AbstractGrid</a> class describes a generic Spatial Data Structure organized on a regular grid, that allows to store elements (ValueType) in a particular way that will be managed by its derived classes (e.g. <a class="el" href="classvcl_1_1StaticGrid.html">StaticGrid</a>, <a class="el" href="classvcl_1_1HashTableGrid.html" title="The HashTableGrid class stores N-Dimensional spatial elements (that could be anything on which it can...">HashTableGrid</a>).  <a href="classvcl_1_1AbstractGrid.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1Array.html">Array</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classvcl_1_1Array.html" title="The Array class is a dynamically allocated N-dimensional array stored in RowWise mode.">Array</a> class is a dynamically allocated N-dimensional array stored in RowWise mode.  <a href="classvcl_1_1Array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1BadCustomComponentTypeException.html">BadCustomComponentTypeException</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1BadVertexIndexException.html">BadVertexIndexException</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1BipartiteGraph.html">BipartiteGraph</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1BitProxy.html">BitProxy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classvcl_1_1BitProxy.html" title="The BitProxy class allows to access to a bool reference from a bit saved in a mask,...">BitProxy</a> class allows to access to a bool reference from a bit saved in a mask, and then allow assignment.  <a href="classvcl_1_1BitProxy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1Box.html">Box</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class representing a box in N-dimensional space.  <a href="classvcl_1_1Box.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1CannotOpenFileException.html">CannotOpenFileException</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1CellIterator.html">CellIterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1Color.html">Color</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classvcl_1_1Color.html" title="The Color class represents an RGBA color.">Color</a> class represents an RGBA color.  <a href="classvcl_1_1Color.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1ConsoleLogger.html">ConsoleLogger</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1ConstMeshEdgeUtil.html">ConstMeshEdgeUtil</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1ConstStaticGridIterator.html">ConstStaticGridIterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvcl_1_1CreateSphereArgs.html">CreateSphereArgs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="structvcl_1_1CreateSphereArgs.html" title="The CreateSphereArgs structs contains a series of parameters to generate a sphere.">CreateSphereArgs</a> structs contains a series of parameters to generate a sphere.  <a href="structvcl_1_1CreateSphereArgs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1CustomComponentVectorHandle.html">CustomComponentVectorHandle</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1DcelMeshT.html">DcelMeshT</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvcl_1_1DistFunctionStruct.html">DistFunctionStruct</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvcl_1_1DistFunctionStruct_3_01Obj1_01_5_00_01Obj2_01_5_00_01ScalarType_01_4.html">DistFunctionStruct&lt; Obj1 *, Obj2 *, ScalarType &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvcl_1_1DistFunctionStruct_3_01Obj1_01_5_00_01Obj2_00_01ScalarType_01_4.html">DistFunctionStruct&lt; Obj1 *, Obj2, ScalarType &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvcl_1_1DistFunctionStruct_3_01Obj1_00_01Obj2_01_5_00_01ScalarType_01_4.html">DistFunctionStruct&lt; Obj1, Obj2 *, ScalarType &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvcl_1_1DistFunctionStruct_3_01Obj1_00_01Obj2_00_01ScalarType_01_4.html">DistFunctionStruct&lt; Obj1, Obj2, ScalarType &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1Distribution.html">Distribution</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classvcl_1_1Distribution.html" title="The Distribution class allows to collect a set of values and then compute some statistics like averag...">Distribution</a> class allows to collect a set of values and then compute some statistics like average, variance, standardDeviation, and percentiles.  <a href="classvcl_1_1Distribution.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1DrawableMesh.html">DrawableMesh</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1DrawableObject.html">DrawableObject</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1DrawableObjectFrame.html">DrawableObjectFrame</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1DrawableObjectVector.html">DrawableObjectVector</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1DrawableObjectVectorFrame.html">DrawableObjectVectorFrame</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1Edge.html">Edge</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classvcl_1_1Edge.html" title="The Edge class.">Edge</a> class.  <a href="classvcl_1_1Edge.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1Edge_3_01MeshType_00_01TypeWrapper_3_01Args_8_8_8_01_4_01_4.html">Edge&lt; MeshType, TypeWrapper&lt; Args... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1EdgeAdjFaceIterator.html">EdgeAdjFaceIterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1EdgeMeshT.html">EdgeMeshT</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1Element.html">Element</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classvcl_1_1Element.html" title="The Element class.">Element</a> class.  <a href="classvcl_1_1Element.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1ElementContainerIterator.html">ElementContainerIterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1Face.html">Face</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classvcl_1_1Face.html" title="The Face class.">Face</a> class.  <a href="classvcl_1_1Face.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1Face_3_01MeshType_00_01TypeWrapper_3_01Args_8_8_8_01_4_01_4.html">Face&lt; MeshType, TypeWrapper&lt; Args... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1FaceAdjFaceIterator.html">FaceAdjFaceIterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1FaceHalfEdgeIterator.html">FaceHalfEdgeIterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1FaceVertexIterator.html">FaceVertexIterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1FaceWedgeColorIterator.html">FaceWedgeColorIterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1FaceWedgeTexCoordIterator.html">FaceWedgeTexCoordIterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1FileInfo.html">FileInfo</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1FileMeshInfo.html">FileMeshInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple class that allows to store which components has been loaded or are going to be saved on a mesh file.  <a href="classvcl_1_1FileMeshInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvcl_1_1FilterTypesByCondition.html">FilterTypesByCondition</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvcl_1_1FilterTypesByCondition_3_01Pred_00_01Head_00_01Tail_8_8_8_01_4.html">FilterTypesByCondition&lt; Pred, Head, Tail... &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all types that do not satisfy a condition, and get them as a tuple.  <a href="structvcl_1_1FilterTypesByCondition_3_01Pred_00_01Head_00_01Tail_8_8_8_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvcl_1_1FilterTypesByCondition_3_01Pred_00_01TypeWrapper_3_01Tail_8_8_8_01_4_01_4.html">FilterTypesByCondition&lt; Pred, TypeWrapper&lt; Tail... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvcl_1_1FirstElementPairComparator.html">FirstElementPairComparator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="structvcl_1_1FirstElementPairComparator.html" title="The FirstElementPairComparator struct is an utility comparator that allow to sort std::pair (or any t...">FirstElementPairComparator</a> struct is an utility comparator that allow to sort std::pair (or any type that has a sortable member called 'first') using only its first element. The second element of the Pair type is ignored and won't be considered by the comparator. This means that pairs having equal first elements but different second elements will be considered as equals.  <a href="structvcl_1_1FirstElementPairComparator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1FirstRefPair.html">FirstRefPair</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvcl_1_1FirstType.html">FirstType</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvcl_1_1FirstType_3_01TypeWrapper_3_01Args_8_8_8_01_4_01_4.html">FirstType&lt; TypeWrapper&lt; Args... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1GenericDrawableMesh.html">GenericDrawableMesh</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvcl_1_1GetTypeByCondition.html">GetTypeByCondition</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The the first type of a pack that satisties the given condition.  <a href="structvcl_1_1GetTypeByCondition.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvcl_1_1GetTypeByCondition_3_01Pred_00_01TypeWrapper_3_01Args_8_8_8_01_4_01_4.html">GetTypeByCondition&lt; Pred, TypeWrapper&lt; Args... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1GLArea.html">GLArea</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1HalfEdge.html">HalfEdge</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classvcl_1_1HalfEdge.html" title="The HalfEdge class.">HalfEdge</a> class.  <a href="classvcl_1_1HalfEdge.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1HalfEdge_3_01MeshType_00_01TypeWrapper_3_01Args_8_8_8_01_4_01_4.html">HalfEdge&lt; MeshType, TypeWrapper&lt; Args... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1HashTableGrid.html">HashTableGrid</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classvcl_1_1HashTableGrid.html" title="The HashTableGrid class stores N-Dimensional spatial elements (that could be anything on which it can...">HashTableGrid</a> class stores N-Dimensional spatial elements (that could be anything on which it can be computed a N-dimensional bounding box) in a regular grid, using a Hash Table having the Cell Grid coordinate as key type.  <a href="classvcl_1_1HashTableGrid.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvcl_1_1HausdorffDistResult.html">HausdorffDistResult</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1Histogram.html">Histogram</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1Image.html">Image</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvcl_1_1IndexInTypes.html">IndexInTypes</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvcl_1_1IndexInTypes_3_01T_00_01TypeWrapper_3_01Us_8_8_8_01_4_01_4.html">IndexInTypes&lt; T, TypeWrapper&lt; Us... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvcl_1_1IntersFunctionStruct.html">IntersFunctionStruct</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvcl_1_1IntersFunctionStruct_3_01Obj1_01_5_00_01Obj2_01_4.html">IntersFunctionStruct&lt; Obj1 *, Obj2 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvcl_1_1IntersFunctionStruct_3_01Obj1_00_01Obj2_01_5_01_4.html">IntersFunctionStruct&lt; Obj1, Obj2 * &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvcl_1_1IntersFunctionStruct_3_01Obj1_00_01Obj2_01_4.html">IntersFunctionStruct&lt; Obj1, Obj2 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1IteratorWrapper.html">IteratorWrapper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classvcl_1_1IteratorWrapper.html" title="The IteratorWrapper class creates an random access iterator starting from a pointer,...">IteratorWrapper</a> class creates an random access iterator starting from a pointer, exposing all the operators available to a pointer and exposing all the types that are normally exposed by an iterator.  <a href="classvcl_1_1IteratorWrapper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1KDTree.html">KDTree</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1KeyRefValueRefPair.html">KeyRefValueRefPair</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1KeyValueRefPair.html">KeyValueRefPair</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1Logger.html">Logger</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvcl_1_1MakeConstPointer.html">MakeConstPointer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvcl_1_1MakeConstPointer_3_01T_01_5_01_4.html">MakeConstPointer&lt; T * &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1MalformedFileException.html">MalformedFileException</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1Markable.html">Markable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classvcl_1_1Markable.html" title="The Markable class is a simple wrapper that makes a Type &quot;Markable&quot;, that is just adding an unsigned ...">Markable</a> class is a simple wrapper that makes a Type "Markable", that is just adding an unsigned int that can be accessed using the <a class="el" href="classvcl_1_1Markable.html#a75e3a7c4edfc3cfe48c73bd6851bf732">mark()</a> member function.  <a href="classvcl_1_1Markable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1Markable_3_01Type_01_6_01_4.html">Markable&lt; Type &amp; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1MarkableVector.html">MarkableVector</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1Mesh.html">Mesh</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a> class represents a generic 3D mesh. A mesh is composed of a generic number of containers of Elements (which can be vertices, faces, edges...), plus some other components.  <a href="classvcl_1_1Mesh.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1MeshEdgeUtil.html">MeshEdgeUtil</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1MeshInertia.html">MeshInertia</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classvcl_1_1MeshInertia.html" title="The MeshInertia class.">MeshInertia</a> class.  <a href="classvcl_1_1MeshInertia.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1MeshPos.html">MeshPos</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classvcl_1_1MeshPos.html" title="The MeshPos class describes a &quot;Position in a Mesh&quot; that can be identified with a triplet of Face-Vert...">MeshPos</a> class describes a "Position in a Mesh" that can be identified with a triplet of Face-Vertex-Edge, where:  <a href="classvcl_1_1MeshPos.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1MeshRenderBuffers.html">MeshRenderBuffers</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1MeshRenderSettings.html">MeshRenderSettings</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classvcl_1_1MeshRenderSettings.html" title="The MeshRenderSettings class allows an easy management of render settings of a Mesh....">MeshRenderSettings</a> class allows an easy management of render settings of a <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>. This class stores the rendering status of a <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a> and the rendering capability of a <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>.  <a href="classvcl_1_1MeshRenderSettings.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1MeshRenderSettingsFrame.html">MeshRenderSettingsFrame</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1MeshSampler.html">MeshSampler</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1MissingCompactnessException.html">MissingCompactnessException</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1MissingComponentException.html">MissingComponentException</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1MissingPolygonalRequirementException.html">MissingPolygonalRequirementException</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1MissingPreconditionException.html">MissingPreconditionException</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1MissingQuadRequirementException.html">MissingQuadRequirementException</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1MissingTriangularRequirementException.html">MissingTriangularRequirementException</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1NestedInitializerListsProcessor.html">NestedInitializerListsProcessor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classvcl_1_1NestedInitializerListsProcessor.html" title="The NestedInitializerListsProcessor class.">NestedInitializerListsProcessor</a> class.  <a href="classvcl_1_1NestedInitializerListsProcessor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1NestedInitializerListsProcessor_3_01T_00_011_01_4.html">NestedInitializerListsProcessor&lt; T, 1 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1NodeIterator.html">NodeIterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1NoIntersectionException.html">NoIntersectionException</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1NullLogger.html">NullLogger</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classvcl_1_1NullLogger.html" title="The NullLogger class is an empty class that is used as default type in all the library functions that...">NullLogger</a> class is an empty class that is used as default type in all the library functions that take as input a logger type.  <a href="classvcl_1_1NullLogger.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvcl_1_1NumberOfTypes.html">NumberOfTypes</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvcl_1_1NumberOfTypes_3_01TypeWrapper_3_01Args_8_8_8_01_4_01_4.html">NumberOfTypes&lt; TypeWrapper&lt; Args... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvcl_1_1PairComparator.html">PairComparator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="structvcl_1_1PairComparator.html" title="The PairComparator struct is an utility comparator to allow to sort pairs in lexical order.">PairComparator</a> struct is an utility comparator to allow to sort pairs in lexical order.  <a href="structvcl_1_1PairComparator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1Plane.html">Plane</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classvcl_1_1Plane.html" title="The Plane class represent a 2D plane in 3D space.">Plane</a> class represent a 2D plane in 3D space.  <a href="classvcl_1_1Plane.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1Point.html">Point</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classvcl_1_1Point.html" title="The Point class represents an N-dimensional point containing N scalar values.">Point</a> class represents an N-dimensional point containing N scalar values.  <a href="classvcl_1_1Point.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1PointCloudT.html">PointCloudT</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1PointerIterator.html">PointerIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classvcl_1_1PointerIterator.html" title="The PointerIterator class is an utility iterator wrapper that allows to create, starting from an iter...">PointerIterator</a> class is an utility iterator wrapper that allows to create, starting from an iterator It that iterates over a type T, an iterator that iterates over T*.  <a href="classvcl_1_1PointerIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1PointSampler.html">PointSampler</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1Polygon.html">Polygon</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1PolyMeshT.html">PolyMeshT</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1PrincipalCurvature.html">PrincipalCurvature</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1QClickableLabel.html">QClickableLabel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classvcl_1_1QClickableLabel.html" title="The QClickableLabel class.">QClickableLabel</a> class.  <a href="classvcl_1_1QClickableLabel.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1RefPair.html">RefPair</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1RegularGrid.html">RegularGrid</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1SecondRefPair.html">SecondRefPair</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1Segment.html">Segment</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class representing a line segment in n-dimensional space. The class is parameterized by a <code>PointConcept</code>, which must provide the <code>DIM</code> constant and the <code>[]</code> operator for accessing the point coordinates.  <a href="classvcl_1_1Segment.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1Sphere.html">Sphere</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1StaticGrid.html">StaticGrid</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1StaticGridIterator.html">StaticGridIterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1TexCoord.html">TexCoord</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1Timer.html">Timer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classvcl_1_1Timer.html" title="The Timer class allows to instantiate simple Timer objects that can be used everywhere.">Timer</a> class allows to instantiate simple <a class="el" href="classvcl_1_1Timer.html" title="The Timer class allows to instantiate simple Timer objects that can be used everywhere.">Timer</a> objects that can be used everywhere.  <a href="classvcl_1_1Timer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1Tokenizer.html">Tokenizer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classvcl_1_1Tokenizer.html" title="The Tokenizer class.">Tokenizer</a> class.  <a href="classvcl_1_1Tokenizer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1Triangle.html">Triangle</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1TriangleWrapper.html">TriangleWrapper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1TriMeshT.html">TriMeshT</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classvcl_1_1TriMeshT.html" title="The TriMeshT class.">TriMeshT</a> class.  <a href="classvcl_1_1TriMeshT.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1TriPolyIndexBiMap.html">TriPolyIndexBiMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classvcl_1_1TriPolyIndexBiMap.html" title="The TriPolyIndexBiMap class allows to store a bidirectional mapping between a Polygon Mesh and a Tria...">TriPolyIndexBiMap</a> class allows to store a bidirectional mapping between a <a class="el" href="classvcl_1_1Polygon.html">Polygon</a> <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a> and a <a class="el" href="classvcl_1_1Triangle.html">Triangle</a> <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a> generated by the polygon mesh.  <a href="classvcl_1_1TriPolyIndexBiMap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvcl_1_1TypesContainConditionType.html">TypesContainConditionType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Its value is set to true if there is at least one type in the given pack Args... that satisfies the given condition.  <a href="structvcl_1_1TypesContainConditionType.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvcl_1_1TypesContainConditionType_3_01Pred_00_01TypeWrapper_3_01Args_8_8_8_01_4_01_4.html">TypesContainConditionType&lt; Pred, TypeWrapper&lt; Args... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvcl_1_1TypeWrapper.html">TypeWrapper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1UndirectedNode.html">UndirectedNode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1UnknownFileFormatException.html">UnknownFileFormatException</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvcl_1_1UnorderedPairComparator.html">UnorderedPairComparator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="structvcl_1_1UnorderedPairComparator.html" title="The UnorderedPairComparator struct is an utility comparator to allow to sort unordered std::pair&lt;T,...">UnorderedPairComparator</a> struct is an utility comparator to allow to sort unordered std::pair&lt;T, T&gt;, that means that it is not important the order of the first and the second element of the pair. This menas that pairs (1, 2) and (2, 1) are considered equal, and (3, 1) &lt; (2, 3).  <a href="structvcl_1_1UnorderedPairComparator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1Vector.html">Vector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classvcl_1_1Vector.html" title="The Vector class is a generic container of objects of type T, that could have fixed or dynamic size,...">Vector</a> class is a generic container of objects of type T, that could have fixed or dynamic size, depending on the templated size N.  <a href="classvcl_1_1Vector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1Vertex.html">Vertex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classvcl_1_1Vertex.html" title="The Vertex class.">Vertex</a> class.  <a href="classvcl_1_1Vertex.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1Vertex_3_01MeshType_00_01TypeWrapper_3_01Args_8_8_8_01_4_01_4.html">Vertex&lt; MeshType, TypeWrapper&lt; Args... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1VertexAdjFaceIterator.html">VertexAdjFaceIterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1VertexAdjVertexIterator.html">VertexAdjVertexIterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1View.html">View</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classvcl_1_1View.html" title="The View class is a simple class that stores and exposes two iterators begin and end.">View</a> class is a simple class that stores and exposes two iterators begin and end.  <a href="classvcl_1_1View.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1ViewerMainWindow.html">ViewerMainWindow</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="concepts" name="concepts"></a>
Concepts</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1IsConst.html">IsConst</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility concept that is evaluated true if T is const or it is a pointer to const. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1IteratorConcept.html">IteratorConcept</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility concept that is evaluated true if T is an iterator. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1IteratesOverClass.html">IteratesOverClass</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility concept that is evaluated true if T is an iterator having its value_type that is a class. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1IteratesOverPointer.html">IteratesOverPointer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility concept that is evaluated true if T is an iterator having its value_type that is a pointer. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1LoggerConcept.html">LoggerConcept</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The LoggerConcept is evaluated to true when the input type is a valid Logger type. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1MeshConcept.html">MeshConcept</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Mesh Concept is evaluated to true when the type is a Mesh. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1HasTriangles.html">HasTriangles</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1HasQuads.html">HasQuads</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1HasPolygons.html">HasPolygons</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1FaceMeshConcept.html">FaceMeshConcept</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1TriangleMeshConcept.html">TriangleMeshConcept</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1QuadMeshConcept.html">QuadMeshConcept</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1PolygonMeshConcept.html">PolygonMeshConcept</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1EdgeMeshConcept.html">EdgeMeshConcept</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1DcelMeshConcept.html">DcelMeshConcept</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The DcelMeshConcept is satisfied when: <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1HasBoundingBox.html">HasBoundingBox</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept that is evaluated true if a Mesh has the BoundingBox component. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1HasColor.html">HasColor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept that is evaluated true if a Mesh has the Color component. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1HasMark.html">HasMark</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept that is evaluated true if a Mesh has the Mark component. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1HasName.html">HasName</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept that checks if a Mesh has the Name component. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1HasTexturePaths.html">HasTexturePaths</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept that checks if a Mesh has the TexturePaths component. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1HasTransformMatrix.html">HasTransformMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept that checks if a Mesh has the TransformMatrix component. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1HasEdges.html">HasEdges</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">HasEdges concepts is satisfied when at least one of its types is (or inherits from) a EdgeContainer. It can be used both to check if a Mesh has edges, or if in a list of types there is a EdgeContainer. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1HasHalfEdges.html">HasHalfEdges</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">HasHalfEdges concepts is satisfied when at least one of its types is (or inherits from) a HalfEdgeContainer. It can be used both to check if a Mesh has half edges, or if in a list of types there is a HalfEdgeContainer. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1HasFaces.html">HasFaces</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">HasFaces concepts is satisfied when at least one of its types is (or inherits from) a FaceContainer. It can be used both to check if a Mesh has faces, or if in a list of types there is a FaceContainer. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1HasVertices.html">HasVertices</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">HasVertices concepts is satisfied when at least one of its types is (or inherits from) a VertexContainer. It can be used both to check if a Mesh has vertices, or if in a list of types there is a VertexContainer. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1EdgeConcept.html">EdgeConcept</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The EdgeConcept describes how a Edge element that can be used for a EdgeContainer should be organized. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1ElementConcept.html">ElementConcept</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1FaceConcept.html">FaceConcept</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The FaceConcept describes how a Face element that can be used for a FaceContainer should be organized. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1TriangleFaceConcept.html">TriangleFaceConcept</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1PolygonFaceConcept.html">PolygonFaceConcept</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The PolygonFaceConcept describes how a Face element class should be organized to be a polygonal face with dynamic size. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1NonDcelPolygonFaceConcept.html">NonDcelPolygonFaceConcept</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1HalfEdgeConcept.html">HalfEdgeConcept</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The HalfEdgeConcept describes how a HalfEdge element that can be used for a HalfEdgeContainer should be organized. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1VertexConcept.html">VertexConcept</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The VertexConcept describes how a Vertex element that can be used for a VertexContainer should be organized. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1HasPerFaceAdjacentEdges.html">HasPerFaceAdjacentEdges</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1HasPerFaceAdjacentFaces.html">HasPerFaceAdjacentFaces</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1HasPerFaceColor.html">HasPerFaceColor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1HasPerFaceHalfEdgeReference.html">HasPerFaceHalfEdgeReference</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1HasPerFaceMark.html">HasPerFaceMark</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1HasPerFaceNormal.html">HasPerFaceNormal</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1HasPerFacePrincipalCurvature.html">HasPerFacePrincipalCurvature</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1HasPerFaceScalar.html">HasPerFaceScalar</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1HasPerFaceWedgeColors.html">HasPerFaceWedgeColors</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1HasPerFaceWedgeTexCoords.html">HasPerFaceWedgeTexCoords</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1HasPerFaceCustomComponents.html">HasPerFaceCustomComponents</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1HasPerHalfEdgeColor.html">HasPerHalfEdgeColor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1HasPerHalfCustomComponents.html">HasPerHalfCustomComponents</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1HasPerHalfEdgeMark.html">HasPerHalfEdgeMark</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1HasPerHalfEdgeScalar.html">HasPerHalfEdgeScalar</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1HasPerHalfEdgeTexCoord.html">HasPerHalfEdgeTexCoord</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1HasPerVertexAdjacentEdges.html">HasPerVertexAdjacentEdges</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1HasPerVertexAdjacentFaces.html">HasPerVertexAdjacentFaces</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1HasPerVertexAdjacentVertices.html">HasPerVertexAdjacentVertices</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1HasPerVertexColor.html">HasPerVertexColor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1HasPerVertexHalfEdgeReference.html">HasPerVertexHalfEdgeReference</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1HasPerVertexMark.html">HasPerVertexMark</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1HasPerVertexNormal.html">HasPerVertexNormal</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1HasPerVertexPrincipalCurvature.html">HasPerVertexPrincipalCurvature</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1HasPerVertexScalar.html">HasPerVertexScalar</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1HasPerVertexTexCoord.html">HasPerVertexTexCoord</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1HasPerVertexCustomComponents.html">HasPerVertexCustomComponents</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1IsPointer.html">IsPointer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility concept that is evaluated true if T is a Pointer. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1IsPointerToConst.html">IsPointerToConst</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility concept that is evaluated true if T is a Pointer to a constant object. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1VertexRangeConcept.html">VertexRangeConcept</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1VertexPointerRangeConcept.html">VertexPointerRangeConcept</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1Range.html">Range</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility concept that is evaluated true if T is a range, e.g. if has a begin and an end. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1BoxConcept.html">BoxConcept</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A concept representing a N-Dimensional Box. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1Box2Concept.html">Box2Concept</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A concept that requires a type to satisfy the BoxConcept and have a dimension of 2. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1Box3Concept.html">Box3Concept</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A concept that requires a type to satisfy the BoxConcept and have a dimension of 3. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1EigenMatrixConcept.html">EigenMatrixConcept</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1PlaneConcept.html">PlaneConcept</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A C++ concept that requires a type to represent a plane in 3D space. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1PointConcept.html">PointConcept</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept for types representing points in Euclidean space. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1Point2Concept.html">Point2Concept</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A concept for points in two-dimensional space. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1Point3Concept.html">Point3Concept</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A concept for points in three-dimensional space. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1Point4Concept.html">Point4Concept</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A concept for points in four-dimensional space. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1PointIteratorConcept.html">PointIteratorConcept</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept for iterators that iterate over Points (class that satisfies the PointConcept). <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1Point2IteratorConcept.html">Point2IteratorConcept</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept for iterators that iterate over 2D Points (class that satisfies the Point2Concept). <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1Point3IteratorConcept.html">Point3IteratorConcept</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept for iterators that iterate over 3D Points (class that satisfies the Point3Concept). <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1Point4IteratorConcept.html">Point4IteratorConcept</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept for iterators that iterate over 4D Points (class that satisfies the Point4Concept). <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1PolygonConcept.html">PolygonConcept</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1Polygon2Concept.html">Polygon2Concept</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1Polygon3Concept.html">Polygon3Concept</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1SamplerConcept.html">SamplerConcept</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A concept for a container that stores Point samples. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1SegmentConcept.html">SegmentConcept</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept for types representing line segments in Euclidean space. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1Segment2Concept.html">Segment2Concept</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A concept to check whether a type meets the requirements of a 2D segment. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1Segment3Concept.html">Segment3Concept</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A concept to check whether a type meets the requirements of a 3D segment. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1SphereConcept.html">SphereConcept</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept for types representing spheres in Euclidean space. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1ConstTriangleConcept.html">ConstTriangleConcept</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1TriangleConcept.html">TriangleConcept</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1ConstTriangle2Concept.html">ConstTriangle2Concept</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1Triangle2Concept.html">Triangle2Concept</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1ConstTriangle3Concept.html">ConstTriangle3Concept</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1Triangle3Concept.html">Triangle3Concept</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:aa909fb65065f7aa1f08e7ae17265653d"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename, typename... &gt; typename Container, typename T &gt; </td></tr>
<tr class="memitem:aa909fb65065f7aa1f08e7ae17265653d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#aa909fb65065f7aa1f08e7ae17265653d">ConstElementContainerIterator</a> = <a class="el" href="classvcl_1_1ElementContainerIterator.html">ElementContainerIterator</a>&lt; Container, T, true &gt;</td></tr>
<tr class="separator:aa909fb65065f7aa1f08e7ae17265653d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70592efcf2670361a337c528b34e4dfb"><td class="memTemplParams" colspan="2">template&lt;typename FaceType &gt; </td></tr>
<tr class="memitem:a70592efcf2670361a337c528b34e4dfb"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a70592efcf2670361a337c528b34e4dfb">ConstEdgeAdjFaceIterator</a> = <a class="el" href="classvcl_1_1EdgeAdjFaceIterator.html">EdgeAdjFaceIterator</a>&lt; FaceType, true &gt;</td></tr>
<tr class="separator:a70592efcf2670361a337c528b34e4dfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9e13c65969a1fb0988d3e57b39fd6d6"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="classvcl_1_1HalfEdge.html">HalfEdge</a> &gt; </td></tr>
<tr class="memitem:aa9e13c65969a1fb0988d3e57b39fd6d6"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#aa9e13c65969a1fb0988d3e57b39fd6d6">ConstFaceAdjFaceIterator</a> = <a class="el" href="classvcl_1_1FaceAdjFaceIterator.html">FaceAdjFaceIterator</a>&lt; <a class="el" href="classvcl_1_1HalfEdge.html">HalfEdge</a>, true &gt;</td></tr>
<tr class="separator:aa9e13c65969a1fb0988d3e57b39fd6d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fbff3665ba9d9fb30e0136ff2fb7be5"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="classvcl_1_1HalfEdge.html">HalfEdge</a> &gt; </td></tr>
<tr class="memitem:a0fbff3665ba9d9fb30e0136ff2fb7be5"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a0fbff3665ba9d9fb30e0136ff2fb7be5">ConstFaceHalfEdgeIterator</a> = <a class="el" href="classvcl_1_1FaceHalfEdgeIterator.html">FaceHalfEdgeIterator</a>&lt; <a class="el" href="classvcl_1_1HalfEdge.html">HalfEdge</a>, true &gt;</td></tr>
<tr class="separator:a0fbff3665ba9d9fb30e0136ff2fb7be5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee598e2468f5d7b8d92ed2e84e5c6c84"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="classvcl_1_1HalfEdge.html">HalfEdge</a> &gt; </td></tr>
<tr class="memitem:aee598e2468f5d7b8d92ed2e84e5c6c84"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#aee598e2468f5d7b8d92ed2e84e5c6c84">ConstFaceVertexIterator</a> = <a class="el" href="classvcl_1_1FaceVertexIterator.html">FaceVertexIterator</a>&lt; <a class="el" href="classvcl_1_1HalfEdge.html">HalfEdge</a>, true &gt;</td></tr>
<tr class="separator:aee598e2468f5d7b8d92ed2e84e5c6c84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a264298bf74423f379fc8f84de9b9027b"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="classvcl_1_1HalfEdge.html">HalfEdge</a> &gt; </td></tr>
<tr class="memitem:a264298bf74423f379fc8f84de9b9027b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a264298bf74423f379fc8f84de9b9027b">ConstFaceWedgeColorIterator</a> = <a class="el" href="classvcl_1_1FaceWedgeColorIterator.html">FaceWedgeColorIterator</a>&lt; <a class="el" href="classvcl_1_1HalfEdge.html">HalfEdge</a>, true &gt;</td></tr>
<tr class="separator:a264298bf74423f379fc8f84de9b9027b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0669a8468e752c2aa2fe9a72dae4d627"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="classvcl_1_1HalfEdge.html">HalfEdge</a> &gt; </td></tr>
<tr class="memitem:a0669a8468e752c2aa2fe9a72dae4d627"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a0669a8468e752c2aa2fe9a72dae4d627">ConstFaceWedgeTexCoordIterator</a> = <a class="el" href="classvcl_1_1FaceWedgeTexCoordIterator.html">FaceWedgeTexCoordIterator</a>&lt; <a class="el" href="classvcl_1_1HalfEdge.html">HalfEdge</a>, true &gt;</td></tr>
<tr class="separator:a0669a8468e752c2aa2fe9a72dae4d627"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a3067a6c32d447288eb7b9adf676eab"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="classvcl_1_1HalfEdge.html">HalfEdge</a> &gt; </td></tr>
<tr class="memitem:a2a3067a6c32d447288eb7b9adf676eab"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a2a3067a6c32d447288eb7b9adf676eab">ConstVertexAdjFaceIterator</a> = <a class="el" href="classvcl_1_1VertexAdjFaceIterator.html">VertexAdjFaceIterator</a>&lt; <a class="el" href="classvcl_1_1HalfEdge.html">HalfEdge</a>, true &gt;</td></tr>
<tr class="separator:a2a3067a6c32d447288eb7b9adf676eab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7254dafde739f74f358cae7ed67be72b"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="classvcl_1_1HalfEdge.html">HalfEdge</a> &gt; </td></tr>
<tr class="memitem:a7254dafde739f74f358cae7ed67be72b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a7254dafde739f74f358cae7ed67be72b">ConstVertexAdjVertexIterator</a> = <a class="el" href="classvcl_1_1VertexAdjVertexIterator.html">VertexAdjVertexIterator</a>&lt; <a class="el" href="classvcl_1_1HalfEdge.html">HalfEdge</a>, true &gt;</td></tr>
<tr class="separator:a7254dafde739f74f358cae7ed67be72b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a294d3a64b949108ec1f6381b950945e9"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a294d3a64b949108ec1f6381b950945e9">Histogramf</a> = <a class="el" href="classvcl_1_1Histogram.html">Histogram</a>&lt; float &gt;</td></tr>
<tr class="separator:a294d3a64b949108ec1f6381b950945e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7eaa15c791dc5118a8eea9677c6ba9b7"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a7eaa15c791dc5118a8eea9677c6ba9b7">Histogramd</a> = <a class="el" href="classvcl_1_1Histogram.html">Histogram</a>&lt; double &gt;</td></tr>
<tr class="separator:a7eaa15c791dc5118a8eea9677c6ba9b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae166b0242a891e25bde6507bf6776730"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae166b0242a891e25bde6507bf6776730"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ae166b0242a891e25bde6507bf6776730">ConstCustomComponentVectorHandle</a> = <a class="el" href="classvcl_1_1CustomComponentVectorHandle.html">CustomComponentVectorHandle</a>&lt; const T &gt;</td></tr>
<tr class="separator:ae166b0242a891e25bde6507bf6776730"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a298206ce188e9698fc3e5fcd15c20e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a6a298206ce188e9698fc3e5fcd15c20e">DcelMeshf</a> = <a class="el" href="classvcl_1_1DcelMeshT.html">DcelMeshT</a>&lt; float &gt;</td></tr>
<tr class="separator:a6a298206ce188e9698fc3e5fcd15c20e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a971ea4057050d3c55edb477acc8bb869"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a971ea4057050d3c55edb477acc8bb869">DcelMesh</a> = <a class="el" href="classvcl_1_1DcelMeshT.html">DcelMeshT</a>&lt; double &gt;</td></tr>
<tr class="separator:a971ea4057050d3c55edb477acc8bb869"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbb0bc2af8032a1d07969e3785645a9c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#acbb0bc2af8032a1d07969e3785645a9c">EdgeMeshf</a> = <a class="el" href="classvcl_1_1EdgeMeshT.html">EdgeMeshT</a>&lt; float &gt;</td></tr>
<tr class="separator:acbb0bc2af8032a1d07969e3785645a9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadd5d4f0adc881097d2c62b003a449cc"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#aadd5d4f0adc881097d2c62b003a449cc">EdgeMesh</a> = <a class="el" href="classvcl_1_1EdgeMeshT.html">EdgeMeshT</a>&lt; double &gt;</td></tr>
<tr class="separator:aadd5d4f0adc881097d2c62b003a449cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1ddd0d2b0a8168f7a6134ed53cd1f3c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ae1ddd0d2b0a8168f7a6134ed53cd1f3c">PointCloudf</a> = <a class="el" href="classvcl_1_1PointCloudT.html">PointCloudT</a>&lt; float &gt;</td></tr>
<tr class="separator:ae1ddd0d2b0a8168f7a6134ed53cd1f3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2939073dbb778a3a2f5d9f93e3fb146"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ab2939073dbb778a3a2f5d9f93e3fb146">PointCloud</a> = <a class="el" href="classvcl_1_1PointCloudT.html">PointCloudT</a>&lt; double &gt;</td></tr>
<tr class="separator:ab2939073dbb778a3a2f5d9f93e3fb146"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adde03ea7837ce8e0d2e4e5aef04a1792"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#adde03ea7837ce8e0d2e4e5aef04a1792">PolyMeshf</a> = <a class="el" href="classvcl_1_1PolyMeshT.html">PolyMeshT</a>&lt; float &gt;</td></tr>
<tr class="separator:adde03ea7837ce8e0d2e4e5aef04a1792"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a416d891cfc10982e070d934a5ab00e7b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a416d891cfc10982e070d934a5ab00e7b">PolyMesh</a> = <a class="el" href="classvcl_1_1PolyMeshT.html">PolyMeshT</a>&lt; double &gt;</td></tr>
<tr class="separator:a416d891cfc10982e070d934a5ab00e7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa63bf0911d51c7377fd467056b2914ff"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__meshes.html#gaa63bf0911d51c7377fd467056b2914ff">TriMeshf</a> = <a class="el" href="classvcl_1_1TriMeshT.html">TriMeshT</a>&lt; float &gt;</td></tr>
<tr class="memdesc:gaa63bf0911d51c7377fd467056b2914ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">The TriMeshf class is a specialization of <a class="el" href="classvcl_1_1TriMeshT.html" title="The TriMeshT class.">TriMeshT</a> that uses <code>float</code> as scalar.  <br /></td></tr>
<tr class="separator:gaa63bf0911d51c7377fd467056b2914ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc7d9c9e25692d22fc9015ac3b3fa4d5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__meshes.html#gadc7d9c9e25692d22fc9015ac3b3fa4d5">TriMesh</a> = <a class="el" href="classvcl_1_1TriMeshT.html">TriMeshT</a>&lt; double &gt;</td></tr>
<tr class="memdesc:gadc7d9c9e25692d22fc9015ac3b3fa4d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">The TriMesh class is a specialization of <a class="el" href="classvcl_1_1TriMeshT.html" title="The TriMeshT class.">TriMeshT</a> that uses <code>double</code> as scalar.  <br /></td></tr>
<tr class="separator:gadc7d9c9e25692d22fc9015ac3b3fa4d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7449b441f4e1a24adf73b0964fb0953"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t L&gt; </td></tr>
<tr class="memitem:ad7449b441f4e1a24adf73b0964fb0953"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ad7449b441f4e1a24adf73b0964fb0953">NestedInitializerLists</a> = typename internal::NestedInitializerListsTraits&lt; T, L &gt;::type</td></tr>
<tr class="memdesc:ad7449b441f4e1a24adf73b0964fb0953"><td class="mdescLeft">&#160;</td><td class="mdescRight">The NestedInitializerLists class manages nested std::initializer_list&lt;T&gt; types of L levels L must be known at compile time, and compilation will fail if the NestedInitializerLists used does not correspond to the number of used levels.  <br /></td></tr>
<tr class="separator:ad7449b441f4e1a24adf73b0964fb0953"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba483b2c91a7c9b1505b87003bdf14d9"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:gaba483b2c91a7c9b1505b87003bdf14d9"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__space.html#gaba483b2c91a7c9b1505b87003bdf14d9">Array2</a> = <a class="el" href="classvcl_1_1Array.html">Array</a>&lt; Scalar, 2 &gt;</td></tr>
<tr class="memdesc:gaba483b2c91a7c9b1505b87003bdf14d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience alias for a 2-dimensional <a class="el" href="classvcl_1_1Array.html" title="The Array class is a dynamically allocated N-dimensional array stored in RowWise mode.">Array</a>.  <br /></td></tr>
<tr class="separator:gaba483b2c91a7c9b1505b87003bdf14d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e4b5482856d73dda9465ed9cb7111ea"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:ga6e4b5482856d73dda9465ed9cb7111ea"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__space.html#ga6e4b5482856d73dda9465ed9cb7111ea">Array3</a> = <a class="el" href="classvcl_1_1Array.html">Array</a>&lt; Scalar, 3 &gt;</td></tr>
<tr class="memdesc:ga6e4b5482856d73dda9465ed9cb7111ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience alias for a 3-dimensional <a class="el" href="classvcl_1_1Array.html" title="The Array class is a dynamically allocated N-dimensional array stored in RowWise mode.">Array</a>.  <br /></td></tr>
<tr class="separator:ga6e4b5482856d73dda9465ed9cb7111ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab8fae8ad3697a3fd5f463d428f1b99d0"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:gab8fae8ad3697a3fd5f463d428f1b99d0"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__space.html#gab8fae8ad3697a3fd5f463d428f1b99d0">Array4</a> = <a class="el" href="classvcl_1_1Array.html">Array</a>&lt; Scalar, 4 &gt;</td></tr>
<tr class="memdesc:gab8fae8ad3697a3fd5f463d428f1b99d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience alias for a 4-dimensional <a class="el" href="classvcl_1_1Array.html" title="The Array class is a dynamically allocated N-dimensional array stored in RowWise mode.">Array</a>.  <br /></td></tr>
<tr class="separator:gab8fae8ad3697a3fd5f463d428f1b99d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad892770b57d7187fe007fc5c7b8e28c6"><td class="memTemplParams" colspan="2">template&lt;typename S &gt; </td></tr>
<tr class="memitem:ad892770b57d7187fe007fc5c7b8e28c6"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ad892770b57d7187fe007fc5c7b8e28c6">Box2</a> = <a class="el" href="classvcl_1_1Box.html">Box</a>&lt; <a class="el" href="group__space.html#ga6d15a5d1bc87330938ae9b8a55373334">Point2</a>&lt; S &gt; &gt;</td></tr>
<tr class="separator:ad892770b57d7187fe007fc5c7b8e28c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43d66b66fa1219da110325fc3c9020f9"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a43d66b66fa1219da110325fc3c9020f9">Box2i</a> = <a class="el" href="classvcl_1_1Box.html">Box</a>&lt; <a class="el" href="group__space.html#ga94bdb300286f9b4bf31987102e011f8d">Point2i</a> &gt;</td></tr>
<tr class="separator:a43d66b66fa1219da110325fc3c9020f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6dc1589c361fc5f1b6444b74aae377d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ae6dc1589c361fc5f1b6444b74aae377d">Box2f</a> = <a class="el" href="classvcl_1_1Box.html">Box</a>&lt; <a class="el" href="group__space.html#gac9560ad588438ce539ec3fdc5658746a">Point2f</a> &gt;</td></tr>
<tr class="separator:ae6dc1589c361fc5f1b6444b74aae377d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77d7b12e8258d508469b505f056917f1"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a77d7b12e8258d508469b505f056917f1">Box2d</a> = <a class="el" href="classvcl_1_1Box.html">Box</a>&lt; <a class="el" href="group__space.html#ga4b02e85ff4d51fe7d689f8dd0e87ecd5">Point2d</a> &gt;</td></tr>
<tr class="separator:a77d7b12e8258d508469b505f056917f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6539e58b4183d50e78e631047cd7ad12"><td class="memTemplParams" colspan="2">template&lt;typename S &gt; </td></tr>
<tr class="memitem:a6539e58b4183d50e78e631047cd7ad12"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a6539e58b4183d50e78e631047cd7ad12">Box3</a> = <a class="el" href="classvcl_1_1Box.html">Box</a>&lt; <a class="el" href="group__space.html#ga13f2718b0763def563b8bd9f65982833">Point3</a>&lt; S &gt; &gt;</td></tr>
<tr class="separator:a6539e58b4183d50e78e631047cd7ad12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84825556201de0537b996b08d1f8aeca"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a84825556201de0537b996b08d1f8aeca">Box3i</a> = <a class="el" href="classvcl_1_1Box.html">Box</a>&lt; <a class="el" href="group__space.html#ga54b0dffe79fabd0458fc78332c91e73a">Point3i</a> &gt;</td></tr>
<tr class="separator:a84825556201de0537b996b08d1f8aeca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad03a804ee48eb9b3cd5aaf47f7641b3f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ad03a804ee48eb9b3cd5aaf47f7641b3f">Box3f</a> = <a class="el" href="classvcl_1_1Box.html">Box</a>&lt; <a class="el" href="group__space.html#gae19b0e9639a4f90c91e46910ee66f54c">Point3f</a> &gt;</td></tr>
<tr class="separator:ad03a804ee48eb9b3cd5aaf47f7641b3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d5a81b5a74bca25157b2bf0de2c3f6d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a4d5a81b5a74bca25157b2bf0de2c3f6d">Box3d</a> = <a class="el" href="classvcl_1_1Box.html">Box</a>&lt; <a class="el" href="group__space.html#gabb47c1364fb2fe1464a54417684f011e">Point3d</a> &gt;</td></tr>
<tr class="separator:a4d5a81b5a74bca25157b2bf0de2c3f6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85b2f3d72f837560dc3dac7b128dd286"><td class="memTemplParams" colspan="2">template&lt;typename ValueType , typename ScalarType  = double, bool AllowDuplicates = true&gt; </td></tr>
<tr class="memitem:a85b2f3d72f837560dc3dac7b128dd286"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a85b2f3d72f837560dc3dac7b128dd286">HashTableGrid2</a> = <a class="el" href="classvcl_1_1HashTableGrid.html">HashTableGrid</a>&lt; <a class="el" href="namespacevcl.html#acf35775c9f8314906299b1b19f6c5f9b">RegularGrid2</a>&lt; ScalarType &gt;, ValueType, AllowDuplicates &gt;</td></tr>
<tr class="separator:a85b2f3d72f837560dc3dac7b128dd286"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4258b9247c46311b39535faa3c2cfaa7"><td class="memTemplParams" colspan="2">template&lt;typename ValueType , typename ScalarType  = double, bool AllowDuplicates = true&gt; </td></tr>
<tr class="memitem:a4258b9247c46311b39535faa3c2cfaa7"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a4258b9247c46311b39535faa3c2cfaa7">HashTableGrid3</a> = <a class="el" href="classvcl_1_1HashTableGrid.html">HashTableGrid</a>&lt; <a class="el" href="namespacevcl.html#a8d7cc878c7f7ccb25c576ebf7ad2df5b">RegularGrid3</a>&lt; ScalarType &gt;, ValueType, AllowDuplicates &gt;</td></tr>
<tr class="separator:a4258b9247c46311b39535faa3c2cfaa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf35775c9f8314906299b1b19f6c5f9b"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:acf35775c9f8314906299b1b19f6c5f9b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#acf35775c9f8314906299b1b19f6c5f9b">RegularGrid2</a> = <a class="el" href="classvcl_1_1RegularGrid.html">RegularGrid</a>&lt; Scalar, 2 &gt;</td></tr>
<tr class="separator:acf35775c9f8314906299b1b19f6c5f9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d7cc878c7f7ccb25c576ebf7ad2df5b"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:a8d7cc878c7f7ccb25c576ebf7ad2df5b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a8d7cc878c7f7ccb25c576ebf7ad2df5b">RegularGrid3</a> = <a class="el" href="classvcl_1_1RegularGrid.html">RegularGrid</a>&lt; Scalar, 3 &gt;</td></tr>
<tr class="separator:a8d7cc878c7f7ccb25c576ebf7ad2df5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bbbace04824cfa901027d8e90d830c6"><td class="memTemplParams" colspan="2">template&lt;typename ValueType , typename ScalarType  = double&gt; </td></tr>
<tr class="memitem:a2bbbace04824cfa901027d8e90d830c6"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a2bbbace04824cfa901027d8e90d830c6">StaticGrid2</a> = <a class="el" href="classvcl_1_1StaticGrid.html">StaticGrid</a>&lt; <a class="el" href="namespacevcl.html#acf35775c9f8314906299b1b19f6c5f9b">RegularGrid2</a>&lt; ScalarType &gt;, ValueType &gt;</td></tr>
<tr class="separator:a2bbbace04824cfa901027d8e90d830c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa27c3398ca14cd8a5a7e1423d7a68cd"><td class="memTemplParams" colspan="2">template&lt;typename ValueType , typename ScalarType  = double&gt; </td></tr>
<tr class="memitem:afa27c3398ca14cd8a5a7e1423d7a68cd"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#afa27c3398ca14cd8a5a7e1423d7a68cd">StaticGrid3</a> = <a class="el" href="classvcl_1_1StaticGrid.html">StaticGrid</a>&lt; <a class="el" href="namespacevcl.html#a8d7cc878c7f7ccb25c576ebf7ad2df5b">RegularGrid3</a>&lt; ScalarType &gt;, ValueType &gt;</td></tr>
<tr class="separator:afa27c3398ca14cd8a5a7e1423d7a68cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a707bb169c4d4cafd5d84170b495721dc"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:a707bb169c4d4cafd5d84170b495721dc"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a707bb169c4d4cafd5d84170b495721dc">Matrix33</a> = Eigen::Matrix&lt; Scalar, 3, 3 &gt;</td></tr>
<tr class="separator:a707bb169c4d4cafd5d84170b495721dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2e70d03403788ee68a3f150a70d8039"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#aa2e70d03403788ee68a3f150a70d8039">Matrix33i</a> = <a class="el" href="namespacevcl.html#a707bb169c4d4cafd5d84170b495721dc">Matrix33</a>&lt; int &gt;</td></tr>
<tr class="separator:aa2e70d03403788ee68a3f150a70d8039"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac96c7ac5d789e9dbf055e35fa5a24835"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ac96c7ac5d789e9dbf055e35fa5a24835">Matrix33f</a> = <a class="el" href="namespacevcl.html#a707bb169c4d4cafd5d84170b495721dc">Matrix33</a>&lt; float &gt;</td></tr>
<tr class="separator:ac96c7ac5d789e9dbf055e35fa5a24835"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21e274a73f9088730a856902ede6ee37"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a21e274a73f9088730a856902ede6ee37">Matrix33d</a> = <a class="el" href="namespacevcl.html#a707bb169c4d4cafd5d84170b495721dc">Matrix33</a>&lt; double &gt;</td></tr>
<tr class="separator:a21e274a73f9088730a856902ede6ee37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad82a126b390f21b2e9658c73e7a795ee"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:ad82a126b390f21b2e9658c73e7a795ee"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ad82a126b390f21b2e9658c73e7a795ee">Matrix44</a> = Eigen::Matrix&lt; Scalar, 4, 4 &gt;</td></tr>
<tr class="separator:ad82a126b390f21b2e9658c73e7a795ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af09e528e12eb6fb1fc6e596b46da8beb"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#af09e528e12eb6fb1fc6e596b46da8beb">Matrix44i</a> = <a class="el" href="namespacevcl.html#ad82a126b390f21b2e9658c73e7a795ee">Matrix44</a>&lt; int &gt;</td></tr>
<tr class="separator:af09e528e12eb6fb1fc6e596b46da8beb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6891233f7166ae9569a840d151cfe140"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a6891233f7166ae9569a840d151cfe140">Matrix44f</a> = <a class="el" href="namespacevcl.html#ad82a126b390f21b2e9658c73e7a795ee">Matrix44</a>&lt; float &gt;</td></tr>
<tr class="separator:a6891233f7166ae9569a840d151cfe140"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c9537d456b6db5dc5f2216dfc8bccdc"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a0c9537d456b6db5dc5f2216dfc8bccdc">Matrix44d</a> = <a class="el" href="namespacevcl.html#ad82a126b390f21b2e9658c73e7a795ee">Matrix44</a>&lt; double &gt;</td></tr>
<tr class="separator:a0c9537d456b6db5dc5f2216dfc8bccdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fa66e0f1a04578cf69387027e898c8d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a6fa66e0f1a04578cf69387027e898c8d">Planef</a> = <a class="el" href="classvcl_1_1Plane.html">Plane</a>&lt; float &gt;</td></tr>
<tr class="separator:a6fa66e0f1a04578cf69387027e898c8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08ef90973b043cbb709bec85607f8313"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a08ef90973b043cbb709bec85607f8313">Planed</a> = <a class="el" href="classvcl_1_1Plane.html">Plane</a>&lt; double &gt;</td></tr>
<tr class="separator:a08ef90973b043cbb709bec85607f8313"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d15a5d1bc87330938ae9b8a55373334"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:ga6d15a5d1bc87330938ae9b8a55373334"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__space.html#ga6d15a5d1bc87330938ae9b8a55373334">Point2</a> = <a class="el" href="classvcl_1_1Point.html">Point</a>&lt; Scalar, 2 &gt;</td></tr>
<tr class="memdesc:ga6d15a5d1bc87330938ae9b8a55373334"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience alias for a 2-dimensional <a class="el" href="classvcl_1_1Point.html" title="The Point class represents an N-dimensional point containing N scalar values.">Point</a>.  <br /></td></tr>
<tr class="separator:ga6d15a5d1bc87330938ae9b8a55373334"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga94bdb300286f9b4bf31987102e011f8d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__space.html#ga94bdb300286f9b4bf31987102e011f8d">Point2i</a> = <a class="el" href="group__space.html#ga6d15a5d1bc87330938ae9b8a55373334">Point2</a>&lt; int &gt;</td></tr>
<tr class="memdesc:ga94bdb300286f9b4bf31987102e011f8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience alias for a 2-dimensional <a class="el" href="classvcl_1_1Point.html" title="The Point class represents an N-dimensional point containing N scalar values.">Point</a> with integer components.  <br /></td></tr>
<tr class="separator:ga94bdb300286f9b4bf31987102e011f8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac9560ad588438ce539ec3fdc5658746a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__space.html#gac9560ad588438ce539ec3fdc5658746a">Point2f</a> = <a class="el" href="group__space.html#ga6d15a5d1bc87330938ae9b8a55373334">Point2</a>&lt; float &gt;</td></tr>
<tr class="memdesc:gac9560ad588438ce539ec3fdc5658746a"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience alias for a 2-dimensional <a class="el" href="classvcl_1_1Point.html" title="The Point class represents an N-dimensional point containing N scalar values.">Point</a> with floating-point components.  <br /></td></tr>
<tr class="separator:gac9560ad588438ce539ec3fdc5658746a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b02e85ff4d51fe7d689f8dd0e87ecd5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__space.html#ga4b02e85ff4d51fe7d689f8dd0e87ecd5">Point2d</a> = <a class="el" href="group__space.html#ga6d15a5d1bc87330938ae9b8a55373334">Point2</a>&lt; double &gt;</td></tr>
<tr class="memdesc:ga4b02e85ff4d51fe7d689f8dd0e87ecd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience alias for a 2-dimensional <a class="el" href="classvcl_1_1Point.html" title="The Point class represents an N-dimensional point containing N scalar values.">Point</a> with double-precision floating-point components.  <br /></td></tr>
<tr class="separator:ga4b02e85ff4d51fe7d689f8dd0e87ecd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga13f2718b0763def563b8bd9f65982833"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:ga13f2718b0763def563b8bd9f65982833"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__space.html#ga13f2718b0763def563b8bd9f65982833">Point3</a> = <a class="el" href="classvcl_1_1Point.html">Point</a>&lt; Scalar, 3 &gt;</td></tr>
<tr class="memdesc:ga13f2718b0763def563b8bd9f65982833"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience alias for a 3-dimensional <a class="el" href="classvcl_1_1Point.html" title="The Point class represents an N-dimensional point containing N scalar values.">Point</a>.  <br /></td></tr>
<tr class="separator:ga13f2718b0763def563b8bd9f65982833"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga54b0dffe79fabd0458fc78332c91e73a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__space.html#ga54b0dffe79fabd0458fc78332c91e73a">Point3i</a> = <a class="el" href="group__space.html#ga13f2718b0763def563b8bd9f65982833">Point3</a>&lt; int &gt;</td></tr>
<tr class="memdesc:ga54b0dffe79fabd0458fc78332c91e73a"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience alias for a 3-dimensional <a class="el" href="classvcl_1_1Point.html" title="The Point class represents an N-dimensional point containing N scalar values.">Point</a> with integer components.  <br /></td></tr>
<tr class="separator:ga54b0dffe79fabd0458fc78332c91e73a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae19b0e9639a4f90c91e46910ee66f54c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__space.html#gae19b0e9639a4f90c91e46910ee66f54c">Point3f</a> = <a class="el" href="group__space.html#ga13f2718b0763def563b8bd9f65982833">Point3</a>&lt; float &gt;</td></tr>
<tr class="memdesc:gae19b0e9639a4f90c91e46910ee66f54c"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience alias for a 3-dimensional <a class="el" href="classvcl_1_1Point.html" title="The Point class represents an N-dimensional point containing N scalar values.">Point</a> with floating-point components.  <br /></td></tr>
<tr class="separator:gae19b0e9639a4f90c91e46910ee66f54c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb47c1364fb2fe1464a54417684f011e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__space.html#gabb47c1364fb2fe1464a54417684f011e">Point3d</a> = <a class="el" href="group__space.html#ga13f2718b0763def563b8bd9f65982833">Point3</a>&lt; double &gt;</td></tr>
<tr class="memdesc:gabb47c1364fb2fe1464a54417684f011e"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience alias for a 3-dimensional <a class="el" href="classvcl_1_1Point.html" title="The Point class represents an N-dimensional point containing N scalar values.">Point</a> with double-precision floating-point components.  <br /></td></tr>
<tr class="separator:gabb47c1364fb2fe1464a54417684f011e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga13715e1b62b4c051146f46d84e04afbc"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:ga13715e1b62b4c051146f46d84e04afbc"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__space.html#ga13715e1b62b4c051146f46d84e04afbc">Point4</a> = <a class="el" href="classvcl_1_1Point.html">Point</a>&lt; Scalar, 4 &gt;</td></tr>
<tr class="memdesc:ga13715e1b62b4c051146f46d84e04afbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience alias for a 4-dimensional <a class="el" href="classvcl_1_1Point.html" title="The Point class represents an N-dimensional point containing N scalar values.">Point</a>.  <br /></td></tr>
<tr class="separator:ga13715e1b62b4c051146f46d84e04afbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac86981d787ccd11247f7774e3be3c7b2"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__space.html#gac86981d787ccd11247f7774e3be3c7b2">Point4i</a> = <a class="el" href="group__space.html#ga13715e1b62b4c051146f46d84e04afbc">Point4</a>&lt; int &gt;</td></tr>
<tr class="memdesc:gac86981d787ccd11247f7774e3be3c7b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience alias for a 4-dimensional <a class="el" href="classvcl_1_1Point.html" title="The Point class represents an N-dimensional point containing N scalar values.">Point</a> with integer components.  <br /></td></tr>
<tr class="separator:gac86981d787ccd11247f7774e3be3c7b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga876dce2d8f1042f58d6ee413cd66b2e1"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__space.html#ga876dce2d8f1042f58d6ee413cd66b2e1">Point4f</a> = <a class="el" href="group__space.html#ga13715e1b62b4c051146f46d84e04afbc">Point4</a>&lt; float &gt;</td></tr>
<tr class="memdesc:ga876dce2d8f1042f58d6ee413cd66b2e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience alias for a 4-dimensional <a class="el" href="classvcl_1_1Point.html" title="The Point class represents an N-dimensional point containing N scalar values.">Point</a> with floating-point components.  <br /></td></tr>
<tr class="separator:ga876dce2d8f1042f58d6ee413cd66b2e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga648562f0e0989c853d13b8b0338f3646"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__space.html#ga648562f0e0989c853d13b8b0338f3646">Point4d</a> = <a class="el" href="group__space.html#ga13715e1b62b4c051146f46d84e04afbc">Point4</a>&lt; double &gt;</td></tr>
<tr class="memdesc:ga648562f0e0989c853d13b8b0338f3646"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience alias for a 4-dimensional <a class="el" href="classvcl_1_1Point.html" title="The Point class represents an N-dimensional point containing N scalar values.">Point</a> with double-precision floating-point components.  <br /></td></tr>
<tr class="separator:ga648562f0e0989c853d13b8b0338f3646"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a924ac7eb7740e67b7701c82f079ca13b"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:a924ac7eb7740e67b7701c82f079ca13b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a924ac7eb7740e67b7701c82f079ca13b">Polygon2</a> = <a class="el" href="classvcl_1_1Polygon.html">Polygon</a>&lt; <a class="el" href="group__space.html#ga6d15a5d1bc87330938ae9b8a55373334">Point2</a>&lt; Scalar &gt; &gt;</td></tr>
<tr class="separator:a924ac7eb7740e67b7701c82f079ca13b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d13400e95eb6871c2e4f6169ef08c23"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a2d13400e95eb6871c2e4f6169ef08c23">Polygon2f</a> = <a class="el" href="classvcl_1_1Polygon.html">Polygon</a>&lt; <a class="el" href="group__space.html#gac9560ad588438ce539ec3fdc5658746a">Point2f</a> &gt;</td></tr>
<tr class="separator:a2d13400e95eb6871c2e4f6169ef08c23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a386fd968f85ff551b4d58e109c21db9a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a386fd968f85ff551b4d58e109c21db9a">Polygon2d</a> = <a class="el" href="classvcl_1_1Polygon.html">Polygon</a>&lt; <a class="el" href="group__space.html#ga4b02e85ff4d51fe7d689f8dd0e87ecd5">Point2d</a> &gt;</td></tr>
<tr class="separator:a386fd968f85ff551b4d58e109c21db9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac04b9a59a6c30f22d15b0d1932e60457"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:ac04b9a59a6c30f22d15b0d1932e60457"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ac04b9a59a6c30f22d15b0d1932e60457">Polygon3</a> = <a class="el" href="classvcl_1_1Polygon.html">Polygon</a>&lt; <a class="el" href="group__space.html#ga13f2718b0763def563b8bd9f65982833">Point3</a>&lt; Scalar &gt; &gt;</td></tr>
<tr class="separator:ac04b9a59a6c30f22d15b0d1932e60457"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a359353bfe1b3e56f12a750b2de4abc"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a4a359353bfe1b3e56f12a750b2de4abc">Polygon3f</a> = <a class="el" href="classvcl_1_1Polygon.html">Polygon</a>&lt; <a class="el" href="group__space.html#gae19b0e9639a4f90c91e46910ee66f54c">Point3f</a> &gt;</td></tr>
<tr class="separator:a4a359353bfe1b3e56f12a750b2de4abc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac010b9e655ca9ca0c32f8c61b1eb56a2"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ac010b9e655ca9ca0c32f8c61b1eb56a2">Polygon3d</a> = <a class="el" href="classvcl_1_1Polygon.html">Polygon</a>&lt; <a class="el" href="group__space.html#gabb47c1364fb2fe1464a54417684f011e">Point3d</a> &gt;</td></tr>
<tr class="separator:ac010b9e655ca9ca0c32f8c61b1eb56a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cb93e7b8a1ccd33f76ba2d53ef9ecfa"><td class="memTemplParams" colspan="2">template&lt;VertexConcept VertexType&gt; </td></tr>
<tr class="memitem:a2cb93e7b8a1ccd33f76ba2d53ef9ecfa"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a2cb93e7b8a1ccd33f76ba2d53ef9ecfa">VertexSampler</a> = internal::VertexSampler&lt; VertexType, false &gt;</td></tr>
<tr class="separator:a2cb93e7b8a1ccd33f76ba2d53ef9ecfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af12c15595ec95998920b3ded3c1a8dbf"><td class="memTemplParams" colspan="2">template&lt;VertexConcept VertexType&gt; </td></tr>
<tr class="memitem:af12c15595ec95998920b3ded3c1a8dbf"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#af12c15595ec95998920b3ded3c1a8dbf">ConstVertexSampler</a> = internal::VertexSampler&lt; VertexType, true &gt;</td></tr>
<tr class="separator:af12c15595ec95998920b3ded3c1a8dbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8c7ce5479499796837976d3247e4df8"><td class="memTemplParams" colspan="2">template&lt;typename S &gt; </td></tr>
<tr class="memitem:af8c7ce5479499796837976d3247e4df8"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#af8c7ce5479499796837976d3247e4df8">Segment2</a> = <a class="el" href="classvcl_1_1Segment.html">Segment</a>&lt; <a class="el" href="group__space.html#ga6d15a5d1bc87330938ae9b8a55373334">Point2</a>&lt; S &gt; &gt;</td></tr>
<tr class="separator:af8c7ce5479499796837976d3247e4df8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ca08e736f7887a86fa4fc2dd396cdc5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a9ca08e736f7887a86fa4fc2dd396cdc5">Segment2i</a> = <a class="el" href="classvcl_1_1Segment.html">Segment</a>&lt; <a class="el" href="group__space.html#ga94bdb300286f9b4bf31987102e011f8d">Point2i</a> &gt;</td></tr>
<tr class="separator:a9ca08e736f7887a86fa4fc2dd396cdc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83dc041e1243c07111706a89433af7a9"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a83dc041e1243c07111706a89433af7a9">Segment2f</a> = <a class="el" href="classvcl_1_1Segment.html">Segment</a>&lt; <a class="el" href="group__space.html#gac9560ad588438ce539ec3fdc5658746a">Point2f</a> &gt;</td></tr>
<tr class="separator:a83dc041e1243c07111706a89433af7a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5da8472ea5b5275ab7109e52d50af04"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ae5da8472ea5b5275ab7109e52d50af04">Segment2d</a> = <a class="el" href="classvcl_1_1Segment.html">Segment</a>&lt; <a class="el" href="group__space.html#ga4b02e85ff4d51fe7d689f8dd0e87ecd5">Point2d</a> &gt;</td></tr>
<tr class="separator:ae5da8472ea5b5275ab7109e52d50af04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc9c518fdcc207d621776ebeeedc0db5"><td class="memTemplParams" colspan="2">template&lt;typename S &gt; </td></tr>
<tr class="memitem:afc9c518fdcc207d621776ebeeedc0db5"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#afc9c518fdcc207d621776ebeeedc0db5">Segment3</a> = <a class="el" href="classvcl_1_1Segment.html">Segment</a>&lt; <a class="el" href="group__space.html#ga13f2718b0763def563b8bd9f65982833">Point3</a>&lt; S &gt; &gt;</td></tr>
<tr class="separator:afc9c518fdcc207d621776ebeeedc0db5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0694142b42086cf347becff6f0db0c9c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a0694142b42086cf347becff6f0db0c9c">Segment3i</a> = <a class="el" href="classvcl_1_1Segment.html">Segment</a>&lt; <a class="el" href="group__space.html#ga54b0dffe79fabd0458fc78332c91e73a">Point3i</a> &gt;</td></tr>
<tr class="separator:a0694142b42086cf347becff6f0db0c9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01b4f12a5cd0b2470b2abcd9890f1de1"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a01b4f12a5cd0b2470b2abcd9890f1de1">Segment3f</a> = <a class="el" href="classvcl_1_1Segment.html">Segment</a>&lt; <a class="el" href="group__space.html#gae19b0e9639a4f90c91e46910ee66f54c">Point3f</a> &gt;</td></tr>
<tr class="separator:a01b4f12a5cd0b2470b2abcd9890f1de1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77d6ff7d119b08bd6bc8d5e84b9fe2ec"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a77d6ff7d119b08bd6bc8d5e84b9fe2ec">Segment3d</a> = <a class="el" href="classvcl_1_1Segment.html">Segment</a>&lt; <a class="el" href="group__space.html#gabb47c1364fb2fe1464a54417684f011e">Point3d</a> &gt;</td></tr>
<tr class="separator:a77d6ff7d119b08bd6bc8d5e84b9fe2ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a918b0af3e76ff4b82da382ddfab126d0"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a918b0af3e76ff4b82da382ddfab126d0">Spheref</a> = <a class="el" href="classvcl_1_1Sphere.html">Sphere</a>&lt; float &gt;</td></tr>
<tr class="separator:a918b0af3e76ff4b82da382ddfab126d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a125a3b42c101ab958048c730060aa8c8"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a125a3b42c101ab958048c730060aa8c8">Sphered</a> = <a class="el" href="classvcl_1_1Sphere.html">Sphere</a>&lt; double &gt;</td></tr>
<tr class="separator:a125a3b42c101ab958048c730060aa8c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a917984925513fc8634c94e269ee0cf82"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a917984925513fc8634c94e269ee0cf82">TexCoordi</a> = <a class="el" href="classvcl_1_1TexCoord.html">TexCoord</a>&lt; int &gt;</td></tr>
<tr class="separator:a917984925513fc8634c94e269ee0cf82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ccd8e32ef2f6bf0decb43463f41fb2b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a6ccd8e32ef2f6bf0decb43463f41fb2b">TexCoordf</a> = <a class="el" href="classvcl_1_1TexCoord.html">TexCoord</a>&lt; float &gt;</td></tr>
<tr class="separator:a6ccd8e32ef2f6bf0decb43463f41fb2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec42e251f09249cda2fe0463b81c0f79"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#aec42e251f09249cda2fe0463b81c0f79">TexCoordd</a> = <a class="el" href="classvcl_1_1TexCoord.html">TexCoord</a>&lt; double &gt;</td></tr>
<tr class="separator:aec42e251f09249cda2fe0463b81c0f79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac0ef38a541827b51057bfae9e8c5039"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:aac0ef38a541827b51057bfae9e8c5039"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#aac0ef38a541827b51057bfae9e8c5039">Triangle2</a> = <a class="el" href="classvcl_1_1Triangle.html">Triangle</a>&lt; <a class="el" href="group__space.html#ga6d15a5d1bc87330938ae9b8a55373334">Point2</a>&lt; Scalar &gt; &gt;</td></tr>
<tr class="separator:aac0ef38a541827b51057bfae9e8c5039"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1f6b217d733de32db193f0e751ece25"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ad1f6b217d733de32db193f0e751ece25">Triangle2f</a> = <a class="el" href="classvcl_1_1Triangle.html">Triangle</a>&lt; <a class="el" href="group__space.html#gac9560ad588438ce539ec3fdc5658746a">Point2f</a> &gt;</td></tr>
<tr class="separator:ad1f6b217d733de32db193f0e751ece25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e9344ae874797a2a653deab133d870f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a8e9344ae874797a2a653deab133d870f">Triangle2d</a> = <a class="el" href="classvcl_1_1Triangle.html">Triangle</a>&lt; <a class="el" href="group__space.html#ga4b02e85ff4d51fe7d689f8dd0e87ecd5">Point2d</a> &gt;</td></tr>
<tr class="separator:a8e9344ae874797a2a653deab133d870f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae03921c36e8b060269d9ff90b068db39"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:ae03921c36e8b060269d9ff90b068db39"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ae03921c36e8b060269d9ff90b068db39">Triangle3</a> = <a class="el" href="classvcl_1_1Triangle.html">Triangle</a>&lt; <a class="el" href="group__space.html#ga13f2718b0763def563b8bd9f65982833">Point3</a>&lt; Scalar &gt; &gt;</td></tr>
<tr class="separator:ae03921c36e8b060269d9ff90b068db39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa2a67863f5edd83d508344306bd7bb3"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#afa2a67863f5edd83d508344306bd7bb3">Triangle3f</a> = <a class="el" href="classvcl_1_1Triangle.html">Triangle</a>&lt; <a class="el" href="group__space.html#gae19b0e9639a4f90c91e46910ee66f54c">Point3f</a> &gt;</td></tr>
<tr class="separator:afa2a67863f5edd83d508344306bd7bb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02db1e7fb252318c4435c8ca9944401e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a02db1e7fb252318c4435c8ca9944401e">Triangle3d</a> = <a class="el" href="classvcl_1_1Triangle.html">Triangle</a>&lt; <a class="el" href="group__space.html#gabb47c1364fb2fe1464a54417684f011e">Point3d</a> &gt;</td></tr>
<tr class="separator:a02db1e7fb252318c4435c8ca9944401e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92c93a12005e031d04c92971247414ef"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:a92c93a12005e031d04c92971247414ef"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a92c93a12005e031d04c92971247414ef">TriangleWrapper2</a> = <a class="el" href="classvcl_1_1TriangleWrapper.html">TriangleWrapper</a>&lt; <a class="el" href="group__space.html#ga6d15a5d1bc87330938ae9b8a55373334">Point2</a>&lt; Scalar &gt; &gt;</td></tr>
<tr class="separator:a92c93a12005e031d04c92971247414ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ff16ee6b33f9bdd47405cb91f29e2d0"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a5ff16ee6b33f9bdd47405cb91f29e2d0">TriangleWrapper2f</a> = <a class="el" href="classvcl_1_1TriangleWrapper.html">TriangleWrapper</a>&lt; <a class="el" href="group__space.html#gac9560ad588438ce539ec3fdc5658746a">Point2f</a> &gt;</td></tr>
<tr class="separator:a5ff16ee6b33f9bdd47405cb91f29e2d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27931fc2ea467c03c1019dc025d218e5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a27931fc2ea467c03c1019dc025d218e5">TriangleWrapper2d</a> = <a class="el" href="classvcl_1_1TriangleWrapper.html">TriangleWrapper</a>&lt; <a class="el" href="group__space.html#ga4b02e85ff4d51fe7d689f8dd0e87ecd5">Point2d</a> &gt;</td></tr>
<tr class="separator:a27931fc2ea467c03c1019dc025d218e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a439efbe438907a52943d563d8a12daab"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:a439efbe438907a52943d563d8a12daab"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a439efbe438907a52943d563d8a12daab">TriangleWrapper3</a> = <a class="el" href="classvcl_1_1TriangleWrapper.html">TriangleWrapper</a>&lt; <a class="el" href="group__space.html#ga13f2718b0763def563b8bd9f65982833">Point3</a>&lt; Scalar &gt; &gt;</td></tr>
<tr class="separator:a439efbe438907a52943d563d8a12daab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a295b4c2f1ffcf361e32166b44a5a4476"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a295b4c2f1ffcf361e32166b44a5a4476">TriangleWrapper3f</a> = <a class="el" href="classvcl_1_1TriangleWrapper.html">TriangleWrapper</a>&lt; <a class="el" href="group__space.html#gae19b0e9639a4f90c91e46910ee66f54c">Point3f</a> &gt;</td></tr>
<tr class="separator:a295b4c2f1ffcf361e32166b44a5a4476"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace2761031333634f83908ed3d4e5fb19"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ace2761031333634f83908ed3d4e5fb19">TriangleWrapper3d</a> = <a class="el" href="classvcl_1_1TriangleWrapper.html">TriangleWrapper</a>&lt; <a class="el" href="group__space.html#gabb47c1364fb2fe1464a54417684f011e">Point3d</a> &gt;</td></tr>
<tr class="separator:ace2761031333634f83908ed3d4e5fb19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05b7c68fb0aa1b6e92e4719859adc941"><td class="memTemplParams" colspan="2">template&lt;typename derived , template&lt; typename... &gt; class base&gt; </td></tr>
<tr class="memitem:a05b7c68fb0aa1b6e92e4719859adc941"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a05b7c68fb0aa1b6e92e4719859adc941">IsDerivedFromTemplateSpecialization</a> = typename std::invoke_result&lt; internal::IsDerivedFromImplementation&lt; base &gt;, typename std::remove_cv&lt; derived &gt;::type * &gt;::type</td></tr>
<tr class="separator:a05b7c68fb0aa1b6e92e4719859adc941"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a997ae3296c55d244ddd31c5037ca4a7b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a997ae3296c55d244ddd31c5037ca4a7b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a997ae3296c55d244ddd31c5037ca4a7b">RemoveRefAndPointer</a> = typename std::remove_pointer_t&lt; typename std::remove_reference_t&lt; T &gt; &gt;</td></tr>
<tr class="separator:a997ae3296c55d244ddd31c5037ca4a7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f737a463fe0a1daa8f1c21c96cb4ff5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6f737a463fe0a1daa8f1c21c96cb4ff5"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a6f737a463fe0a1daa8f1c21c96cb4ff5">RemoveConstRef</a> = typename std::remove_const_t&lt; std::remove_reference_t&lt; T &gt; &gt;</td></tr>
<tr class="separator:a6f737a463fe0a1daa8f1c21c96cb4ff5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a665881ae7f71a35814e41147c4bcd417"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a665881ae7f71a35814e41147c4bcd417"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a665881ae7f71a35814e41147c4bcd417">RemoveConstPointer</a> = std::conditional_t&lt; std::is_pointer_v&lt; T &gt;, std::add_pointer_t&lt; typename std::remove_cv_t&lt; typename std::remove_pointer_t&lt; T &gt; &gt; &gt;, T &gt;</td></tr>
<tr class="separator:a665881ae7f71a35814e41147c4bcd417"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a5a4e8376b2d47797f9167f2a8dd6fb0e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a5a4e8376b2d47797f9167f2a8dd6fb0e">HausdorffSamplingMethod</a> { <a class="el" href="namespacevcl.html#a5a4e8376b2d47797f9167f2a8dd6fb0ea33aad0431cadce18cad82201cb732f49">HAUSDORFF_VERTEX_UNIFORM</a> = 0
, <a class="el" href="namespacevcl.html#a5a4e8376b2d47797f9167f2a8dd6fb0eac8770691ceb41b51c7ab63b70f1da9c6">HAUSDORFF_EDGE_UNIFORM</a>
, <a class="el" href="namespacevcl.html#a5a4e8376b2d47797f9167f2a8dd6fb0eaf9d0153b4af81b71be3972e5a9e3307a">HAUSDORFF_MONTECARLO</a>
 }</td></tr>
<tr class="separator:a5a4e8376b2d47797f9167f2a8dd6fb0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaca879a6bfd47ff8429d6b2f6cfa9440"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#aaca879a6bfd47ff8429d6b2f6cfa9440">VCLibPrincipalCurvatureAlgorithm</a> { <a class="el" href="namespacevcl.html#aaca879a6bfd47ff8429d6b2f6cfa9440a16e818963316b0b43fcbdec6d75f25ed">VCL_PRINCIPAL_CURVATURE_TAUBIN95</a>
, <a class="el" href="namespacevcl.html#aaca879a6bfd47ff8429d6b2f6cfa9440a2c812dad0f96c382657b60bb2d2f8180">VCL_PRINCIPAL_CURVATURE_PCA</a>
 }</td></tr>
<tr class="separator:aaca879a6bfd47ff8429d6b2f6cfa9440"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64e691de6b710b9fd1dc3d5db66a6f7a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a64e691de6b710b9fd1dc3d5db66a6f7a">ElementEnumType</a> { <a class="el" href="namespacevcl.html#a64e691de6b710b9fd1dc3d5db66a6f7aa2b976bb23bc172fe0c729ce8f367b76e">VERTEX</a> = 0
, <a class="el" href="namespacevcl.html#a64e691de6b710b9fd1dc3d5db66a6f7aa0deacef785932de145d594f20e312b58">FACE</a>
, <a class="el" href="namespacevcl.html#a64e691de6b710b9fd1dc3d5db66a6f7aa277eb4b09247da79fe02b8a334452e67">EDGE</a>
, <a class="el" href="namespacevcl.html#a64e691de6b710b9fd1dc3d5db66a6f7aabb582b413a6845c1f70f5198e603bd04">HALF_EDGE</a>
 }</td></tr>
<tr class="separator:a64e691de6b710b9fd1dc3d5db66a6f7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga1ad883eeb58e2a302d15ce6ba179752f"><td class="memTemplParams" colspan="2">template&lt;PointConcept PointType&gt; </td></tr>
<tr class="memitem:ga1ad883eeb58e2a302d15ce6ba179752f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bounding__box.html#ga1ad883eeb58e2a302d15ce6ba179752f">boundingBox</a> (const PointType &amp;p)</td></tr>
<tr class="memdesc:ga1ad883eeb58e2a302d15ce6ba179752f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the bounding box of a single point.  <br /></td></tr>
<tr class="separator:ga1ad883eeb58e2a302d15ce6ba179752f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga776dc863a78918d5a0f104907ab8a26f"><td class="memTemplParams" colspan="2">template&lt;SegmentConcept SegmentType&gt; </td></tr>
<tr class="memitem:ga776dc863a78918d5a0f104907ab8a26f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bounding__box.html#ga776dc863a78918d5a0f104907ab8a26f">boundingBox</a> (const SegmentType &amp;s)</td></tr>
<tr class="memdesc:ga776dc863a78918d5a0f104907ab8a26f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the bounding box of a line segment.  <br /></td></tr>
<tr class="separator:ga776dc863a78918d5a0f104907ab8a26f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab8f4fd4f0f5ffcf56b82e44e7bb6a1dd"><td class="memTemplParams" colspan="2">template&lt;SphereConcept SphereType&gt; </td></tr>
<tr class="memitem:gab8f4fd4f0f5ffcf56b82e44e7bb6a1dd"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bounding__box.html#gab8f4fd4f0f5ffcf56b82e44e7bb6a1dd">boundingBox</a> (const SphereType &amp;s)</td></tr>
<tr class="memdesc:gab8f4fd4f0f5ffcf56b82e44e7bb6a1dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the bounding box of a sphere.  <br /></td></tr>
<tr class="separator:gab8f4fd4f0f5ffcf56b82e44e7bb6a1dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2aa52bf969238c1f809e218722e63ccf"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga2aa52bf969238c1f809e218722e63ccf"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bounding__box.html#ga2aa52bf969238c1f809e218722e63ccf">boundingBox</a> (const MeshType &amp;m)</td></tr>
<tr class="memdesc:ga2aa52bf969238c1f809e218722e63ccf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the bounding box of a mesh.  <br /></td></tr>
<tr class="separator:ga2aa52bf969238c1f809e218722e63ccf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5394cef99570de3bb2538e6c4dae69f7"><td class="memTemplParams" colspan="2">template&lt;VertexConcept VertexType&gt; </td></tr>
<tr class="memitem:ga5394cef99570de3bb2538e6c4dae69f7"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bounding__box.html#ga5394cef99570de3bb2538e6c4dae69f7">boundingBox</a> (const VertexType &amp;v)</td></tr>
<tr class="memdesc:ga5394cef99570de3bb2538e6c4dae69f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the bounding box of a vertex.  <br /></td></tr>
<tr class="separator:ga5394cef99570de3bb2538e6c4dae69f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga65283494a83b003698a6f37d3157384a"><td class="memTemplParams" colspan="2">template&lt;VertexConcept VertexType&gt; </td></tr>
<tr class="memitem:ga65283494a83b003698a6f37d3157384a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bounding__box.html#ga65283494a83b003698a6f37d3157384a">boundingBox</a> (const VertexType *v)</td></tr>
<tr class="memdesc:ga65283494a83b003698a6f37d3157384a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the bounding box of a vertex pointer.  <br /></td></tr>
<tr class="separator:ga65283494a83b003698a6f37d3157384a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf568c42e98a48937632002951ba1a0c7"><td class="memTemplParams" colspan="2">template&lt;FaceConcept FaceType&gt; </td></tr>
<tr class="memitem:gaf568c42e98a48937632002951ba1a0c7"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bounding__box.html#gaf568c42e98a48937632002951ba1a0c7">boundingBox</a> (const FaceType &amp;f)</td></tr>
<tr class="memdesc:gaf568c42e98a48937632002951ba1a0c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the bounding box of a face.  <br /></td></tr>
<tr class="separator:gaf568c42e98a48937632002951ba1a0c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafcd15ef8e31e650a8e3714feb5c6efcc"><td class="memTemplParams" colspan="2">template&lt;FaceConcept FaceType&gt; </td></tr>
<tr class="memitem:gafcd15ef8e31e650a8e3714feb5c6efcc"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bounding__box.html#gafcd15ef8e31e650a8e3714feb5c6efcc">boundingBox</a> (const FaceType *f)</td></tr>
<tr class="memdesc:gafcd15ef8e31e650a8e3714feb5c6efcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the bounding box of a face pointer.  <br /></td></tr>
<tr class="separator:gafcd15ef8e31e650a8e3714feb5c6efcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3364ecfcc22e860e202e0c4edc2bbc79"><td class="memTemplParams" colspan="2">template&lt;EdgeConcept EdgeType&gt; </td></tr>
<tr class="memitem:ga3364ecfcc22e860e202e0c4edc2bbc79"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bounding__box.html#ga3364ecfcc22e860e202e0c4edc2bbc79">boundingBox</a> (const EdgeType &amp;e)</td></tr>
<tr class="memdesc:ga3364ecfcc22e860e202e0c4edc2bbc79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the bounding box of an edge.  <br /></td></tr>
<tr class="separator:ga3364ecfcc22e860e202e0c4edc2bbc79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac83361d6c2d4182da008a6e198fe4465"><td class="memTemplParams" colspan="2">template&lt;EdgeConcept EdgeType&gt; </td></tr>
<tr class="memitem:gac83361d6c2d4182da008a6e198fe4465"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bounding__box.html#gac83361d6c2d4182da008a6e198fe4465">boundingBox</a> (const EdgeType *e)</td></tr>
<tr class="memdesc:gac83361d6c2d4182da008a6e198fe4465"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the bounding box of an edge pointer.  <br /></td></tr>
<tr class="separator:gac83361d6c2d4182da008a6e198fe4465"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c874831bf64431e53535e966bccb9e9"><td class="memTemplParams" colspan="2">template&lt;typename Iterator &gt; </td></tr>
<tr class="memitem:ga6c874831bf64431e53535e966bccb9e9"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bounding__box.html#ga6c874831bf64431e53535e966bccb9e9">boundingBox</a> (Iterator begin, Iterator end)</td></tr>
<tr class="memdesc:ga6c874831bf64431e53535e966bccb9e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the bounding box of a set of objects.  <br /></td></tr>
<tr class="separator:ga6c874831bf64431e53535e966bccb9e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga780e912fa6dbf0a2a7d0e49445f65347"><td class="memTemplParams" colspan="2">template&lt;Range Rng&gt; </td></tr>
<tr class="memitem:ga780e912fa6dbf0a2a7d0e49445f65347"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bounding__box.html#ga780e912fa6dbf0a2a7d0e49445f65347">boundingBox</a> (Rng &amp;&amp;r)</td></tr>
<tr class="memdesc:ga780e912fa6dbf0a2a7d0e49445f65347"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the bounding box of a range of objects.  <br /></td></tr>
<tr class="separator:ga780e912fa6dbf0a2a7d0e49445f65347"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed545a1f18ff8b6c2ee273c0d44c9b9f"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:gaed545a1f18ff8b6c2ee273c0d44c9b9f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__clean.html#gaed545a1f18ff8b6c2ee273c0d44c9b9f">numberUnreferencedVertices</a> (const MeshType &amp;m)</td></tr>
<tr class="memdesc:gaed545a1f18ff8b6c2ee273c0d44c9b9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of non-deleted unreferenced vertices of the mesh.  <br /></td></tr>
<tr class="separator:gaed545a1f18ff8b6c2ee273c0d44c9b9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25c5d478a258364fa7a8215e7ffbb7d2"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga25c5d478a258364fa7a8215e7ffbb7d2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__clean.html#ga25c5d478a258364fa7a8215e7ffbb7d2">removeUnreferencedVertices</a> (MeshType &amp;m)</td></tr>
<tr class="memdesc:ga25c5d478a258364fa7a8215e7ffbb7d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marks as deleted all the non-deleted unreferenced vertices of the mesh.  <br /></td></tr>
<tr class="separator:ga25c5d478a258364fa7a8215e7ffbb7d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabce801a437aa06438837271fde16cb5a"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:gabce801a437aa06438837271fde16cb5a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__clean.html#gabce801a437aa06438837271fde16cb5a">removeDuplicatedVertices</a> (MeshType &amp;m)</td></tr>
<tr class="memdesc:gabce801a437aa06438837271fde16cb5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marks as deleted the duplicate vertices of the mesh, by looking only at their spatial positions.  <br /></td></tr>
<tr class="separator:gabce801a437aa06438837271fde16cb5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e771a075c5db04274b407af212d2c2b"><td class="memTemplParams" colspan="2">template&lt;TriangleMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga6e771a075c5db04274b407af212d2c2b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__clean.html#ga6e771a075c5db04274b407af212d2c2b">removeDuplicatedFaces</a> (MeshType &amp;m)</td></tr>
<tr class="memdesc:ga6e771a075c5db04274b407af212d2c2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all duplicate faces of the mesh by looking only at their vertex references.  <br /></td></tr>
<tr class="separator:ga6e771a075c5db04274b407af212d2c2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga351485ba1c87c7bd1193917323921ba7"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga351485ba1c87c7bd1193917323921ba7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__clean.html#ga351485ba1c87c7bd1193917323921ba7">removeDegeneratedVertices</a> (MeshType &amp;m, bool deleteAlsoFaces)</td></tr>
<tr class="memdesc:ga351485ba1c87c7bd1193917323921ba7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all vertices that have coordinates with invalid floating point values (NaN or inf).  <br /></td></tr>
<tr class="separator:ga351485ba1c87c7bd1193917323921ba7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3561ea390b2dfc6fec49d12543ea60e7"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga3561ea390b2dfc6fec49d12543ea60e7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__clean.html#ga3561ea390b2dfc6fec49d12543ea60e7">removeDegenerateFaces</a> (MeshType &amp;m)</td></tr>
<tr class="memdesc:ga3561ea390b2dfc6fec49d12543ea60e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all degenerate faces from the input mesh.  <br /></td></tr>
<tr class="separator:ga3561ea390b2dfc6fec49d12543ea60e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd1e4943610b0e15397196d5fc73b0da"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:gabd1e4943610b0e15397196d5fc73b0da"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__clean.html#gabd1e4943610b0e15397196d5fc73b0da">numberNonManifoldVertices</a> (const MeshType &amp;m)</td></tr>
<tr class="memdesc:gabd1e4943610b0e15397196d5fc73b0da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counts the number of non-manifold vertices in the input mesh.  <br /></td></tr>
<tr class="separator:gabd1e4943610b0e15397196d5fc73b0da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae4c34d80af91ce6339f86c6de2c702cd"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:gae4c34d80af91ce6339f86c6de2c702cd"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__clean.html#gae4c34d80af91ce6339f86c6de2c702cd">isWaterTight</a> (const MeshType &amp;m)</td></tr>
<tr class="memdesc:gae4c34d80af91ce6339f86c6de2c702cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the input mesh is water tight.  <br /></td></tr>
<tr class="separator:gae4c34d80af91ce6339f86c6de2c702cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c6de124adcaf9fb747b9c490667f093"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; <br />
requires <a class="el" href="conceptvcl_1_1HasPerFaceAdjacentFaces.html">vcl::HasPerFaceAdjacentFaces</a>&lt;MeshType&gt;</td></tr>
<tr class="memitem:ga4c6de124adcaf9fb747b9c490667f093"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__clean.html#ga4c6de124adcaf9fb747b9c490667f093">numberHoles</a> (const MeshType &amp;m)</td></tr>
<tr class="memdesc:ga4c6de124adcaf9fb747b9c490667f093"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counts the number of holes in the input mesh.  <br /></td></tr>
<tr class="separator:ga4c6de124adcaf9fb747b9c490667f093"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga774f9a47e9cef107d59b97d0434177f7"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; <br />
requires <a class="el" href="conceptvcl_1_1HasPerFaceAdjacentFaces.html">vcl::HasPerFaceAdjacentFaces</a>&lt;MeshType&gt;</td></tr>
<tr class="memitem:ga774f9a47e9cef107d59b97d0434177f7"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::set&lt; <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__clean.html#ga774f9a47e9cef107d59b97d0434177f7">connectedComponents</a> (const MeshType &amp;m)</td></tr>
<tr class="memdesc:ga774f9a47e9cef107d59b97d0434177f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the connected components of the input mesh based on its topology.  <br /></td></tr>
<tr class="separator:ga774f9a47e9cef107d59b97d0434177f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf8a059b21f1238f6e531191f40685670"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:gaf8a059b21f1238f6e531191f40685670"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__clean.html#gaf8a059b21f1238f6e531191f40685670">numberConnectedComponents</a> (const MeshType &amp;m)</td></tr>
<tr class="memdesc:gaf8a059b21f1238f6e531191f40685670"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the number of connected components of the input mesh based on its topology.  <br /></td></tr>
<tr class="separator:gaf8a059b21f1238f6e531191f40685670"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59f079a11ad7619de8d924b3df2bca0e"><td class="memTemplParams" colspan="2">template&lt;PolygonMeshConcept MeshType, LoggerConcept LogType&gt; </td></tr>
<tr class="memitem:a59f079a11ad7619de8d924b3df2bca0e"><td class="memTemplItemLeft" align="right" valign="top">MeshType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a59f079a11ad7619de8d924b3df2bca0e">createDodecahedron</a> (LogType &amp;log)</td></tr>
<tr class="memdesc:a59f079a11ad7619de8d924b3df2bca0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates and returns a <a class="el" href="classvcl_1_1Polygon.html">Polygon</a> <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a> containing a Dodecahedron.  <br /></td></tr>
<tr class="separator:a59f079a11ad7619de8d924b3df2bca0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad27918bc874e941633aeeb83c09ef8bc"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ad27918bc874e941633aeeb83c09ef8bc"><td class="memTemplItemLeft" align="right" valign="top">MeshType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ad27918bc874e941633aeeb83c09ef8bc">createHexahedron</a> ()</td></tr>
<tr class="memdesc:ad27918bc874e941633aeeb83c09ef8bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates and returns a hexahedron having as extremes the points <code>(-1, -1, -1)</code> and <code>(1, 1, 1)</code>.  <br /></td></tr>
<tr class="separator:ad27918bc874e941633aeeb83c09ef8bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99aea140f795216e3bad1e4086ea3fe5"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType, PointConcept CoordType&gt; </td></tr>
<tr class="memitem:a99aea140f795216e3bad1e4086ea3fe5"><td class="memTemplItemLeft" align="right" valign="top">MeshType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a99aea140f795216e3bad1e4086ea3fe5">createHexahedron</a> (const CoordType &amp;<a class="el" href="namespacevcl.html#a3edcb561672a6be17e9453bd1ea446d5">min</a>, const CoordType &amp;<a class="el" href="namespacevcl.html#a69cc63a5ad2974d082145ed1dee7846b">max</a>)</td></tr>
<tr class="memdesc:a99aea140f795216e3bad1e4086ea3fe5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates and returns a Hexahedron having as extremes points min and max given as arguments.  <br /></td></tr>
<tr class="separator:a99aea140f795216e3bad1e4086ea3fe5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7383cbe54f93fa408ebd2f3e6f66ae21"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType, PointConcept CoordType&gt; </td></tr>
<tr class="memitem:a7383cbe54f93fa408ebd2f3e6f66ae21"><td class="memTemplItemLeft" align="right" valign="top">MeshType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a7383cbe54f93fa408ebd2f3e6f66ae21">createCube</a> (const CoordType &amp;<a class="el" href="namespacevcl.html#a3edcb561672a6be17e9453bd1ea446d5">min</a>, double edgeLength)</td></tr>
<tr class="memdesc:a7383cbe54f93fa408ebd2f3e6f66ae21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates and returns a Cube having <code>min</code> as minimum extreme and the given edge length.  <br /></td></tr>
<tr class="separator:a7383cbe54f93fa408ebd2f3e6f66ae21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a269b1a97ae12274a20f3ef034cb65150"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a269b1a97ae12274a20f3ef034cb65150"><td class="memTemplItemLeft" align="right" valign="top">MeshType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a269b1a97ae12274a20f3ef034cb65150">createIcosahedron</a> (bool normalizeVertices)</td></tr>
<tr class="separator:a269b1a97ae12274a20f3ef034cb65150"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a178428edf0329a0ed798ccc4b9a6feae"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a178428edf0329a0ed798ccc4b9a6feae"><td class="memTemplItemLeft" align="right" valign="top">MeshType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a178428edf0329a0ed798ccc4b9a6feae">createSphereUV</a> (const SphereConcept auto &amp;sp, <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> parallels, <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> meridians)</td></tr>
<tr class="separator:a178428edf0329a0ed798ccc4b9a6feae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6f54ee450c902f94c4185193d7bfed0"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ad6f54ee450c902f94c4185193d7bfed0"><td class="memTemplItemLeft" align="right" valign="top">MeshType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ad6f54ee450c902f94c4185193d7bfed0">createSphereNormalizedCube</a> (const SphereConcept auto &amp;sp, <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> divisions)</td></tr>
<tr class="separator:ad6f54ee450c902f94c4185193d7bfed0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a964925e1a22e75db7dea160f6ca9b9bd"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a964925e1a22e75db7dea160f6ca9b9bd"><td class="memTemplItemLeft" align="right" valign="top">MeshType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a964925e1a22e75db7dea160f6ca9b9bd">createSphereSpherifiedCube</a> (const SphereConcept auto &amp;sp, <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> divisions)</td></tr>
<tr class="separator:a964925e1a22e75db7dea160f6ca9b9bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fa15f02159bbc4db0b84ffa8978b154"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a4fa15f02159bbc4db0b84ffa8978b154"><td class="memTemplItemLeft" align="right" valign="top">MeshType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a4fa15f02159bbc4db0b84ffa8978b154">createSphereIcosahedron</a> (const SphereConcept auto &amp;sp, <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> divisions)</td></tr>
<tr class="separator:a4fa15f02159bbc4db0b84ffa8978b154"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48405fa64042edde48ab488b84ce78df"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a48405fa64042edde48ab488b84ce78df"><td class="memTemplItemLeft" align="right" valign="top">MeshType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a48405fa64042edde48ab488b84ce78df">createSphere</a> (const SphereConcept auto &amp;sp, const <a class="el" href="structvcl_1_1CreateSphereArgs.html">CreateSphereArgs</a> &amp;args)</td></tr>
<tr class="memdesc:a48405fa64042edde48ab488b84ce78df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="classvcl_1_1Sphere.html">Sphere</a> <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a> centered in <code>center</code> point and having radius <code>radius</code>, using the generation method given in the argument args.mode (see <a href="https://github.com/caosdoar/spheres">https://github.com/caosdoar/spheres</a> for more details).  <br /></td></tr>
<tr class="separator:a48405fa64042edde48ab488b84ce78df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a455a7abda2f207c424dd5946c30c48c6"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a455a7abda2f207c424dd5946c30c48c6"><td class="memTemplItemLeft" align="right" valign="top">MeshType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a455a7abda2f207c424dd5946c30c48c6">createSphere</a> ()</td></tr>
<tr class="memdesc:a455a7abda2f207c424dd5946c30c48c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="classvcl_1_1Sphere.html">Sphere</a> <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a> using the UV mode (<a href="https://github.com/caosdoar/spheres">https://github.com/caosdoar/spheres</a>), centered in (0, 0, 0), having radius 1, with 10 parallels and 20 meridias.  <br /></td></tr>
<tr class="separator:a455a7abda2f207c424dd5946c30c48c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d38a6ecac2b2ab64dd11d53d78e98ca"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a3d38a6ecac2b2ab64dd11d53d78e98ca"><td class="memTemplItemLeft" align="right" valign="top">MeshType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a3d38a6ecac2b2ab64dd11d53d78e98ca">createTetrahedron</a> ()</td></tr>
<tr class="memdesc:a3d38a6ecac2b2ab64dd11d53d78e98ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">createTetrahedron creates a simple tetrahedron mesh with the following point coordinates:  <br /></td></tr>
<tr class="separator:a3d38a6ecac2b2ab64dd11d53d78e98ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c70a856983dfae4697e3521825dce90"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType, PointConcept CoordType&gt; </td></tr>
<tr class="memitem:a7c70a856983dfae4697e3521825dce90"><td class="memTemplItemLeft" align="right" valign="top">MeshType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a7c70a856983dfae4697e3521825dce90">createTetrahedron</a> (const CoordType &amp;p0, const CoordType &amp;p1, const CoordType &amp;p2, const CoordType &amp;p3)</td></tr>
<tr class="memdesc:a7c70a856983dfae4697e3521825dce90"><td class="mdescLeft">&#160;</td><td class="mdescRight">createTetrahedron createTetrahedron creates a simple tetrahedron mesh with the given points. The function assumes that the points p0, p1 and p2 are in counterclockwise order, and does not perform any sanity check about the validity of the points.  <br /></td></tr>
<tr class="separator:a7c70a856983dfae4697e3521825dce90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3b70ae405303e6bc3c6b36ccd2f2cd9"><td class="memTemplParams" colspan="2">template&lt;Point3Concept PointType, FaceConcept FaceType, typename ScalarType &gt; </td></tr>
<tr class="memitem:ad3b70ae405303e6bc3c6b36ccd2f2cd9"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ad3b70ae405303e6bc3c6b36ccd2f2cd9">pointFaceDistance</a> (const PointType &amp;p, const FaceType &amp;f, ScalarType maxDist, PointType &amp;closest, bool signedDist)</td></tr>
<tr class="memdesc:ad3b70ae405303e6bc3c6b36ccd2f2cd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the distance between a 3D point and a 3D triangle face.  <br /></td></tr>
<tr class="separator:ad3b70ae405303e6bc3c6b36ccd2f2cd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8004a267a203fab97954933935d7fe8a"><td class="memTemplParams" colspan="2">template&lt;Point3Concept PointType, FaceConcept FaceType, typename ScalarType &gt; </td></tr>
<tr class="memitem:a8004a267a203fab97954933935d7fe8a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a8004a267a203fab97954933935d7fe8a">pointFaceDistance</a> (const PointType &amp;p, const FaceType &amp;f, ScalarType maxDist, bool signedDist)</td></tr>
<tr class="separator:a8004a267a203fab97954933935d7fe8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d852efcb4d8028aa9c9e70af2c92cff"><td class="memTemplParams" colspan="2">template&lt;Point3Concept PointType, FaceConcept FaceType&gt; </td></tr>
<tr class="memitem:a6d852efcb4d8028aa9c9e70af2c92cff"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a6d852efcb4d8028aa9c9e70af2c92cff">pointFaceDistance</a> (const PointType &amp;p, const FaceType &amp;f, PointType &amp;closest, bool signedDist)</td></tr>
<tr class="separator:a6d852efcb4d8028aa9c9e70af2c92cff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdfe6ef5ae382e3727241bb20d8f1e3c"><td class="memTemplParams" colspan="2">template&lt;Point3Concept PointType, FaceConcept FaceType&gt; </td></tr>
<tr class="memitem:afdfe6ef5ae382e3727241bb20d8f1e3c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#afdfe6ef5ae382e3727241bb20d8f1e3c">pointFaceDistance</a> (const PointType &amp;p, const FaceType &amp;f, bool signedDist)</td></tr>
<tr class="memdesc:afdfe6ef5ae382e3727241bb20d8f1e3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the distance between a 3D point and a 3D triangle face.  <br /></td></tr>
<tr class="separator:afdfe6ef5ae382e3727241bb20d8f1e3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63f7958bed5f73548d28f436c7eb7b35"><td class="memTemplParams" colspan="2">template&lt;typename Obj1 , typename Obj2 &gt; </td></tr>
<tr class="memitem:a63f7958bed5f73548d28f436c7eb7b35"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a63f7958bed5f73548d28f436c7eb7b35">distFunction</a> ()</td></tr>
<tr class="memdesc:a63f7958bed5f73548d28f436c7eb7b35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a proper dist function between a Obj1 object and an Obj2 object.  <br /></td></tr>
<tr class="separator:a63f7958bed5f73548d28f436c7eb7b35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b9b1898fbdb7ba13f1e1adaf832ba4d"><td class="memTemplParams" colspan="2">template&lt;typename Obj1 , typename Obj2 , typename ScalarType  = double&gt; </td></tr>
<tr class="memitem:a1b9b1898fbdb7ba13f1e1adaf832ba4d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a1b9b1898fbdb7ba13f1e1adaf832ba4d">boundedDistFunction</a> ()</td></tr>
<tr class="memdesc:a1b9b1898fbdb7ba13f1e1adaf832ba4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a proper dist function between a Obj1 object and an Obj2 object.  <br /></td></tr>
<tr class="separator:a1b9b1898fbdb7ba13f1e1adaf832ba4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88893f1c397d1d0aca42ccb3e360c1db"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType1, MeshConcept MeshType2, LoggerConcept LogType&gt; </td></tr>
<tr class="memitem:a88893f1c397d1d0aca42ccb3e360c1db"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structvcl_1_1HausdorffDistResult.html">HausdorffDistResult</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a88893f1c397d1d0aca42ccb3e360c1db">hausdorffDistance</a> (const MeshType1 &amp;m1, const MeshType2 &amp;m2, LogType &amp;log, <a class="el" href="namespacevcl.html#a5a4e8376b2d47797f9167f2a8dd6fb0e">HausdorffSamplingMethod</a> sampMethod, <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> nSamples, bool deterministic)</td></tr>
<tr class="separator:a88893f1c397d1d0aca42ccb3e360c1db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a142e6d7ccfbbece897edecff226ced45"><td class="memTemplParams" colspan="2">template&lt;Point3Concept PointType, PlaneConcept PlaneType&gt; </td></tr>
<tr class="memitem:a142e6d7ccfbbece897edecff226ced45"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a142e6d7ccfbbece897edecff226ced45">pointPlaneDistance</a> (const PointType &amp;p, const PlaneType &amp;plane, bool signedDist)</td></tr>
<tr class="separator:a142e6d7ccfbbece897edecff226ced45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d8430571d9a6027e6d7e3bac4816b95"><td class="memTemplParams" colspan="2">template&lt;PointConcept PointType, SegmentConcept SegmentType&gt; <br />
requires (PointType::DIM == SegmentType::DIM)</td></tr>
<tr class="memitem:a1d8430571d9a6027e6d7e3bac4816b95"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a1d8430571d9a6027e6d7e3bac4816b95">pointSegmentDistance</a> (const PointType &amp;p, const SegmentType &amp;s, PointType &amp;closest)</td></tr>
<tr class="separator:a1d8430571d9a6027e6d7e3bac4816b95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e95f3d99f53e335c7e17af14b42f991"><td class="memTemplParams" colspan="2">template&lt;PointConcept PointType, SegmentConcept SegmentType&gt; <br />
requires (PointType::DIM == SegmentType::DIM)</td></tr>
<tr class="memitem:a7e95f3d99f53e335c7e17af14b42f991"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a7e95f3d99f53e335c7e17af14b42f991">pointSegmentDistance</a> (const PointType &amp;p, const SegmentType &amp;s)</td></tr>
<tr class="separator:a7e95f3d99f53e335c7e17af14b42f991"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59d8e830fa317191e2d02ff5cafc7149"><td class="memTemplParams" colspan="2">template&lt;typename Matrix , EdgeMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a59d8e830fa317191e2d02ff5cafc7149"><td class="memTemplItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a59d8e830fa317191e2d02ff5cafc7149">edgeMatrix</a> (const MeshType &amp;mesh)</td></tr>
<tr class="memdesc:a59d8e830fa317191e2d02ff5cafc7149"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a #V*3 Matrix of scalars containing the coordinates of the vertices of a <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>. The function is templated on the Matrix itself.  <br /></td></tr>
<tr class="separator:a59d8e830fa317191e2d02ff5cafc7149"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fdd1423f72e851ab3c51fecda888b60"><td class="memTemplParams" colspan="2">template&lt;typename Matrix , MeshConcept MeshType&gt; <br />
requires HasPerVertexNormal&lt;MeshType&gt;</td></tr>
<tr class="memitem:a8fdd1423f72e851ab3c51fecda888b60"><td class="memTemplItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a8fdd1423f72e851ab3c51fecda888b60">vertexNormalsMatrix</a> (const MeshType &amp;mesh)</td></tr>
<tr class="memdesc:a8fdd1423f72e851ab3c51fecda888b60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a #V*3 Matrix of scalars containing the normals of the vertices of a <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>. The function is templated on the Matrix itself.  <br /></td></tr>
<tr class="separator:a8fdd1423f72e851ab3c51fecda888b60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7b813fbc070c26bf20205c4d9adb98a"><td class="memTemplParams" colspan="2">template&lt;typename Matrix , MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:aa7b813fbc070c26bf20205c4d9adb98a"><td class="memTemplItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#aa7b813fbc070c26bf20205c4d9adb98a">vertexMatrix</a> (const MeshType &amp;m)</td></tr>
<tr class="separator:aa7b813fbc070c26bf20205c4d9adb98a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d24eb3ce9ebe9df51ee8862901f7d70"><td class="memTemplParams" colspan="2">template&lt;typename Matrix , FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a3d24eb3ce9ebe9df51ee8862901f7d70"><td class="memTemplItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a3d24eb3ce9ebe9df51ee8862901f7d70">faceMatrix</a> (const MeshType &amp;m)</td></tr>
<tr class="separator:a3d24eb3ce9ebe9df51ee8862901f7d70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbf2dd04b5f4477ba07ab217dd603d14"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:abbf2dd04b5f4477ba07ab217dd603d14"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Plane.html">Plane</a>&lt; Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#abbf2dd04b5f4477ba07ab217dd603d14">fitPlaneToPointCloud</a> (const std::vector&lt; <a class="el" href="group__space.html#ga13f2718b0763def563b8bd9f65982833">Point3</a>&lt; Scalar &gt; &gt; &amp;pointVec)</td></tr>
<tr class="memdesc:abbf2dd04b5f4477ba07ab217dd603d14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the plane best fitting a set of points The algorithm used is the classical Covariance matrix eigenvector approach.  <br /></td></tr>
<tr class="separator:abbf2dd04b5f4477ba07ab217dd603d14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8d724d35f1e65a0966e980fc544364f"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:af8d724d35f1e65a0966e980fc544364f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Plane.html">Plane</a>&lt; Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#af8d724d35f1e65a0966e980fc544364f">fitPlaneToWeightedPointCloud</a> (const std::vector&lt; <a class="el" href="group__space.html#ga13f2718b0763def563b8bd9f65982833">Point3</a>&lt; Scalar &gt; &gt; &amp;pointVec)</td></tr>
<tr class="memdesc:af8d724d35f1e65a0966e980fc544364f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the plane best fitting a wighted set of points The algorithm used is the wighted Covariance matrix eigenvector approach.  <br /></td></tr>
<tr class="separator:af8d724d35f1e65a0966e980fc544364f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dc6c66ef4c3f576abc54ce27ec3eb65"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a2dc6c66ef4c3f576abc54ce27ec3eb65"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a2dc6c66ef4c3f576abc54ce27ec3eb65">boolVectorFromVertexSelection</a> (const MeshType &amp;m)</td></tr>
<tr class="memdesc:a2dc6c66ef4c3f576abc54ce27ec3eb65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector of boolean values. For each ith vertex in the mesh, the corresponding value in the vector will be true if the vertex is selected, false otherwise.  <br /></td></tr>
<tr class="separator:a2dc6c66ef4c3f576abc54ce27ec3eb65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42de8353c96495dd4d54ee83909d6c77"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a42de8353c96495dd4d54ee83909d6c77"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a42de8353c96495dd4d54ee83909d6c77">boolVectorFromFaceSelection</a> (const MeshType &amp;m)</td></tr>
<tr class="memdesc:a42de8353c96495dd4d54ee83909d6c77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector of boolean values. For each ith face in the mesh, the corresponding value in the vector will be true if the face is selected, false otherwise.  <br /></td></tr>
<tr class="separator:a42de8353c96495dd4d54ee83909d6c77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a667ab307eae18191ae03623ea329be05"><td class="memTemplParams" colspan="2">template&lt;MeshConcept InMeshType, MeshConcept OutMeshType&gt; </td></tr>
<tr class="memitem:a667ab307eae18191ae03623ea329be05"><td class="memTemplItemLeft" align="right" valign="top">OutMeshType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a667ab307eae18191ae03623ea329be05">generateMeshFromVertexBoolVector</a> (const InMeshType &amp;m, std::vector&lt; bool &gt; &amp;vec, bool saveBirthIndicesInCustomComponent)</td></tr>
<tr class="memdesc:a667ab307eae18191ae03623ea329be05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates and returns a new mesh that is composed of the vertices of the input mesh <code>m</code> having their value in the input vector of booleans <code>vec</code> set to true.  <br /></td></tr>
<tr class="separator:a667ab307eae18191ae03623ea329be05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58a47028bed1d2e5df56ae17dccaeced"><td class="memTemplParams" colspan="2">template&lt;MeshConcept InMeshType, MeshConcept OutMeshType&gt; </td></tr>
<tr class="memitem:a58a47028bed1d2e5df56ae17dccaeced"><td class="memTemplItemLeft" align="right" valign="top">OutMeshType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a58a47028bed1d2e5df56ae17dccaeced">generateMeshFromFaceBoolVector</a> (const InMeshType &amp;m, std::vector&lt; bool &gt; &amp;vec, bool saveBirthIndicesInCustomComponent)</td></tr>
<tr class="memdesc:a58a47028bed1d2e5df56ae17dccaeced"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates and returns a new mesh that is composed of the faces of the input mesh <code>m</code> having their value in the input vector of booleans <code>vec</code> set to true. Only vertices belonging to the imported faces will be imported in the output mesh.  <br /></td></tr>
<tr class="separator:a58a47028bed1d2e5df56ae17dccaeced"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb99398069d243b6bb7b09e55a279792"><td class="memTemplParams" colspan="2">template&lt;FaceConcept FaceType, PointConcept PointType&gt; </td></tr>
<tr class="memitem:abb99398069d243b6bb7b09e55a279792"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#abb99398069d243b6bb7b09e55a279792">faceBoxIntersect</a> (const FaceType &amp;f, const <a class="el" href="classvcl_1_1Box.html">Box</a>&lt; PointType &gt; &amp;box)</td></tr>
<tr class="separator:abb99398069d243b6bb7b09e55a279792"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cec6eee8e30eefd8783a997a48127fa"><td class="memTemplParams" colspan="2">template&lt;FaceConcept FaceType, PointConcept PointType, typename SScalar &gt; </td></tr>
<tr class="memitem:a0cec6eee8e30eefd8783a997a48127fa"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a0cec6eee8e30eefd8783a997a48127fa">faceSphereItersect</a> (const FaceType &amp;f, const <a class="el" href="classvcl_1_1Sphere.html">Sphere</a>&lt; SScalar &gt; &amp;sphere, PointType &amp;witness, std::pair&lt; SScalar, SScalar &gt; &amp;res)</td></tr>
<tr class="memdesc:a0cec6eee8e30eefd8783a997a48127fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the intersection between a sphere and a face, that may be also polygonal.  <br /></td></tr>
<tr class="separator:a0cec6eee8e30eefd8783a997a48127fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a74b10bc09834d0a2d787336a5f7823"><td class="memTemplParams" colspan="2">template&lt;FaceConcept FaceType, typename SScalar &gt; </td></tr>
<tr class="memitem:a9a74b10bc09834d0a2d787336a5f7823"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a9a74b10bc09834d0a2d787336a5f7823">faceSphereItersect</a> (const FaceType &amp;f, const <a class="el" href="classvcl_1_1Sphere.html">Sphere</a>&lt; SScalar &gt; &amp;sphere)</td></tr>
<tr class="memdesc:a9a74b10bc09834d0a2d787336a5f7823"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the intersection between a sphere and a face, that may be also polygonal.  <br /></td></tr>
<tr class="separator:a9a74b10bc09834d0a2d787336a5f7823"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70dad48ffd4a840c11d422b0c3121393"><td class="memTemplParams" colspan="2">template&lt;typename Obj1 , typename Obj2 &gt; </td></tr>
<tr class="memitem:a70dad48ffd4a840c11d422b0c3121393"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a70dad48ffd4a840c11d422b0c3121393">intersectFunction</a> ()</td></tr>
<tr class="memdesc:a70dad48ffd4a840c11d422b0c3121393"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a proper intersect function between a Obj1 object and an Obj2 object.  <br /></td></tr>
<tr class="separator:a70dad48ffd4a840c11d422b0c3121393"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adac28fe9c51f808b6120eb2d9387484b"><td class="memTemplParams" colspan="2">template&lt;EdgeMeshConcept EdgeMesh, FaceMeshConcept MeshType, PlaneConcept PlaneType&gt; </td></tr>
<tr class="memitem:adac28fe9c51f808b6120eb2d9387484b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacevcl.html#aadd5d4f0adc881097d2c62b003a449cc">EdgeMesh</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#adac28fe9c51f808b6120eb2d9387484b">meshPlaneIntersection</a> (const MeshType &amp;m, const PlaneType &amp;pl)</td></tr>
<tr class="memdesc:adac28fe9c51f808b6120eb2d9387484b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes a mesh and a plane as inputs and computes the intersection between the mesh and the plane. It creates a new EdgeMesh to represent the intersection edges.  <br /></td></tr>
<tr class="separator:adac28fe9c51f808b6120eb2d9387484b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5da120ef4b6039bf54902d14cb8b7519"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType, typename SScalar &gt; </td></tr>
<tr class="memitem:a5da120ef4b6039bf54902d14cb8b7519"><td class="memTemplItemLeft" align="right" valign="top">MeshType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a5da120ef4b6039bf54902d14cb8b7519">meshSphereIntersection</a> (const MeshType &amp;m, const <a class="el" href="classvcl_1_1Sphere.html">vcl::Sphere</a>&lt; SScalar &gt; &amp;sphere)</td></tr>
<tr class="memdesc:a5da120ef4b6039bf54902d14cb8b7519"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as meshSphereIntersection(MeshType, Sphere, double);.  <br /></td></tr>
<tr class="separator:a5da120ef4b6039bf54902d14cb8b7519"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e4c155f781f7c3e6fca2b922398fb82"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType, typename SScalar &gt; </td></tr>
<tr class="memitem:a1e4c155f781f7c3e6fca2b922398fb82"><td class="memTemplItemLeft" align="right" valign="top">MeshType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a1e4c155f781f7c3e6fca2b922398fb82">meshSphereIntersection</a> (const MeshType &amp;m, const <a class="el" href="classvcl_1_1Sphere.html">vcl::Sphere</a>&lt; SScalar &gt; &amp;sphere, double tol)</td></tr>
<tr class="memdesc:a1e4c155f781f7c3e6fca2b922398fb82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the intersection between a mesh and a ball.  <br /></td></tr>
<tr class="separator:a1e4c155f781f7c3e6fca2b922398fb82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27474522dfcc3be4ce96d6a8b44fcc09"><td class="memTemplParams" colspan="2">template&lt;PlaneConcept PlaneType, Box3Concept BoxType&gt; </td></tr>
<tr class="memitem:a27474522dfcc3be4ce96d6a8b44fcc09"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a27474522dfcc3be4ce96d6a8b44fcc09">planeBoxIntersect</a> (const PlaneType &amp;p, const BoxType &amp;box)</td></tr>
<tr class="memdesc:a27474522dfcc3be4ce96d6a8b44fcc09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a plane intersects with a box.  <br /></td></tr>
<tr class="separator:a27474522dfcc3be4ce96d6a8b44fcc09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a095d688d385405cbf305d7f501f672a6"><td class="memTemplParams" colspan="2">template&lt;PlaneConcept PlaneType, Segment3Concept SegmentType&gt; </td></tr>
<tr class="memitem:a095d688d385405cbf305d7f501f672a6"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a095d688d385405cbf305d7f501f672a6">planeSegmentIntersect</a> (const PlaneType &amp;p, const SegmentType &amp;s, typename SegmentType::PointType &amp;intersection)</td></tr>
<tr class="memdesc:a095d688d385405cbf305d7f501f672a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function computes the intersection between a plane and a 3D segment. If the intersection exists, it returns true and stores the intersection point in the output parameter intersection, otherwise, it returns false.  <br /></td></tr>
<tr class="separator:a095d688d385405cbf305d7f501f672a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5603e96ba08d11993828c0e47f2657b2"><td class="memTemplParams" colspan="2">template&lt;PlaneConcept PlaneType, Segment3Concept SegmentType&gt; </td></tr>
<tr class="memitem:a5603e96ba08d11993828c0e47f2657b2"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a5603e96ba08d11993828c0e47f2657b2">planeSegmentIntersect</a> (const PlaneType &amp;p, const SegmentType &amp;s)</td></tr>
<tr class="memdesc:a5603e96ba08d11993828c0e47f2657b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function computes the intersection between a plane and a 3D segment. If the intersection exists, it returns true, otherwise, it returns false.  <br /></td></tr>
<tr class="separator:a5603e96ba08d11993828c0e47f2657b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9349b9ea771a0058a9cb4a57eedd624b"><td class="memTemplParams" colspan="2">template&lt;SphereConcept SphereType, Box3Concept BoxType&gt; </td></tr>
<tr class="memitem:a9349b9ea771a0058a9cb4a57eedd624b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a9349b9ea771a0058a9cb4a57eedd624b">sphereBoxIntersect</a> (const SphereType &amp;s, const BoxType &amp;box)</td></tr>
<tr class="separator:a9349b9ea771a0058a9cb4a57eedd624b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab78be5dc0d03ed32cde7a2262b506c74"><td class="memTemplParams" colspan="2">template&lt;ConstTriangle2Concept TriangleType, Point2Concept PointType&gt; </td></tr>
<tr class="memitem:ab78be5dc0d03ed32cde7a2262b506c74"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ab78be5dc0d03ed32cde7a2262b506c74">trianglePointIntersect</a> (const TriangleType &amp;tr, const PointType &amp;p)</td></tr>
<tr class="separator:ab78be5dc0d03ed32cde7a2262b506c74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b3c4b3e9c618082e4fbd063afafccb4"><td class="memTemplParams" colspan="2">template&lt;ConstTriangle3Concept TriangleType, Box3Concept BoxType&gt; </td></tr>
<tr class="memitem:a9b3c4b3e9c618082e4fbd063afafccb4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a9b3c4b3e9c618082e4fbd063afafccb4">triangleBoxIntersect</a> (const TriangleType &amp;t, const BoxType &amp;box)</td></tr>
<tr class="memdesc:a9b3c4b3e9c618082e4fbd063afafccb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a triangle intersects with a box. <a href="https://gist.github.com/jflipts/fc68d4eeacfcc04fbdb2bf38e0911850">https://gist.github.com/jflipts/fc68d4eeacfcc04fbdb2bf38e0911850</a>.  <br /></td></tr>
<tr class="separator:a9b3c4b3e9c618082e4fbd063afafccb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afef4c14e85563ae0db11815309e9a5cc"><td class="memTemplParams" colspan="2">template&lt;ConstTriangle3Concept TriangleType, SphereConcept SphereType, Point3Concept PointType, typename ScalarType &gt; </td></tr>
<tr class="memitem:afef4c14e85563ae0db11815309e9a5cc"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#afef4c14e85563ae0db11815309e9a5cc">triangleSphereItersect</a> (const TriangleType &amp;t, const SphereType &amp;sphere, PointType &amp;witness, std::pair&lt; ScalarType, ScalarType &gt; &amp;res)</td></tr>
<tr class="memdesc:afef4c14e85563ae0db11815309e9a5cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the intersection between a sphere and a triangle.  <br /></td></tr>
<tr class="separator:afef4c14e85563ae0db11815309e9a5cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af510b267910115525d77a6b4539ca3cd"><td class="memTemplParams" colspan="2">template&lt;ConstTriangle3Concept TriangleType, SphereConcept SphereType&gt; </td></tr>
<tr class="memitem:af510b267910115525d77a6b4539ca3cd"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#af510b267910115525d77a6b4539ca3cd">triangleSphereItersect</a> (const TriangleType &amp;t, const SphereType &amp;sphere)</td></tr>
<tr class="memdesc:af510b267910115525d77a6b4539ca3cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the intersection between a sphere and a triangle.  <br /></td></tr>
<tr class="separator:af510b267910115525d77a6b4539ca3cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9190d4a7064adc36dd67f861e9dd9322"><td class="memTemplParams" colspan="2">template&lt;SamplerConcept SamplerType, MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga9190d4a7064adc36dd67f861e9dd9322"><td class="memTemplItemLeft" align="right" valign="top">SamplerType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__point__sampling.html#ga9190d4a7064adc36dd67f861e9dd9322">allVerticesPointSampling</a> (const MeshType &amp;m, std::vector&lt; <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> &gt; &amp;birthVertices, bool onlySelected)</td></tr>
<tr class="memdesc:ga9190d4a7064adc36dd67f861e9dd9322"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a Sampler object that contains all the vertices contained in the given mesh.  <br /></td></tr>
<tr class="separator:ga9190d4a7064adc36dd67f861e9dd9322"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5df069dc1f33303397baf57de3e966cc"><td class="memTemplParams" colspan="2">template&lt;SamplerConcept SamplerType, MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga5df069dc1f33303397baf57de3e966cc"><td class="memTemplItemLeft" align="right" valign="top">SamplerType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__point__sampling.html#ga5df069dc1f33303397baf57de3e966cc">allVerticesPointSampling</a> (const MeshType &amp;m, bool onlySelected)</td></tr>
<tr class="memdesc:ga5df069dc1f33303397baf57de3e966cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a Sampler object that contains all the vertices contained in the given mesh.  <br /></td></tr>
<tr class="separator:ga5df069dc1f33303397baf57de3e966cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf7d743af1e6c73e4353e92c4e31f2dea"><td class="memTemplParams" colspan="2">template&lt;SamplerConcept SamplerType, FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:gaf7d743af1e6c73e4353e92c4e31f2dea"><td class="memTemplItemLeft" align="right" valign="top">SamplerType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__point__sampling.html#gaf7d743af1e6c73e4353e92c4e31f2dea">allFacesPointSampling</a> (const MeshType &amp;m, std::vector&lt; <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> &gt; &amp;birthFaces, bool onlySelected)</td></tr>
<tr class="memdesc:gaf7d743af1e6c73e4353e92c4e31f2dea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a SamplerType object that contains all the faces contained in the given mesh.  <br /></td></tr>
<tr class="separator:gaf7d743af1e6c73e4353e92c4e31f2dea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf12be366db17880d95d50fe65229a637"><td class="memTemplParams" colspan="2">template&lt;SamplerConcept SamplerType, FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:gaf12be366db17880d95d50fe65229a637"><td class="memTemplItemLeft" align="right" valign="top">SamplerType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__point__sampling.html#gaf12be366db17880d95d50fe65229a637">allFacesPointSampling</a> (const MeshType &amp;m, bool onlySelected)</td></tr>
<tr class="memdesc:gaf12be366db17880d95d50fe65229a637"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a SamplerType object that contains all the faces contained in the given mesh.  <br /></td></tr>
<tr class="separator:gaf12be366db17880d95d50fe65229a637"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab21d73d98ef71519f9dcd946e074a30f"><td class="memTemplParams" colspan="2">template&lt;SamplerConcept SamplerType, MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:gab21d73d98ef71519f9dcd946e074a30f"><td class="memTemplItemLeft" align="right" valign="top">SamplerType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__point__sampling.html#gab21d73d98ef71519f9dcd946e074a30f">vertexUniformPointSampling</a> (const MeshType &amp;m, <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> nSamples, std::vector&lt; <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> &gt; &amp;birthVertices, bool onlySelected, bool deterministic)</td></tr>
<tr class="memdesc:gab21d73d98ef71519f9dcd946e074a30f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a SamplerType object that contains the given number of samples taken from the vertices of the given mesh. Each vertex has the same probability of being chosen. If onlySelected is true, only the selected vertices are sampled. The indices of the sampled vertices in the mesh are stored in the birthVertices vector.  <br /></td></tr>
<tr class="separator:gab21d73d98ef71519f9dcd946e074a30f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b0f0e586c17f86d507b68f6c9be931c"><td class="memTemplParams" colspan="2">template&lt;SamplerConcept SamplerType, MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga2b0f0e586c17f86d507b68f6c9be931c"><td class="memTemplItemLeft" align="right" valign="top">SamplerType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__point__sampling.html#ga2b0f0e586c17f86d507b68f6c9be931c">vertexUniformPointSampling</a> (const MeshType &amp;m, <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> nSamples, bool onlySelected, bool deterministic)</td></tr>
<tr class="memdesc:ga2b0f0e586c17f86d507b68f6c9be931c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a SamplerType object that contains the given number of samples taken from the vertices of the given mesh. Each vertex has the same probability of being chosen. If onlySelected is true, only the selected vertices are sampled.  <br /></td></tr>
<tr class="separator:ga2b0f0e586c17f86d507b68f6c9be931c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae529794d6bff468c44714e4dfdbe947e"><td class="memTemplParams" colspan="2">template&lt;SamplerConcept SamplerType, FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:gae529794d6bff468c44714e4dfdbe947e"><td class="memTemplItemLeft" align="right" valign="top">SamplerType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__point__sampling.html#gae529794d6bff468c44714e4dfdbe947e">faceUniformPointSampling</a> (const MeshType &amp;m, <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> nSamples, std::vector&lt; <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> &gt; &amp;birthFaces, bool onlySelected, bool deterministic)</td></tr>
<tr class="memdesc:gae529794d6bff468c44714e4dfdbe947e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a SamplerType object that contains the given number of samples taken from the faces of the given mesh. Each face has the same probability of being chosen. If onlySelected is true, only the selected faces are sampled. The indices of the sampled faces in the mesh are stored in the birthFaces vector.  <br /></td></tr>
<tr class="separator:gae529794d6bff468c44714e4dfdbe947e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga92ab86d0eaeb53923cd7be50cb7a84d6"><td class="memTemplParams" colspan="2">template&lt;SamplerConcept SamplerType, FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga92ab86d0eaeb53923cd7be50cb7a84d6"><td class="memTemplItemLeft" align="right" valign="top">SamplerType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__point__sampling.html#ga92ab86d0eaeb53923cd7be50cb7a84d6">faceUniformPointSampling</a> (const MeshType &amp;m, <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> nSamples, bool onlySelected, bool deterministic)</td></tr>
<tr class="memdesc:ga92ab86d0eaeb53923cd7be50cb7a84d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a SamplerType object that contains the given number of samples taken from the faces of the given mesh. Each face has the same probability of being chosen. If onlySelected is true, only the selected faces are sampled.  <br /></td></tr>
<tr class="separator:ga92ab86d0eaeb53923cd7be50cb7a84d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa5e659096b646a5838a567d108eb119c"><td class="memTemplParams" colspan="2">template&lt;SamplerConcept SamplerType, MeshConcept MeshType, typename ScalarType &gt; </td></tr>
<tr class="memitem:gaa5e659096b646a5838a567d108eb119c"><td class="memTemplItemLeft" align="right" valign="top">SamplerType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__point__sampling.html#gaa5e659096b646a5838a567d108eb119c">vertexWeightedPointSampling</a> (const MeshType &amp;m, const std::vector&lt; ScalarType &gt; &amp;weights, <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> nSamples, std::vector&lt; <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> &gt; &amp;birthVertices, bool deterministic)</td></tr>
<tr class="memdesc:gaa5e659096b646a5838a567d108eb119c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Samples the vertices in a weighted way, using the per vertex weights given as input. Each vertex has a probability of being chosen that is proportional to its weight. If onlySelected is true, only the selected vertices are sampled. The indices of the sampled vertices in the mesh are stored in the birthVertices vector.  <br /></td></tr>
<tr class="separator:gaa5e659096b646a5838a567d108eb119c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32b292e1fc64c49886e8c695d63c37be"><td class="memTemplParams" colspan="2">template&lt;SamplerConcept SamplerType, MeshConcept MeshType, typename ScalarType &gt; </td></tr>
<tr class="memitem:ga32b292e1fc64c49886e8c695d63c37be"><td class="memTemplItemLeft" align="right" valign="top">SamplerType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__point__sampling.html#ga32b292e1fc64c49886e8c695d63c37be">vertexWeightedPointSampling</a> (const MeshType &amp;m, const std::vector&lt; ScalarType &gt; &amp;weights, <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> nSamples, bool deterministic)</td></tr>
<tr class="memdesc:ga32b292e1fc64c49886e8c695d63c37be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Samples the vertices in a weighted way, using the per vertex weights given as input. Each vertex has a probability of being chosen that is proportional to its weight. If onlySelected is true, only the selected vertices are sampled.  <br /></td></tr>
<tr class="separator:ga32b292e1fc64c49886e8c695d63c37be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafdcad62fa8a48a369ba9f56ffece73d7"><td class="memTemplParams" colspan="2">template&lt;SamplerConcept SamplerType, FaceMeshConcept MeshType, typename ScalarType &gt; </td></tr>
<tr class="memitem:gafdcad62fa8a48a369ba9f56ffece73d7"><td class="memTemplItemLeft" align="right" valign="top">SamplerType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__point__sampling.html#gafdcad62fa8a48a369ba9f56ffece73d7">faceWeightedPointSampling</a> (const MeshType &amp;m, const std::vector&lt; ScalarType &gt; &amp;weights, <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> nSamples, std::vector&lt; <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> &gt; &amp;birthFaces, bool deterministic)</td></tr>
<tr class="memdesc:gafdcad62fa8a48a369ba9f56ffece73d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a SamplerType object that contains the given number of samples taken from the faces of the given mesh. Each face has the same probability of being chosen. If onlySelected is true, only the selected faces are sampled. The indices of the sampled faces in the mesh are stored in the birthFaces vector.  <br /></td></tr>
<tr class="separator:gafdcad62fa8a48a369ba9f56ffece73d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga85fae359ca5c28f2e2a7e1735249b765"><td class="memTemplParams" colspan="2">template&lt;SamplerConcept SamplerType, FaceMeshConcept MeshType, typename ScalarType &gt; </td></tr>
<tr class="memitem:ga85fae359ca5c28f2e2a7e1735249b765"><td class="memTemplItemLeft" align="right" valign="top">SamplerType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__point__sampling.html#ga85fae359ca5c28f2e2a7e1735249b765">faceWeightedPointSampling</a> (const MeshType &amp;m, const std::vector&lt; ScalarType &gt; &amp;weights, <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> nSamples, bool deterministic)</td></tr>
<tr class="memdesc:ga85fae359ca5c28f2e2a7e1735249b765"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a SamplerType object that contains the given number of samples taken from the faces of the given mesh. Each face has the same probability of being chosen. If onlySelected is true, only the selected faces are sampled.  <br /></td></tr>
<tr class="separator:ga85fae359ca5c28f2e2a7e1735249b765"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f721d1906d9162a569331a614b4830b"><td class="memTemplParams" colspan="2">template&lt;SamplerConcept SamplerType, MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga9f721d1906d9162a569331a614b4830b"><td class="memTemplItemLeft" align="right" valign="top">SamplerType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__point__sampling.html#ga9f721d1906d9162a569331a614b4830b">vertexScalarWeightedPointSampling</a> (const MeshType &amp;m, <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> nSamples, bool deterministic)</td></tr>
<tr class="memdesc:ga9f721d1906d9162a569331a614b4830b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Samples the vertices in a weighted way, using the per vertex Scalar component. Each vertex has a probability of being chosen that is proportional to its scalar value.  <br /></td></tr>
<tr class="separator:ga9f721d1906d9162a569331a614b4830b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8fd0bc03ed59b595624f4493b0c4bf4e"><td class="memTemplParams" colspan="2">template&lt;SamplerConcept SamplerType, FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga8fd0bc03ed59b595624f4493b0c4bf4e"><td class="memTemplItemLeft" align="right" valign="top">SamplerType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__point__sampling.html#ga8fd0bc03ed59b595624f4493b0c4bf4e">faceScalarWeightedPointSampling</a> (const MeshType &amp;m, <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> nSamples, bool deterministic)</td></tr>
<tr class="memdesc:ga8fd0bc03ed59b595624f4493b0c4bf4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Samples the faces in a weighted way, using the per face Scalar component. Each face has a probability of being chosen that is proportional to its scalar value.  <br /></td></tr>
<tr class="separator:ga8fd0bc03ed59b595624f4493b0c4bf4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga35b842f769c4ad52c01eff2afa97efe4"><td class="memTemplParams" colspan="2">template&lt;SamplerConcept SamplerType, FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga35b842f769c4ad52c01eff2afa97efe4"><td class="memTemplItemLeft" align="right" valign="top">SamplerType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__point__sampling.html#ga35b842f769c4ad52c01eff2afa97efe4">vertexAreaWeightedPointSampling</a> (const MeshType &amp;m, <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> nSamples, bool deterministic)</td></tr>
<tr class="memdesc:ga35b842f769c4ad52c01eff2afa97efe4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Samples the vertices in a weighted way, using the area. Each vertex has a probability of being chosen that is proportional to the average area of its adjacent faces.  <br /></td></tr>
<tr class="separator:ga35b842f769c4ad52c01eff2afa97efe4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f348e7bb2a39ccc0ea30296c619f275"><td class="memTemplParams" colspan="2">template&lt;SamplerConcept SamplerType, FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga1f348e7bb2a39ccc0ea30296c619f275"><td class="memTemplItemLeft" align="right" valign="top">SamplerType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__point__sampling.html#ga1f348e7bb2a39ccc0ea30296c619f275">faceAreaWeightedPointSampling</a> (const MeshType &amp;m, <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> nSamples, bool deterministic)</td></tr>
<tr class="memdesc:ga1f348e7bb2a39ccc0ea30296c619f275"><td class="mdescLeft">&#160;</td><td class="mdescRight">Samples the faces in a weighted way, using the per face area. Each face has a probability of being chosen that is proportional to its area.  <br /></td></tr>
<tr class="separator:ga1f348e7bb2a39ccc0ea30296c619f275"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga677c02ca3e317c777210659045a301a1"><td class="memTemplParams" colspan="2">template&lt;SamplerConcept SamplerType, FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga677c02ca3e317c777210659045a301a1"><td class="memTemplItemLeft" align="right" valign="top">SamplerType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__point__sampling.html#ga677c02ca3e317c777210659045a301a1">montecarloPointSampling</a> (const MeshType &amp;m, <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> nSamples, std::vector&lt; <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> &gt; &amp;birthFaces, bool deterministic)</td></tr>
<tr class="memdesc:ga677c02ca3e317c777210659045a301a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a montecarlo distribution with an exact number of samples. It works by generating a sequence of consecutive segments proportional to the face areas and actually shooting sample over this line. The indices of the sampled faces in the mesh are stored in the birthFaces vector.  <br /></td></tr>
<tr class="separator:ga677c02ca3e317c777210659045a301a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4019223ed77edbba4626024a25218417"><td class="memTemplParams" colspan="2">template&lt;SamplerConcept SamplerType, FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga4019223ed77edbba4626024a25218417"><td class="memTemplItemLeft" align="right" valign="top">SamplerType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__point__sampling.html#ga4019223ed77edbba4626024a25218417">montecarloPointSampling</a> (const MeshType &amp;m, <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> nSamples, bool deterministic)</td></tr>
<tr class="memdesc:ga4019223ed77edbba4626024a25218417"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a montecarlo distribution with an exact number of samples. It works by generating a sequence of consecutive segments proportional to the face areas and actually shooting sample over this line.  <br /></td></tr>
<tr class="separator:ga4019223ed77edbba4626024a25218417"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e6de171a0b26281abfdfcf8d8873391"><td class="memTemplParams" colspan="2">template&lt;SamplerConcept SamplerType, FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a4e6de171a0b26281abfdfcf8d8873391"><td class="memTemplItemLeft" align="right" valign="top">SamplerType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a4e6de171a0b26281abfdfcf8d8873391">stratifiedMontecarloPointSampling</a> (const MeshType &amp;m, <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> nSamples, bool deterministic)</td></tr>
<tr class="separator:a4e6de171a0b26281abfdfcf8d8873391"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga919311a534e5f0a4f1f185d8d61af87d"><td class="memTemplParams" colspan="2">template&lt;SamplerConcept SamplerType, FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga919311a534e5f0a4f1f185d8d61af87d"><td class="memTemplItemLeft" align="right" valign="top">SamplerType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__point__sampling.html#ga919311a534e5f0a4f1f185d8d61af87d">montecarloPoissonPointSampling</a> (const MeshType &amp;m, <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> nSamples, bool deterministic)</td></tr>
<tr class="memdesc:ga919311a534e5f0a4f1f185d8d61af87d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function compute montecarlo distribution with an approximate number of samples exploiting the poisson distribution approximation of the binomial distribution.  <br /></td></tr>
<tr class="separator:ga919311a534e5f0a4f1f185d8d61af87d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac85dcd1cf45edec73080b696eec3b979"><td class="memTemplParams" colspan="2">template&lt;SamplerConcept SamplerType, FaceMeshConcept MeshType, typename ScalarType &gt; </td></tr>
<tr class="memitem:ac85dcd1cf45edec73080b696eec3b979"><td class="memTemplItemLeft" align="right" valign="top">SamplerType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ac85dcd1cf45edec73080b696eec3b979">vertexWeightedMontecarloPointSampling</a> (const MeshType &amp;m, const std::vector&lt; ScalarType &gt; &amp;weights, <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> nSamples, double variance, bool deterministic)</td></tr>
<tr class="separator:ac85dcd1cf45edec73080b696eec3b979"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ae1dec894859f749aaff3df2b173f32"><td class="memTemplParams" colspan="2">template&lt;SamplerConcept SamplerType, FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a6ae1dec894859f749aaff3df2b173f32"><td class="memTemplItemLeft" align="right" valign="top">SamplerType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a6ae1dec894859f749aaff3df2b173f32">vertexScalarWeightedMontecarloPointSampling</a> (const MeshType &amp;m, <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> nSamples, double variance, bool deterministic)</td></tr>
<tr class="separator:a6ae1dec894859f749aaff3df2b173f32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa89dee93752905adc3252463a187c046"><td class="memTemplParams" colspan="2">template&lt;FaceConcept FaceType&gt; </td></tr>
<tr class="memitem:aa89dee93752905adc3252463a187c046"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#aa89dee93752905adc3252463a187c046">faceCoords</a> (const FaceType &amp;f)</td></tr>
<tr class="separator:aa89dee93752905adc3252463a187c046"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a350d3edc324e0bef955a2c2ef8e20859"><td class="memTemplParams" colspan="2">template&lt;FaceConcept FaceType&gt; </td></tr>
<tr class="memitem:a350d3edc324e0bef955a2c2ef8e20859"><td class="memTemplItemLeft" align="right" valign="top">FaceType::VertexType::CoordType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a350d3edc324e0bef955a2c2ef8e20859">faceNormal</a> (const FaceType &amp;f)</td></tr>
<tr class="memdesc:a350d3edc324e0bef955a2c2ef8e20859"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the normal of a face, without modifying the face. Works both for triangle and polygonal faces, and it is optimized in case of triangle faces.  <br /></td></tr>
<tr class="separator:a350d3edc324e0bef955a2c2ef8e20859"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53b4f63db0979e578ebfa4b9e8b41f8a"><td class="memTemplParams" colspan="2">template&lt;FaceConcept FaceType&gt; </td></tr>
<tr class="memitem:a53b4f63db0979e578ebfa4b9e8b41f8a"><td class="memTemplItemLeft" align="right" valign="top">FaceType::VertexType::CoordType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a53b4f63db0979e578ebfa4b9e8b41f8a">faceBarycenter</a> (const FaceType &amp;f)</td></tr>
<tr class="memdesc:a53b4f63db0979e578ebfa4b9e8b41f8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the barycenter of a face. Works both for triangle and polygonal faces, and it is optimized in case of triangle faces.  <br /></td></tr>
<tr class="separator:a53b4f63db0979e578ebfa4b9e8b41f8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fc3b9cae851d7a729f40dc2f4ebe824"><td class="memTemplParams" colspan="2">template&lt;FaceConcept FaceType&gt; </td></tr>
<tr class="memitem:a9fc3b9cae851d7a729f40dc2f4ebe824"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a9fc3b9cae851d7a729f40dc2f4ebe824">faceArea</a> (const FaceType &amp;f)</td></tr>
<tr class="memdesc:a9fc3b9cae851d7a729f40dc2f4ebe824"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the area of a face. Works both for triangle and polygonal faces, and it is optimized in case of triangle faces.  <br /></td></tr>
<tr class="separator:a9fc3b9cae851d7a729f40dc2f4ebe824"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dccfede16e36e5ded5213fb13643943"><td class="memTemplParams" colspan="2">template&lt;FaceConcept FaceType&gt; </td></tr>
<tr class="memitem:a1dccfede16e36e5ded5213fb13643943"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a1dccfede16e36e5ded5213fb13643943">facePerimeter</a> (const FaceType &amp;f)</td></tr>
<tr class="memdesc:a1dccfede16e36e5ded5213fb13643943"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the perimeter of a face. Works both for triangle and polygonal faces, and it is optimized in case of triangle faces.  <br /></td></tr>
<tr class="separator:a1dccfede16e36e5ded5213fb13643943"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12529598a32a7b21eac27744b3578600"><td class="memTemplParams" colspan="2">template&lt;FaceConcept FaceType&gt; </td></tr>
<tr class="memitem:a12529598a32a7b21eac27744b3578600"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a12529598a32a7b21eac27744b3578600">faceAngleOnVertexRad</a> (const FaceType &amp;f, <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> vi)</td></tr>
<tr class="memdesc:a12529598a32a7b21eac27744b3578600"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the internal angle (in radians) of the vi-th vertex of the face.  <br /></td></tr>
<tr class="separator:a12529598a32a7b21eac27744b3578600"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2177afd92cfc4dbe6468aa05892b016f"><td class="memTemplParams" colspan="2">template&lt;FaceConcept FaceType&gt; <br />
requires comp::HasAdjacentFaces&lt;FaceType&gt;</td></tr>
<tr class="memitem:a2177afd92cfc4dbe6468aa05892b016f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a2177afd92cfc4dbe6468aa05892b016f">faceDihedralAngleOnEdge</a> (const FaceType &amp;f, <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> e)</td></tr>
<tr class="memdesc:a2177afd92cfc4dbe6468aa05892b016f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the signed dihedral angle between the normals of the given face and its adjacent face on the edge <code>e</code>.  <br /></td></tr>
<tr class="separator:a2177afd92cfc4dbe6468aa05892b016f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25a86f4bcf104c60099849828d71e06f"><td class="memTemplParams" colspan="2">template&lt;FaceConcept FaceType&gt; <br />
requires comp::HasAdjacentFaces&lt;FaceType&gt;</td></tr>
<tr class="memitem:a25a86f4bcf104c60099849828d71e06f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a25a86f4bcf104c60099849828d71e06f">isFaceManifoldOnEdge</a> (const FaceType &amp;f, <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> edge)</td></tr>
<tr class="memdesc:a25a86f4bcf104c60099849828d71e06f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if an edge in the given face is manifold.  <br /></td></tr>
<tr class="separator:a25a86f4bcf104c60099849828d71e06f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af888cb13421f6fb92d776927f302518b"><td class="memTemplParams" colspan="2">template&lt;FaceConcept FaceType&gt; <br />
requires comp::HasAdjacentFaces&lt;FaceType&gt;</td></tr>
<tr class="memitem:af888cb13421f6fb92d776927f302518b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#af888cb13421f6fb92d776927f302518b">isFaceEdgeOnBorder</a> (const FaceType &amp;f, <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> edge)</td></tr>
<tr class="memdesc:af888cb13421f6fb92d776927f302518b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if an edge in the given face is on the border.  <br /></td></tr>
<tr class="separator:af888cb13421f6fb92d776927f302518b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47188a6c411a5a4fbd8542d5ce1525aa"><td class="memTemplParams" colspan="2">template&lt;FaceConcept FaceType&gt; <br />
requires comp::HasAdjacentFaces&lt;FaceType&gt;</td></tr>
<tr class="memitem:a47188a6c411a5a4fbd8542d5ce1525aa"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a47188a6c411a5a4fbd8542d5ce1525aa">checkFlipEdge</a> (const FaceType &amp;f, <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> edge)</td></tr>
<tr class="memdesc:a47188a6c411a5a4fbd8542d5ce1525aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a boolean value indicating whether the edge flip operation is allowed or not.  <br /></td></tr>
<tr class="separator:a47188a6c411a5a4fbd8542d5ce1525aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77bd6f212cc6ca4ad37ce181c2ba6d1b"><td class="memTemplParams" colspan="2">template&lt;FaceConcept FaceType&gt; <br />
requires comp::HasAdjacentFaces&lt;FaceType&gt;</td></tr>
<tr class="memitem:a77bd6f212cc6ca4ad37ce181c2ba6d1b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a77bd6f212cc6ca4ad37ce181c2ba6d1b">edgeAdjacentFacesNumber</a> (const FaceType &amp;f, <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> edge)</td></tr>
<tr class="memdesc:a77bd6f212cc6ca4ad37ce181c2ba6d1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of adjacent faces to the given edge of the face f.  <br /></td></tr>
<tr class="separator:a77bd6f212cc6ca4ad37ce181c2ba6d1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a711865422c63688724ec6328b4e7c4cd"><td class="memTemplParams" colspan="2">template&lt;FaceConcept FaceType&gt; <br />
requires comp::HasAdjacentFaces&lt;FaceType&gt;</td></tr>
<tr class="memitem:a711865422c63688724ec6328b4e7c4cd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a711865422c63688724ec6328b4e7c4cd">faceEdgesOnBorderNumber</a> (const FaceType &amp;f)</td></tr>
<tr class="memdesc:a711865422c63688724ec6328b4e7c4cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of edges that are on border (no adjacent faces) on the given face.  <br /></td></tr>
<tr class="separator:a711865422c63688724ec6328b4e7c4cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3109cc4c0e2128888f2a3fa6ae27a98f"><td class="memTemplParams" colspan="2">template&lt;FaceConcept FaceType&gt; <br />
requires comp::HasAdjacentFaces&lt;FaceType&gt;</td></tr>
<tr class="memitem:a3109cc4c0e2128888f2a3fa6ae27a98f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a3109cc4c0e2128888f2a3fa6ae27a98f">detachAdjacentFacesOnEdge</a> (FaceType &amp;f, <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> edge)</td></tr>
<tr class="memdesc:a3109cc4c0e2128888f2a3fa6ae27a98f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detaches the face <code>f</code> on the given edge, which consists on updating adjacent faces such that any face that was linking the face <code>f</code> won't link it anymore. It manages also non-manifold edges.  <br /></td></tr>
<tr class="separator:a3109cc4c0e2128888f2a3fa6ae27a98f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af67d9147410404febe19163fb506397d"><td class="memTemplParams" colspan="2">template&lt;FaceConcept FaceType&gt; <br />
requires comp::HasAdjacentFaces&lt;FaceType&gt;</td></tr>
<tr class="memitem:af67d9147410404febe19163fb506397d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#af67d9147410404febe19163fb506397d">detachFace</a> (FaceType &amp;f)</td></tr>
<tr class="memdesc:af67d9147410404febe19163fb506397d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detaches the given face from all its adjacent vertices and adjacent faces.  <br /></td></tr>
<tr class="separator:af67d9147410404febe19163fb506397d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3983ab4b434d669a765240b81daa236e"><td class="memTemplParams" colspan="2">template&lt;FaceConcept Face&gt; </td></tr>
<tr class="memitem:a3983ab4b434d669a765240b81daa236e"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a3983ab4b434d669a765240b81daa236e">earCut</a> (const <a class="el" href="classvcl_1_1Face.html">Face</a> &amp;polygon)</td></tr>
<tr class="memdesc:a3983ab4b434d669a765240b81daa236e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the earcut algorithm of a 3D <em>planar</em> polygon, that returns a triangulation of the polygon.  <br /></td></tr>
<tr class="separator:a3983ab4b434d669a765240b81daa236e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab5bd336ab6b6a6138f89ffbb56ef3b5"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType, FaceConcept FaceType&gt; </td></tr>
<tr class="memitem:aab5bd336ab6b6a6138f89ffbb56ef3b5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#aab5bd336ab6b6a6138f89ffbb56ef3b5">addTriangleFacesFromPolygon</a> (MeshType &amp;m, FaceType &amp;f, const std::vector&lt; <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> &gt; &amp;polygon)</td></tr>
<tr class="memdesc:aab5bd336ab6b6a6138f89ffbb56ef3b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a vector of indices of vertices in a mesh representing a polyon, this function adds N triangular faces to the mesh, that are the triangulation of the input polygon. <a class="el" href="classvcl_1_1Triangle.html">Triangle</a> edges that are internal in the polygon are marked as faux.  <br /></td></tr>
<tr class="separator:aab5bd336ab6b6a6138f89ffbb56ef3b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acad48a316f6b47d2ce4fa978be50a97e"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:acad48a316f6b47d2ce4fa978be50a97e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#acad48a316f6b47d2ce4fa978be50a97e">addTriangleFacesFromPolygon</a> (MeshType &amp;m, const std::vector&lt; <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> &gt; &amp;polygon)</td></tr>
<tr class="memdesc:acad48a316f6b47d2ce4fa978be50a97e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a vector of indices of vertices in a mesh representing a polyon, this function adds N triangular faces to the mesh, that are the triangulation of the input polygon. <a class="el" href="classvcl_1_1Triangle.html">Triangle</a> edges that are internal in the polygon are marked as faux. This function returns the index of the first added triangle.  <br /></td></tr>
<tr class="separator:acad48a316f6b47d2ce4fa978be50a97e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1de4c115d6d43fdd8ace65d0cc333222"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a1de4c115d6d43fdd8ace65d0cc333222"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; typename MeshType::VertexType * &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a1de4c115d6d43fdd8ace65d0cc333222">fillAndShuffleVertexPointerVector</a> (MeshType &amp;m, bool deterministic)</td></tr>
<tr class="separator:a1de4c115d6d43fdd8ace65d0cc333222"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59d8791cc0d0b3f02cb4d41a0d5882a4"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a59d8791cc0d0b3f02cb4d41a0d5882a4"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; const typename MeshType::VertexType * &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a59d8791cc0d0b3f02cb4d41a0d5882a4">fillAndShuffleVertexPointerVector</a> (const MeshType &amp;m, bool deterministic)</td></tr>
<tr class="separator:a59d8791cc0d0b3f02cb4d41a0d5882a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfd59977983dd4b0f0dc907c6b88c66b"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:abfd59977983dd4b0f0dc907c6b88c66b"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#abfd59977983dd4b0f0dc907c6b88c66b">fillAndShuffleVertexIndexVector</a> (const MeshType &amp;m, bool deterministic)</td></tr>
<tr class="separator:abfd59977983dd4b0f0dc907c6b88c66b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dcdb951920e460a95c3aa6b85fda047"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a2dcdb951920e460a95c3aa6b85fda047"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; typename MeshType::FaceType * &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a2dcdb951920e460a95c3aa6b85fda047">fillAndShuffleFacePointerVector</a> (MeshType &amp;m, bool deterministic)</td></tr>
<tr class="separator:a2dcdb951920e460a95c3aa6b85fda047"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf22261daf1773fd04458b9df1c56500"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:acf22261daf1773fd04458b9df1c56500"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; const typename MeshType::FaceType * &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#acf22261daf1773fd04458b9df1c56500">fillAndShuffleFacePointerVector</a> (const MeshType &amp;m, bool deterministic)</td></tr>
<tr class="separator:acf22261daf1773fd04458b9df1c56500"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3049b170706391972a31e8d746877e55"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a3049b170706391972a31e8d746877e55"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a3049b170706391972a31e8d746877e55">fillAndShuffleFaceIndexVector</a> (const MeshType &amp;m, bool deterministic)</td></tr>
<tr class="separator:a3049b170706391972a31e8d746877e55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5136cc5ad6e21d0ae63aeb217983ff55"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a5136cc5ad6e21d0ae63aeb217983ff55"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a5136cc5ad6e21d0ae63aeb217983ff55">laplacianSmoothing</a> (MeshType &amp;m, <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> step, bool smoothSelected, bool cotangentWeight)</td></tr>
<tr class="memdesc:a5136cc5ad6e21d0ae63aeb217983ff55"><td class="mdescLeft">&#160;</td><td class="mdescRight">vertexCoordLaplacianSmoothing the classical Laplacian smoothing. Each vertex is moved onto the average of the adjacent vertices.  <br /></td></tr>
<tr class="separator:a5136cc5ad6e21d0ae63aeb217983ff55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4be0c0af294a129f49f266a45ee51c9"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ab4be0c0af294a129f49f266a45ee51c9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ab4be0c0af294a129f49f266a45ee51c9">taubinSmoothing</a> (MeshType &amp;m, <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> step, float lambda, float mu, bool smoothSelected)</td></tr>
<tr class="separator:ab4be0c0af294a129f49f266a45ee51c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a2005cb82322d607914a2e2dcd63e66"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a9a2005cb82322d607914a2e2dcd63e66"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a9a2005cb82322d607914a2e2dcd63e66">smoothPerVertexNormalsPointCloud</a> (MeshType &amp;m, <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> neighborNum, <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> iterNum)</td></tr>
<tr class="memdesc:a9a2005cb82322d607914a2e2dcd63e66"><td class="mdescLeft">&#160;</td><td class="mdescRight">smoothPerVertexNormalsPointCloud  <br /></td></tr>
<tr class="separator:a9a2005cb82322d607914a2e2dcd63e66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33f84f8e28d1adf77369c920bb0e46b5"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType, PointConcept PointType&gt; </td></tr>
<tr class="memitem:a33f84f8e28d1adf77369c920bb0e46b5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a33f84f8e28d1adf77369c920bb0e46b5">smoothPerVertexNormalsPointCloud</a> (MeshType &amp;m, const <a class="el" href="classvcl_1_1KDTree.html">KDTree</a>&lt; PointType &gt; &amp;tree, <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> neighborNum, <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> iterNum)</td></tr>
<tr class="memdesc:a33f84f8e28d1adf77369c920bb0e46b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">smoothPerVertexNormalsPointCloud  <br /></td></tr>
<tr class="separator:a33f84f8e28d1adf77369c920bb0e46b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af62bcbd9846a668e72b01f6f06df4962"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:af62bcbd9846a668e72b01f6f06df4962"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classvcl_1_1MeshEdgeUtil.html">MeshEdgeUtil</a>&lt; MeshType &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#af62bcbd9846a668e72b01f6f06df4962">fillAndSortMeshEdgeUtilVector</a> (MeshType &amp;m, bool includeFauxEdges)</td></tr>
<tr class="separator:af62bcbd9846a668e72b01f6f06df4962"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88fd48e496c91294c52b286f8d9abd97"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a88fd48e496c91294c52b286f8d9abd97"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classvcl_1_1ConstMeshEdgeUtil.html">ConstMeshEdgeUtil</a>&lt; MeshType &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a88fd48e496c91294c52b286f8d9abd97">fillAndSortMeshEdgeUtilVector</a> (const MeshType &amp;m, bool includeFauxEdges)</td></tr>
<tr class="separator:a88fd48e496c91294c52b286f8d9abd97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66e2e1e0ec5d91e9def735ecf4f84b0e"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a66e2e1e0ec5d91e9def735ecf4f84b0e"><td class="memTemplItemLeft" align="right" valign="top">MeshType::VertexType::CoordType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a66e2e1e0ec5d91e9def735ecf4f84b0e">barycenter</a> (const MeshType &amp;m)</td></tr>
<tr class="memdesc:a66e2e1e0ec5d91e9def735ecf4f84b0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the barycenter of the mesh, that is the simple average of all the vertex coordintes of the mesh.  <br /></td></tr>
<tr class="separator:a66e2e1e0ec5d91e9def735ecf4f84b0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63bff22265d64d974b4fe4267b6dbac0"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a63bff22265d64d974b4fe4267b6dbac0"><td class="memTemplItemLeft" align="right" valign="top">MeshType::VertexType::CoordType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a63bff22265d64d974b4fe4267b6dbac0">scalarWeightedBarycenter</a> (const MeshType &amp;m)</td></tr>
<tr class="memdesc:a63bff22265d64d974b4fe4267b6dbac0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the barycenter of the mesh weighted on the per vertex scalar values.  <br /></td></tr>
<tr class="separator:a63bff22265d64d974b4fe4267b6dbac0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecc52dfd02e09e49a5dd1612183a2cb8"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:aecc52dfd02e09e49a5dd1612183a2cb8"><td class="memTemplItemLeft" align="right" valign="top">MeshType::VertexType::CoordType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#aecc52dfd02e09e49a5dd1612183a2cb8">shellBarycenter</a> (const MeshType &amp;m)</td></tr>
<tr class="memdesc:aecc52dfd02e09e49a5dd1612183a2cb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the barycenter of the surface thin-shell. E.g. it assume a 'empty' model where all the mass is located on the surface and compute the barycenter of that thinshell. Works for any polygonal model (no problem with open, nonmanifold selfintersecting models). Useful for computing the barycenter of 2D planar figures.  <br /></td></tr>
<tr class="separator:aecc52dfd02e09e49a5dd1612183a2cb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a3eb7aeb0da02be51ca136620616b43"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a9a3eb7aeb0da02be51ca136620616b43"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a9a3eb7aeb0da02be51ca136620616b43">volume</a> (const MeshType &amp;m)</td></tr>
<tr class="memdesc:a9a3eb7aeb0da02be51ca136620616b43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the volume of a closed surface <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>. Returned value is meaningful only if the input mesh is watertight.  <br /></td></tr>
<tr class="separator:a9a3eb7aeb0da02be51ca136620616b43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dfa8d4e30b457c12c3e5e21b4fc123a"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a5dfa8d4e30b457c12c3e5e21b4fc123a"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a5dfa8d4e30b457c12c3e5e21b4fc123a">surfaceArea</a> (const MeshType &amp;m)</td></tr>
<tr class="memdesc:a5dfa8d4e30b457c12c3e5e21b4fc123a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the surface area of the given <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>, that is the sum of the areas of each face of the mesh.  <br /></td></tr>
<tr class="separator:a5dfa8d4e30b457c12c3e5e21b4fc123a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86c0811cfbc37a3b319d57902e81e949"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a86c0811cfbc37a3b319d57902e81e949"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a86c0811cfbc37a3b319d57902e81e949">borderLength</a> (const MeshType &amp;m)</td></tr>
<tr class="memdesc:a86c0811cfbc37a3b319d57902e81e949"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the border length of the given <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>, that is the sum of the length of the edges that are on border in the given mesh.  <br /></td></tr>
<tr class="separator:a86c0811cfbc37a3b319d57902e81e949"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9fd633374c0d8ab86df9e354a9a0fb5"><td class="memTemplParams" colspan="2">template&lt;PointConcept PointType&gt; </td></tr>
<tr class="memitem:af9fd633374c0d8ab86df9e354a9a0fb5"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#af9fd633374c0d8ab86df9e354a9a0fb5">covarianceMatrixOfPointCloud</a> (const std::vector&lt; PointType &gt; &amp;pointVec)</td></tr>
<tr class="memdesc:af9fd633374c0d8ab86df9e354a9a0fb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the covariance matrix of a set of points.  <br /></td></tr>
<tr class="separator:af9fd633374c0d8ab86df9e354a9a0fb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46a67e9dd1e0a9805f812c10328caaa2"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a46a67e9dd1e0a9805f812c10328caaa2"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a46a67e9dd1e0a9805f812c10328caaa2">covarianceMatrixOfPointCloud</a> (const MeshType &amp;m)</td></tr>
<tr class="memdesc:a46a67e9dd1e0a9805f812c10328caaa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the covariance matrix of a <a class="el" href="classvcl_1_1Point.html" title="The Point class represents an N-dimensional point containing N scalar values.">Point</a> Cloud <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>.  <br /></td></tr>
<tr class="separator:a46a67e9dd1e0a9805f812c10328caaa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe0d3154bb94af5fb7d34bd186eba0b3"><td class="memTemplParams" colspan="2">template&lt;PointConcept PointType&gt; </td></tr>
<tr class="memitem:abe0d3154bb94af5fb7d34bd186eba0b3"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#abe0d3154bb94af5fb7d34bd186eba0b3">weightedCovarianceMatrixOfPointCloud</a> (const std::vector&lt; PointType &gt; &amp;pointVec, const std::vector&lt; typename PointType::ScalarType &gt; &amp;weights)</td></tr>
<tr class="memdesc:abe0d3154bb94af5fb7d34bd186eba0b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the weighted covariance matrix of a set of points.  <br /></td></tr>
<tr class="separator:abe0d3154bb94af5fb7d34bd186eba0b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49e57acf0c1cb51e98f7a176051d99ee"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a49e57acf0c1cb51e98f7a176051d99ee"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a49e57acf0c1cb51e98f7a176051d99ee">covarianceMatrixOfMesh</a> (const MeshType &amp;m)</td></tr>
<tr class="memdesc:a49e57acf0c1cb51e98f7a176051d99ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute covariance matrix of a mesh, i.e. the integral int_{m} { (x-b)(x-b)^T }dx where b is the barycenter and x spans over the mesh m.  <br /></td></tr>
<tr class="separator:a49e57acf0c1cb51e98f7a176051d99ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca01bc85ddb1d1380f67edccbc1de874"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType, typename ScalarType &gt; </td></tr>
<tr class="memitem:aca01bc85ddb1d1380f67edccbc1de874"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; ScalarType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#aca01bc85ddb1d1380f67edccbc1de874">vertexRadiusFromWeights</a> (const MeshType &amp;m, const std::vector&lt; ScalarType &gt; &amp;weights, double diskRadius, double radiusVariance, bool invert)</td></tr>
<tr class="memdesc:aca01bc85ddb1d1380f67edccbc1de874"><td class="mdescLeft">&#160;</td><td class="mdescRight">When performing an adptive pruning for each sample we expect a varying radius to be removed. The radius is a PerVertex attribute that we compute from the current per vertex weights given as argument. The expected radius of the sample is computed so that it linearly maps the quality between diskradius and diskradius*variance.  <br /></td></tr>
<tr class="separator:aca01bc85ddb1d1380f67edccbc1de874"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a8d317c143b86f988742f1d171fcf0e"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a4a8d317c143b86f988742f1d171fcf0e"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; typename MeshType::VertexType::ScalarType, typename MeshType::VertexType::ScalarType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a4a8d317c143b86f988742f1d171fcf0e">vertexScalarMinMax</a> (const MeshType &amp;m)</td></tr>
<tr class="memdesc:a4a8d317c143b86f988742f1d171fcf0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pair containing the min and the maximum vertex scalars.  <br /></td></tr>
<tr class="separator:a4a8d317c143b86f988742f1d171fcf0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8aea6a69e2b5319acebef66b06bd6692"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a8aea6a69e2b5319acebef66b06bd6692"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; typename MeshType::FaceType::ScalarType, typename MeshType::FaceType::ScalarType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a8aea6a69e2b5319acebef66b06bd6692">faceScalarMinMax</a> (const MeshType &amp;m)</td></tr>
<tr class="memdesc:a8aea6a69e2b5319acebef66b06bd6692"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pair containing the min and the maximum face scalars.  <br /></td></tr>
<tr class="separator:a8aea6a69e2b5319acebef66b06bd6692"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75ed72afa568f487bd2a4cc2f6839c93"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a75ed72afa568f487bd2a4cc2f6839c93"><td class="memTemplItemLeft" align="right" valign="top">MeshType::VertexType::ScalarType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a75ed72afa568f487bd2a4cc2f6839c93">vertexScalarAverage</a> (const MeshType &amp;m)</td></tr>
<tr class="memdesc:a75ed72afa568f487bd2a4cc2f6839c93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a scalar that is the average of the vertex scalars.  <br /></td></tr>
<tr class="separator:a75ed72afa568f487bd2a4cc2f6839c93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2325a44d0d3b56eb04cd498d4a233ae5"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a2325a44d0d3b56eb04cd498d4a233ae5"><td class="memTemplItemLeft" align="right" valign="top">MeshType::FaceType::ScalarType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a2325a44d0d3b56eb04cd498d4a233ae5">faceScalarAverage</a> (const MeshType &amp;m)</td></tr>
<tr class="memdesc:a2325a44d0d3b56eb04cd498d4a233ae5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a scalar that is the average of the face scalars.  <br /></td></tr>
<tr class="separator:a2325a44d0d3b56eb04cd498d4a233ae5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2f710a404acc6926e189fab8c987a38"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ad2f710a404acc6926e189fab8c987a38"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; typename MeshType::VertexType::ScalarType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ad2f710a404acc6926e189fab8c987a38">vertexRadiusFromScalar</a> (const MeshType &amp;m, double diskRadius, double radiusVariance, bool invert)</td></tr>
<tr class="memdesc:ad2f710a404acc6926e189fab8c987a38"><td class="mdescLeft">&#160;</td><td class="mdescRight">When performing an adptive pruning for each sample we expect a varying radius to be removed. The radius is a PerVertex attribute that we compute from the current per vertex scalar component. The expected radius of the sample is computed so that it linearly maps the quality between diskradius and diskradius*variance.  <br /></td></tr>
<tr class="separator:ad2f710a404acc6926e189fab8c987a38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6593afbf201de1ecd2c075ec374092d"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType, typename HScalar &gt; </td></tr>
<tr class="memitem:ad6593afbf201de1ecd2c075ec374092d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Histogram.html">Histogram</a>&lt; HScalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ad6593afbf201de1ecd2c075ec374092d">vertexScalarHistogram</a> (const MeshType &amp;m, bool selectionOnly, <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> histSize)</td></tr>
<tr class="separator:ad6593afbf201de1ecd2c075ec374092d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a841b98019d6492c95446f2ae39917934"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType, typename HScalar &gt; </td></tr>
<tr class="memitem:a841b98019d6492c95446f2ae39917934"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Histogram.html">Histogram</a>&lt; HScalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a841b98019d6492c95446f2ae39917934">faceScalarHistogram</a> (const MeshType &amp;m, bool selectionOnly, <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> histSize)</td></tr>
<tr class="separator:a841b98019d6492c95446f2ae39917934"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ebad55b87f91b27b05663d9ce7ad406"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a7ebad55b87f91b27b05663d9ce7ad406"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a7ebad55b87f91b27b05663d9ce7ad406">vertexSelectionNumber</a> (const MeshType &amp;m)</td></tr>
<tr class="separator:a7ebad55b87f91b27b05663d9ce7ad406"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5585995167e0f9338ebb153314c0067b"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a5585995167e0f9338ebb153314c0067b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a5585995167e0f9338ebb153314c0067b">faceSelectionNumber</a> (const MeshType &amp;m)</td></tr>
<tr class="separator:a5585995167e0f9338ebb153314c0067b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ecd18a495232ac86d4c81913a1ad3f7"><td class="memTemplParams" colspan="2">template&lt;HasBoundingBox MeshType&gt; </td></tr>
<tr class="memitem:a8ecd18a495232ac86d4c81913a1ad3f7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a8ecd18a495232ac86d4c81913a1ad3f7">updateBoundingBox</a> (MeshType &amp;m)</td></tr>
<tr class="memdesc:a8ecd18a495232ac86d4c81913a1ad3f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the bounding box of the mesh.  <br /></td></tr>
<tr class="separator:a8ecd18a495232ac86d4c81913a1ad3f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa643c00b32840296da8c9dbe4932dabb"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:aa643c00b32840296da8c9dbe4932dabb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#aa643c00b32840296da8c9dbe4932dabb">setPerVertexColor</a> (MeshType &amp;m, <a class="el" href="classvcl_1_1Color.html">vcl::Color</a> c, bool onlySelected)</td></tr>
<tr class="memdesc:aa643c00b32840296da8c9dbe4932dabb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the color of the vertices. If the <code>onlySelected</code> flag is set to <code>true</code>, only the color of the selected vertices will be set. Otherwise, all the vertices will have the same color.  <br /></td></tr>
<tr class="separator:aa643c00b32840296da8c9dbe4932dabb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a236951d11e297e90a0a316f64c77e749"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a236951d11e297e90a0a316f64c77e749"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a236951d11e297e90a0a316f64c77e749">setPerFaceColor</a> (MeshType &amp;m, <a class="el" href="classvcl_1_1Color.html">vcl::Color</a> c, bool onlySelected)</td></tr>
<tr class="memdesc:a236951d11e297e90a0a316f64c77e749"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the color of the faces. If the <code>onlySelected</code> flag is set to <code>true</code>, only the color of the selected faces will be set. Otherwise, all the faces will have the same color.  <br /></td></tr>
<tr class="separator:a236951d11e297e90a0a316f64c77e749"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cb661aee95c85d26bcd064375b3c7dd"><td class="memTemplParams" colspan="2">template&lt;HasColor MeshType&gt; </td></tr>
<tr class="memitem:a2cb661aee95c85d26bcd064375b3c7dd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a2cb661aee95c85d26bcd064375b3c7dd">setMeshColor</a> (MeshType &amp;m, <a class="el" href="classvcl_1_1Color.html">vcl::Color</a> c)</td></tr>
<tr class="memdesc:a2cb661aee95c85d26bcd064375b3c7dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the color component of a mesh.  <br /></td></tr>
<tr class="separator:a2cb661aee95c85d26bcd064375b3c7dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a003227edc01710ea2a42c6e326b34698"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a003227edc01710ea2a42c6e326b34698"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a003227edc01710ea2a42c6e326b34698">setPerVertexColorFromFaceColor</a> (MeshType &amp;m)</td></tr>
<tr class="memdesc:a003227edc01710ea2a42c6e326b34698"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the vertex colors from its incident face colors, computing a plain average of the face colors.  <br /></td></tr>
<tr class="separator:a003227edc01710ea2a42c6e326b34698"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a698e981e0c5fd646f3401579735e7825"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a698e981e0c5fd646f3401579735e7825"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a698e981e0c5fd646f3401579735e7825">setPerFaceColorFromVertexColor</a> (MeshType &amp;m)</td></tr>
<tr class="memdesc:a698e981e0c5fd646f3401579735e7825"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the face colors from its incident vertex colors, computing a plain average of the vertex colors.  <br /></td></tr>
<tr class="separator:a698e981e0c5fd646f3401579735e7825"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac937d4372b4e0784cc9cf85b33fc1e61"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ac937d4372b4e0784cc9cf85b33fc1e61"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ac937d4372b4e0784cc9cf85b33fc1e61">setPerVertexColorFromScalar</a> (MeshType &amp;m, <a class="el" href="classvcl_1_1Color.html#a32ace7bd7fccf742b39f6cd83042a10f">vcl::Color::ColorMap</a> colorMap, typename MeshType::VertexType::ScalarType minScalar, typename MeshType::VertexType::ScalarType maxScalar)</td></tr>
<tr class="memdesc:ac937d4372b4e0784cc9cf85b33fc1e61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the vertex colors from the scalar values by computing a shading in the given color map (default is Red to Blue color map), in the given interval [minScalar, maxScalar].  <br /></td></tr>
<tr class="separator:ac937d4372b4e0784cc9cf85b33fc1e61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae93eb0f4de91d15f5de763f2372a046a"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ae93eb0f4de91d15f5de763f2372a046a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ae93eb0f4de91d15f5de763f2372a046a">setPerFaceColorFromScalar</a> (MeshType &amp;m, <a class="el" href="classvcl_1_1Color.html#a32ace7bd7fccf742b39f6cd83042a10f">vcl::Color::ColorMap</a> colorMap, typename MeshType::FaceType::ScalarType minScalar, typename MeshType::FaceType::ScalarType maxScalar)</td></tr>
<tr class="memdesc:ae93eb0f4de91d15f5de763f2372a046a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the face colors from the scalar values by computing a shading in the given color map (default is Red to Blue color map), in the given interval [minScalar, maxScalar].  <br /></td></tr>
<tr class="separator:ae93eb0f4de91d15f5de763f2372a046a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8af505d2c161282e28934d6be34a3cfc"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a8af505d2c161282e28934d6be34a3cfc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a8af505d2c161282e28934d6be34a3cfc">setPerVertexColorFromFaceBorderFlag</a> (MeshType &amp;m, <a class="el" href="classvcl_1_1Color.html">Color</a> borderColor, <a class="el" href="classvcl_1_1Color.html">Color</a> internalColor, <a class="el" href="classvcl_1_1Color.html">Color</a> mixColor)</td></tr>
<tr class="memdesc:a8af505d2c161282e28934d6be34a3cfc"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classvcl_1_1Color.html" title="The Color class represents an RGBA color.">Color</a> the vertices of the mesh that are on border, using the border flags of the faces.  <br /></td></tr>
<tr class="separator:a8af505d2c161282e28934d6be34a3cfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefda81ff00c7e8d3b5ff19c9e90c03bf"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:aefda81ff00c7e8d3b5ff19c9e90c03bf"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#aefda81ff00c7e8d3b5ff19c9e90c03bf">setPerFaceColorFromConnectedComponents</a> (MeshType &amp;m, const std::vector&lt; std::set&lt; <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> &gt; &gt; &amp;<a class="el" href="group__clean.html#ga774f9a47e9cef107d59b97d0434177f7">connectedComponents</a>)</td></tr>
<tr class="memdesc:aefda81ff00c7e8d3b5ff19c9e90c03bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an already computed vector of sets of connected components (see vcl::connectedComponents(m) in <code><a class="el" href="clean_8h.html">vclib/algorithms/clean.h</a></code>), sets face colors according from connected components of the mesh. Each connected component will have a different per face color.  <br /></td></tr>
<tr class="separator:aefda81ff00c7e8d3b5ff19c9e90c03bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39a8c9027a5e7c936518969bda799f71"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a39a8c9027a5e7c936518969bda799f71"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a39a8c9027a5e7c936518969bda799f71">setPerFaceColorFromConnectedComponents</a> (MeshType &amp;m)</td></tr>
<tr class="memdesc:a39a8c9027a5e7c936518969bda799f71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets face colors according from connected components of the mesh. Each connected component will have a different per face color. Since this function will need to compute connected components of the mesh, also per <a class="el" href="classvcl_1_1Face.html" title="The Face class.">Face</a> AdjacentFaces component is required.  <br /></td></tr>
<tr class="separator:a39a8c9027a5e7c936518969bda799f71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af02be2fb7f65c872e8dde9bd8565bc09"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:af02be2fb7f65c872e8dde9bd8565bc09"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#af02be2fb7f65c872e8dde9bd8565bc09">setPerFaceColorScattering</a> (MeshType &amp;m, <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> nColors, bool checkFauxEdges)</td></tr>
<tr class="memdesc:af02be2fb7f65c872e8dde9bd8565bc09"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function colors each face of the mesh using a given number of scattering colors (default number is 50). By default, colors uniformely adjacent faces having faux edges in common. This check is made only if the option <code>checkFauxEdges</code> is set to true, and if the per <a class="el" href="classvcl_1_1Face.html" title="The Face class.">Face</a> AdjacentFaces component is available in the mesh.  <br /></td></tr>
<tr class="separator:af02be2fb7f65c872e8dde9bd8565bc09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c2fd97be0605b1e7a49d2b5611f51aa"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType, PointConcept PointType&gt; </td></tr>
<tr class="memitem:a0c2fd97be0605b1e7a49d2b5611f51aa"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a0c2fd97be0605b1e7a49d2b5611f51aa">setPerVertexColorPerlinNoise</a> (MeshType &amp;m, PointType period, PointType offset, bool onSelected)</td></tr>
<tr class="memdesc:a0c2fd97be0605b1e7a49d2b5611f51aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the vertex color according to a perlin noise computed on the vertex coordinates.  <br /></td></tr>
<tr class="separator:a0c2fd97be0605b1e7a49d2b5611f51aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae27dccedeec719d7d3f0e7f1f084a84e"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType, PointConcept PointType&gt; </td></tr>
<tr class="memitem:ae27dccedeec719d7d3f0e7f1f084a84e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ae27dccedeec719d7d3f0e7f1f084a84e">setPerVertexPerlinColor</a> (MeshType &amp;m, double period, PointType offset, <a class="el" href="classvcl_1_1Color.html">Color</a> color1, <a class="el" href="classvcl_1_1Color.html">Color</a> color2, bool onSelected)</td></tr>
<tr class="memdesc:ae27dccedeec719d7d3f0e7f1f084a84e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple Perlin color mixing. <code>color1</code> and <code>color2</code> are mixed according the perlin noise function, with period and offset.  <br /></td></tr>
<tr class="separator:ae27dccedeec719d7d3f0e7f1f084a84e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0953cccb4f94dded63edb630530e2197"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType, LoggerConcept LogType&gt; </td></tr>
<tr class="memitem:a0953cccb4f94dded63edb630530e2197"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a0953cccb4f94dded63edb630530e2197">updatePrincipalCurvatureTaubin95</a> (MeshType &amp;m, LogType &amp;log)</td></tr>
<tr class="separator:a0953cccb4f94dded63edb630530e2197"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f5267f974ec6b9fef98556736bbe9ea"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType, LoggerConcept LogType&gt; </td></tr>
<tr class="memitem:a6f5267f974ec6b9fef98556736bbe9ea"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a6f5267f974ec6b9fef98556736bbe9ea">updatePrincipalCurvaturePCA</a> (MeshType &amp;m, typename MeshType::VertexType::ScalarType radius, bool montecarloSampling, LogType &amp;log)</td></tr>
<tr class="memdesc:a6f5267f974ec6b9fef98556736bbe9ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the Principal Curvature meseaure as described in the paper: Robust principal curvatures on Multiple Scales, Yong-Liang Yang, Yu-Kun Lai, Shi-Min Hu Helmut Pottmann SGP 2004. If montecarloSampling==true the covariance is computed by montecarlo sampling on the mesh (faster); If montecarloSampling==false the covariance is computed by (analytic)integration over the surface (slower).  <br /></td></tr>
<tr class="separator:a6f5267f974ec6b9fef98556736bbe9ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a187f29d4ba3ddfbf954bab8ad61967d1"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType, LoggerConcept LogType&gt; </td></tr>
<tr class="memitem:a187f29d4ba3ddfbf954bab8ad61967d1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a187f29d4ba3ddfbf954bab8ad61967d1">updatePrincipalCurvature</a> (MeshType &amp;m, LogType &amp;log)</td></tr>
<tr class="separator:a187f29d4ba3ddfbf954bab8ad61967d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d231fe4d9706e7a951c377995688079"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType, LoggerConcept LogType&gt; </td></tr>
<tr class="memitem:a0d231fe4d9706e7a951c377995688079"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a0d231fe4d9706e7a951c377995688079">updatePrincipalCurvature</a> (MeshType &amp;m, <a class="el" href="namespacevcl.html#aaca879a6bfd47ff8429d6b2f6cfa9440">VCLibPrincipalCurvatureAlgorithm</a> alg, LogType &amp;log)</td></tr>
<tr class="separator:a0d231fe4d9706e7a951c377995688079"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a359b253b8af6d1ae3ac24625e8ac7a56"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a359b253b8af6d1ae3ac24625e8ac7a56"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a359b253b8af6d1ae3ac24625e8ac7a56">updateBorder</a> (MeshType &amp;m)</td></tr>
<tr class="memdesc:a359b253b8af6d1ae3ac24625e8ac7a56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes per-face border flags without requiring any kind of topology info.  <br /></td></tr>
<tr class="separator:a359b253b8af6d1ae3ac24625e8ac7a56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3ccefcbb94fc15319e388a1183f3925"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ae3ccefcbb94fc15319e388a1183f3925"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ae3ccefcbb94fc15319e388a1183f3925">normalizePerFaceNormals</a> (MeshType &amp;m)</td></tr>
<tr class="memdesc:ae3ccefcbb94fc15319e388a1183f3925"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalizes the length of the face normals.  <br /></td></tr>
<tr class="separator:ae3ccefcbb94fc15319e388a1183f3925"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a15ac19d4224a7a140430d7c209203c"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a9a15ac19d4224a7a140430d7c209203c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a9a15ac19d4224a7a140430d7c209203c">updatePerFaceNormals</a> (MeshType &amp;m, bool normalize)</td></tr>
<tr class="memdesc:a9a15ac19d4224a7a140430d7c209203c"><td class="mdescLeft">&#160;</td><td class="mdescRight">updatePerFaceNormals  <br /></td></tr>
<tr class="separator:a9a15ac19d4224a7a140430d7c209203c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6a0e2bc172c69d34a84631e824c75a4"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ad6a0e2bc172c69d34a84631e824c75a4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ad6a0e2bc172c69d34a84631e824c75a4">clearPerVertexNormals</a> (MeshType &amp;m)</td></tr>
<tr class="memdesc:ad6a0e2bc172c69d34a84631e824c75a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets to zero the normals of all the vertices of the mesh, including the unreferenced ones.  <br /></td></tr>
<tr class="separator:ad6a0e2bc172c69d34a84631e824c75a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5ad240da55effe35e495f1aad2e3507"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:aa5ad240da55effe35e495f1aad2e3507"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#aa5ad240da55effe35e495f1aad2e3507">clearPerReferencedVertexNormals</a> (MeshType &amp;m)</td></tr>
<tr class="memdesc:aa5ad240da55effe35e495f1aad2e3507"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets to zero all the normals of vertices that are referenced by at least one face, leaving unchanged all the normals of the unreferenced vertices that may be still useful.  <br /></td></tr>
<tr class="separator:aa5ad240da55effe35e495f1aad2e3507"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c7590577a9732afcd1dc3639b3965b6"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a0c7590577a9732afcd1dc3639b3965b6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a0c7590577a9732afcd1dc3639b3965b6">normalizePerVertexNormals</a> (MeshType &amp;m)</td></tr>
<tr class="memdesc:a0c7590577a9732afcd1dc3639b3965b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalizes the length of the vertex normals.  <br /></td></tr>
<tr class="separator:a0c7590577a9732afcd1dc3639b3965b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ffafa25128bbb020b17d135d5f1ac30"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a5ffafa25128bbb020b17d135d5f1ac30"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a5ffafa25128bbb020b17d135d5f1ac30">updatePerVertexNormals</a> (MeshType &amp;m, bool normalize)</td></tr>
<tr class="memdesc:a5ffafa25128bbb020b17d135d5f1ac30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the vertex normal as the classic area weighted average.  <br /></td></tr>
<tr class="separator:a5ffafa25128bbb020b17d135d5f1ac30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a174b88dbc14a78799d856505b061a2cb"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a174b88dbc14a78799d856505b061a2cb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a174b88dbc14a78799d856505b061a2cb">updatePerVertexNormalsFromFaceNormals</a> (MeshType &amp;m, bool normalize)</td></tr>
<tr class="memdesc:a174b88dbc14a78799d856505b061a2cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the vertex normal as the sum of the adjacent faces normals.  <br /></td></tr>
<tr class="separator:a174b88dbc14a78799d856505b061a2cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abed9b2152933865a0d095b9ff2e28087"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:abed9b2152933865a0d095b9ff2e28087"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#abed9b2152933865a0d095b9ff2e28087">updatePerVertexNormalsAngleWeighted</a> (MeshType &amp;m, bool normalize)</td></tr>
<tr class="memdesc:abed9b2152933865a0d095b9ff2e28087"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the vertex normal as an angle weighted average.  <br /></td></tr>
<tr class="separator:abed9b2152933865a0d095b9ff2e28087"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac81b97996fdfb6ff64cf8f42688b9ebc"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ac81b97996fdfb6ff64cf8f42688b9ebc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ac81b97996fdfb6ff64cf8f42688b9ebc">updatePerVertexNormalsNelsonMaxWeighted</a> (MeshType &amp;m, bool normalize)</td></tr>
<tr class="memdesc:ac81b97996fdfb6ff64cf8f42688b9ebc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the vertex normal using the Max et al. weighting scheme.  <br /></td></tr>
<tr class="separator:ac81b97996fdfb6ff64cf8f42688b9ebc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae925bc10e1eec9a48761c6b852756e42"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType, typename MScalar &gt; </td></tr>
<tr class="memitem:ae925bc10e1eec9a48761c6b852756e42"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ae925bc10e1eec9a48761c6b852756e42">multiplyPerFaceNormalsByMatrix</a> (MeshType &amp;mesh, const <a class="el" href="namespacevcl.html#ad82a126b390f21b2e9658c73e7a795ee">vcl::Matrix44</a>&lt; MScalar &gt; &amp;mat, bool removeScalingFromMatrix)</td></tr>
<tr class="memdesc:ae925bc10e1eec9a48761c6b852756e42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies the <a class="el" href="classvcl_1_1Face.html" title="The Face class.">Face</a> Normals by the given TRS 4x4 Matrix. By default, the scale component is removed from the matrix.  <br /></td></tr>
<tr class="separator:ae925bc10e1eec9a48761c6b852756e42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c520689bfd82598aafdae321530c762"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType, typename MScalar &gt; </td></tr>
<tr class="memitem:a7c520689bfd82598aafdae321530c762"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a7c520689bfd82598aafdae321530c762">multiplyPerVertexNormalsByMatrix</a> (MeshType &amp;mesh, const <a class="el" href="namespacevcl.html#ad82a126b390f21b2e9658c73e7a795ee">vcl::Matrix44</a>&lt; MScalar &gt; &amp;mat, bool removeScalingFromMatrix)</td></tr>
<tr class="memdesc:a7c520689bfd82598aafdae321530c762"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies the <a class="el" href="classvcl_1_1Vertex.html" title="The Vertex class.">Vertex</a> Normals by the given TRS 4x4 Matrix. By default, the scale component is removed from the matrix.  <br /></td></tr>
<tr class="separator:a7c520689bfd82598aafdae321530c762"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d78bdbe3ba40a15958c4606980cdc36"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a7d78bdbe3ba40a15958c4606980cdc36"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a7d78bdbe3ba40a15958c4606980cdc36">setPerVertexScalar</a> (MeshType &amp;m, typename MeshType::VertexType::ScalarType s)</td></tr>
<tr class="memdesc:a7d78bdbe3ba40a15958c4606980cdc36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a constant value to all the vertex scalars of the mesh.  <br /></td></tr>
<tr class="separator:a7d78bdbe3ba40a15958c4606980cdc36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a325958d633ef2b4e07217615993933af"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a325958d633ef2b4e07217615993933af"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a325958d633ef2b4e07217615993933af">setPerFaceScalar</a> (MeshType &amp;m, typename MeshType::FaceType::ScalarType s)</td></tr>
<tr class="memdesc:a325958d633ef2b4e07217615993933af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a constant value to all the face scalars of the mesh.  <br /></td></tr>
<tr class="separator:a325958d633ef2b4e07217615993933af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23e2af9adc2addc3187a9c086146723e"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a23e2af9adc2addc3187a9c086146723e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a23e2af9adc2addc3187a9c086146723e">clampPerVertexScalar</a> (MeshType &amp;m, typename MeshType::VertexType::ScalarType minS, typename MeshType::VertexType::ScalarType maxS)</td></tr>
<tr class="memdesc:a23e2af9adc2addc3187a9c086146723e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clamps the vertex scalars of a mesh in a given interval.  <br /></td></tr>
<tr class="separator:a23e2af9adc2addc3187a9c086146723e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa98b23c4b973942fb42c0247077299b0"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:aa98b23c4b973942fb42c0247077299b0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#aa98b23c4b973942fb42c0247077299b0">clampPerFaceScalar</a> (MeshType &amp;m, typename MeshType::FaceType::ScalarType minS, typename MeshType::FaceType::ScalarType maxS)</td></tr>
<tr class="memdesc:aa98b23c4b973942fb42c0247077299b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clamps the face scalars of a mesh in a given interval.  <br /></td></tr>
<tr class="separator:aa98b23c4b973942fb42c0247077299b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3955ddf9f13739cc169caca71a2db88"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ab3955ddf9f13739cc169caca71a2db88"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ab3955ddf9f13739cc169caca71a2db88">normalizePerVertexScalar</a> (MeshType &amp;m, typename MeshType::VertexType::ScalarType minS, typename MeshType::VertexType::ScalarType maxS)</td></tr>
<tr class="memdesc:ab3955ddf9f13739cc169caca71a2db88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalizes the vertex scalars of a mesh in a given interval (default [0, 1]).  <br /></td></tr>
<tr class="separator:ab3955ddf9f13739cc169caca71a2db88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acac925494e3e17b45b0a352bcd2c5961"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:acac925494e3e17b45b0a352bcd2c5961"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#acac925494e3e17b45b0a352bcd2c5961">normalizePerFaceScalar</a> (MeshType &amp;m, typename MeshType::FaceType::ScalarType minS, typename MeshType::FaceType::ScalarType maxS)</td></tr>
<tr class="memdesc:acac925494e3e17b45b0a352bcd2c5961"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalizes the face scalars of a mesh in a given interval (default [0, 1]).  <br /></td></tr>
<tr class="separator:acac925494e3e17b45b0a352bcd2c5961"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e4d00c0f0dfb599819e7cf5b1e6c746"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a2e4d00c0f0dfb599819e7cf5b1e6c746"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a2e4d00c0f0dfb599819e7cf5b1e6c746">setPerVertexScalarFromVertexValence</a> (MeshType &amp;m)</td></tr>
<tr class="memdesc:a2e4d00c0f0dfb599819e7cf5b1e6c746"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign to the vertex scalars of the mesh the valence of each vertex, that is the number of adjacent faces of the vertex.  <br /></td></tr>
<tr class="separator:a2e4d00c0f0dfb599819e7cf5b1e6c746"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1d1835fbdfdc91928dee5eb7234b8ba"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ae1d1835fbdfdc91928dee5eb7234b8ba"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ae1d1835fbdfdc91928dee5eb7234b8ba">setPerFaceScalarFromFaceArea</a> (MeshType &amp;m)</td></tr>
<tr class="memdesc:ae1d1835fbdfdc91928dee5eb7234b8ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign to the face scalars of the mesh the area of each face.  <br /></td></tr>
<tr class="separator:ae1d1835fbdfdc91928dee5eb7234b8ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff1028f512578880b9d45e7557df8478"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:aff1028f512578880b9d45e7557df8478"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#aff1028f512578880b9d45e7557df8478">setPerVertexScalarFromPrincipalCurvatureGaussian</a> (MeshType &amp;m)</td></tr>
<tr class="separator:aff1028f512578880b9d45e7557df8478"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a5fcab23abe4e1e0206dc195499f5ba"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a4a5fcab23abe4e1e0206dc195499f5ba"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a4a5fcab23abe4e1e0206dc195499f5ba">setPerVertexScalarFromPrincipalCurvatureMean</a> (MeshType &amp;m)</td></tr>
<tr class="separator:a4a5fcab23abe4e1e0206dc195499f5ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b39039c4d3a1cdf840bd91d66739359"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a0b39039c4d3a1cdf840bd91d66739359"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a0b39039c4d3a1cdf840bd91d66739359">setPerVertexScalarFromPrincipalCurvatureMinValue</a> (MeshType &amp;m)</td></tr>
<tr class="separator:a0b39039c4d3a1cdf840bd91d66739359"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1398a1d87b760f96ad7a9ffc63e9dcd"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ae1398a1d87b760f96ad7a9ffc63e9dcd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ae1398a1d87b760f96ad7a9ffc63e9dcd">setPerVertexScalarFromPrincipalCurvatureMaxValue</a> (MeshType &amp;m)</td></tr>
<tr class="separator:ae1398a1d87b760f96ad7a9ffc63e9dcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82d7eb86556357c67e9e4d9bc26e743a"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a82d7eb86556357c67e9e4d9bc26e743a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a82d7eb86556357c67e9e4d9bc26e743a">setPerVertexScalarFromPrincipalCurvatureShapeIndex</a> (MeshType &amp;m)</td></tr>
<tr class="memdesc:a82d7eb86556357c67e9e4d9bc26e743a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the Shape Index S from the Principal Curvature, as defined by [Koenderink 1992] and stores it in the per-vertex scalar.  <br /></td></tr>
<tr class="separator:a82d7eb86556357c67e9e4d9bc26e743a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91859f211d5a934ec05e85d4824c1259"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a91859f211d5a934ec05e85d4824c1259"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a91859f211d5a934ec05e85d4824c1259">setPerVertexScalarFromPrincipalCurvatureCurvedness</a> (MeshType &amp;m)</td></tr>
<tr class="memdesc:a91859f211d5a934ec05e85d4824c1259"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the Curvedness C from the Principal Curvature, as defined by [Koenderink 1992] and stores it in the per-vertex scalar.  <br /></td></tr>
<tr class="separator:a91859f211d5a934ec05e85d4824c1259"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b0bc5dbd8005d39d14ccf664ffca33c"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a7b0bc5dbd8005d39d14ccf664ffca33c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a7b0bc5dbd8005d39d14ccf664ffca33c">clearVertexSelection</a> (MeshType &amp;m)</td></tr>
<tr class="separator:a7b0bc5dbd8005d39d14ccf664ffca33c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb5edd39f9dd2fc2220d8b08be523e29"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:abb5edd39f9dd2fc2220d8b08be523e29"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#abb5edd39f9dd2fc2220d8b08be523e29">clearFaceSelection</a> (MeshType &amp;m)</td></tr>
<tr class="separator:abb5edd39f9dd2fc2220d8b08be523e29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0416a0056c7bbd35f81e72bb9b536db0"><td class="memTemplParams" colspan="2">template&lt;EdgeMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a0416a0056c7bbd35f81e72bb9b536db0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a0416a0056c7bbd35f81e72bb9b536db0">clearEdgeSelection</a> (MeshType &amp;m)</td></tr>
<tr class="separator:a0416a0056c7bbd35f81e72bb9b536db0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24d5ffd9bfb1588f06ccd35551e82ec0"><td class="memTemplParams" colspan="2">template&lt;DcelMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a24d5ffd9bfb1588f06ccd35551e82ec0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a24d5ffd9bfb1588f06ccd35551e82ec0">clearHalfEdgeSelection</a> (MeshType &amp;m)</td></tr>
<tr class="separator:a24d5ffd9bfb1588f06ccd35551e82ec0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaec6c356404a0bf3eb24a29e867004df"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:aaec6c356404a0bf3eb24a29e867004df"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#aaec6c356404a0bf3eb24a29e867004df">selectNonManifoldVertices</a> (MeshType &amp;m, bool clearSelectionFirst)</td></tr>
<tr class="separator:aaec6c356404a0bf3eb24a29e867004df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54e8371c2ddda188c9540ea7e7bddf78"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a54e8371c2ddda188c9540ea7e7bddf78"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a54e8371c2ddda188c9540ea7e7bddf78">clearPerVertexAdjacentFaces</a> (MeshType &amp;m)</td></tr>
<tr class="memdesc:a54e8371c2ddda188c9540ea7e7bddf78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the adjacent faces of each vertex of the mesh.  <br /></td></tr>
<tr class="separator:a54e8371c2ddda188c9540ea7e7bddf78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3ecae45cc9e58f948dc04178fd6669b"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:af3ecae45cc9e58f948dc04178fd6669b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#af3ecae45cc9e58f948dc04178fd6669b">updatePerVertexAdjacentFaces</a> (MeshType &amp;m)</td></tr>
<tr class="memdesc:af3ecae45cc9e58f948dc04178fd6669b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the adjacent faces of each vertex of the mesh.  <br /></td></tr>
<tr class="separator:af3ecae45cc9e58f948dc04178fd6669b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a312c8ca27b3e94994a1f03bc1a3d826d"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a312c8ca27b3e94994a1f03bc1a3d826d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a312c8ca27b3e94994a1f03bc1a3d826d">clearPerVertexAdjacentVertices</a> (MeshType &amp;m)</td></tr>
<tr class="memdesc:a312c8ca27b3e94994a1f03bc1a3d826d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the adjacent vertices of each vertex of the mesh.  <br /></td></tr>
<tr class="separator:a312c8ca27b3e94994a1f03bc1a3d826d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b6e8d46b2b867729d95c72ab1925df2"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a6b6e8d46b2b867729d95c72ab1925df2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a6b6e8d46b2b867729d95c72ab1925df2">updatePerVertexAdjacentVertices</a> (MeshType &amp;m)</td></tr>
<tr class="memdesc:a6b6e8d46b2b867729d95c72ab1925df2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the adjacent vertices of each vertex of the mesh.  <br /></td></tr>
<tr class="separator:a6b6e8d46b2b867729d95c72ab1925df2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec301aa1e068ae4ceeeef43761b9ee04"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:aec301aa1e068ae4ceeeef43761b9ee04"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#aec301aa1e068ae4ceeeef43761b9ee04">clearPerFaceAdjacentFaces</a> (MeshType &amp;m)</td></tr>
<tr class="memdesc:aec301aa1e068ae4ceeeef43761b9ee04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the adjacent faces of each face of the mesh.  <br /></td></tr>
<tr class="separator:aec301aa1e068ae4ceeeef43761b9ee04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3db69fc234fc8072747aabf1724f9b92"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a3db69fc234fc8072747aabf1724f9b92"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a3db69fc234fc8072747aabf1724f9b92">updatePerFaceAdjacentFaces</a> (MeshType &amp;m)</td></tr>
<tr class="memdesc:a3db69fc234fc8072747aabf1724f9b92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the per face adjacent face component.  <br /></td></tr>
<tr class="separator:a3db69fc234fc8072747aabf1724f9b92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd2f68e498f63c306c81c756e63653c9"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType, typename ScalarM &gt; </td></tr>
<tr class="memitem:acd2f68e498f63c306c81c756e63653c9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#acd2f68e498f63c306c81c756e63653c9">applyTransformMatrix</a> (MeshType &amp;mesh, const <a class="el" href="namespacevcl.html#ad82a126b390f21b2e9658c73e7a795ee">Matrix44</a>&lt; ScalarM &gt; &amp;matrix, bool updateNormals)</td></tr>
<tr class="separator:acd2f68e498f63c306c81c756e63653c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c4a60eeed3ddead3611508975cb6045"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType, PointConcept PointType&gt; </td></tr>
<tr class="memitem:a7c4a60eeed3ddead3611508975cb6045"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a7c4a60eeed3ddead3611508975cb6045">translate</a> (MeshType &amp;mesh, const PointType &amp;t)</td></tr>
<tr class="separator:a7c4a60eeed3ddead3611508975cb6045"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5217f309d49911db6e36a4f6d31acdaa"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType, PointConcept PointType&gt; </td></tr>
<tr class="memitem:a5217f309d49911db6e36a4f6d31acdaa"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a5217f309d49911db6e36a4f6d31acdaa">scale</a> (MeshType &amp;mesh, const PointType &amp;s)</td></tr>
<tr class="separator:a5217f309d49911db6e36a4f6d31acdaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7f4da00ff716cc6e58e2e9ade275d6a"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType, typename Scalar &gt; </td></tr>
<tr class="memitem:ad7f4da00ff716cc6e58e2e9ade275d6a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ad7f4da00ff716cc6e58e2e9ade275d6a">scale</a> (MeshType &amp;mesh, const Scalar &amp;s)</td></tr>
<tr class="separator:ad7f4da00ff716cc6e58e2e9ade275d6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a516ae081ca79f1afbf5a77883613be72"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a516ae081ca79f1afbf5a77883613be72">drawPoint2</a> (const <a class="el" href="group__space.html#ga4b02e85ff4d51fe7d689f8dd0e87ecd5">Point2d</a> &amp;p, const <a class="el" href="classvcl_1_1Color.html">Color</a> &amp;c, int size=8)</td></tr>
<tr class="memdesc:a516ae081ca79f1afbf5a77883613be72"><td class="mdescLeft">&#160;</td><td class="mdescRight">drawPoint2  <br /></td></tr>
<tr class="separator:a516ae081ca79f1afbf5a77883613be72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a692ed5f64fdbbc22a85818682bd6ec79"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a692ed5f64fdbbc22a85818682bd6ec79">drawLine2</a> (const <a class="el" href="group__space.html#ga4b02e85ff4d51fe7d689f8dd0e87ecd5">Point2d</a> &amp;a, const <a class="el" href="group__space.html#ga4b02e85ff4d51fe7d689f8dd0e87ecd5">Point2d</a> &amp;b, const <a class="el" href="classvcl_1_1Color.html">Color</a> &amp;c, int width)</td></tr>
<tr class="memdesc:a692ed5f64fdbbc22a85818682bd6ec79"><td class="mdescLeft">&#160;</td><td class="mdescRight">drawLine2  <br /></td></tr>
<tr class="separator:a692ed5f64fdbbc22a85818682bd6ec79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af62e633fc49d9f0d17b0c72b10ca6e8d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#af62e633fc49d9f0d17b0c72b10ca6e8d">drawTriangle2</a> (const std::array&lt; <a class="el" href="group__space.html#ga4b02e85ff4d51fe7d689f8dd0e87ecd5">Point2d</a>, 3 &gt; &amp;arr, const <a class="el" href="classvcl_1_1Color.html">Color</a> &amp;c, int width, bool fill)</td></tr>
<tr class="memdesc:af62e633fc49d9f0d17b0c72b10ca6e8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">drawTriangle2  <br /></td></tr>
<tr class="separator:af62e633fc49d9f0d17b0c72b10ca6e8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad939bbe736d6a065e65c0b84b88b04d4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ad939bbe736d6a065e65c0b84b88b04d4">drawTriangle2</a> (const <a class="el" href="group__space.html#ga4b02e85ff4d51fe7d689f8dd0e87ecd5">Point2d</a> &amp;p1, const <a class="el" href="group__space.html#ga4b02e85ff4d51fe7d689f8dd0e87ecd5">Point2d</a> &amp;p2, const <a class="el" href="group__space.html#ga4b02e85ff4d51fe7d689f8dd0e87ecd5">Point2d</a> &amp;p3, const <a class="el" href="classvcl_1_1Color.html">Color</a> &amp;c, int width, bool fill)</td></tr>
<tr class="memdesc:ad939bbe736d6a065e65c0b84b88b04d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">drawTriangle2  <br /></td></tr>
<tr class="separator:ad939bbe736d6a065e65c0b84b88b04d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a355ec6a3dc7d99e96765a4e30f6610"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a1a355ec6a3dc7d99e96765a4e30f6610">drawQuad2</a> (const std::array&lt; <a class="el" href="group__space.html#ga4b02e85ff4d51fe7d689f8dd0e87ecd5">Point2d</a>, 4 &gt; &amp;points, const <a class="el" href="classvcl_1_1Color.html">Color</a> &amp;c, int width, bool fill)</td></tr>
<tr class="memdesc:a1a355ec6a3dc7d99e96765a4e30f6610"><td class="mdescLeft">&#160;</td><td class="mdescRight">drawQuad2  <br /></td></tr>
<tr class="separator:a1a355ec6a3dc7d99e96765a4e30f6610"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e4e098e07b2cacca973fd8683f48c72"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a3e4e098e07b2cacca973fd8683f48c72">drawQuad2</a> (const <a class="el" href="group__space.html#ga4b02e85ff4d51fe7d689f8dd0e87ecd5">Point2d</a> &amp;p1, const <a class="el" href="group__space.html#ga4b02e85ff4d51fe7d689f8dd0e87ecd5">Point2d</a> &amp;p2, const <a class="el" href="group__space.html#ga4b02e85ff4d51fe7d689f8dd0e87ecd5">Point2d</a> &amp;p3, const <a class="el" href="group__space.html#ga4b02e85ff4d51fe7d689f8dd0e87ecd5">Point2d</a> &amp;p4, const <a class="el" href="classvcl_1_1Color.html">Color</a> &amp;c, int width, bool fill)</td></tr>
<tr class="memdesc:a3e4e098e07b2cacca973fd8683f48c72"><td class="mdescLeft">&#160;</td><td class="mdescRight">drawQuad2D  <br /></td></tr>
<tr class="separator:a3e4e098e07b2cacca973fd8683f48c72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e3c74a0c0e3fa706fa71a222971abac"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a5e3c74a0c0e3fa706fa71a222971abac">drawPoint3</a> (const <a class="el" href="group__space.html#gabb47c1364fb2fe1464a54417684f011e">Point3d</a> &amp;p, const <a class="el" href="classvcl_1_1Color.html">Color</a> &amp;c, int size)</td></tr>
<tr class="memdesc:a5e3c74a0c0e3fa706fa71a222971abac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draws a point on the plane (coord z = 0 if 3D).  <br /></td></tr>
<tr class="separator:a5e3c74a0c0e3fa706fa71a222971abac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7eed248a4465f8e5b2c1db86515e27b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ac7eed248a4465f8e5b2c1db86515e27b">drawSphere</a> (const <a class="el" href="group__space.html#gabb47c1364fb2fe1464a54417684f011e">Point3d</a> &amp;center, float radius, const <a class="el" href="classvcl_1_1Color.html">Color</a> &amp;color, int precision)</td></tr>
<tr class="memdesc:ac7eed248a4465f8e5b2c1db86515e27b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draws a sphere with opengl.  <br /></td></tr>
<tr class="separator:ac7eed248a4465f8e5b2c1db86515e27b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ccdd454b5ec361dc7783be5ab01dcc2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a4ccdd454b5ec361dc7783be5ab01dcc2">drawCylinder</a> (const <a class="el" href="group__space.html#gabb47c1364fb2fe1464a54417684f011e">Point3d</a> &amp;a, const <a class="el" href="group__space.html#gabb47c1364fb2fe1464a54417684f011e">Point3d</a> &amp;b, float top_radius, float bottom_radius, const <a class="el" href="classvcl_1_1Color.html">Color</a> &amp;color, unsigned int slices, unsigned int stacks)</td></tr>
<tr class="memdesc:a4ccdd454b5ec361dc7783be5ab01dcc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">drawCylinder  <br /></td></tr>
<tr class="separator:a4ccdd454b5ec361dc7783be5ab01dcc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe81dae5e15d5acbb8c959e3d2208d49"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#abe81dae5e15d5acbb8c959e3d2208d49">drawArrow3</a> (const <a class="el" href="group__space.html#gabb47c1364fb2fe1464a54417684f011e">Point3d</a> &amp;a, const <a class="el" href="group__space.html#gabb47c1364fb2fe1464a54417684f011e">Point3d</a> &amp;b, float bottom_radius, const <a class="el" href="classvcl_1_1Color.html">Color</a> &amp;color, unsigned int slices, unsigned int stacks)</td></tr>
<tr class="memdesc:abe81dae5e15d5acbb8c959e3d2208d49"><td class="mdescLeft">&#160;</td><td class="mdescRight">drawArrow  <br /></td></tr>
<tr class="separator:abe81dae5e15d5acbb8c959e3d2208d49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae16b4f65fcbf4d8d8168e0e16f1a47b7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ae16b4f65fcbf4d8d8168e0e16f1a47b7">drawLine3</a> (const <a class="el" href="group__space.html#gabb47c1364fb2fe1464a54417684f011e">Point3d</a> &amp;a, const <a class="el" href="group__space.html#gabb47c1364fb2fe1464a54417684f011e">Point3d</a> &amp;b, const <a class="el" href="classvcl_1_1Color.html">Color</a> &amp;c, int width)</td></tr>
<tr class="memdesc:ae16b4f65fcbf4d8d8168e0e16f1a47b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">drawLine  <br /></td></tr>
<tr class="separator:ae16b4f65fcbf4d8d8168e0e16f1a47b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f7d585e242c1ea867826bdffeff032b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a7f7d585e242c1ea867826bdffeff032b">drawSegment3</a> (const <a class="el" href="group__space.html#gabb47c1364fb2fe1464a54417684f011e">Point3d</a> &amp;a, const <a class="el" href="group__space.html#gabb47c1364fb2fe1464a54417684f011e">Point3d</a> &amp;b, const <a class="el" href="classvcl_1_1Color.html">Color</a> &amp;c, int width)</td></tr>
<tr class="separator:a7f7d585e242c1ea867826bdffeff032b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d6d6df1422f4d638b9f6d61b2163005"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a4d6d6df1422f4d638b9f6d61b2163005">drawDashedLine3</a> (const <a class="el" href="group__space.html#gabb47c1364fb2fe1464a54417684f011e">Point3d</a> &amp;a, const <a class="el" href="group__space.html#gabb47c1364fb2fe1464a54417684f011e">Point3d</a> &amp;b, const <a class="el" href="classvcl_1_1Color.html">Color</a> &amp;c, int width)</td></tr>
<tr class="memdesc:a4d6d6df1422f4d638b9f6d61b2163005"><td class="mdescLeft">&#160;</td><td class="mdescRight">drawDashedLine  <br /></td></tr>
<tr class="separator:a4d6d6df1422f4d638b9f6d61b2163005"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab78db3f7c64deb1008fb9e8b7f881e2d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ab78db3f7c64deb1008fb9e8b7f881e2d">drawTriangle</a> (const <a class="el" href="group__space.html#gabb47c1364fb2fe1464a54417684f011e">Point3d</a> &amp;p1, const <a class="el" href="group__space.html#gabb47c1364fb2fe1464a54417684f011e">Point3d</a> &amp;p2, const <a class="el" href="group__space.html#gabb47c1364fb2fe1464a54417684f011e">Point3d</a> &amp;p3, const <a class="el" href="classvcl_1_1Color.html">Color</a> &amp;c, int width, bool fill)</td></tr>
<tr class="memdesc:ab78db3f7c64deb1008fb9e8b7f881e2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">drawTriangle  <br /></td></tr>
<tr class="separator:ab78db3f7c64deb1008fb9e8b7f881e2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fb32ee3ac1da460849e059415520f17"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a3fb32ee3ac1da460849e059415520f17">drawQuad3</a> (const <a class="el" href="group__space.html#gabb47c1364fb2fe1464a54417684f011e">Point3d</a> &amp;a, const <a class="el" href="group__space.html#gabb47c1364fb2fe1464a54417684f011e">Point3d</a> &amp;b, const <a class="el" href="group__space.html#gabb47c1364fb2fe1464a54417684f011e">Point3d</a> &amp;c, const <a class="el" href="group__space.html#gabb47c1364fb2fe1464a54417684f011e">Point3d</a> &amp;d, int width)</td></tr>
<tr class="memdesc:a3fb32ee3ac1da460849e059415520f17"><td class="mdescLeft">&#160;</td><td class="mdescRight">drawQuad3  <br /></td></tr>
<tr class="separator:a3fb32ee3ac1da460849e059415520f17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a650b9887818f5833f6784a0a879ca2b6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a650b9887818f5833f6784a0a879ca2b6">drawBox3</a> (const <a class="el" href="group__space.html#gabb47c1364fb2fe1464a54417684f011e">Point3d</a> &amp;<a class="el" href="namespacevcl.html#a3edcb561672a6be17e9453bd1ea446d5">min</a>, const <a class="el" href="group__space.html#gabb47c1364fb2fe1464a54417684f011e">Point3d</a> &amp;<a class="el" href="namespacevcl.html#a69cc63a5ad2974d082145ed1dee7846b">max</a>, const <a class="el" href="classvcl_1_1Color.html">Color</a> &amp;c, int width)</td></tr>
<tr class="memdesc:a650b9887818f5833f6784a0a879ca2b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">drawBox3  <br /></td></tr>
<tr class="separator:a650b9887818f5833f6784a0a879ca2b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3189cf637794b419973820f73bd2ac0d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a3189cf637794b419973820f73bd2ac0d">drawBox3</a> (const std::vector&lt; <a class="el" href="group__space.html#gabb47c1364fb2fe1464a54417684f011e">Point3d</a> &gt; &amp;p, const <a class="el" href="classvcl_1_1Color.html">Color</a> &amp;c, int width)</td></tr>
<tr class="memdesc:a3189cf637794b419973820f73bd2ac0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">drawBox3  <br /></td></tr>
<tr class="separator:a3189cf637794b419973820f73bd2ac0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a983e11aa618329af3a02f60b6375d72c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a983e11aa618329af3a02f60b6375d72c">drawBox3</a> (const <a class="el" href="group__space.html#gabb47c1364fb2fe1464a54417684f011e">Point3d</a> &amp;p0, const <a class="el" href="group__space.html#gabb47c1364fb2fe1464a54417684f011e">Point3d</a> &amp;p1, const <a class="el" href="group__space.html#gabb47c1364fb2fe1464a54417684f011e">Point3d</a> &amp;p2, const <a class="el" href="group__space.html#gabb47c1364fb2fe1464a54417684f011e">Point3d</a> &amp;p3, const <a class="el" href="group__space.html#gabb47c1364fb2fe1464a54417684f011e">Point3d</a> &amp;p4, const <a class="el" href="group__space.html#gabb47c1364fb2fe1464a54417684f011e">Point3d</a> &amp;p5, const <a class="el" href="group__space.html#gabb47c1364fb2fe1464a54417684f011e">Point3d</a> &amp;p6, const <a class="el" href="group__space.html#gabb47c1364fb2fe1464a54417684f011e">Point3d</a> &amp;p7, const <a class="el" href="classvcl_1_1Color.html">Color</a> &amp;c, int width)</td></tr>
<tr class="memdesc:a983e11aa618329af3a02f60b6375d72c"><td class="mdescLeft">&#160;</td><td class="mdescRight">drawBox3  <br /></td></tr>
<tr class="separator:a983e11aa618329af3a02f60b6375d72c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a338dea159760ae814dc6e78425e284a1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a338dea159760ae814dc6e78425e284a1">_check_gl_error</a> (const char *file, int line)</td></tr>
<tr class="separator:a338dea159760ae814dc6e78425e284a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga74cf51705f9d8da2b9eb300b202df461"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType, LoggerConcept LogType&gt; </td></tr>
<tr class="memitem:ga74cf51705f9d8da2b9eb300b202df461"><td class="memTemplItemLeft" align="right" valign="top">MeshType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__load.html#ga74cf51705f9d8da2b9eb300b202df461">load</a> (const std::string &amp;filename, LogType &amp;log, bool enableOptionalComponents)</td></tr>
<tr class="memdesc:ga74cf51705f9d8da2b9eb300b202df461"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads a mesh from a file with the given filename and stores it in the returned mesh object. Checks automatically the file format to load from the fiven filename.  <br /></td></tr>
<tr class="separator:ga74cf51705f9d8da2b9eb300b202df461"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b4f014f12a8ab00cf00a0e79a471281"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType, LoggerConcept LogType&gt; </td></tr>
<tr class="memitem:ga5b4f014f12a8ab00cf00a0e79a471281"><td class="memTemplItemLeft" align="right" valign="top">MeshType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__load.html#ga5b4f014f12a8ab00cf00a0e79a471281">load</a> (const std::string &amp;filename, <a class="el" href="classvcl_1_1FileMeshInfo.html">FileMeshInfo</a> &amp;loadedInfo, LogType &amp;log, bool enableOptionalComponents)</td></tr>
<tr class="memdesc:ga5b4f014f12a8ab00cf00a0e79a471281"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads a mesh from a file with the given filename and stores it in the returned mesh object. Checks automatically the file format to load from the fiven filename.  <br /></td></tr>
<tr class="separator:ga5b4f014f12a8ab00cf00a0e79a471281"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf1b97082aa008d28fb7821adbfc5fc0e"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType, LoggerConcept LogType&gt; </td></tr>
<tr class="memitem:gaf1b97082aa008d28fb7821adbfc5fc0e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__load.html#gaf1b97082aa008d28fb7821adbfc5fc0e">load</a> (MeshType &amp;m, const std::string &amp;filename, LogType &amp;log, bool enableOptionalComponents)</td></tr>
<tr class="memdesc:gaf1b97082aa008d28fb7821adbfc5fc0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads a mesh from a file with the given filename and stores it in the given mesh object. Checks automatically the file format to load from the fiven filename.  <br /></td></tr>
<tr class="separator:gaf1b97082aa008d28fb7821adbfc5fc0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00d543d48ac427d67e2e7fc19047acfd"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType, LoggerConcept LogType&gt; </td></tr>
<tr class="memitem:ga00d543d48ac427d67e2e7fc19047acfd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__load.html#ga00d543d48ac427d67e2e7fc19047acfd">load</a> (MeshType &amp;m, const std::string &amp;filename, <a class="el" href="classvcl_1_1FileMeshInfo.html">FileMeshInfo</a> &amp;loadedInfo, LogType &amp;log, bool enableOptionalComponents)</td></tr>
<tr class="memdesc:ga00d543d48ac427d67e2e7fc19047acfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads a mesh from a file with the given filename and stores it in the given mesh object. Checks automatically the file format to load from the fiven filename.  <br /></td></tr>
<tr class="separator:ga00d543d48ac427d67e2e7fc19047acfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d724a376d90559c72f63a862d0bc895"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType, LoggerConcept LogType&gt; </td></tr>
<tr class="memitem:a4d724a376d90559c72f63a862d0bc895"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a4d724a376d90559c72f63a862d0bc895">save</a> (const MeshType &amp;m, const std::string &amp;filename, LogType &amp;log, bool binary)</td></tr>
<tr class="separator:a4d724a376d90559c72f63a862d0bc895"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8f881fa3253b964c05b23dae03a2462"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ab8f881fa3253b964c05b23dae03a2462"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ab8f881fa3253b964c05b23dae03a2462">save</a> (const MeshType &amp;m, const std::string &amp;filename, bool binary)</td></tr>
<tr class="separator:ab8f881fa3253b964c05b23dae03a2462"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0face38d71aff86d6af2bb2ee7e35d9a"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType, LoggerConcept LogType&gt; </td></tr>
<tr class="memitem:a0face38d71aff86d6af2bb2ee7e35d9a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a0face38d71aff86d6af2bb2ee7e35d9a">save</a> (const MeshType &amp;m, const std::string &amp;filename, const <a class="el" href="classvcl_1_1FileMeshInfo.html">FileMeshInfo</a> &amp;info, LogType &amp;log, bool binary)</td></tr>
<tr class="separator:a0face38d71aff86d6af2bb2ee7e35d9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33948b0cb8e44bec17d4b0dfef8bd254"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:a33948b0cb8e44bec17d4b0dfef8bd254"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a33948b0cb8e44bec17d4b0dfef8bd254">isDegenerate</a> (Scalar t)</td></tr>
<tr class="separator:a33948b0cb8e44bec17d4b0dfef8bd254"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dc92e18b3bf638868ab5a3fa204a54d"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:a2dc92e18b3bf638868ab5a3fa204a54d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a2dc92e18b3bf638868ab5a3fa204a54d">epsilonCompare</a> (Scalar p1, Scalar p2, Scalar epsilon)</td></tr>
<tr class="separator:a2dc92e18b3bf638868ab5a3fa204a54d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53f705e848cce98dd23542a2d109e55b"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:a53f705e848cce98dd23542a2d109e55b"><td class="memTemplItemLeft" align="right" valign="top">Scalar&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a53f705e848cce98dd23542a2d109e55b">toRad</a> (const Scalar &amp;a)</td></tr>
<tr class="separator:a53f705e848cce98dd23542a2d109e55b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1578b48cbfdb04c6675ac5a3b535bb83"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:a1578b48cbfdb04c6675ac5a3b535bb83"><td class="memTemplItemLeft" align="right" valign="top">Scalar&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a1578b48cbfdb04c6675ac5a3b535bb83">toDeg</a> (const Scalar &amp;a)</td></tr>
<tr class="separator:a1578b48cbfdb04c6675ac5a3b535bb83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86d25b0ff01d215f96bcdf6084299684"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a86d25b0ff01d215f96bcdf6084299684">lnOfFactorial</a> (int n)</td></tr>
<tr class="memdesc:a86d25b0ff01d215f96bcdf6084299684"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes and caches the result of the natural logarithm of n!  <br /></td></tr>
<tr class="separator:a86d25b0ff01d215f96bcdf6084299684"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86d25b0ff01d215f96bcdf6084299684"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a86d25b0ff01d215f96bcdf6084299684">lnOfFactorial</a> (int n)</td></tr>
<tr class="separator:a86d25b0ff01d215f96bcdf6084299684"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a438da980623645640c78105766bde287"><td class="memTemplParams" colspan="2">template&lt;Point3Concept PointType&gt; </td></tr>
<tr class="memitem:a438da980623645640c78105766bde287"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; PointType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a438da980623645640c78105766bde287">sphericalFibonacciPointSet</a> (<a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> n)</td></tr>
<tr class="memdesc:a438da980623645640c78105766bde287"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector of <code>n</code> points distributed in a unit sphere.  <br /></td></tr>
<tr class="separator:a438da980623645640c78105766bde287"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3edcb561672a6be17e9453bd1ea446d5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3edcb561672a6be17e9453bd1ea446d5"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a3edcb561672a6be17e9453bd1ea446d5">min</a> (const T &amp;el1, const T &amp;el2)</td></tr>
<tr class="separator:a3edcb561672a6be17e9453bd1ea446d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c1835cef3addd7dbae2b21a43523f3a"><td class="memTemplParams" colspan="2">template&lt;typename Head , typename... Tail&gt; <br />
requires (sizeof...(tail) &gt; 0)</td></tr>
<tr class="memitem:a9c1835cef3addd7dbae2b21a43523f3a"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a9c1835cef3addd7dbae2b21a43523f3a">min</a> (const Head &amp;head0, const Head &amp;head1, const Tail &amp;... tail)</td></tr>
<tr class="separator:a9c1835cef3addd7dbae2b21a43523f3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69cc63a5ad2974d082145ed1dee7846b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a69cc63a5ad2974d082145ed1dee7846b"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a69cc63a5ad2974d082145ed1dee7846b">max</a> (const T &amp;el1, const T &amp;el2)</td></tr>
<tr class="separator:a69cc63a5ad2974d082145ed1dee7846b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a212fbf643d263ad106507f7aa462cf46"><td class="memTemplParams" colspan="2">template&lt;typename Head , typename... Tail&gt; <br />
requires (sizeof...(tail) &gt; 0)</td></tr>
<tr class="memitem:a212fbf643d263ad106507f7aa462cf46"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a212fbf643d263ad106507f7aa462cf46">max</a> (const Head &amp;head0, const Head &amp;head1, const Tail &amp;... tail)</td></tr>
<tr class="separator:a212fbf643d263ad106507f7aa462cf46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac11460526cb6d79733a8dfe0e15614f4"><td class="memTemplParams" colspan="2">template&lt;PointConcept PointType&gt; </td></tr>
<tr class="memitem:ac11460526cb6d79733a8dfe0e15614f4"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ac11460526cb6d79733a8dfe0e15614f4">min</a> (const PointType &amp;p1, const PointType &amp;p2)</td></tr>
<tr class="separator:ac11460526cb6d79733a8dfe0e15614f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49a9bdba85989ec5842081c5c84d4fc7"><td class="memTemplParams" colspan="2">template&lt;PointConcept PointType&gt; </td></tr>
<tr class="memitem:a49a9bdba85989ec5842081c5c84d4fc7"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a49a9bdba85989ec5842081c5c84d4fc7">max</a> (const PointType &amp;p1, const PointType &amp;p2)</td></tr>
<tr class="separator:a49a9bdba85989ec5842081c5c84d4fc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc2f93864498c3b143e13c1b0009bdc4"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#afc2f93864498c3b143e13c1b0009bdc4">perlinNoise</a> (double x, double y, double z)</td></tr>
<tr class="memdesc:afc2f93864498c3b143e13c1b0009bdc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">3D Perlin noise, returns a value in the [-1,1] range with period 255  <br /></td></tr>
<tr class="separator:afc2f93864498c3b143e13c1b0009bdc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cc1884dbb897a34716178c7b06e7bb2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a2cc1884dbb897a34716178c7b06e7bb2">poissonRatioOfUniformsInteger</a> (double L, std::mt19937 &amp;gen)</td></tr>
<tr class="memdesc:a2cc1884dbb897a34716178c7b06e7bb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This subfunction generates a integer with the poisson distribution using the ratio-of-uniforms rejection method (PRUAt). This approach is STABLE even for large L (e.g. it does not suffer from the overflow limit of the classical Knuth implementation) Execution time does not depend on L, except that it matters whether is within the range where ln(n!) is tabulated.  <br /></td></tr>
<tr class="separator:a2cc1884dbb897a34716178c7b06e7bb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef13acb79205bb8fe990f66e1fa203f3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#aef13acb79205bb8fe990f66e1fa203f3">poissonRatioOfUniformsInteger</a> (double L)</td></tr>
<tr class="separator:aef13acb79205bb8fe990f66e1fa203f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a212c052ae1efd3426a5ea49051f8011c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a212c052ae1efd3426a5ea49051f8011c">poissonRandomNumber</a> (double lambda, std::mt19937 &amp;gen)</td></tr>
<tr class="memdesc:a212c052ae1efd3426a5ea49051f8011c"><td class="mdescLeft">&#160;</td><td class="mdescRight">algorithm poisson random number (Knuth): init: Let L ← e^−λ, k ← 0 and p ← 1. do: k ← k + 1. Generate uniform random number u in [0,1] and let p ← p × u. while p &gt; L. return k − 1.  <br /></td></tr>
<tr class="separator:a212c052ae1efd3426a5ea49051f8011c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee130ece16518760ce1f2c1a9da3a6e1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#aee130ece16518760ce1f2c1a9da3a6e1">poissonRandomNumber</a> (double lambda)</td></tr>
<tr class="separator:aee130ece16518760ce1f2c1a9da3a6e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06f5b66d996c91397fab66781fc73402"><td class="memTemplParams" colspan="2">template&lt;typename ScalarType &gt; </td></tr>
<tr class="memitem:a06f5b66d996c91397fab66781fc73402"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__space.html#ga13f2718b0763def563b8bd9f65982833">vcl::Point3</a>&lt; ScalarType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a06f5b66d996c91397fab66781fc73402">randomTriangleBarycentricCoordinate</a> (std::mt19937 &amp;gen)</td></tr>
<tr class="memdesc:a06f5b66d996c91397fab66781fc73402"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate the barycentric coords of a random point over a triangle, with a uniform distribution over the triangle. It uses the parallelogram folding trick.  <br /></td></tr>
<tr class="separator:a06f5b66d996c91397fab66781fc73402"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7b855bdab068b3fee59bc40914436e2"><td class="memTemplParams" colspan="2">template&lt;typename ScalarType &gt; </td></tr>
<tr class="memitem:ad7b855bdab068b3fee59bc40914436e2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__space.html#ga13f2718b0763def563b8bd9f65982833">vcl::Point3</a>&lt; ScalarType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ad7b855bdab068b3fee59bc40914436e2">randomTriangleBarycentricCoordinate</a> ()</td></tr>
<tr class="separator:ad7b855bdab068b3fee59bc40914436e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c7c00f108bb07302bfb7643c66f3ef4"><td class="memTemplParams" colspan="2">template&lt;typename ScalarType &gt; </td></tr>
<tr class="memitem:a7c7c00f108bb07302bfb7643c66f3ef4"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; ScalarType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a7c7c00f108bb07302bfb7643c66f3ef4">randomPolygonBarycentricCoordinate</a> (<a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> polySize, std::mt19937 &amp;gen)</td></tr>
<tr class="separator:a7c7c00f108bb07302bfb7643c66f3ef4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d0305c02567d29d5bc48a0cdbaacda3"><td class="memTemplParams" colspan="2">template&lt;typename ScalarType &gt; </td></tr>
<tr class="memitem:a3d0305c02567d29d5bc48a0cdbaacda3"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; ScalarType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a3d0305c02567d29d5bc48a0cdbaacda3">randomPolygonBarycentricCoordinate</a> (<a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> polySize)</td></tr>
<tr class="separator:a3d0305c02567d29d5bc48a0cdbaacda3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24901186f1a77f31a23d64f30f0b0dc3"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType , PointConcept PointType, typename ScalarType &gt; </td></tr>
<tr class="memitem:a24901186f1a77f31a23d64f30f0b0dc3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a24901186f1a77f31a23d64f30f0b0dc3">setTransformMatrixRotation</a> (MatrixType &amp;matrix, PointType axis, const ScalarType &amp;angleRad)</td></tr>
<tr class="memdesc:a24901186f1a77f31a23d64f30f0b0dc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an 3D axis and an angle expressed in randiants, fills the given matrix with a transform matrix that represents the rotation matrix of the given axis/angle.  <br /></td></tr>
<tr class="separator:a24901186f1a77f31a23d64f30f0b0dc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd5d95d87600e42a0da835735e35ea99"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType , PointConcept PointType, typename ScalarType &gt; </td></tr>
<tr class="memitem:abd5d95d87600e42a0da835735e35ea99"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#abd5d95d87600e42a0da835735e35ea99">setTransformMatrixRotationDeg</a> (MatrixType &amp;matrix, PointType axis, const ScalarType &amp;angleDeg)</td></tr>
<tr class="memdesc:abd5d95d87600e42a0da835735e35ea99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an 3D axis and an angle expressed in degrees, fills the given matrix with a transform matrix that represents the rotation matrix of the given axis/angle.  <br /></td></tr>
<tr class="separator:abd5d95d87600e42a0da835735e35ea99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbb9f1401057fda582e6b0cda2a36b18"><td class="memTemplParams" colspan="2">template&lt;typename ScalarType , PointConcept PointType&gt; </td></tr>
<tr class="memitem:adbb9f1401057fda582e6b0cda2a36b18"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#adbb9f1401057fda582e6b0cda2a36b18">setTrasformMatrixTranslation</a> (<a class="el" href="namespacevcl.html#ad82a126b390f21b2e9658c73e7a795ee">Matrix44</a>&lt; ScalarType &gt; &amp;matrix, const PointType &amp;translation)</td></tr>
<tr class="separator:adbb9f1401057fda582e6b0cda2a36b18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5a78d0411b7f20298f45618c3e2aff5"><td class="memTemplParams" colspan="2">template&lt;typename ScalarType , PointConcept PointType&gt; </td></tr>
<tr class="memitem:af5a78d0411b7f20298f45618c3e2aff5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#af5a78d0411b7f20298f45618c3e2aff5">setTrasformMatrixScale</a> (<a class="el" href="namespacevcl.html#ad82a126b390f21b2e9658c73e7a795ee">Matrix44</a>&lt; ScalarType &gt; &amp;matrix, const PointType &amp;<a class="el" href="namespacevcl.html#a5217f309d49911db6e36a4f6d31acdaa">scale</a>)</td></tr>
<tr class="separator:af5a78d0411b7f20298f45618c3e2aff5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefa0051d67bdf4a551140929a2cc0b2f"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType , PointConcept PointType, typename ScalarType &gt; </td></tr>
<tr class="memitem:aefa0051d67bdf4a551140929a2cc0b2f"><td class="memTemplItemLeft" align="right" valign="top">MatrixType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#aefa0051d67bdf4a551140929a2cc0b2f">rotationMatrix</a> (const PointType &amp;axis, const ScalarType &amp;angleRad)</td></tr>
<tr class="memdesc:aefa0051d67bdf4a551140929a2cc0b2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an 3D axis and an angle expressed in randiants, returns a transform matrix that represents the rotation matrix of the given axis/angle.  <br /></td></tr>
<tr class="separator:aefa0051d67bdf4a551140929a2cc0b2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f6b127154a5e14946cb66492d214de8"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType , PointConcept PointType, typename ScalarType &gt; </td></tr>
<tr class="memitem:a7f6b127154a5e14946cb66492d214de8"><td class="memTemplItemLeft" align="right" valign="top">MatrixType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a7f6b127154a5e14946cb66492d214de8">rotationMatrixDeg</a> (const PointType &amp;axis, const ScalarType &amp;angleDeg)</td></tr>
<tr class="memdesc:a7f6b127154a5e14946cb66492d214de8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an 3D axis and an angle expressed in degrees, fills the given matrix with a transform matrix that represents the rotation matrix of the given axis/angle.  <br /></td></tr>
<tr class="separator:a7f6b127154a5e14946cb66492d214de8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca827384c3a3069cf55d77dc48e3f4fa"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:aca827384c3a3069cf55d77dc48e3f4fa"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#aca827384c3a3069cf55d77dc48e3f4fa">isFaceContainerCompact</a> (const MeshType &amp;m)</td></tr>
<tr class="memdesc:aca827384c3a3069cf55d77dc48e3f4fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if the given mesh has its <a class="el" href="classvcl_1_1Face.html" title="The Face class.">Face</a> Container compact.  <br /></td></tr>
<tr class="separator:aca827384c3a3069cf55d77dc48e3f4fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0486aed98c9b93d69825d29579c8cefa"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a0486aed98c9b93d69825d29579c8cefa"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a0486aed98c9b93d69825d29579c8cefa">isPerFaceAdjacentFacesEnabled</a> (const MeshType &amp;m)</td></tr>
<tr class="separator:a0486aed98c9b93d69825d29579c8cefa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb30f645e6cc1b2c1d8655f445bf1843"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:acb30f645e6cc1b2c1d8655f445bf1843"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#acb30f645e6cc1b2c1d8655f445bf1843">enableIfPerFaceAdjacentFacesOptional</a> (MeshType &amp;m)</td></tr>
<tr class="separator:acb30f645e6cc1b2c1d8655f445bf1843"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af39819c217b9f787d0c228d1c570d327"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:af39819c217b9f787d0c228d1c570d327"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#af39819c217b9f787d0c228d1c570d327">isPerFaceColorEnabled</a> (const MeshType &amp;m)</td></tr>
<tr class="separator:af39819c217b9f787d0c228d1c570d327"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3262073d55561ee24b5cfcc22250ee1"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:af3262073d55561ee24b5cfcc22250ee1"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#af3262073d55561ee24b5cfcc22250ee1">enableIfPerFaceColorOptional</a> (MeshType &amp;m)</td></tr>
<tr class="separator:af3262073d55561ee24b5cfcc22250ee1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a882e488c25ef1d9a8de741319f5ab35e"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a882e488c25ef1d9a8de741319f5ab35e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a882e488c25ef1d9a8de741319f5ab35e">isPerFaceMarkEnabled</a> (const MeshType &amp;m)</td></tr>
<tr class="separator:a882e488c25ef1d9a8de741319f5ab35e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0efcb1c23b82c5c20f26149672806012"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a0efcb1c23b82c5c20f26149672806012"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a0efcb1c23b82c5c20f26149672806012">enableIfPerFaceMarkOptional</a> (MeshType &amp;m)</td></tr>
<tr class="separator:a0efcb1c23b82c5c20f26149672806012"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2d03c59d458283eca7e0eb2fbaf7053"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ab2d03c59d458283eca7e0eb2fbaf7053"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ab2d03c59d458283eca7e0eb2fbaf7053">isPerFaceNormalEnabled</a> (const MeshType &amp;m)</td></tr>
<tr class="separator:ab2d03c59d458283eca7e0eb2fbaf7053"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af07e8fad913b41d5db61c140e24d35c4"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:af07e8fad913b41d5db61c140e24d35c4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#af07e8fad913b41d5db61c140e24d35c4">enableIfPerFaceNormalOptional</a> (MeshType &amp;m)</td></tr>
<tr class="separator:af07e8fad913b41d5db61c140e24d35c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66bf0c5e88fa00f72ef1ed429d1bf9c8"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a66bf0c5e88fa00f72ef1ed429d1bf9c8"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a66bf0c5e88fa00f72ef1ed429d1bf9c8">isPerFacePrincipalCurvatureEnabled</a> (const MeshType &amp;m)</td></tr>
<tr class="separator:a66bf0c5e88fa00f72ef1ed429d1bf9c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e4d93cc27448070bbb26df5cf3c200a"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a7e4d93cc27448070bbb26df5cf3c200a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a7e4d93cc27448070bbb26df5cf3c200a">enableIfPerFacePrincipalCurvatureOptional</a> (MeshType &amp;m)</td></tr>
<tr class="separator:a7e4d93cc27448070bbb26df5cf3c200a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2103ff0400b90b291072164ef4112794"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a2103ff0400b90b291072164ef4112794"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a2103ff0400b90b291072164ef4112794">isPerFaceScalarEnabled</a> (const MeshType &amp;m)</td></tr>
<tr class="separator:a2103ff0400b90b291072164ef4112794"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0eb8cf1210036e1819699354a854a76"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ac0eb8cf1210036e1819699354a854a76"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ac0eb8cf1210036e1819699354a854a76">enableIfPerFaceScalarOptional</a> (MeshType &amp;m)</td></tr>
<tr class="separator:ac0eb8cf1210036e1819699354a854a76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24cf22a3269f6c86954cd90f452f6a91"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a24cf22a3269f6c86954cd90f452f6a91"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a24cf22a3269f6c86954cd90f452f6a91">isPerFaceWedgeColorsEnabled</a> (const MeshType &amp;m)</td></tr>
<tr class="separator:a24cf22a3269f6c86954cd90f452f6a91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2bc7d8c340f922fda76e1d01588433c"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:af2bc7d8c340f922fda76e1d01588433c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#af2bc7d8c340f922fda76e1d01588433c">enableIfPerFaceWedgeColorsOptional</a> (MeshType &amp;m)</td></tr>
<tr class="separator:af2bc7d8c340f922fda76e1d01588433c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea40a37467f4117bc1d84760bbc8e082"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:aea40a37467f4117bc1d84760bbc8e082"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#aea40a37467f4117bc1d84760bbc8e082">isPerFaceWedgeTexCoordsEnabled</a> (const MeshType &amp;m)</td></tr>
<tr class="separator:aea40a37467f4117bc1d84760bbc8e082"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cfd1a61b06b32978aa70024f8b8e8f3"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a5cfd1a61b06b32978aa70024f8b8e8f3"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a5cfd1a61b06b32978aa70024f8b8e8f3">enableIfPerFaceWedgeTexCoordsOptional</a> (MeshType &amp;m)</td></tr>
<tr class="separator:a5cfd1a61b06b32978aa70024f8b8e8f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5e8d79003b3a928d430219d244a4855"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:aa5e8d79003b3a928d430219d244a4855"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#aa5e8d79003b3a928d430219d244a4855">requireFaceContainerCompactness</a> (const MeshType &amp;m)</td></tr>
<tr class="separator:aa5e8d79003b3a928d430219d244a4855"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff3602e750a1d1c93374f642be47a6b0"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; <br />
requires HasPerFaceAdjacentFaces&lt;MeshType&gt;</td></tr>
<tr class="memitem:aff3602e750a1d1c93374f642be47a6b0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#aff3602e750a1d1c93374f642be47a6b0">requirePerFaceAdjacentFaces</a> (const MeshType &amp;m)</td></tr>
<tr class="separator:aff3602e750a1d1c93374f642be47a6b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6372afb65d4cb206aed162aff2d71c3"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; <br />
requires HasPerFaceColor&lt;MeshType&gt;</td></tr>
<tr class="memitem:ae6372afb65d4cb206aed162aff2d71c3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ae6372afb65d4cb206aed162aff2d71c3">requirePerFaceColor</a> (const MeshType &amp;m)</td></tr>
<tr class="separator:ae6372afb65d4cb206aed162aff2d71c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac96a0a92c22ced9c629b174dade3dd70"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; <br />
requires HasPerFaceMark&lt;MeshType&gt;</td></tr>
<tr class="memitem:ac96a0a92c22ced9c629b174dade3dd70"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ac96a0a92c22ced9c629b174dade3dd70">requirePerFaceMark</a> (const MeshType &amp;m)</td></tr>
<tr class="separator:ac96a0a92c22ced9c629b174dade3dd70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac641c6af53b47b21fe2b1b85f1b1c8c4"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; <br />
requires HasPerFaceNormal&lt;MeshType&gt;</td></tr>
<tr class="memitem:ac641c6af53b47b21fe2b1b85f1b1c8c4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ac641c6af53b47b21fe2b1b85f1b1c8c4">requirePerFaceNormal</a> (const MeshType &amp;m)</td></tr>
<tr class="separator:ac641c6af53b47b21fe2b1b85f1b1c8c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a880bfabf90d17524361cc4115587db56"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; <br />
requires HasPerFacePrincipalCurvature&lt;MeshType&gt;</td></tr>
<tr class="memitem:a880bfabf90d17524361cc4115587db56"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a880bfabf90d17524361cc4115587db56">requirePerFacePrincipalCurvature</a> (const MeshType &amp;m)</td></tr>
<tr class="separator:a880bfabf90d17524361cc4115587db56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b27fb34180501bde527a828cf281479"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; <br />
requires HasPerFaceScalar&lt;MeshType&gt;</td></tr>
<tr class="memitem:a5b27fb34180501bde527a828cf281479"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a5b27fb34180501bde527a828cf281479">requirePerFaceScalar</a> (const MeshType &amp;m)</td></tr>
<tr class="separator:a5b27fb34180501bde527a828cf281479"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef39ab9380581074304975fc0cb49570"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; <br />
requires HasPerFaceWedgeColors&lt;MeshType&gt;</td></tr>
<tr class="memitem:aef39ab9380581074304975fc0cb49570"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#aef39ab9380581074304975fc0cb49570">requirePerFaceWedgeColors</a> (const MeshType &amp;m)</td></tr>
<tr class="separator:aef39ab9380581074304975fc0cb49570"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f262a65d84b84b17a5d41b13fa98329"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; <br />
requires HasPerFaceWedgeTexCoords&lt;MeshType&gt;</td></tr>
<tr class="memitem:a7f262a65d84b84b17a5d41b13fa98329"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a7f262a65d84b84b17a5d41b13fa98329">requirePerFaceWedgeTexCoords</a> (const MeshType &amp;m)</td></tr>
<tr class="separator:a7f262a65d84b84b17a5d41b13fa98329"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bce10c7a1576d043e084010b0481369"><td class="memTemplParams" colspan="2">template&lt;DcelMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a6bce10c7a1576d043e084010b0481369"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a6bce10c7a1576d043e084010b0481369">isHalfEdgeContainerCompact</a> (const MeshType &amp;m)</td></tr>
<tr class="memdesc:a6bce10c7a1576d043e084010b0481369"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if the given mesh has its <a class="el" href="classvcl_1_1HalfEdge.html" title="The HalfEdge class.">HalfEdge</a> Container compact. Returns <code>false</code> if the mesh has no <a class="el" href="classvcl_1_1HalfEdge.html" title="The HalfEdge class.">HalfEdge</a> Container.  <br /></td></tr>
<tr class="separator:a6bce10c7a1576d043e084010b0481369"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0de31119b41b551829bcec648f3e299e"><td class="memTemplParams" colspan="2">template&lt;DcelMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a0de31119b41b551829bcec648f3e299e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a0de31119b41b551829bcec648f3e299e">isPerHalfEdgeColorEnabled</a> (const MeshType &amp;m)</td></tr>
<tr class="separator:a0de31119b41b551829bcec648f3e299e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab916befe515685645779ed6e6496ef7f"><td class="memTemplParams" colspan="2">template&lt;DcelMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ab916befe515685645779ed6e6496ef7f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ab916befe515685645779ed6e6496ef7f">enableIfPerHalfEdgeColorOptional</a> (MeshType &amp;m)</td></tr>
<tr class="separator:ab916befe515685645779ed6e6496ef7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a242bcb896ac0bb33e925c7b70ea3b283"><td class="memTemplParams" colspan="2">template&lt;DcelMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a242bcb896ac0bb33e925c7b70ea3b283"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a242bcb896ac0bb33e925c7b70ea3b283">isPerHalfEdgeMarkEnabled</a> (const MeshType &amp;m)</td></tr>
<tr class="separator:a242bcb896ac0bb33e925c7b70ea3b283"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb7133d4f4f203243589a002605dcbc3"><td class="memTemplParams" colspan="2">template&lt;DcelMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:abb7133d4f4f203243589a002605dcbc3"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#abb7133d4f4f203243589a002605dcbc3">enableIfPerHalfEdgeMarkOptional</a> (MeshType &amp;m)</td></tr>
<tr class="separator:abb7133d4f4f203243589a002605dcbc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1ef3fad09c2f9fa34d0473f0a447c1d"><td class="memTemplParams" colspan="2">template&lt;DcelMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ab1ef3fad09c2f9fa34d0473f0a447c1d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ab1ef3fad09c2f9fa34d0473f0a447c1d">isPerHalfEdgeScalarEnabled</a> (const MeshType &amp;m)</td></tr>
<tr class="separator:ab1ef3fad09c2f9fa34d0473f0a447c1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45ba8ec2901d287606faca1bb8c8c224"><td class="memTemplParams" colspan="2">template&lt;DcelMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a45ba8ec2901d287606faca1bb8c8c224"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a45ba8ec2901d287606faca1bb8c8c224">enableIfPerHalfEdgeScalarOptional</a> (MeshType &amp;m)</td></tr>
<tr class="separator:a45ba8ec2901d287606faca1bb8c8c224"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3c37ce92676691df1c039d463d48db6"><td class="memTemplParams" colspan="2">template&lt;DcelMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ae3c37ce92676691df1c039d463d48db6"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ae3c37ce92676691df1c039d463d48db6">isPerHalfEdgeTexCoordEnabled</a> (const MeshType &amp;m)</td></tr>
<tr class="separator:ae3c37ce92676691df1c039d463d48db6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c874ee251571b905630d390b33a566c"><td class="memTemplParams" colspan="2">template&lt;DcelMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a9c874ee251571b905630d390b33a566c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a9c874ee251571b905630d390b33a566c">enableIfPerHalfEdgeTexCoordOptional</a> (MeshType &amp;m)</td></tr>
<tr class="separator:a9c874ee251571b905630d390b33a566c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a609b362469e59878aa3bba0097a3a00d"><td class="memTemplParams" colspan="2">template&lt;DcelMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a609b362469e59878aa3bba0097a3a00d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a609b362469e59878aa3bba0097a3a00d">requireHalfEdgeContainerCompactness</a> (const MeshType &amp;m)</td></tr>
<tr class="separator:a609b362469e59878aa3bba0097a3a00d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3e1c6b6d6d73a6d542084c7c47ea858"><td class="memTemplParams" colspan="2">template&lt;DcelMeshConcept MeshType&gt; <br />
requires HasPerHalfEdgeColor&lt;MeshType&gt;</td></tr>
<tr class="memitem:ad3e1c6b6d6d73a6d542084c7c47ea858"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ad3e1c6b6d6d73a6d542084c7c47ea858">requirePerHalfEdgeColor</a> (const MeshType &amp;m)</td></tr>
<tr class="separator:ad3e1c6b6d6d73a6d542084c7c47ea858"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacdeb06385ef42c65be942ce79ebdd2f"><td class="memTemplParams" colspan="2">template&lt;DcelMeshConcept MeshType&gt; <br />
requires HasPerHalfEdgeMark&lt;MeshType&gt;</td></tr>
<tr class="memitem:aacdeb06385ef42c65be942ce79ebdd2f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#aacdeb06385ef42c65be942ce79ebdd2f">requirePerHalfEdgeMark</a> (const MeshType &amp;m)</td></tr>
<tr class="separator:aacdeb06385ef42c65be942ce79ebdd2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07b74f9a0baee35bd34e5ee925270440"><td class="memTemplParams" colspan="2">template&lt;DcelMeshConcept MeshType&gt; <br />
requires HasPerHalfEdgeScalar&lt;MeshType&gt;</td></tr>
<tr class="memitem:a07b74f9a0baee35bd34e5ee925270440"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a07b74f9a0baee35bd34e5ee925270440">requirePerHalfEdgeScalar</a> (const MeshType &amp;m)</td></tr>
<tr class="separator:a07b74f9a0baee35bd34e5ee925270440"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2535d580dc788c502bc75f04f9e648b6"><td class="memTemplParams" colspan="2">template&lt;DcelMeshConcept MeshType&gt; <br />
requires HasPerHalfEdgeTexCoord&lt;MeshType&gt;</td></tr>
<tr class="memitem:a2535d580dc788c502bc75f04f9e648b6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a2535d580dc788c502bc75f04f9e648b6">requirePerHalfEdgeTexCoord</a> (const MeshType &amp;m)</td></tr>
<tr class="separator:a2535d580dc788c502bc75f04f9e648b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f44643cdd6a934b9ab5f60315e6f01a"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a2f44643cdd6a934b9ab5f60315e6f01a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a2f44643cdd6a934b9ab5f60315e6f01a">isTriangleMesh</a> (const MeshType &amp;m)</td></tr>
<tr class="memdesc:a2f44643cdd6a934b9ab5f60315e6f01a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks <em>at run time</em> if the mesh m is composed of triangles. If the size of the <a class="el" href="classvcl_1_1Face.html" title="The Face class.">Face</a> <a class="el" href="classvcl_1_1Vertex.html" title="The Vertex class.">Vertex</a> References is 3, this check is immediate. If it is not 3, the functions checks for each face if it has 3 vertices.  <br /></td></tr>
<tr class="separator:a2f44643cdd6a934b9ab5f60315e6f01a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1878ac13ce283e3535efd93d254d1843"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a1878ac13ce283e3535efd93d254d1843"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a1878ac13ce283e3535efd93d254d1843">isQuadMesh</a> (const MeshType &amp;m)</td></tr>
<tr class="memdesc:a1878ac13ce283e3535efd93d254d1843"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks <em>at run time</em> if the mesh is composed of quads. If the size of the <a class="el" href="classvcl_1_1Face.html" title="The Face class.">Face</a> <a class="el" href="classvcl_1_1Vertex.html" title="The Vertex class.">Vertex</a> References is 4, this check is immediate. If it is not 4, the functions checks for each face if it has 4 vertices.  <br /></td></tr>
<tr class="separator:a1878ac13ce283e3535efd93d254d1843"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb9fbe7647f2b656ab871e2bb20b8c33"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:acb9fbe7647f2b656ab871e2bb20b8c33"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#acb9fbe7647f2b656ab871e2bb20b8c33">isCompact</a> (const MeshType &amp;m)</td></tr>
<tr class="memdesc:acb9fbe7647f2b656ab871e2bb20b8c33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a> is compact, that is if it does not contains deleted elements.  <br /></td></tr>
<tr class="separator:acb9fbe7647f2b656ab871e2bb20b8c33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f347e31d2e1fd9471cc98f46668c64c"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a3f347e31d2e1fd9471cc98f46668c64c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a3f347e31d2e1fd9471cc98f46668c64c">requireTriangleMesh</a> (const MeshType &amp;m)</td></tr>
<tr class="separator:a3f347e31d2e1fd9471cc98f46668c64c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa713300521a68b8fe8bf5154fdae27b8"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:aa713300521a68b8fe8bf5154fdae27b8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#aa713300521a68b8fe8bf5154fdae27b8">requireQuadMesh</a> (const MeshType &amp;m)</td></tr>
<tr class="separator:aa713300521a68b8fe8bf5154fdae27b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84e84c881525f5d76599d6ef8d4a0933"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a84e84c881525f5d76599d6ef8d4a0933"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a84e84c881525f5d76599d6ef8d4a0933">requireCompactness</a> (const MeshType &amp;m)</td></tr>
<tr class="separator:a84e84c881525f5d76599d6ef8d4a0933"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af71077b0dd03e109c80a05dc1bcafdf5"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:af71077b0dd03e109c80a05dc1bcafdf5"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#af71077b0dd03e109c80a05dc1bcafdf5">isVertexContainerCompact</a> (const MeshType &amp;m)</td></tr>
<tr class="memdesc:af71077b0dd03e109c80a05dc1bcafdf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if the given mesh has its <a class="el" href="classvcl_1_1Vertex.html" title="The Vertex class.">Vertex</a> Container compact.  <br /></td></tr>
<tr class="separator:af71077b0dd03e109c80a05dc1bcafdf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32903e0a292bcdaa77ab10536316c531"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a32903e0a292bcdaa77ab10536316c531"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a32903e0a292bcdaa77ab10536316c531">isPerVertexAdjacentFacesEnabled</a> (const MeshType &amp;m)</td></tr>
<tr class="separator:a32903e0a292bcdaa77ab10536316c531"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a617cf756eac51fcf6b566ce5d4c09393"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a617cf756eac51fcf6b566ce5d4c09393"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a617cf756eac51fcf6b566ce5d4c09393">enableIfPerVertexAdjacentFacesOptional</a> (MeshType &amp;m)</td></tr>
<tr class="separator:a617cf756eac51fcf6b566ce5d4c09393"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b69a485cf086be8551cc40210172e6a"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a2b69a485cf086be8551cc40210172e6a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a2b69a485cf086be8551cc40210172e6a">isPerVertexAdjacentVerticesEnabled</a> (const MeshType &amp;m)</td></tr>
<tr class="separator:a2b69a485cf086be8551cc40210172e6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e15c93274d1207f45bb0673fce3ba8a"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a6e15c93274d1207f45bb0673fce3ba8a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a6e15c93274d1207f45bb0673fce3ba8a">enableIfPerVertexAdjacentVerticesOptional</a> (MeshType &amp;m)</td></tr>
<tr class="separator:a6e15c93274d1207f45bb0673fce3ba8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accfcf562d26791650dbddf9910105e26"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:accfcf562d26791650dbddf9910105e26"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#accfcf562d26791650dbddf9910105e26">isPerVertexColorEnabled</a> (const MeshType &amp;m)</td></tr>
<tr class="separator:accfcf562d26791650dbddf9910105e26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a802d56a620a24d04972ba5d483a2730a"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a802d56a620a24d04972ba5d483a2730a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a802d56a620a24d04972ba5d483a2730a">enableIfPerVertexColorOptional</a> (MeshType &amp;m)</td></tr>
<tr class="separator:a802d56a620a24d04972ba5d483a2730a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d1e8025d3ef60421266da65134a4311"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a3d1e8025d3ef60421266da65134a4311"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a3d1e8025d3ef60421266da65134a4311">isPerVertexMarkEnabled</a> (const MeshType &amp;m)</td></tr>
<tr class="separator:a3d1e8025d3ef60421266da65134a4311"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64bde18cc07f8804c0c96e5def984f26"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a64bde18cc07f8804c0c96e5def984f26"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a64bde18cc07f8804c0c96e5def984f26">enableIfPerVertexMarkOptional</a> (MeshType &amp;m)</td></tr>
<tr class="separator:a64bde18cc07f8804c0c96e5def984f26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a42ac0f4ca25059bc805e9a5238a083"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a7a42ac0f4ca25059bc805e9a5238a083"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a7a42ac0f4ca25059bc805e9a5238a083">isPerVertexNormalEnabled</a> (const MeshType &amp;m)</td></tr>
<tr class="separator:a7a42ac0f4ca25059bc805e9a5238a083"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4a7a739d6f30a2e4768b7b12c663418"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:af4a7a739d6f30a2e4768b7b12c663418"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#af4a7a739d6f30a2e4768b7b12c663418">enableIfPerVertexNormalOptional</a> (MeshType &amp;m)</td></tr>
<tr class="separator:af4a7a739d6f30a2e4768b7b12c663418"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0120edd84580c8e6bd446c913937c937"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a0120edd84580c8e6bd446c913937c937"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a0120edd84580c8e6bd446c913937c937">isPerVertexPrincipalCurvatureEnabled</a> (const MeshType &amp;m)</td></tr>
<tr class="separator:a0120edd84580c8e6bd446c913937c937"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a579b161f8a4132e5106608bebc70e363"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a579b161f8a4132e5106608bebc70e363"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a579b161f8a4132e5106608bebc70e363">enableIfPerVertexPrincipalCurvatureOptional</a> (MeshType &amp;m)</td></tr>
<tr class="separator:a579b161f8a4132e5106608bebc70e363"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a394d8b695689371fc986ddd3a64161dd"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a394d8b695689371fc986ddd3a64161dd"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a394d8b695689371fc986ddd3a64161dd">isPerVertexScalarEnabled</a> (const MeshType &amp;m)</td></tr>
<tr class="separator:a394d8b695689371fc986ddd3a64161dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad25a1b222bdd0347c1cdfa9d25ffa191"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ad25a1b222bdd0347c1cdfa9d25ffa191"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ad25a1b222bdd0347c1cdfa9d25ffa191">enableIfPerVertexScalarOptional</a> (MeshType &amp;m)</td></tr>
<tr class="separator:ad25a1b222bdd0347c1cdfa9d25ffa191"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad553855e74ee03b94f8c7e11c3085cf8"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ad553855e74ee03b94f8c7e11c3085cf8"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ad553855e74ee03b94f8c7e11c3085cf8">isPerVertexTexCoordEnabled</a> (const MeshType &amp;m)</td></tr>
<tr class="separator:ad553855e74ee03b94f8c7e11c3085cf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a369d2067cce035b7b4a710c5b364a28c"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a369d2067cce035b7b4a710c5b364a28c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a369d2067cce035b7b4a710c5b364a28c">enableIfPerVertexTexCoordOptional</a> (MeshType &amp;m)</td></tr>
<tr class="separator:a369d2067cce035b7b4a710c5b364a28c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5e94dd9b89e9bc4fb21701af6e788ca"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ae5e94dd9b89e9bc4fb21701af6e788ca"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ae5e94dd9b89e9bc4fb21701af6e788ca">requireVertexContainerCompactness</a> (const MeshType &amp;m)</td></tr>
<tr class="separator:ae5e94dd9b89e9bc4fb21701af6e788ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f6666a7b9cd7293ab07aaf6cbc1dc4c"><td class="memTemplParams" colspan="2">template&lt;typename MeshType &gt; <br />
requires HasPerVertexAdjacentFaces&lt;MeshType&gt;</td></tr>
<tr class="memitem:a1f6666a7b9cd7293ab07aaf6cbc1dc4c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a1f6666a7b9cd7293ab07aaf6cbc1dc4c">requirePerVertexAdjacentFaces</a> (const MeshType &amp;m)</td></tr>
<tr class="separator:a1f6666a7b9cd7293ab07aaf6cbc1dc4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a224534742afebeedf036df597231c700"><td class="memTemplParams" colspan="2">template&lt;typename MeshType &gt; <br />
requires HasPerVertexAdjacentVertices&lt;MeshType&gt;</td></tr>
<tr class="memitem:a224534742afebeedf036df597231c700"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a224534742afebeedf036df597231c700">requirePerVertexAdjacentVertices</a> (const MeshType &amp;m)</td></tr>
<tr class="separator:a224534742afebeedf036df597231c700"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fc65a005474dd6f983d5f9b235b5387"><td class="memTemplParams" colspan="2">template&lt;typename MeshType &gt; <br />
requires HasPerVertexColor&lt;MeshType&gt;</td></tr>
<tr class="memitem:a3fc65a005474dd6f983d5f9b235b5387"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a3fc65a005474dd6f983d5f9b235b5387">requirePerVertexColor</a> (const MeshType &amp;m)</td></tr>
<tr class="separator:a3fc65a005474dd6f983d5f9b235b5387"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1b0cb92a48a555d7084bb6fb94ef359"><td class="memTemplParams" colspan="2">template&lt;typename MeshType &gt; <br />
requires HasPerVertexMark&lt;MeshType&gt;</td></tr>
<tr class="memitem:ad1b0cb92a48a555d7084bb6fb94ef359"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ad1b0cb92a48a555d7084bb6fb94ef359">requirePerVertexMark</a> (const MeshType &amp;m)</td></tr>
<tr class="separator:ad1b0cb92a48a555d7084bb6fb94ef359"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab43f884f6ca679c8f57255e11ddaa768"><td class="memTemplParams" colspan="2">template&lt;typename MeshType &gt; <br />
requires HasPerVertexNormal&lt;MeshType&gt;</td></tr>
<tr class="memitem:ab43f884f6ca679c8f57255e11ddaa768"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ab43f884f6ca679c8f57255e11ddaa768">requirePerVertexNormal</a> (const MeshType &amp;m)</td></tr>
<tr class="separator:ab43f884f6ca679c8f57255e11ddaa768"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af330a765b2c7772ff85378f617ade27b"><td class="memTemplParams" colspan="2">template&lt;typename MeshType &gt; <br />
requires HasPerVertexPrincipalCurvature&lt;MeshType&gt;</td></tr>
<tr class="memitem:af330a765b2c7772ff85378f617ade27b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#af330a765b2c7772ff85378f617ade27b">requirePerVertexPrincipalCurvature</a> (const MeshType &amp;m)</td></tr>
<tr class="separator:af330a765b2c7772ff85378f617ade27b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba5f0aba238fdf49f79c8986cee2bfa9"><td class="memTemplParams" colspan="2">template&lt;typename MeshType &gt; <br />
requires HasPerVertexScalar&lt;MeshType&gt;</td></tr>
<tr class="memitem:aba5f0aba238fdf49f79c8986cee2bfa9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#aba5f0aba238fdf49f79c8986cee2bfa9">requirePerVertexScalar</a> (const MeshType &amp;m)</td></tr>
<tr class="separator:aba5f0aba238fdf49f79c8986cee2bfa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f20fd534d1bb822fe5b13f2515025ee"><td class="memTemplParams" colspan="2">template&lt;typename MeshType &gt; <br />
requires HasPerVertexTexCoord&lt;MeshType&gt;</td></tr>
<tr class="memitem:a5f20fd534d1bb822fe5b13f2515025ee"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a5f20fd534d1bb822fe5b13f2515025ee">requirePerVertexTexCoord</a> (const MeshType &amp;m)</td></tr>
<tr class="separator:a5f20fd534d1bb822fe5b13f2515025ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cdf6b9e1ed3c93d2a4c6265a9fed40c"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Args&gt; </td></tr>
<tr class="memitem:a6cdf6b9e1ed3c93d2a4c6265a9fed40c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a6cdf6b9e1ed3c93d2a4c6265a9fed40c">compactVector</a> (std::vector&lt; T, Args... &gt; &amp;vec, const std::vector&lt; int &gt; &amp;newIndices)</td></tr>
<tr class="memdesc:a6cdf6b9e1ed3c93d2a4c6265a9fed40c"><td class="mdescLeft">&#160;</td><td class="mdescRight">It will take care of compacting the vector vec, depending on the content of the vector newIndices.  <br /></td></tr>
<tr class="separator:a6cdf6b9e1ed3c93d2a4c6265a9fed40c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb189433c1c9d7bf52a96ff359f364ec"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Rest&gt; </td></tr>
<tr class="memitem:aeb189433c1c9d7bf52a96ff359f364ec"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#aeb189433c1c9d7bf52a96ff359f364ec">hashCombine</a> (std::size_t &amp;seed, const T &amp;v, const Rest &amp;... rest)</td></tr>
<tr class="memdesc:aeb189433c1c9d7bf52a96ff359f364ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starting from a seed, computes the hash of a series of objects.  <br /></td></tr>
<tr class="separator:aeb189433c1c9d7bf52a96ff359f364ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9692d4f1afe48a370a2fe551d5ea55d4"><td class="memTemplParams" colspan="2">template&lt;LoggerConcept T&gt; </td></tr>
<tr class="memitem:a9692d4f1afe48a370a2fe551d5ea55d4"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a9692d4f1afe48a370a2fe551d5ea55d4">isLoggerValid</a> ()</td></tr>
<tr class="memdesc:a9692d4f1afe48a370a2fe551d5ea55d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="namespacevcl.html#a9692d4f1afe48a370a2fe551d5ea55d4" title="The isLoggerValid() function returns true if the type T is not the NullLogger type.">isLoggerValid()</a> function returns true if the type T is not the <a class="el" href="classvcl_1_1NullLogger.html" title="The NullLogger class is an empty class that is used as default type in all the library functions that...">NullLogger</a> type.  <br /></td></tr>
<tr class="separator:a9692d4f1afe48a370a2fe551d5ea55d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abde6b767fa0b116a5fd8b2a5fa0af488"><td class="memTemplParams" colspan="2">template&lt;typename Iterator , typename Lambda &gt; </td></tr>
<tr class="memitem:abde6b767fa0b116a5fd8b2a5fa0af488"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#abde6b767fa0b116a5fd8b2a5fa0af488">parallelFor</a> (Iterator &amp;&amp;begin, Iterator &amp;&amp;end, Lambda &amp;&amp;F)</td></tr>
<tr class="memdesc:abde6b767fa0b116a5fd8b2a5fa0af488"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function executes a parallel (vectorized) for over the elements iterated between <code>begin</code> and <code>end</code> iterators, if parallel requirements have been found in the system.  <br /></td></tr>
<tr class="separator:abde6b767fa0b116a5fd8b2a5fa0af488"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac74faed2021a2b157f5b80757ee694d8"><td class="memTemplParams" colspan="2">template&lt;typename Iterator , typename Lambda &gt; </td></tr>
<tr class="memitem:ac74faed2021a2b157f5b80757ee694d8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ac74faed2021a2b157f5b80757ee694d8">parallelFor</a> (const Iterator &amp;begin, const Iterator &amp;end, Lambda &amp;&amp;F)</td></tr>
<tr class="memdesc:ac74faed2021a2b157f5b80757ee694d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function executes a parallel (vectorized) for over the elements iterated between <code>begin</code> and <code>end</code> iterators, if parallel requirements have been found in the system.  <br /></td></tr>
<tr class="separator:ac74faed2021a2b157f5b80757ee694d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bbb25a5a74276bc05a251ab860a286d"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="conceptvcl_1_1Range.html">vcl::Range</a> Rng, typename Lambda &gt; </td></tr>
<tr class="memitem:a0bbb25a5a74276bc05a251ab860a286d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a0bbb25a5a74276bc05a251ab860a286d">parallelFor</a> (Rng &amp;&amp;r, Lambda &amp;&amp;F)</td></tr>
<tr class="memdesc:a0bbb25a5a74276bc05a251ab860a286d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function executes a parallel (vectorized) for over a range if parallel requirements have been found in the system.  <br /></td></tr>
<tr class="separator:a0bbb25a5a74276bc05a251ab860a286d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad43b0e6c5acf9f903daf25853361a24c"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="conceptvcl_1_1Range.html">vcl::Range</a> Rng, typename Lambda &gt; </td></tr>
<tr class="memitem:ad43b0e6c5acf9f903daf25853361a24c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ad43b0e6c5acf9f903daf25853361a24c">parallelFor</a> (const Rng &amp;r, Lambda &amp;&amp;F)</td></tr>
<tr class="memdesc:ad43b0e6c5acf9f903daf25853361a24c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function executes a parallel (vectorized) for over a range if parallel requirements have been found in the system.  <br /></td></tr>
<tr class="separator:ad43b0e6c5acf9f903daf25853361a24c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08ddfb40632cb38ec4750610e0e2ebaa"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename... Us&gt; </td></tr>
<tr class="memitem:a08ddfb40632cb38ec4750610e0e2ebaa"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a08ddfb40632cb38ec4750610e0e2ebaa">tupleIndexByType</a> (const std::tuple&lt; U, Us... &gt; &amp;)</td></tr>
<tr class="memdesc:a08ddfb40632cb38ec4750610e0e2ebaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of a type T in a std::tuple&lt;U, Us...&gt; passed as parameter; Returns UINT_NULL if the type T is not found in the tuple.  <br /></td></tr>
<tr class="separator:a08ddfb40632cb38ec4750610e0e2ebaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29085f23ae80546ea3ba0e9f6da41a90"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a29085f23ae80546ea3ba0e9f6da41a90">swap</a> (<a class="el" href="classvcl_1_1DrawableObjectVector.html">DrawableObjectVector</a> &amp;v1, <a class="el" href="classvcl_1_1DrawableObjectVector.html">DrawableObjectVector</a> &amp;v2)</td></tr>
<tr class="separator:a29085f23ae80546ea3ba0e9f6da41a90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10783cb155a40826adff62ef42123efe"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:a10783cb155a40826adff62ef42123efe"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a10783cb155a40826adff62ef42123efe">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classvcl_1_1Array.html">Array</a>&lt; Scalar, 2 &gt; &amp;a)</td></tr>
<tr class="separator:a10783cb155a40826adff62ef42123efe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05dd102880d029a4ce6a952207559088"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a05dd102880d029a4ce6a952207559088">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classvcl_1_1Color.html">Color</a> &amp;c)</td></tr>
<tr class="memdesc:a05dd102880d029a4ce6a952207559088"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload of stream operator to allow a pretty print of a <a class="el" href="classvcl_1_1Color.html" title="The Color class represents an RGBA color.">vcl::Color</a>.  <br /></td></tr>
<tr class="separator:a05dd102880d029a4ce6a952207559088"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dcc49648719fc830554b892110ff8f2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Color.html">Color</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a9dcc49648719fc830554b892110ff8f2">colorLerp</a> (const <a class="el" href="classvcl_1_1Color.html">Color</a> &amp;c0, const <a class="el" href="classvcl_1_1Color.html">Color</a> &amp;c1, float value)</td></tr>
<tr class="memdesc:a9dcc49648719fc830554b892110ff8f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an interval of colors (from <code>c0</code> to <code>c1</code>) and a value in the interval [0, 1], returns the linear interpolation color between <code>c0</code> and <code>c1</code> based on <code>value</code> in the [0, 1] interval. If <code>value</code> is out of range, it will be set to the nearest extreme of the interval.  <br /></td></tr>
<tr class="separator:a9dcc49648719fc830554b892110ff8f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5851edce0478bfc7f4084e3529ae6962"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Color.html">Color</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a5851edce0478bfc7f4084e3529ae6962">colorFromInterval</a> (float value, <a class="el" href="classvcl_1_1Color.html#a32ace7bd7fccf742b39f6cd83042a10f">Color::ColorMap</a> cm)</td></tr>
<tr class="memdesc:a5851edce0478bfc7f4084e3529ae6962"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a <code>value</code> in the interval [0, 1], it returns the color in the position in the given ColorMap <code>cm</code> corresponding to the position of <code>value</code> in the interval [0, 1].  <br /></td></tr>
<tr class="separator:a5851edce0478bfc7f4084e3529ae6962"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5a54ddc3c9d67e0c7ed179e78c2ca06"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Color.html">Color</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ab5a54ddc3c9d67e0c7ed179e78c2ca06">colorFromInterval</a> (float <a class="el" href="namespacevcl.html#a3edcb561672a6be17e9453bd1ea446d5">min</a>, float <a class="el" href="namespacevcl.html#a69cc63a5ad2974d082145ed1dee7846b">max</a>, float value, <a class="el" href="classvcl_1_1Color.html#a32ace7bd7fccf742b39f6cd83042a10f">Color::ColorMap</a> cm)</td></tr>
<tr class="memdesc:ab5a54ddc3c9d67e0c7ed179e78c2ca06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a color in the interval from the minimum color to the maximum color of the given colormap <code>cm</code>, depending on the position of the given value in the given interval [min, max].  <br /></td></tr>
<tr class="separator:ab5a54ddc3c9d67e0c7ed179e78c2ca06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c348d7127fb95f134332b8c275846f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Color.html">Color</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a6c348d7127fb95f134332b8c275846f7">colorFromIntervalRedBlue</a> (float value)</td></tr>
<tr class="memdesc:a6c348d7127fb95f134332b8c275846f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a color in the interval from Red to Blue depending on the position of the given value in the interval [0, 1].  <br /></td></tr>
<tr class="separator:a6c348d7127fb95f134332b8c275846f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa361024b35e8aef9609826b177ac1cb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Color.html">Color</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#afa361024b35e8aef9609826b177ac1cb">colorFromIntervalRedBlue</a> (float <a class="el" href="namespacevcl.html#a3edcb561672a6be17e9453bd1ea446d5">min</a>, float <a class="el" href="namespacevcl.html#a69cc63a5ad2974d082145ed1dee7846b">max</a>, float value)</td></tr>
<tr class="memdesc:afa361024b35e8aef9609826b177ac1cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a color in the interval from Red to Blue depending on the position of the given value in the given interval [min, max].  <br /></td></tr>
<tr class="separator:afa361024b35e8aef9609826b177ac1cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7728ec836fa169f447a90a4d2eee3df5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Color.html">Color</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a7728ec836fa169f447a90a4d2eee3df5">colorFromIntervalParula</a> (float value)</td></tr>
<tr class="memdesc:a7728ec836fa169f447a90a4d2eee3df5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a color in the Paraula colormap depending on the position of the given value in the interval [0, 1].  <br /></td></tr>
<tr class="separator:a7728ec836fa169f447a90a4d2eee3df5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9725bc9a2f5b27ce885e76be92185a20"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Color.html">Color</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a9725bc9a2f5b27ce885e76be92185a20">colorFromIntervalParula</a> (float <a class="el" href="namespacevcl.html#a3edcb561672a6be17e9453bd1ea446d5">min</a>, float <a class="el" href="namespacevcl.html#a69cc63a5ad2974d082145ed1dee7846b">max</a>, float value)</td></tr>
<tr class="memdesc:a9725bc9a2f5b27ce885e76be92185a20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a color in the Paraula colormap depending on the position of the given value in the given interval [min, max].  <br /></td></tr>
<tr class="separator:a9725bc9a2f5b27ce885e76be92185a20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8232d4e3c3aca4125e84cb8f124ebc29"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Color.html">Color</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a8232d4e3c3aca4125e84cb8f124ebc29">colorFromIntervalGreyShade</a> (float value)</td></tr>
<tr class="memdesc:a8232d4e3c3aca4125e84cb8f124ebc29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a color in the grey shade colormap depending on the position of the given value in the interval [0, 1].  <br /></td></tr>
<tr class="separator:a8232d4e3c3aca4125e84cb8f124ebc29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99b591f2eba1ded24ebf6f4b0ee4353f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Color.html">Color</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a99b591f2eba1ded24ebf6f4b0ee4353f">colorFromIntervalGreyShade</a> (float <a class="el" href="namespacevcl.html#a3edcb561672a6be17e9453bd1ea446d5">min</a>, float <a class="el" href="namespacevcl.html#a69cc63a5ad2974d082145ed1dee7846b">max</a>, float value)</td></tr>
<tr class="memdesc:a99b591f2eba1ded24ebf6f4b0ee4353f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a color in the grey shade colormap depending on the position of the given value in the given interval [min, max].  <br /></td></tr>
<tr class="separator:a99b591f2eba1ded24ebf6f4b0ee4353f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab09621efab9b0f2003139f2aac2d339a"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classvcl_1_1Color.html">Color</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ab09621efab9b0f2003139f2aac2d339a">colorScattering</a> (<a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> n, float sat, float val)</td></tr>
<tr class="memdesc:ab09621efab9b0f2003139f2aac2d339a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a number <code>n</code>, returns a vector of <code>n</code> colors so that each color differs as much as possible from the previous one of the vector.  <br /></td></tr>
<tr class="separator:ab09621efab9b0f2003139f2aac2d339a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f45446c5f7bcad8bd9dd9c515bf1e55"><td class="memTemplParams" colspan="2">template&lt;PointConcept PointType&gt; </td></tr>
<tr class="memitem:a6f45446c5f7bcad8bd9dd9c515bf1e55"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Point.html">Point</a>&lt; <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a>, PointType::DIM &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a6f45446c5f7bcad8bd9dd9c515bf1e55">bestGridSize</a> (const PointType &amp;lengths, <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> nElements)</td></tr>
<tr class="memdesc:a6f45446c5f7bcad8bd9dd9c515bf1e55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the best sizes (number of cells per dimension) of a Grid, starting from the lengths of the grid and the number of elements to place in the grid.  <br /></td></tr>
<tr class="separator:a6f45446c5f7bcad8bd9dd9c515bf1e55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1420d0b9ba83dea9e692db635533f46c"><td class="memTemplParams" colspan="2">template&lt;PointConcept PointType, typename D &gt; </td></tr>
<tr class="memitem:a1420d0b9ba83dea9e692db635533f46c"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a1420d0b9ba83dea9e692db635533f46c">RegularGrid</a> (PointType, PointType, D) -&gt; <a class="el" href="classvcl_1_1RegularGrid.html">RegularGrid</a>&lt; typename PointType::ScalarType, PointType::DIM &gt;</td></tr>
<tr class="separator:a1420d0b9ba83dea9e692db635533f46c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f1aec3c668a14a8c09ee1f6976c1a1e"><td class="memTemplParams" colspan="2">template&lt;PointConcept PointType&gt; </td></tr>
<tr class="memitem:a9f1aec3c668a14a8c09ee1f6976c1a1e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Point.html">vcl::Point</a>&lt; <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a>, PointType::DIM &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a9f1aec3c668a14a8c09ee1f6976c1a1e">bestGridSize</a> (const PointType &amp;lengths, <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> nElements)</td></tr>
<tr class="memdesc:a9f1aec3c668a14a8c09ee1f6976c1a1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the best sizes (number of cells per dimension) of a Grid, starting from the lengths of the grid and the number of elements to place in the grid.  <br /></td></tr>
<tr class="separator:a9f1aec3c668a14a8c09ee1f6976c1a1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1f5ecc820f6ab64fb437ba12296601c"><td class="memTemplParams" colspan="2">template&lt;PointIteratorConcept It&gt; </td></tr>
<tr class="memitem:ab1f5ecc820f6ab64fb437ba12296601c"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ab1f5ecc820f6ab64fb437ba12296601c">StaticGrid</a> (It, It) -&gt; <a class="el" href="classvcl_1_1StaticGrid.html">StaticGrid</a>&lt; <a class="el" href="classvcl_1_1RegularGrid.html">RegularGrid</a>&lt; typename It::value_type, It::value_type::DIM &gt;, typename It::value_type::ScalarType &gt;</td></tr>
<tr class="separator:ab1f5ecc820f6ab64fb437ba12296601c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7586ced2cedb8cd2aa668c8136b24603"><td class="memTemplParams" colspan="2">template&lt;PointIteratorConcept It, typename F &gt; </td></tr>
<tr class="memitem:a7586ced2cedb8cd2aa668c8136b24603"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a7586ced2cedb8cd2aa668c8136b24603">StaticGrid</a> (It, It, F) -&gt; <a class="el" href="classvcl_1_1StaticGrid.html">StaticGrid</a>&lt; <a class="el" href="classvcl_1_1RegularGrid.html">RegularGrid</a>&lt; typename It::value_type, It::value_type::DIM &gt;, typename It::value_type::ScalarType &gt;</td></tr>
<tr class="separator:a7586ced2cedb8cd2aa668c8136b24603"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6d4557abc45cc5daf2fe2e389b91ce9"><td class="memTemplParams" colspan="2">template&lt;VertexPointerRangeConcept Rng&gt; </td></tr>
<tr class="memitem:ae6d4557abc45cc5daf2fe2e389b91ce9"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ae6d4557abc45cc5daf2fe2e389b91ce9">StaticGrid</a> (Rng) -&gt; <a class="el" href="classvcl_1_1StaticGrid.html">StaticGrid</a>&lt; <a class="el" href="classvcl_1_1RegularGrid.html">RegularGrid</a>&lt; typename std::remove_pointer_t&lt; typename std::ranges::iterator_t&lt; Rng &gt;::value_type &gt;::CoordType::ScalarType, 3 &gt;, typename std::ranges::iterator_t&lt; Rng &gt;::value_type &gt;</td></tr>
<tr class="separator:ae6d4557abc45cc5daf2fe2e389b91ce9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7606be147f292f38e1e22a709708a19"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ab7606be147f292f38e1e22a709708a19"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ab7606be147f292f38e1e22a709708a19">KDTree</a> (const MeshType &amp;m) -&gt; <a class="el" href="classvcl_1_1KDTree.html">KDTree</a>&lt; typename MeshType::VertexType::CoordType &gt;</td></tr>
<tr class="separator:ab7606be147f292f38e1e22a709708a19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1ec171b583b3872ae8b1b5e6a513b49"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ab1ec171b583b3872ae8b1b5e6a513b49"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ab1ec171b583b3872ae8b1b5e6a513b49">KDTree</a> (const MeshType &amp;m, <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> pointsPerCell) -&gt; <a class="el" href="classvcl_1_1KDTree.html">KDTree</a>&lt; typename MeshType::VertexType::CoordType &gt;</td></tr>
<tr class="separator:ab1ec171b583b3872ae8b1b5e6a513b49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5c4a6423ece2f30e5d81a3f5b0026b9"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ae5c4a6423ece2f30e5d81a3f5b0026b9"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ae5c4a6423ece2f30e5d81a3f5b0026b9">KDTree</a> (const MeshType &amp;m, <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> pointsPerCell, <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> maxDepth) -&gt; <a class="el" href="classvcl_1_1KDTree.html">KDTree</a>&lt; typename MeshType::VertexType::CoordType &gt;</td></tr>
<tr class="separator:ae5c4a6423ece2f30e5d81a3f5b0026b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9e8e92d81c40489de3567c10b3db44c"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ae9e8e92d81c40489de3567c10b3db44c"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ae9e8e92d81c40489de3567c10b3db44c">KDTree</a> (const MeshType &amp;m, <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> pointsPerCell, <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> maxDepth, bool balanced) -&gt; <a class="el" href="classvcl_1_1KDTree.html">KDTree</a>&lt; typename MeshType::VertexType::CoordType &gt;</td></tr>
<tr class="separator:ae9e8e92d81c40489de3567c10b3db44c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25bd91133ba21843329a21218fa52069"><td class="memTemplParams" colspan="2">template&lt;EigenMatrixConcept MatrixType, PointConcept PointType&gt; <br />
requires ( MatrixType::RowsAtCompileTime == PointType::DIM &amp;&amp; MatrixType::ColsAtCompileTime == PointType::DIM)</td></tr>
<tr class="memitem:a25bd91133ba21843329a21218fa52069"><td class="memTemplItemLeft" align="right" valign="top">PointType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a25bd91133ba21843329a21218fa52069">operator*</a> (const MatrixType &amp;m, const PointType &amp;p)</td></tr>
<tr class="memdesc:a25bd91133ba21843329a21218fa52069"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies a matrix and a point.  <br /></td></tr>
<tr class="separator:a25bd91133ba21843329a21218fa52069"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2b5fc956b8e7b0ed2fe7f1846a6a74d"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> N&gt; </td></tr>
<tr class="memitem:aa2b5fc956b8e7b0ed2fe7f1846a6a74d"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#aa2b5fc956b8e7b0ed2fe7f1846a6a74d">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classvcl_1_1Point.html">Point</a>&lt; Scalar, N &gt; &amp;p1)</td></tr>
<tr class="memdesc:aa2b5fc956b8e7b0ed2fe7f1846a6a74d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes this point to an output stream.  <br /></td></tr>
<tr class="separator:aa2b5fc956b8e7b0ed2fe7f1846a6a74d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf860b9816e4dc7fc87d0bf27aaa0670"><td class="memTemplParams" colspan="2">template&lt;typename S , typename... Scalars&gt; </td></tr>
<tr class="memitem:aaf860b9816e4dc7fc87d0bf27aaa0670"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#aaf860b9816e4dc7fc87d0bf27aaa0670">Point</a> (S, Scalars... scalars) -&gt; <a class="el" href="classvcl_1_1Point.html">Point</a>&lt; S, sizeof...(Scalars)+1 &gt;</td></tr>
<tr class="separator:aaf860b9816e4dc7fc87d0bf27aaa0670"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a1a624c7abe7c703618b7f512c33039"><td class="memTemplParams" colspan="2">template&lt;Point3Concept P, typename T &gt; </td></tr>
<tr class="memitem:a0a1a624c7abe7c703618b7f512c33039"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a0a1a624c7abe7c703618b7f512c33039">Sphere</a> (P, T) -&gt; <a class="el" href="classvcl_1_1Sphere.html">Sphere</a>&lt; typename P::ScalarType &gt;</td></tr>
<tr class="separator:a0a1a624c7abe7c703618b7f512c33039"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a901098c9caa8ff551547adb1e555c159"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a901098c9caa8ff551547adb1e555c159"><td class="memTemplItemLeft" align="right" valign="top">constexpr T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a901098c9caa8ff551547adb1e555c159">asConst</a> (T const &amp;value) noexcept</td></tr>
<tr class="separator:a901098c9caa8ff551547adb1e555c159"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69ab9dde7c49bdb94779a3f1068bed6d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a69ab9dde7c49bdb94779a3f1068bed6d"><td class="memTemplItemLeft" align="right" valign="top">constexpr T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a69ab9dde7c49bdb94779a3f1068bed6d">asConst</a> (T const *value) noexcept</td></tr>
<tr class="separator:a69ab9dde7c49bdb94779a3f1068bed6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe5c457181ae725f99627c541993a3a8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:abe5c457181ae725f99627c541993a3a8"><td class="memTemplItemLeft" align="right" valign="top">constexpr T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#abe5c457181ae725f99627c541993a3a8">asConst</a> (T *value) noexcept</td></tr>
<tr class="separator:abe5c457181ae725f99627c541993a3a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade7f012cfff33f3713171b1352d876fe"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ade7f012cfff33f3713171b1352d876fe"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ade7f012cfff33f3713171b1352d876fe">asConst</a> (T const &amp;&amp;)=delete</td></tr>
<tr class="separator:ade7f012cfff33f3713171b1352d876fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae01694fdca8b252384be3296f82fa946"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename... Us&gt; </td></tr>
<tr class="memitem:ae01694fdca8b252384be3296f82fa946"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ae01694fdca8b252384be3296f82fa946">indexInTypePack</a> ()</td></tr>
<tr class="separator:ae01694fdca8b252384be3296f82fa946"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga3377e3c875ec245e90ac5a395105ce99"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classvcl_1_1NullLogger.html">NullLogger</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__miscellaneous.html#ga3377e3c875ec245e90ac5a395105ce99">nullLogger</a></td></tr>
<tr class="memdesc:ga3377e3c875ec245e90ac5a395105ce99"><td class="mdescLeft">&#160;</td><td class="mdescRight">The static nullLogger object is an object of type <a class="el" href="classvcl_1_1NullLogger.html" title="The NullLogger class is an empty class that is used as default type in all the library functions that...">NullLogger</a> that is used as default argument in the functions that can take as input a logger.  <br /></td></tr>
<tr class="separator:ga3377e3c875ec245e90ac5a395105ce99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a519b68bed74d2385e33a29e725601002"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a519b68bed74d2385e33a29e725601002">UINT_NULL</a> = std::numeric_limits&lt;<a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a>&gt;<a class="el" href="namespacevcl.html#a69cc63a5ad2974d082145ed1dee7846b">::max</a>()</td></tr>
<tr class="separator:a519b68bed74d2385e33a29e725601002"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ad892770b57d7187fe007fc5c7b8e28c6" name="ad892770b57d7187fe007fc5c7b8e28c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad892770b57d7187fe007fc5c7b8e28c6">&#9670;&#160;</a></span>Box2</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename S &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevcl.html#ad892770b57d7187fe007fc5c7b8e28c6">vcl::Box2</a> = typedef <a class="el" href="classvcl_1_1Box.html">Box</a>&lt;<a class="el" href="group__space.html#ga6d15a5d1bc87330938ae9b8a55373334">Point2</a>&lt;S&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a77d7b12e8258d508469b505f056917f1" name="a77d7b12e8258d508469b505f056917f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77d7b12e8258d508469b505f056917f1">&#9670;&#160;</a></span>Box2d</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevcl.html#a77d7b12e8258d508469b505f056917f1">vcl::Box2d</a> = typedef <a class="el" href="classvcl_1_1Box.html">Box</a>&lt;<a class="el" href="group__space.html#ga4b02e85ff4d51fe7d689f8dd0e87ecd5">Point2d</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae6dc1589c361fc5f1b6444b74aae377d" name="ae6dc1589c361fc5f1b6444b74aae377d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6dc1589c361fc5f1b6444b74aae377d">&#9670;&#160;</a></span>Box2f</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevcl.html#ae6dc1589c361fc5f1b6444b74aae377d">vcl::Box2f</a> = typedef <a class="el" href="classvcl_1_1Box.html">Box</a>&lt;<a class="el" href="group__space.html#gac9560ad588438ce539ec3fdc5658746a">Point2f</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a43d66b66fa1219da110325fc3c9020f9" name="a43d66b66fa1219da110325fc3c9020f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43d66b66fa1219da110325fc3c9020f9">&#9670;&#160;</a></span>Box2i</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevcl.html#a43d66b66fa1219da110325fc3c9020f9">vcl::Box2i</a> = typedef <a class="el" href="classvcl_1_1Box.html">Box</a>&lt;<a class="el" href="group__space.html#ga94bdb300286f9b4bf31987102e011f8d">Point2i</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6539e58b4183d50e78e631047cd7ad12" name="a6539e58b4183d50e78e631047cd7ad12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6539e58b4183d50e78e631047cd7ad12">&#9670;&#160;</a></span>Box3</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename S &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevcl.html#a6539e58b4183d50e78e631047cd7ad12">vcl::Box3</a> = typedef <a class="el" href="classvcl_1_1Box.html">Box</a>&lt;<a class="el" href="group__space.html#ga13f2718b0763def563b8bd9f65982833">Point3</a>&lt;S&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4d5a81b5a74bca25157b2bf0de2c3f6d" name="a4d5a81b5a74bca25157b2bf0de2c3f6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d5a81b5a74bca25157b2bf0de2c3f6d">&#9670;&#160;</a></span>Box3d</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevcl.html#a4d5a81b5a74bca25157b2bf0de2c3f6d">vcl::Box3d</a> = typedef <a class="el" href="classvcl_1_1Box.html">Box</a>&lt;<a class="el" href="group__space.html#gabb47c1364fb2fe1464a54417684f011e">Point3d</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad03a804ee48eb9b3cd5aaf47f7641b3f" name="ad03a804ee48eb9b3cd5aaf47f7641b3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad03a804ee48eb9b3cd5aaf47f7641b3f">&#9670;&#160;</a></span>Box3f</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevcl.html#ad03a804ee48eb9b3cd5aaf47f7641b3f">vcl::Box3f</a> = typedef <a class="el" href="classvcl_1_1Box.html">Box</a>&lt;<a class="el" href="group__space.html#gae19b0e9639a4f90c91e46910ee66f54c">Point3f</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a84825556201de0537b996b08d1f8aeca" name="a84825556201de0537b996b08d1f8aeca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84825556201de0537b996b08d1f8aeca">&#9670;&#160;</a></span>Box3i</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevcl.html#a84825556201de0537b996b08d1f8aeca">vcl::Box3i</a> = typedef <a class="el" href="classvcl_1_1Box.html">Box</a>&lt;<a class="el" href="group__space.html#ga54b0dffe79fabd0458fc78332c91e73a">Point3i</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae166b0242a891e25bde6507bf6776730" name="ae166b0242a891e25bde6507bf6776730"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae166b0242a891e25bde6507bf6776730">&#9670;&#160;</a></span>ConstCustomComponentVectorHandle</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevcl.html#ae166b0242a891e25bde6507bf6776730">vcl::ConstCustomComponentVectorHandle</a> = typedef <a class="el" href="classvcl_1_1CustomComponentVectorHandle.html">CustomComponentVectorHandle</a>&lt;const T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a70592efcf2670361a337c528b34e4dfb" name="a70592efcf2670361a337c528b34e4dfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70592efcf2670361a337c528b34e4dfb">&#9670;&#160;</a></span>ConstEdgeAdjFaceIterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FaceType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevcl.html#a70592efcf2670361a337c528b34e4dfb">vcl::ConstEdgeAdjFaceIterator</a> = typedef <a class="el" href="classvcl_1_1EdgeAdjFaceIterator.html">EdgeAdjFaceIterator</a>&lt;FaceType, true&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa909fb65065f7aa1f08e7ae17265653d" name="aa909fb65065f7aa1f08e7ae17265653d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa909fb65065f7aa1f08e7ae17265653d">&#9670;&#160;</a></span>ConstElementContainerIterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename, typename... &gt; typename Container, typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevcl.html#aa909fb65065f7aa1f08e7ae17265653d">vcl::ConstElementContainerIterator</a> = typedef <a class="el" href="classvcl_1_1ElementContainerIterator.html">ElementContainerIterator</a>&lt;Container, T, true&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa9e13c65969a1fb0988d3e57b39fd6d6" name="aa9e13c65969a1fb0988d3e57b39fd6d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9e13c65969a1fb0988d3e57b39fd6d6">&#9670;&#160;</a></span>ConstFaceAdjFaceIterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classvcl_1_1HalfEdge.html">HalfEdge</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevcl.html#aa9e13c65969a1fb0988d3e57b39fd6d6">vcl::ConstFaceAdjFaceIterator</a> = typedef <a class="el" href="classvcl_1_1FaceAdjFaceIterator.html">FaceAdjFaceIterator</a>&lt;<a class="el" href="classvcl_1_1HalfEdge.html">HalfEdge</a>, true&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0fbff3665ba9d9fb30e0136ff2fb7be5" name="a0fbff3665ba9d9fb30e0136ff2fb7be5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fbff3665ba9d9fb30e0136ff2fb7be5">&#9670;&#160;</a></span>ConstFaceHalfEdgeIterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classvcl_1_1HalfEdge.html">HalfEdge</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevcl.html#a0fbff3665ba9d9fb30e0136ff2fb7be5">vcl::ConstFaceHalfEdgeIterator</a> = typedef <a class="el" href="classvcl_1_1FaceHalfEdgeIterator.html">FaceHalfEdgeIterator</a>&lt;<a class="el" href="classvcl_1_1HalfEdge.html">HalfEdge</a>, true&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aee598e2468f5d7b8d92ed2e84e5c6c84" name="aee598e2468f5d7b8d92ed2e84e5c6c84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee598e2468f5d7b8d92ed2e84e5c6c84">&#9670;&#160;</a></span>ConstFaceVertexIterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classvcl_1_1HalfEdge.html">HalfEdge</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevcl.html#aee598e2468f5d7b8d92ed2e84e5c6c84">vcl::ConstFaceVertexIterator</a> = typedef <a class="el" href="classvcl_1_1FaceVertexIterator.html">FaceVertexIterator</a>&lt;<a class="el" href="classvcl_1_1HalfEdge.html">HalfEdge</a>, true&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a264298bf74423f379fc8f84de9b9027b" name="a264298bf74423f379fc8f84de9b9027b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a264298bf74423f379fc8f84de9b9027b">&#9670;&#160;</a></span>ConstFaceWedgeColorIterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classvcl_1_1HalfEdge.html">HalfEdge</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevcl.html#a264298bf74423f379fc8f84de9b9027b">vcl::ConstFaceWedgeColorIterator</a> = typedef <a class="el" href="classvcl_1_1FaceWedgeColorIterator.html">FaceWedgeColorIterator</a>&lt;<a class="el" href="classvcl_1_1HalfEdge.html">HalfEdge</a>, true&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0669a8468e752c2aa2fe9a72dae4d627" name="a0669a8468e752c2aa2fe9a72dae4d627"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0669a8468e752c2aa2fe9a72dae4d627">&#9670;&#160;</a></span>ConstFaceWedgeTexCoordIterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classvcl_1_1HalfEdge.html">HalfEdge</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevcl.html#a0669a8468e752c2aa2fe9a72dae4d627">vcl::ConstFaceWedgeTexCoordIterator</a> = typedef <a class="el" href="classvcl_1_1FaceWedgeTexCoordIterator.html">FaceWedgeTexCoordIterator</a>&lt;<a class="el" href="classvcl_1_1HalfEdge.html">HalfEdge</a>, true&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2a3067a6c32d447288eb7b9adf676eab" name="a2a3067a6c32d447288eb7b9adf676eab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a3067a6c32d447288eb7b9adf676eab">&#9670;&#160;</a></span>ConstVertexAdjFaceIterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classvcl_1_1HalfEdge.html">HalfEdge</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevcl.html#a2a3067a6c32d447288eb7b9adf676eab">vcl::ConstVertexAdjFaceIterator</a> = typedef <a class="el" href="classvcl_1_1VertexAdjFaceIterator.html">VertexAdjFaceIterator</a>&lt;<a class="el" href="classvcl_1_1HalfEdge.html">HalfEdge</a>, true&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7254dafde739f74f358cae7ed67be72b" name="a7254dafde739f74f358cae7ed67be72b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7254dafde739f74f358cae7ed67be72b">&#9670;&#160;</a></span>ConstVertexAdjVertexIterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classvcl_1_1HalfEdge.html">HalfEdge</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevcl.html#a7254dafde739f74f358cae7ed67be72b">vcl::ConstVertexAdjVertexIterator</a> = typedef <a class="el" href="classvcl_1_1VertexAdjVertexIterator.html">VertexAdjVertexIterator</a>&lt;<a class="el" href="classvcl_1_1HalfEdge.html">HalfEdge</a>, true&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af12c15595ec95998920b3ded3c1a8dbf" name="af12c15595ec95998920b3ded3c1a8dbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af12c15595ec95998920b3ded3c1a8dbf">&#9670;&#160;</a></span>ConstVertexSampler</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;VertexConcept VertexType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevcl.html#af12c15595ec95998920b3ded3c1a8dbf">vcl::ConstVertexSampler</a> = typedef internal::VertexSampler&lt;VertexType, true&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a971ea4057050d3c55edb477acc8bb869" name="a971ea4057050d3c55edb477acc8bb869"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a971ea4057050d3c55edb477acc8bb869">&#9670;&#160;</a></span>DcelMesh</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevcl.html#a971ea4057050d3c55edb477acc8bb869">vcl::DcelMesh</a> = typedef <a class="el" href="classvcl_1_1DcelMeshT.html">DcelMeshT</a>&lt;double&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6a298206ce188e9698fc3e5fcd15c20e" name="a6a298206ce188e9698fc3e5fcd15c20e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a298206ce188e9698fc3e5fcd15c20e">&#9670;&#160;</a></span>DcelMeshf</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevcl.html#a6a298206ce188e9698fc3e5fcd15c20e">vcl::DcelMeshf</a> = typedef <a class="el" href="classvcl_1_1DcelMeshT.html">DcelMeshT</a>&lt;float&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aadd5d4f0adc881097d2c62b003a449cc" name="aadd5d4f0adc881097d2c62b003a449cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadd5d4f0adc881097d2c62b003a449cc">&#9670;&#160;</a></span>EdgeMesh</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevcl.html#aadd5d4f0adc881097d2c62b003a449cc">vcl::EdgeMesh</a> = typedef <a class="el" href="classvcl_1_1EdgeMeshT.html">EdgeMeshT</a>&lt;double&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acbb0bc2af8032a1d07969e3785645a9c" name="acbb0bc2af8032a1d07969e3785645a9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbb0bc2af8032a1d07969e3785645a9c">&#9670;&#160;</a></span>EdgeMeshf</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevcl.html#acbb0bc2af8032a1d07969e3785645a9c">vcl::EdgeMeshf</a> = typedef <a class="el" href="classvcl_1_1EdgeMeshT.html">EdgeMeshT</a>&lt;float&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a85b2f3d72f837560dc3dac7b128dd286" name="a85b2f3d72f837560dc3dac7b128dd286"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85b2f3d72f837560dc3dac7b128dd286">&#9670;&#160;</a></span>HashTableGrid2</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename ScalarType  = double, bool AllowDuplicates = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevcl.html#a85b2f3d72f837560dc3dac7b128dd286">vcl::HashTableGrid2</a> = typedef <a class="el" href="classvcl_1_1HashTableGrid.html">HashTableGrid</a>&lt;<a class="el" href="namespacevcl.html#acf35775c9f8314906299b1b19f6c5f9b">RegularGrid2</a>&lt;ScalarType&gt;, ValueType, AllowDuplicates&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4258b9247c46311b39535faa3c2cfaa7" name="a4258b9247c46311b39535faa3c2cfaa7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4258b9247c46311b39535faa3c2cfaa7">&#9670;&#160;</a></span>HashTableGrid3</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename ScalarType  = double, bool AllowDuplicates = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevcl.html#a4258b9247c46311b39535faa3c2cfaa7">vcl::HashTableGrid3</a> = typedef <a class="el" href="classvcl_1_1HashTableGrid.html">HashTableGrid</a>&lt;<a class="el" href="namespacevcl.html#a8d7cc878c7f7ccb25c576ebf7ad2df5b">RegularGrid3</a>&lt;ScalarType&gt;, ValueType, AllowDuplicates&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7eaa15c791dc5118a8eea9677c6ba9b7" name="a7eaa15c791dc5118a8eea9677c6ba9b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7eaa15c791dc5118a8eea9677c6ba9b7">&#9670;&#160;</a></span>Histogramd</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevcl.html#a7eaa15c791dc5118a8eea9677c6ba9b7">vcl::Histogramd</a> = typedef <a class="el" href="classvcl_1_1Histogram.html">Histogram</a>&lt;double&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a294d3a64b949108ec1f6381b950945e9" name="a294d3a64b949108ec1f6381b950945e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a294d3a64b949108ec1f6381b950945e9">&#9670;&#160;</a></span>Histogramf</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevcl.html#a294d3a64b949108ec1f6381b950945e9">vcl::Histogramf</a> = typedef <a class="el" href="classvcl_1_1Histogram.html">Histogram</a>&lt;float&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a05b7c68fb0aa1b6e92e4719859adc941" name="a05b7c68fb0aa1b6e92e4719859adc941"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05b7c68fb0aa1b6e92e4719859adc941">&#9670;&#160;</a></span>IsDerivedFromTemplateSpecialization</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename derived , template&lt; typename... &gt; class base&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevcl.html#a05b7c68fb0aa1b6e92e4719859adc941">vcl::IsDerivedFromTemplateSpecialization</a> = typedef typename std::invoke_result&lt; internal::IsDerivedFromImplementation&lt;base&gt;, typename std::remove_cv&lt;derived&gt;::type*&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a707bb169c4d4cafd5d84170b495721dc" name="a707bb169c4d4cafd5d84170b495721dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a707bb169c4d4cafd5d84170b495721dc">&#9670;&#160;</a></span>Matrix33</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevcl.html#a707bb169c4d4cafd5d84170b495721dc">vcl::Matrix33</a> = typedef Eigen::Matrix&lt;Scalar, 3, 3&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a21e274a73f9088730a856902ede6ee37" name="a21e274a73f9088730a856902ede6ee37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21e274a73f9088730a856902ede6ee37">&#9670;&#160;</a></span>Matrix33d</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevcl.html#a21e274a73f9088730a856902ede6ee37">vcl::Matrix33d</a> = typedef <a class="el" href="namespacevcl.html#a707bb169c4d4cafd5d84170b495721dc">Matrix33</a>&lt;double&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac96c7ac5d789e9dbf055e35fa5a24835" name="ac96c7ac5d789e9dbf055e35fa5a24835"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac96c7ac5d789e9dbf055e35fa5a24835">&#9670;&#160;</a></span>Matrix33f</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevcl.html#ac96c7ac5d789e9dbf055e35fa5a24835">vcl::Matrix33f</a> = typedef <a class="el" href="namespacevcl.html#a707bb169c4d4cafd5d84170b495721dc">Matrix33</a>&lt;float&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa2e70d03403788ee68a3f150a70d8039" name="aa2e70d03403788ee68a3f150a70d8039"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2e70d03403788ee68a3f150a70d8039">&#9670;&#160;</a></span>Matrix33i</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevcl.html#aa2e70d03403788ee68a3f150a70d8039">vcl::Matrix33i</a> = typedef <a class="el" href="namespacevcl.html#a707bb169c4d4cafd5d84170b495721dc">Matrix33</a>&lt;int&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad82a126b390f21b2e9658c73e7a795ee" name="ad82a126b390f21b2e9658c73e7a795ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad82a126b390f21b2e9658c73e7a795ee">&#9670;&#160;</a></span>Matrix44</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevcl.html#ad82a126b390f21b2e9658c73e7a795ee">vcl::Matrix44</a> = typedef Eigen::Matrix&lt;Scalar, 4, 4&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0c9537d456b6db5dc5f2216dfc8bccdc" name="a0c9537d456b6db5dc5f2216dfc8bccdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c9537d456b6db5dc5f2216dfc8bccdc">&#9670;&#160;</a></span>Matrix44d</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevcl.html#a0c9537d456b6db5dc5f2216dfc8bccdc">vcl::Matrix44d</a> = typedef <a class="el" href="namespacevcl.html#ad82a126b390f21b2e9658c73e7a795ee">Matrix44</a>&lt;double&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6891233f7166ae9569a840d151cfe140" name="a6891233f7166ae9569a840d151cfe140"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6891233f7166ae9569a840d151cfe140">&#9670;&#160;</a></span>Matrix44f</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevcl.html#a6891233f7166ae9569a840d151cfe140">vcl::Matrix44f</a> = typedef <a class="el" href="namespacevcl.html#ad82a126b390f21b2e9658c73e7a795ee">Matrix44</a>&lt;float&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af09e528e12eb6fb1fc6e596b46da8beb" name="af09e528e12eb6fb1fc6e596b46da8beb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af09e528e12eb6fb1fc6e596b46da8beb">&#9670;&#160;</a></span>Matrix44i</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevcl.html#af09e528e12eb6fb1fc6e596b46da8beb">vcl::Matrix44i</a> = typedef <a class="el" href="namespacevcl.html#ad82a126b390f21b2e9658c73e7a795ee">Matrix44</a>&lt;int&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad7449b441f4e1a24adf73b0964fb0953" name="ad7449b441f4e1a24adf73b0964fb0953"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7449b441f4e1a24adf73b0964fb0953">&#9670;&#160;</a></span>NestedInitializerLists</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t L&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevcl.html#ad7449b441f4e1a24adf73b0964fb0953">vcl::NestedInitializerLists</a> = typedef typename internal::NestedInitializerListsTraits&lt;T, L&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The NestedInitializerLists class manages nested std::initializer_list&lt;T&gt; types of L levels L must be known at compile time, and compilation will fail if the NestedInitializerLists used does not correspond to the number of used levels. </p>

</div>
</div>
<a id="a08ef90973b043cbb709bec85607f8313" name="a08ef90973b043cbb709bec85607f8313"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08ef90973b043cbb709bec85607f8313">&#9670;&#160;</a></span>Planed</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevcl.html#a08ef90973b043cbb709bec85607f8313">vcl::Planed</a> = typedef <a class="el" href="classvcl_1_1Plane.html">Plane</a>&lt;double&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6fa66e0f1a04578cf69387027e898c8d" name="a6fa66e0f1a04578cf69387027e898c8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fa66e0f1a04578cf69387027e898c8d">&#9670;&#160;</a></span>Planef</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevcl.html#a6fa66e0f1a04578cf69387027e898c8d">vcl::Planef</a> = typedef <a class="el" href="classvcl_1_1Plane.html">Plane</a>&lt;float&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab2939073dbb778a3a2f5d9f93e3fb146" name="ab2939073dbb778a3a2f5d9f93e3fb146"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2939073dbb778a3a2f5d9f93e3fb146">&#9670;&#160;</a></span>PointCloud</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevcl.html#ab2939073dbb778a3a2f5d9f93e3fb146">vcl::PointCloud</a> = typedef <a class="el" href="classvcl_1_1PointCloudT.html">PointCloudT</a>&lt;double&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae1ddd0d2b0a8168f7a6134ed53cd1f3c" name="ae1ddd0d2b0a8168f7a6134ed53cd1f3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1ddd0d2b0a8168f7a6134ed53cd1f3c">&#9670;&#160;</a></span>PointCloudf</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevcl.html#ae1ddd0d2b0a8168f7a6134ed53cd1f3c">vcl::PointCloudf</a> = typedef <a class="el" href="classvcl_1_1PointCloudT.html">PointCloudT</a>&lt;float&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a924ac7eb7740e67b7701c82f079ca13b" name="a924ac7eb7740e67b7701c82f079ca13b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a924ac7eb7740e67b7701c82f079ca13b">&#9670;&#160;</a></span>Polygon2</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevcl.html#a924ac7eb7740e67b7701c82f079ca13b">vcl::Polygon2</a> = typedef <a class="el" href="classvcl_1_1Polygon.html">Polygon</a>&lt;<a class="el" href="group__space.html#ga6d15a5d1bc87330938ae9b8a55373334">Point2</a>&lt;Scalar&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a386fd968f85ff551b4d58e109c21db9a" name="a386fd968f85ff551b4d58e109c21db9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a386fd968f85ff551b4d58e109c21db9a">&#9670;&#160;</a></span>Polygon2d</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevcl.html#a386fd968f85ff551b4d58e109c21db9a">vcl::Polygon2d</a> = typedef <a class="el" href="classvcl_1_1Polygon.html">Polygon</a>&lt;<a class="el" href="group__space.html#ga4b02e85ff4d51fe7d689f8dd0e87ecd5">Point2d</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2d13400e95eb6871c2e4f6169ef08c23" name="a2d13400e95eb6871c2e4f6169ef08c23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d13400e95eb6871c2e4f6169ef08c23">&#9670;&#160;</a></span>Polygon2f</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevcl.html#a2d13400e95eb6871c2e4f6169ef08c23">vcl::Polygon2f</a> = typedef <a class="el" href="classvcl_1_1Polygon.html">Polygon</a>&lt;<a class="el" href="group__space.html#gac9560ad588438ce539ec3fdc5658746a">Point2f</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac04b9a59a6c30f22d15b0d1932e60457" name="ac04b9a59a6c30f22d15b0d1932e60457"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac04b9a59a6c30f22d15b0d1932e60457">&#9670;&#160;</a></span>Polygon3</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevcl.html#ac04b9a59a6c30f22d15b0d1932e60457">vcl::Polygon3</a> = typedef <a class="el" href="classvcl_1_1Polygon.html">Polygon</a>&lt;<a class="el" href="group__space.html#ga13f2718b0763def563b8bd9f65982833">Point3</a>&lt;Scalar&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac010b9e655ca9ca0c32f8c61b1eb56a2" name="ac010b9e655ca9ca0c32f8c61b1eb56a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac010b9e655ca9ca0c32f8c61b1eb56a2">&#9670;&#160;</a></span>Polygon3d</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevcl.html#ac010b9e655ca9ca0c32f8c61b1eb56a2">vcl::Polygon3d</a> = typedef <a class="el" href="classvcl_1_1Polygon.html">Polygon</a>&lt;<a class="el" href="group__space.html#gabb47c1364fb2fe1464a54417684f011e">Point3d</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4a359353bfe1b3e56f12a750b2de4abc" name="a4a359353bfe1b3e56f12a750b2de4abc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a359353bfe1b3e56f12a750b2de4abc">&#9670;&#160;</a></span>Polygon3f</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevcl.html#a4a359353bfe1b3e56f12a750b2de4abc">vcl::Polygon3f</a> = typedef <a class="el" href="classvcl_1_1Polygon.html">Polygon</a>&lt;<a class="el" href="group__space.html#gae19b0e9639a4f90c91e46910ee66f54c">Point3f</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a416d891cfc10982e070d934a5ab00e7b" name="a416d891cfc10982e070d934a5ab00e7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a416d891cfc10982e070d934a5ab00e7b">&#9670;&#160;</a></span>PolyMesh</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevcl.html#a416d891cfc10982e070d934a5ab00e7b">vcl::PolyMesh</a> = typedef <a class="el" href="classvcl_1_1PolyMeshT.html">PolyMeshT</a>&lt;double&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="adde03ea7837ce8e0d2e4e5aef04a1792" name="adde03ea7837ce8e0d2e4e5aef04a1792"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adde03ea7837ce8e0d2e4e5aef04a1792">&#9670;&#160;</a></span>PolyMeshf</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevcl.html#adde03ea7837ce8e0d2e4e5aef04a1792">vcl::PolyMeshf</a> = typedef <a class="el" href="classvcl_1_1PolyMeshT.html">PolyMeshT</a>&lt;float&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acf35775c9f8314906299b1b19f6c5f9b" name="acf35775c9f8314906299b1b19f6c5f9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf35775c9f8314906299b1b19f6c5f9b">&#9670;&#160;</a></span>RegularGrid2</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevcl.html#acf35775c9f8314906299b1b19f6c5f9b">vcl::RegularGrid2</a> = typedef <a class="el" href="classvcl_1_1RegularGrid.html">RegularGrid</a>&lt;Scalar, 2&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8d7cc878c7f7ccb25c576ebf7ad2df5b" name="a8d7cc878c7f7ccb25c576ebf7ad2df5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d7cc878c7f7ccb25c576ebf7ad2df5b">&#9670;&#160;</a></span>RegularGrid3</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevcl.html#a8d7cc878c7f7ccb25c576ebf7ad2df5b">vcl::RegularGrid3</a> = typedef <a class="el" href="classvcl_1_1RegularGrid.html">RegularGrid</a>&lt;Scalar, 3&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a665881ae7f71a35814e41147c4bcd417" name="a665881ae7f71a35814e41147c4bcd417"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a665881ae7f71a35814e41147c4bcd417">&#9670;&#160;</a></span>RemoveConstPointer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevcl.html#a665881ae7f71a35814e41147c4bcd417">vcl::RemoveConstPointer</a> = typedef std::conditional_t&lt;std::is_pointer_v&lt;T&gt;, std::add_pointer_t&lt;typename std::remove_cv_t&lt;typename std::remove_pointer_t&lt;T&gt; &gt;&gt;, T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6f737a463fe0a1daa8f1c21c96cb4ff5" name="a6f737a463fe0a1daa8f1c21c96cb4ff5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f737a463fe0a1daa8f1c21c96cb4ff5">&#9670;&#160;</a></span>RemoveConstRef</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevcl.html#a6f737a463fe0a1daa8f1c21c96cb4ff5">vcl::RemoveConstRef</a> = typedef typename std::remove_const_t&lt;std::remove_reference_t&lt;T&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a997ae3296c55d244ddd31c5037ca4a7b" name="a997ae3296c55d244ddd31c5037ca4a7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a997ae3296c55d244ddd31c5037ca4a7b">&#9670;&#160;</a></span>RemoveRefAndPointer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevcl.html#a997ae3296c55d244ddd31c5037ca4a7b">vcl::RemoveRefAndPointer</a> = typedef typename std::remove_pointer_t&lt;typename std::remove_reference_t&lt;T&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af8c7ce5479499796837976d3247e4df8" name="af8c7ce5479499796837976d3247e4df8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8c7ce5479499796837976d3247e4df8">&#9670;&#160;</a></span>Segment2</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename S &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevcl.html#af8c7ce5479499796837976d3247e4df8">vcl::Segment2</a> = typedef <a class="el" href="classvcl_1_1Segment.html">Segment</a>&lt;<a class="el" href="group__space.html#ga6d15a5d1bc87330938ae9b8a55373334">Point2</a>&lt;S&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae5da8472ea5b5275ab7109e52d50af04" name="ae5da8472ea5b5275ab7109e52d50af04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5da8472ea5b5275ab7109e52d50af04">&#9670;&#160;</a></span>Segment2d</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevcl.html#ae5da8472ea5b5275ab7109e52d50af04">vcl::Segment2d</a> = typedef <a class="el" href="classvcl_1_1Segment.html">Segment</a>&lt;<a class="el" href="group__space.html#ga4b02e85ff4d51fe7d689f8dd0e87ecd5">Point2d</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a83dc041e1243c07111706a89433af7a9" name="a83dc041e1243c07111706a89433af7a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83dc041e1243c07111706a89433af7a9">&#9670;&#160;</a></span>Segment2f</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevcl.html#a83dc041e1243c07111706a89433af7a9">vcl::Segment2f</a> = typedef <a class="el" href="classvcl_1_1Segment.html">Segment</a>&lt;<a class="el" href="group__space.html#gac9560ad588438ce539ec3fdc5658746a">Point2f</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9ca08e736f7887a86fa4fc2dd396cdc5" name="a9ca08e736f7887a86fa4fc2dd396cdc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ca08e736f7887a86fa4fc2dd396cdc5">&#9670;&#160;</a></span>Segment2i</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevcl.html#a9ca08e736f7887a86fa4fc2dd396cdc5">vcl::Segment2i</a> = typedef <a class="el" href="classvcl_1_1Segment.html">Segment</a>&lt;<a class="el" href="group__space.html#ga94bdb300286f9b4bf31987102e011f8d">Point2i</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afc9c518fdcc207d621776ebeeedc0db5" name="afc9c518fdcc207d621776ebeeedc0db5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc9c518fdcc207d621776ebeeedc0db5">&#9670;&#160;</a></span>Segment3</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename S &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevcl.html#afc9c518fdcc207d621776ebeeedc0db5">vcl::Segment3</a> = typedef <a class="el" href="classvcl_1_1Segment.html">Segment</a>&lt;<a class="el" href="group__space.html#ga13f2718b0763def563b8bd9f65982833">Point3</a>&lt;S&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a77d6ff7d119b08bd6bc8d5e84b9fe2ec" name="a77d6ff7d119b08bd6bc8d5e84b9fe2ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77d6ff7d119b08bd6bc8d5e84b9fe2ec">&#9670;&#160;</a></span>Segment3d</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevcl.html#a77d6ff7d119b08bd6bc8d5e84b9fe2ec">vcl::Segment3d</a> = typedef <a class="el" href="classvcl_1_1Segment.html">Segment</a>&lt;<a class="el" href="group__space.html#gabb47c1364fb2fe1464a54417684f011e">Point3d</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a01b4f12a5cd0b2470b2abcd9890f1de1" name="a01b4f12a5cd0b2470b2abcd9890f1de1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01b4f12a5cd0b2470b2abcd9890f1de1">&#9670;&#160;</a></span>Segment3f</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevcl.html#a01b4f12a5cd0b2470b2abcd9890f1de1">vcl::Segment3f</a> = typedef <a class="el" href="classvcl_1_1Segment.html">Segment</a>&lt;<a class="el" href="group__space.html#gae19b0e9639a4f90c91e46910ee66f54c">Point3f</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0694142b42086cf347becff6f0db0c9c" name="a0694142b42086cf347becff6f0db0c9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0694142b42086cf347becff6f0db0c9c">&#9670;&#160;</a></span>Segment3i</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevcl.html#a0694142b42086cf347becff6f0db0c9c">vcl::Segment3i</a> = typedef <a class="el" href="classvcl_1_1Segment.html">Segment</a>&lt;<a class="el" href="group__space.html#ga54b0dffe79fabd0458fc78332c91e73a">Point3i</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a125a3b42c101ab958048c730060aa8c8" name="a125a3b42c101ab958048c730060aa8c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a125a3b42c101ab958048c730060aa8c8">&#9670;&#160;</a></span>Sphered</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevcl.html#a125a3b42c101ab958048c730060aa8c8">vcl::Sphered</a> = typedef <a class="el" href="classvcl_1_1Sphere.html">Sphere</a>&lt;double&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a918b0af3e76ff4b82da382ddfab126d0" name="a918b0af3e76ff4b82da382ddfab126d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a918b0af3e76ff4b82da382ddfab126d0">&#9670;&#160;</a></span>Spheref</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevcl.html#a918b0af3e76ff4b82da382ddfab126d0">vcl::Spheref</a> = typedef <a class="el" href="classvcl_1_1Sphere.html">Sphere</a>&lt;float&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2bbbace04824cfa901027d8e90d830c6" name="a2bbbace04824cfa901027d8e90d830c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bbbace04824cfa901027d8e90d830c6">&#9670;&#160;</a></span>StaticGrid2</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename ScalarType  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevcl.html#a2bbbace04824cfa901027d8e90d830c6">vcl::StaticGrid2</a> = typedef <a class="el" href="classvcl_1_1StaticGrid.html">StaticGrid</a>&lt;<a class="el" href="namespacevcl.html#acf35775c9f8314906299b1b19f6c5f9b">RegularGrid2</a>&lt;ScalarType&gt;, ValueType&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afa27c3398ca14cd8a5a7e1423d7a68cd" name="afa27c3398ca14cd8a5a7e1423d7a68cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa27c3398ca14cd8a5a7e1423d7a68cd">&#9670;&#160;</a></span>StaticGrid3</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename ScalarType  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevcl.html#afa27c3398ca14cd8a5a7e1423d7a68cd">vcl::StaticGrid3</a> = typedef <a class="el" href="classvcl_1_1StaticGrid.html">StaticGrid</a>&lt;<a class="el" href="namespacevcl.html#a8d7cc878c7f7ccb25c576ebf7ad2df5b">RegularGrid3</a>&lt;ScalarType&gt;, ValueType&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aec42e251f09249cda2fe0463b81c0f79" name="aec42e251f09249cda2fe0463b81c0f79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec42e251f09249cda2fe0463b81c0f79">&#9670;&#160;</a></span>TexCoordd</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevcl.html#aec42e251f09249cda2fe0463b81c0f79">vcl::TexCoordd</a> = typedef <a class="el" href="classvcl_1_1TexCoord.html">TexCoord</a>&lt;double&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6ccd8e32ef2f6bf0decb43463f41fb2b" name="a6ccd8e32ef2f6bf0decb43463f41fb2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ccd8e32ef2f6bf0decb43463f41fb2b">&#9670;&#160;</a></span>TexCoordf</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevcl.html#a6ccd8e32ef2f6bf0decb43463f41fb2b">vcl::TexCoordf</a> = typedef <a class="el" href="classvcl_1_1TexCoord.html">TexCoord</a>&lt;float&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a917984925513fc8634c94e269ee0cf82" name="a917984925513fc8634c94e269ee0cf82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a917984925513fc8634c94e269ee0cf82">&#9670;&#160;</a></span>TexCoordi</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevcl.html#a917984925513fc8634c94e269ee0cf82">vcl::TexCoordi</a> = typedef <a class="el" href="classvcl_1_1TexCoord.html">TexCoord</a>&lt;int&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aac0ef38a541827b51057bfae9e8c5039" name="aac0ef38a541827b51057bfae9e8c5039"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac0ef38a541827b51057bfae9e8c5039">&#9670;&#160;</a></span>Triangle2</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevcl.html#aac0ef38a541827b51057bfae9e8c5039">vcl::Triangle2</a> = typedef <a class="el" href="classvcl_1_1Triangle.html">Triangle</a>&lt;<a class="el" href="group__space.html#ga6d15a5d1bc87330938ae9b8a55373334">Point2</a>&lt;Scalar&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8e9344ae874797a2a653deab133d870f" name="a8e9344ae874797a2a653deab133d870f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e9344ae874797a2a653deab133d870f">&#9670;&#160;</a></span>Triangle2d</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevcl.html#a8e9344ae874797a2a653deab133d870f">vcl::Triangle2d</a> = typedef <a class="el" href="classvcl_1_1Triangle.html">Triangle</a>&lt;<a class="el" href="group__space.html#ga4b02e85ff4d51fe7d689f8dd0e87ecd5">Point2d</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad1f6b217d733de32db193f0e751ece25" name="ad1f6b217d733de32db193f0e751ece25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1f6b217d733de32db193f0e751ece25">&#9670;&#160;</a></span>Triangle2f</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevcl.html#ad1f6b217d733de32db193f0e751ece25">vcl::Triangle2f</a> = typedef <a class="el" href="classvcl_1_1Triangle.html">Triangle</a>&lt;<a class="el" href="group__space.html#gac9560ad588438ce539ec3fdc5658746a">Point2f</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae03921c36e8b060269d9ff90b068db39" name="ae03921c36e8b060269d9ff90b068db39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae03921c36e8b060269d9ff90b068db39">&#9670;&#160;</a></span>Triangle3</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevcl.html#ae03921c36e8b060269d9ff90b068db39">vcl::Triangle3</a> = typedef <a class="el" href="classvcl_1_1Triangle.html">Triangle</a>&lt;<a class="el" href="group__space.html#ga13f2718b0763def563b8bd9f65982833">Point3</a>&lt;Scalar&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a02db1e7fb252318c4435c8ca9944401e" name="a02db1e7fb252318c4435c8ca9944401e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02db1e7fb252318c4435c8ca9944401e">&#9670;&#160;</a></span>Triangle3d</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevcl.html#a02db1e7fb252318c4435c8ca9944401e">vcl::Triangle3d</a> = typedef <a class="el" href="classvcl_1_1Triangle.html">Triangle</a>&lt;<a class="el" href="group__space.html#gabb47c1364fb2fe1464a54417684f011e">Point3d</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afa2a67863f5edd83d508344306bd7bb3" name="afa2a67863f5edd83d508344306bd7bb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa2a67863f5edd83d508344306bd7bb3">&#9670;&#160;</a></span>Triangle3f</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevcl.html#afa2a67863f5edd83d508344306bd7bb3">vcl::Triangle3f</a> = typedef <a class="el" href="classvcl_1_1Triangle.html">Triangle</a>&lt;<a class="el" href="group__space.html#gae19b0e9639a4f90c91e46910ee66f54c">Point3f</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a92c93a12005e031d04c92971247414ef" name="a92c93a12005e031d04c92971247414ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92c93a12005e031d04c92971247414ef">&#9670;&#160;</a></span>TriangleWrapper2</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevcl.html#a92c93a12005e031d04c92971247414ef">vcl::TriangleWrapper2</a> = typedef <a class="el" href="classvcl_1_1TriangleWrapper.html">TriangleWrapper</a>&lt;<a class="el" href="group__space.html#ga6d15a5d1bc87330938ae9b8a55373334">Point2</a>&lt;Scalar&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a27931fc2ea467c03c1019dc025d218e5" name="a27931fc2ea467c03c1019dc025d218e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27931fc2ea467c03c1019dc025d218e5">&#9670;&#160;</a></span>TriangleWrapper2d</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevcl.html#a27931fc2ea467c03c1019dc025d218e5">vcl::TriangleWrapper2d</a> = typedef <a class="el" href="classvcl_1_1TriangleWrapper.html">TriangleWrapper</a>&lt;<a class="el" href="group__space.html#ga4b02e85ff4d51fe7d689f8dd0e87ecd5">Point2d</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5ff16ee6b33f9bdd47405cb91f29e2d0" name="a5ff16ee6b33f9bdd47405cb91f29e2d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ff16ee6b33f9bdd47405cb91f29e2d0">&#9670;&#160;</a></span>TriangleWrapper2f</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevcl.html#a5ff16ee6b33f9bdd47405cb91f29e2d0">vcl::TriangleWrapper2f</a> = typedef <a class="el" href="classvcl_1_1TriangleWrapper.html">TriangleWrapper</a>&lt;<a class="el" href="group__space.html#gac9560ad588438ce539ec3fdc5658746a">Point2f</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a439efbe438907a52943d563d8a12daab" name="a439efbe438907a52943d563d8a12daab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a439efbe438907a52943d563d8a12daab">&#9670;&#160;</a></span>TriangleWrapper3</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevcl.html#a439efbe438907a52943d563d8a12daab">vcl::TriangleWrapper3</a> = typedef <a class="el" href="classvcl_1_1TriangleWrapper.html">TriangleWrapper</a>&lt;<a class="el" href="group__space.html#ga13f2718b0763def563b8bd9f65982833">Point3</a>&lt;Scalar&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ace2761031333634f83908ed3d4e5fb19" name="ace2761031333634f83908ed3d4e5fb19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace2761031333634f83908ed3d4e5fb19">&#9670;&#160;</a></span>TriangleWrapper3d</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevcl.html#ace2761031333634f83908ed3d4e5fb19">vcl::TriangleWrapper3d</a> = typedef <a class="el" href="classvcl_1_1TriangleWrapper.html">TriangleWrapper</a>&lt;<a class="el" href="group__space.html#gabb47c1364fb2fe1464a54417684f011e">Point3d</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a295b4c2f1ffcf361e32166b44a5a4476" name="a295b4c2f1ffcf361e32166b44a5a4476"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a295b4c2f1ffcf361e32166b44a5a4476">&#9670;&#160;</a></span>TriangleWrapper3f</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevcl.html#a295b4c2f1ffcf361e32166b44a5a4476">vcl::TriangleWrapper3f</a> = typedef <a class="el" href="classvcl_1_1TriangleWrapper.html">TriangleWrapper</a>&lt;<a class="el" href="group__space.html#gae19b0e9639a4f90c91e46910ee66f54c">Point3f</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2cb93e7b8a1ccd33f76ba2d53ef9ecfa" name="a2cb93e7b8a1ccd33f76ba2d53ef9ecfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cb93e7b8a1ccd33f76ba2d53ef9ecfa">&#9670;&#160;</a></span>VertexSampler</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;VertexConcept VertexType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevcl.html#a2cb93e7b8a1ccd33f76ba2d53ef9ecfa">vcl::VertexSampler</a> = typedef internal::VertexSampler&lt;VertexType, false&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a64e691de6b710b9fd1dc3d5db66a6f7a" name="a64e691de6b710b9fd1dc3d5db66a6f7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64e691de6b710b9fd1dc3d5db66a6f7a">&#9670;&#160;</a></span>ElementEnumType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacevcl.html#a64e691de6b710b9fd1dc3d5db66a6f7a">vcl::ElementEnumType</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a64e691de6b710b9fd1dc3d5db66a6f7aa2b976bb23bc172fe0c729ce8f367b76e" name="a64e691de6b710b9fd1dc3d5db66a6f7aa2b976bb23bc172fe0c729ce8f367b76e"></a>VERTEX&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a64e691de6b710b9fd1dc3d5db66a6f7aa0deacef785932de145d594f20e312b58" name="a64e691de6b710b9fd1dc3d5db66a6f7aa0deacef785932de145d594f20e312b58"></a>FACE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a64e691de6b710b9fd1dc3d5db66a6f7aa277eb4b09247da79fe02b8a334452e67" name="a64e691de6b710b9fd1dc3d5db66a6f7aa277eb4b09247da79fe02b8a334452e67"></a>EDGE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a64e691de6b710b9fd1dc3d5db66a6f7aabb582b413a6845c1f70f5198e603bd04" name="a64e691de6b710b9fd1dc3d5db66a6f7aabb582b413a6845c1f70f5198e603bd04"></a>HALF_EDGE&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a5a4e8376b2d47797f9167f2a8dd6fb0e" name="a5a4e8376b2d47797f9167f2a8dd6fb0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a4e8376b2d47797f9167f2a8dd6fb0e">&#9670;&#160;</a></span>HausdorffSamplingMethod</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacevcl.html#a5a4e8376b2d47797f9167f2a8dd6fb0e">vcl::HausdorffSamplingMethod</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a5a4e8376b2d47797f9167f2a8dd6fb0ea33aad0431cadce18cad82201cb732f49" name="a5a4e8376b2d47797f9167f2a8dd6fb0ea33aad0431cadce18cad82201cb732f49"></a>HAUSDORFF_VERTEX_UNIFORM&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a5a4e8376b2d47797f9167f2a8dd6fb0eac8770691ceb41b51c7ab63b70f1da9c6" name="a5a4e8376b2d47797f9167f2a8dd6fb0eac8770691ceb41b51c7ab63b70f1da9c6"></a>HAUSDORFF_EDGE_UNIFORM&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a5a4e8376b2d47797f9167f2a8dd6fb0eaf9d0153b4af81b71be3972e5a9e3307a" name="a5a4e8376b2d47797f9167f2a8dd6fb0eaf9d0153b4af81b71be3972e5a9e3307a"></a>HAUSDORFF_MONTECARLO&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="aaca879a6bfd47ff8429d6b2f6cfa9440" name="aaca879a6bfd47ff8429d6b2f6cfa9440"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaca879a6bfd47ff8429d6b2f6cfa9440">&#9670;&#160;</a></span>VCLibPrincipalCurvatureAlgorithm</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacevcl.html#aaca879a6bfd47ff8429d6b2f6cfa9440">vcl::VCLibPrincipalCurvatureAlgorithm</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aaca879a6bfd47ff8429d6b2f6cfa9440a16e818963316b0b43fcbdec6d75f25ed" name="aaca879a6bfd47ff8429d6b2f6cfa9440a16e818963316b0b43fcbdec6d75f25ed"></a>VCL_PRINCIPAL_CURVATURE_TAUBIN95&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aaca879a6bfd47ff8429d6b2f6cfa9440a2c812dad0f96c382657b60bb2d2f8180" name="aaca879a6bfd47ff8429d6b2f6cfa9440a2c812dad0f96c382657b60bb2d2f8180"></a>VCL_PRINCIPAL_CURVATURE_PCA&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a338dea159760ae814dc6e78425e284a1" name="a338dea159760ae814dc6e78425e284a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a338dea159760ae814dc6e78425e284a1">&#9670;&#160;</a></span>_check_gl_error()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vcl::_check_gl_error </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>line</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="acad48a316f6b47d2ce4fa978be50a97e" name="acad48a316f6b47d2ce4fa978be50a97e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acad48a316f6b47d2ce4fa978be50a97e">&#9670;&#160;</a></span>addTriangleFacesFromPolygon() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> vcl::addTriangleFacesFromPolygon </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>polygon</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a vector of indices of vertices in a mesh representing a polyon, this function adds N triangular faces to the mesh, that are the triangulation of the input polygon. <a class="el" href="classvcl_1_1Triangle.html">Triangle</a> edges that are internal in the polygon are marked as faux. This function returns the index of the first added triangle. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MeshType</td><td>the type of the face that satisfies the FaceMeshConcept.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">m</td><td>the mesh on which add the triangulation of the polygon. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">polygon</td><td>the vertex indices in the mesh representing the polygon. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the first triangle added to the mesh. </dd></dl>

</div>
</div>
<a id="aab5bd336ab6b6a6138f89ffbb56ef3b5" name="aab5bd336ab6b6a6138f89ffbb56ef3b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab5bd336ab6b6a6138f89ffbb56ef3b5">&#9670;&#160;</a></span>addTriangleFacesFromPolygon() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType, FaceConcept FaceType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::addTriangleFacesFromPolygon </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FaceType &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>polygon</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a vector of indices of vertices in a mesh representing a polyon, this function adds N triangular faces to the mesh, that are the triangulation of the input polygon. <a class="el" href="classvcl_1_1Triangle.html">Triangle</a> edges that are internal in the polygon are marked as faux. </p>
<p>This function assumes that the first (triangular) face has been already added to the mesh and just needs to be filled with vertex references. This is useful in some cases (e.g. when reading from file and you realize just at some point that you need to manage a polygon). In all the other cases, you should use the function that does not take a face in input, that is:</p>
<div class="fragment"><div class="line"><a class="code hl_typedef" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> fid = <a class="code hl_function" href="namespacevcl.html#aab5bd336ab6b6a6138f89ffbb56ef3b5">addTriangleFacesFromPolygon</a>(mesh, polygon);</div>
<div class="ttc" id="anamespacevcl_html_aab5bd336ab6b6a6138f89ffbb56ef3b5"><div class="ttname"><a href="namespacevcl.html#aab5bd336ab6b6a6138f89ffbb56ef3b5">vcl::addTriangleFacesFromPolygon</a></div><div class="ttdeci">void addTriangleFacesFromPolygon(MeshType &amp;m, FaceType &amp;f, const std::vector&lt; uint &gt; &amp;polygon)</div><div class="ttdoc">Given a vector of indices of vertices in a mesh representing a polyon, this function adds N triangula...</div><div class="ttdef"><b>Definition:</b> topology.cpp:381</div></div>
<div class="ttc" id="atypes_2base_8h_html_a69aa29b598b851b0640aa225a9e5d61d"><div class="ttname"><a href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a></div><div class="ttdeci">unsigned int uint</div><div class="ttdef"><b>Definition:</b> base.h:31</div></div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MeshType</td><td>the type of the face that satisfies the FaceMeshConcept. </td></tr>
    <tr><td class="paramname">FaceType</td><td>the type of the face that satisfies the FaceConcept.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">m</td><td>the mesh on which add the triangulation of the polygon. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">f</td><td>the first face of the triangulation, that will be filled. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">polygon</td><td>the vertex indices in the mesh representing the polygon. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acd2f68e498f63c306c81c756e63653c9" name="acd2f68e498f63c306c81c756e63653c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd2f68e498f63c306c81c756e63653c9">&#9670;&#160;</a></span>applyTransformMatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType, typename ScalarM &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::applyTransformMatrix </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacevcl.html#ad82a126b390f21b2e9658c73e7a795ee">Matrix44</a>&lt; ScalarM &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>updateNormals</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abe5c457181ae725f99627c541993a3a8" name="abe5c457181ae725f99627c541993a3a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe5c457181ae725f99627c541993a3a8">&#9670;&#160;</a></span>asConst() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr T * vcl::asConst </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ade7f012cfff33f3713171b1352d876fe" name="ade7f012cfff33f3713171b1352d876fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade7f012cfff33f3713171b1352d876fe">&#9670;&#160;</a></span>asConst() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vcl::asConst </td>
          <td>(</td>
          <td class="paramtype">T const &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a901098c9caa8ff551547adb1e555c159" name="a901098c9caa8ff551547adb1e555c159"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a901098c9caa8ff551547adb1e555c159">&#9670;&#160;</a></span>asConst() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr T &amp; vcl::asConst </td>
          <td>(</td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a69ab9dde7c49bdb94779a3f1068bed6d" name="a69ab9dde7c49bdb94779a3f1068bed6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69ab9dde7c49bdb94779a3f1068bed6d">&#9670;&#160;</a></span>asConst() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr T * vcl::asConst </td>
          <td>(</td>
          <td class="paramtype">T const *&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a66e2e1e0ec5d91e9def735ecf4f84b0e" name="a66e2e1e0ec5d91e9def735ecf4f84b0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66e2e1e0ec5d91e9def735ecf4f84b0e">&#9670;&#160;</a></span>barycenter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">MeshType::VertexType::CoordType vcl::barycenter </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the barycenter of the mesh, that is the simple average of all the vertex coordintes of the mesh. </p>
<p>Requirements:</p><ul>
<li><a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>:<ul>
<li>Vertices</li>
</ul>
</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>input mesh on which compute the barycenter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The barycenter of the input mesh. </dd></dl>

</div>
</div>
<a id="a6f45446c5f7bcad8bd9dd9c515bf1e55" name="a6f45446c5f7bcad8bd9dd9c515bf1e55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f45446c5f7bcad8bd9dd9c515bf1e55">&#9670;&#160;</a></span>bestGridSize() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;PointConcept PointType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Point.html">Point</a>&lt; <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a>, PointType::DIM &gt; vcl::bestGridSize </td>
          <td>(</td>
          <td class="paramtype">const PointType &amp;&#160;</td>
          <td class="paramname"><em>lengths</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a>&#160;</td>
          <td class="paramname"><em>nElements</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the best sizes (number of cells per dimension) of a Grid, starting from the lengths of the grid and the number of elements to place in the grid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lengths</td><td></td></tr>
    <tr><td class="paramname">nElements</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a9f1aec3c668a14a8c09ee1f6976c1a1e" name="a9f1aec3c668a14a8c09ee1f6976c1a1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f1aec3c668a14a8c09ee1f6976c1a1e">&#9670;&#160;</a></span>bestGridSize() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;PointConcept PointType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Point.html">vcl::Point</a>&lt; <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a>, PointType::DIM &gt; vcl::bestGridSize </td>
          <td>(</td>
          <td class="paramtype">const PointType &amp;&#160;</td>
          <td class="paramname"><em>lengths</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a>&#160;</td>
          <td class="paramname"><em>nElements</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the best sizes (number of cells per dimension) of a Grid, starting from the lengths of the grid and the number of elements to place in the grid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lengths</td><td></td></tr>
    <tr><td class="paramname">nElements</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a42de8353c96495dd4d54ee83909d6c77" name="a42de8353c96495dd4d54ee83909d6c77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42de8353c96495dd4d54ee83909d6c77">&#9670;&#160;</a></span>boolVectorFromFaceSelection()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; bool &gt; vcl::boolVectorFromFaceSelection </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a vector of boolean values. For each ith face in the mesh, the corresponding value in the vector will be true if the face is selected, false otherwise. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a2dc6c66ef4c3f576abc54ce27ec3eb65" name="a2dc6c66ef4c3f576abc54ce27ec3eb65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2dc6c66ef4c3f576abc54ce27ec3eb65">&#9670;&#160;</a></span>boolVectorFromVertexSelection()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; bool &gt; vcl::boolVectorFromVertexSelection </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a vector of boolean values. For each ith vertex in the mesh, the corresponding value in the vector will be true if the vertex is selected, false otherwise. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>input mesh. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a86c0811cfbc37a3b319d57902e81e949" name="a86c0811cfbc37a3b319d57902e81e949"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86c0811cfbc37a3b319d57902e81e949">&#9670;&#160;</a></span>borderLength()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double vcl::borderLength </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the border length of the given <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>, that is the sum of the length of the edges that are on border in the given mesh. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>mesh on which compute the border length. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The border length of the given mesh. </dd></dl>

</div>
</div>
<a id="a1b9b1898fbdb7ba13f1e1adaf832ba4d" name="a1b9b1898fbdb7ba13f1e1adaf832ba4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b9b1898fbdb7ba13f1e1adaf832ba4d">&#9670;&#160;</a></span>boundedDistFunction()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Obj1 , typename Obj2 , typename ScalarType  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto vcl::boundedDistFunction </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a proper dist function between a Obj1 object and an Obj2 object. </p>
<p>The function will return a function called <code>boundDistFun</code> defined in a specialization of the struct <a class="el" href="structvcl_1_1DistFunctionStruct.html">DistFunctionStruct</a>.</p>
<p>This function is different w.r.t. the distFunction because the returned function here takes three arguments: the two objects on which compute the distance, and a scalar that represent the maximum distance that can be returned. This value is used by some distance functions for performance reasons: it allows to avoid several computation if a first distance does already exceed the maximum value.</p>
<p>The returned function is a std::function that takes in input two const references of the desired types and a scalar that is the maximum distance expected and returns a scalar that is the distance between the two objects. If the returned value is &gt;= the input maximum distance, the distance was not computed totally and should be discarded.</p>
<p>If the distance function for your types is not defined, you can write your own <a class="el" href="structvcl_1_1DistFunctionStruct.html">DistFunctionStruct</a> specialization that defines a proper <code>static const inline</code> object called <code>boundDistFun</code> of <code>std::function</code> type. </p>

</div>
</div>
<a id="a47188a6c411a5a4fbd8542d5ce1525aa" name="a47188a6c411a5a4fbd8542d5ce1525aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47188a6c411a5a4fbd8542d5ce1525aa">&#9670;&#160;</a></span>checkFlipEdge()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceConcept FaceType&gt; <br />
requires comp::HasAdjacentFaces&lt;FaceType&gt;</div>
      <table class="memname">
        <tr>
          <td class="memname">bool vcl::checkFlipEdge </td>
          <td>(</td>
          <td class="paramtype">const FaceType &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a>&#160;</td>
          <td class="paramname"><em>edge</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a boolean value indicating whether the edge flip operation is allowed or not. </p>
<p>This function requires AdjacentFaces component, that must be enabled and computed before calling this function.</p>
<p>The function first checks if the specified edge is a boundary edge, in which case the flip operation is not allowed. If the edge is not a boundary edge, the function checks whether the mesh is well-oriented by verifying that the vertices of the edge to be flipped are the same in the adjacent face.</p>
<p>Next, the function checks if the flipped edge already exists in the mesh. To do this, the function performs a depth-first search starting from the current face, following the edges that share the opposite vertex to the edge being flipped. The search checks if the vertex on the other end of the flipped edge is already connected to any other face in the mesh. If it is, the flip operation is not allowed.</p>
<p>The depth-first search is limited to the faces that share the opposite vertex to the edge being flipped, so it does not perform an exhaustive search of the entire mesh. However, it is sufficient to detect non-manifoldness caused by the flipped edge.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FaceType</td><td>the type of the face that satisfies the FaceConcept.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>The face that contains the edge to flip. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">edge</td><td>The index of the edge to flip.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the edge flip is allowed, false otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classvcl_1_1MissingComponentException.html">vcl::MissingComponentException</a></td><td>If the "AdjacentFaces" component is not enabled on <code>f</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa98b23c4b973942fb42c0247077299b0" name="aa98b23c4b973942fb42c0247077299b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa98b23c4b973942fb42c0247077299b0">&#9670;&#160;</a></span>clampPerFaceScalar()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::clampPerFaceScalar </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename MeshType::FaceType::ScalarType&#160;</td>
          <td class="paramname"><em>minS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename MeshType::FaceType::ScalarType&#160;</td>
          <td class="paramname"><em>maxS</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clamps the face scalars of a mesh in a given interval. </p>
<p>Requirements:</p><ul>
<li><a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>:<ul>
<li>Faces:<ul>
<li>Scalar</li>
</ul>
</li>
</ul>
</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">m</td><td>mesh on which clamp the face scalars </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">minS</td><td>minimum value of the clamping interval </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxS</td><td>maximum value of the clamping interval </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a23e2af9adc2addc3187a9c086146723e" name="a23e2af9adc2addc3187a9c086146723e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23e2af9adc2addc3187a9c086146723e">&#9670;&#160;</a></span>clampPerVertexScalar()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::clampPerVertexScalar </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename MeshType::VertexType::ScalarType&#160;</td>
          <td class="paramname"><em>minS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename MeshType::VertexType::ScalarType&#160;</td>
          <td class="paramname"><em>maxS</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clamps the vertex scalars of a mesh in a given interval. </p>
<p>Requirements:</p><ul>
<li><a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>:<ul>
<li>Vertices:<ul>
<li>Scalar</li>
</ul>
</li>
</ul>
</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">m</td><td>mesh on which clamp the vertex scalars </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">minS</td><td>minimum value of the clamping interval </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxS</td><td>maximum value of the clamping interval </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0416a0056c7bbd35f81e72bb9b536db0" name="a0416a0056c7bbd35f81e72bb9b536db0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0416a0056c7bbd35f81e72bb9b536db0">&#9670;&#160;</a></span>clearEdgeSelection()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;EdgeMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::clearEdgeSelection </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abb5edd39f9dd2fc2220d8b08be523e29" name="abb5edd39f9dd2fc2220d8b08be523e29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb5edd39f9dd2fc2220d8b08be523e29">&#9670;&#160;</a></span>clearFaceSelection()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::clearFaceSelection </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a24d5ffd9bfb1588f06ccd35551e82ec0" name="a24d5ffd9bfb1588f06ccd35551e82ec0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24d5ffd9bfb1588f06ccd35551e82ec0">&#9670;&#160;</a></span>clearHalfEdgeSelection()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;DcelMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::clearHalfEdgeSelection </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aec301aa1e068ae4ceeeef43761b9ee04" name="aec301aa1e068ae4ceeeef43761b9ee04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec301aa1e068ae4ceeeef43761b9ee04">&#9670;&#160;</a></span>clearPerFaceAdjacentFaces()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::clearPerFaceAdjacentFaces </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clears the adjacent faces of each face of the mesh. </p>
<p>Since the number of adjacent faces per face is tied to the number of vertices of the face, at the end of this function each face will have f-&gt;vertexNumber() adjacent faces set to nullptr.</p>
<p>Requirements:</p><ul>
<li><a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>:<ul>
<li>Faces:<ul>
<li>AdjacentFaces</li>
</ul>
</li>
</ul>
</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>the mesh on which clear the per face adjacent faces. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa5ad240da55effe35e495f1aad2e3507" name="aa5ad240da55effe35e495f1aad2e3507"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5ad240da55effe35e495f1aad2e3507">&#9670;&#160;</a></span>clearPerReferencedVertexNormals()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::clearPerReferencedVertexNormals </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets to zero all the normals of vertices that are referenced by at least one face, leaving unchanged all the normals of the unreferenced vertices that may be still useful. </p>
<p>Requirements:</p><ul>
<li><a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>:<ul>
<li>Vertices:<ul>
<li>Normal</li>
</ul>
</li>
<li>Faces</li>
</ul>
</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">m</td><td>The mesh on which clear the referenced vertex normals. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a54e8371c2ddda188c9540ea7e7bddf78" name="a54e8371c2ddda188c9540ea7e7bddf78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54e8371c2ddda188c9540ea7e7bddf78">&#9670;&#160;</a></span>clearPerVertexAdjacentFaces()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::clearPerVertexAdjacentFaces </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clears the adjacent faces of each vertex of the mesh. </p>
<p>Since the number of adjacent faces per vertex is dynamic, at the end of this function each vertex will have 0 adjacent Faces.</p>
<p>Requirements:</p><ul>
<li><a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>:<ul>
<li>Vertices:<ul>
<li>AdjacentFaces</li>
</ul>
</li>
</ul>
</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>the mesh on which clear the per vertex adjacent faces. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a312c8ca27b3e94994a1f03bc1a3d826d" name="a312c8ca27b3e94994a1f03bc1a3d826d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a312c8ca27b3e94994a1f03bc1a3d826d">&#9670;&#160;</a></span>clearPerVertexAdjacentVertices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::clearPerVertexAdjacentVertices </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clears the adjacent vertices of each vertex of the mesh. </p>
<p>Since the number of adjacent vertices per vertex is dynamic, at the end of this function each vertex will have 0 adjacent vertices.</p>
<p>Requirements:</p><ul>
<li><a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>:<ul>
<li>Vertices:<ul>
<li>AdjacentVertices</li>
</ul>
</li>
</ul>
</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>the mesh on which clear the per vertex adjacent vertices. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad6a0e2bc172c69d34a84631e824c75a4" name="ad6a0e2bc172c69d34a84631e824c75a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6a0e2bc172c69d34a84631e824c75a4">&#9670;&#160;</a></span>clearPerVertexNormals()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::clearPerVertexNormals </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets to zero the normals of all the vertices of the mesh, including the unreferenced ones. </p>
<p>Requirements:</p><ul>
<li><a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>:<ul>
<li>Vertices:<ul>
<li>Normal</li>
</ul>
</li>
</ul>
</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">m</td><td>The mesh on which clear the vertex normals. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7b0bc5dbd8005d39d14ccf664ffca33c" name="a7b0bc5dbd8005d39d14ccf664ffca33c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b0bc5dbd8005d39d14ccf664ffca33c">&#9670;&#160;</a></span>clearVertexSelection()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::clearVertexSelection </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab5a54ddc3c9d67e0c7ed179e78c2ca06" name="ab5a54ddc3c9d67e0c7ed179e78c2ca06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5a54ddc3c9d67e0c7ed179e78c2ca06">&#9670;&#160;</a></span>colorFromInterval() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Color.html">Color</a> vcl::colorFromInterval </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Color.html#a32ace7bd7fccf742b39f6cd83042a10f">Color::ColorMap</a>&#160;</td>
          <td class="paramname"><em>cm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a color in the interval from the minimum color to the maximum color of the given colormap <code>cm</code>, depending on the position of the given value in the given interval [min, max]. </p>
<p>If the given value is less than the minimum value of the interval, the minimum color will be returned. If the given value is higher than the maximum value of the interval, the maximum color will be returned. If min and max are equal, the Grey color will be returned.</p>
<p>This function works also if the values of the interval are swapped.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">min</td><td>minimum value of the interval </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max</td><td>maximum value of the interval </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>the value in the interval to ramp. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cm</td><td>the colormap on which compute the color. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A color in the given colormap representing the position of value in the interval [min, max]. </dd></dl>

</div>
</div>
<a id="a5851edce0478bfc7f4084e3529ae6962" name="a5851edce0478bfc7f4084e3529ae6962"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5851edce0478bfc7f4084e3529ae6962">&#9670;&#160;</a></span>colorFromInterval() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Color.html">Color</a> vcl::colorFromInterval </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Color.html#a32ace7bd7fccf742b39f6cd83042a10f">Color::ColorMap</a>&#160;</td>
          <td class="paramname"><em>cm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a <code>value</code> in the interval [0, 1], it returns the color in the position in the given ColorMap <code>cm</code> corresponding to the position of <code>value</code> in the interval [0, 1]. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>a float value between 0 and 1. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">[cm]</td><td>cm: the colormap used to compute the color. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The color in the position of <code>value</code> in the given colormap. </dd></dl>

</div>
</div>
<a id="a99b591f2eba1ded24ebf6f4b0ee4353f" name="a99b591f2eba1ded24ebf6f4b0ee4353f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99b591f2eba1ded24ebf6f4b0ee4353f">&#9670;&#160;</a></span>colorFromIntervalGreyShade() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Color.html">Color</a> vcl::colorFromIntervalGreyShade </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a color in the grey shade colormap depending on the position of the given value in the given interval [min, max]. </p>
<p>If the given value is less than the minimum value of the interval, the minimum color of the colormap will be returned. If the given value is higher than the maximum value of the interval, the maximum color in the colormap will be returned. If min and max are equal, the Grey color will be returned.</p>
<p>This function works also if the values of the interval are swapped.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">min</td><td>minimum value of the interval </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max</td><td>maximum value of the interval </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>the value in the interval to ramp. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A color in the grey shade colormap representing the position of value in the interval [min, max]. </dd></dl>

</div>
</div>
<a id="a8232d4e3c3aca4125e84cb8f124ebc29" name="a8232d4e3c3aca4125e84cb8f124ebc29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8232d4e3c3aca4125e84cb8f124ebc29">&#9670;&#160;</a></span>colorFromIntervalGreyShade() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Color.html">Color</a> vcl::colorFromIntervalGreyShade </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a color in the grey shade colormap depending on the position of the given value in the interval [0, 1]. </p>
<p>If the given value is less than 0, the minimum color of the colormap will be returned. If the given value is higher than 1, the maximum color in the colormap will be returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>the value between 0 and 1 to ramp. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A color in the grey shade colormap representing the position of value in the interval [0, 1]. </dd></dl>

</div>
</div>
<a id="a9725bc9a2f5b27ce885e76be92185a20" name="a9725bc9a2f5b27ce885e76be92185a20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9725bc9a2f5b27ce885e76be92185a20">&#9670;&#160;</a></span>colorFromIntervalParula() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Color.html">Color</a> vcl::colorFromIntervalParula </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a color in the Paraula colormap depending on the position of the given value in the given interval [min, max]. </p>
<p>If the given value is less than the minimum value of the interval, the minimum color of the colormap will be returned. If the given value is higher than the maximum value of the interval, the maximum color in the colormap will be returned. If min and max are equal, the Grey color will be returned.</p>
<p>This function works also if the values of the interval are swapped.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">min</td><td>minimum value of the interval </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max</td><td>maximum value of the interval </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>the value in the interval to ramp. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A color in the Parula colormap representing the position of value in the interval [min, max]. </dd></dl>

</div>
</div>
<a id="a7728ec836fa169f447a90a4d2eee3df5" name="a7728ec836fa169f447a90a4d2eee3df5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7728ec836fa169f447a90a4d2eee3df5">&#9670;&#160;</a></span>colorFromIntervalParula() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Color.html">Color</a> vcl::colorFromIntervalParula </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a color in the Paraula colormap depending on the position of the given value in the interval [0, 1]. </p>
<p>If the given value is less than 0, the minimum color of the colormap will be returned. If the given value is higher than 1, the maximum color in the colormap will be returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>the value between 0 and 1 to ramp. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A color in the Parula colormap representing the position of value in the interval [0, 1]. </dd></dl>

</div>
</div>
<a id="afa361024b35e8aef9609826b177ac1cb" name="afa361024b35e8aef9609826b177ac1cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa361024b35e8aef9609826b177ac1cb">&#9670;&#160;</a></span>colorFromIntervalRedBlue() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Color.html">Color</a> vcl::colorFromIntervalRedBlue </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a color in the interval from Red to Blue depending on the position of the given value in the given interval [min, max]. </p>
<p>If the given value is less than the minimum value of the interval, the Red color will be returned. If the given value is higher than the maximum value of the interval, the Blue color will be returned. If min and max are equal, the Grey color will be returned.</p>
<p>This function works also if the values of the interval are swapped.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">min</td><td>minimum value of the interval </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max</td><td>maximum value of the interval </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>the value in the interval to ramp. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A color between Red and Blue representing the position of value in the interval [min, max]. </dd></dl>

</div>
</div>
<a id="a6c348d7127fb95f134332b8c275846f7" name="a6c348d7127fb95f134332b8c275846f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c348d7127fb95f134332b8c275846f7">&#9670;&#160;</a></span>colorFromIntervalRedBlue() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Color.html">Color</a> vcl::colorFromIntervalRedBlue </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a color in the interval from Red to Blue depending on the position of the given value in the interval [0, 1]. </p>
<p>If the given value is less than 0, the Red color will be returned. If the given value is higher than 1, the Blue color will be returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>the value between 0 and 1 to ramp. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A color between Red and Blue representing the position of value in the interval [0, 1]. </dd></dl>

</div>
</div>
<a id="a9dcc49648719fc830554b892110ff8f2" name="a9dcc49648719fc830554b892110ff8f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9dcc49648719fc830554b892110ff8f2">&#9670;&#160;</a></span>colorLerp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Color.html">Color</a> vcl::colorLerp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvcl_1_1Color.html">Color</a> &amp;&#160;</td>
          <td class="paramname"><em>c0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvcl_1_1Color.html">Color</a> &amp;&#160;</td>
          <td class="paramname"><em>c1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given an interval of colors (from <code>c0</code> to <code>c1</code>) and a value in the interval [0, 1], returns the linear interpolation color between <code>c0</code> and <code>c1</code> based on <code>value</code> in the [0, 1] interval. If <code>value</code> is out of range, it will be set to the nearest extreme of the interval. </p>
<p>Linear interpolation is computed in the RGBA values of the two colors.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">c0</td><td>minimum in the input color interval. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">c1</td><td>minimum in the input color interval. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>a float value between 0 and 1. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The linear interpolation between <code>c0</code> and <code>c1</code>. </dd></dl>

</div>
</div>
<a id="ab09621efab9b0f2003139f2aac2d339a" name="ab09621efab9b0f2003139f2aac2d339a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab09621efab9b0f2003139f2aac2d339a">&#9670;&#160;</a></span>colorScattering()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classvcl_1_1Color.html">Color</a> &gt; vcl::colorScattering </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>sat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a number <code>n</code>, returns a vector of <code>n</code> colors so that each color differs as much as possible from the previous one of the vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the number of colors in the returned vector </td></tr>
    <tr><td class="paramname">sat</td><td>the saturation in the returned colors (default 0.3) </td></tr>
    <tr><td class="paramname">val</td><td>the value in the returned colors (default 0.9) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector of different colors. </dd></dl>

</div>
</div>
<a id="a6cdf6b9e1ed3c93d2a4c6265a9fed40c" name="a6cdf6b9e1ed3c93d2a4c6265a9fed40c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cdf6b9e1ed3c93d2a4c6265a9fed40c">&#9670;&#160;</a></span>compactVector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::compactVector </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T, Args... &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>newIndices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>It will take care of compacting the vector vec, depending on the content of the vector newIndices. </p>
<p>Given the vector newIndices having the following features:</p><ul>
<li>have the same size of vec</li>
<li>for each position i:<ul>
<li>newIndices[i] contains the new position of the element vec[i] after the compactness</li>
<li>newIndices[i] contains a value &lt; 0 if the element vec[i] must be deleted</li>
</ul>
</li>
</ul>
<p>Non-negative elements of newIndices must unique, and their value must be less than the new size of vec after the compactness. The new size of vec will be the number of non-negative elements of newIndices.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td></td></tr>
    <tr><td class="paramname">newIndices</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a49e57acf0c1cb51e98f7a176051d99ee" name="a49e57acf0c1cb51e98f7a176051d99ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49e57acf0c1cb51e98f7a176051d99ee">&#9670;&#160;</a></span>covarianceMatrixOfMesh()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto vcl::covarianceMatrixOfMesh </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute covariance matrix of a mesh, i.e. the integral int_{m} { (x-b)(x-b)^T }dx where b is the barycenter and x spans over the mesh m. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The 3x3 covariance matrix of the given mesh. </dd></dl>

</div>
</div>
<a id="a46a67e9dd1e0a9805f812c10328caaa2" name="a46a67e9dd1e0a9805f812c10328caaa2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46a67e9dd1e0a9805f812c10328caaa2">&#9670;&#160;</a></span>covarianceMatrixOfPointCloud() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto vcl::covarianceMatrixOfPointCloud </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the covariance matrix of a <a class="el" href="classvcl_1_1Point.html" title="The Point class represents an N-dimensional point containing N scalar values.">Point</a> Cloud <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>. </p>
<p>Requirements:</p><ul>
<li><a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>:<ul>
<li>Vertices</li>
</ul>
</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The 3x3 covariance matrix of the given point cloud. </dd></dl>

</div>
</div>
<a id="af9fd633374c0d8ab86df9e354a9a0fb5" name="af9fd633374c0d8ab86df9e354a9a0fb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9fd633374c0d8ab86df9e354a9a0fb5">&#9670;&#160;</a></span>covarianceMatrixOfPointCloud() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;PointConcept PointType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto vcl::covarianceMatrixOfPointCloud </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; PointType &gt; &amp;&#160;</td>
          <td class="paramname"><em>pointVec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the covariance matrix of a set of points. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pointVec</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The 3x3 covariance matrix of the given set of points. </dd></dl>

</div>
</div>
<a id="a7383cbe54f93fa408ebd2f3e6f66ae21" name="a7383cbe54f93fa408ebd2f3e6f66ae21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7383cbe54f93fa408ebd2f3e6f66ae21">&#9670;&#160;</a></span>createCube()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType, PointConcept CoordType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">MeshType vcl::createCube </td>
          <td>(</td>
          <td class="paramtype">const CoordType &amp;&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>edgeLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates and returns a Cube having <code>min</code> as minimum extreme and the given edge length. </p>
<p>If the mesh is composed of triangles, the the returned mesh is already triangulated. If the mesh is composed of quads or polygons, a mesh containing 6 quads will be returned.</p>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a> containing a <code>[min, min+edgeLength]</code> Cube. </dd></dl>

</div>
</div>
<a id="a59f079a11ad7619de8d924b3df2bca0e" name="a59f079a11ad7619de8d924b3df2bca0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59f079a11ad7619de8d924b3df2bca0e">&#9670;&#160;</a></span>createDodecahedron()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;PolygonMeshConcept MeshType, LoggerConcept LogType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">MeshType vcl::createDodecahedron </td>
          <td>(</td>
          <td class="paramtype">LogType &amp;&#160;</td>
          <td class="paramname"><em>log</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates and returns a <a class="el" href="classvcl_1_1Polygon.html">Polygon</a> <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a> containing a Dodecahedron. </p>
<p>Creates and returns a <a class="el" href="classvcl_1_1Triangle.html">Triangle</a> <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a> containing a triangulated Dodecahedron.</p>
<p>The returned mesh will contain 12 pentagons.</p>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a> containing a dodecahedron.</dd></dl>
<p>If the mesh is composed of triangles, the the returned mesh is already triangulated. If the mesh is polygonal, a mesh containing 12 pentagons will be returned.</p>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a> containing a dodecahedron. </dd></dl>

</div>
</div>
<a id="ad27918bc874e941633aeeb83c09ef8bc" name="ad27918bc874e941633aeeb83c09ef8bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad27918bc874e941633aeeb83c09ef8bc">&#9670;&#160;</a></span>createHexahedron() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">MeshType vcl::createHexahedron </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates and returns a hexahedron having as extremes the points <code>(-1, -1, -1)</code> and <code>(1, 1, 1)</code>. </p>
<p>If the mesh is composed of triangles, the the returned mesh is already triangulated. If the mesh is composed of quads or polygons, a mesh containing 6 quads will be returned.</p>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a> containing a <code>[(-1, -1, -1), (1, 1, 1)]</code>Hexahedron . </dd></dl>

</div>
</div>
<a id="a99aea140f795216e3bad1e4086ea3fe5" name="a99aea140f795216e3bad1e4086ea3fe5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99aea140f795216e3bad1e4086ea3fe5">&#9670;&#160;</a></span>createHexahedron() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType, PointConcept CoordType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">MeshType vcl::createHexahedron </td>
          <td>(</td>
          <td class="paramtype">const CoordType &amp;&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CoordType &amp;&#160;</td>
          <td class="paramname"><em>max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates and returns a Hexahedron having as extremes points min and max given as arguments. </p>
<p>If the mesh is composed of triangles, the the returned mesh is already triangulated. If the mesh is composed of quads or polygons, a mesh containing 6 quads will be returned.</p>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a> containing a <code>[min, max]</code>Hexahedron . </dd></dl>

</div>
</div>
<a id="a269b1a97ae12274a20f3ef034cb65150" name="a269b1a97ae12274a20f3ef034cb65150"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a269b1a97ae12274a20f3ef034cb65150">&#9670;&#160;</a></span>createIcosahedron()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">MeshType vcl::createIcosahedron </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>normalizeVertices</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a455a7abda2f207c424dd5946c30c48c6" name="a455a7abda2f207c424dd5946c30c48c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a455a7abda2f207c424dd5946c30c48c6">&#9670;&#160;</a></span>createSphere() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">MeshType vcl::createSphere </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a <a class="el" href="classvcl_1_1Sphere.html">Sphere</a> <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a> using the UV mode (<a href="https://github.com/caosdoar/spheres">https://github.com/caosdoar/spheres</a>), centered in (0, 0, 0), having radius 1, with 10 parallels and 20 meridias. </p>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a48405fa64042edde48ab488b84ce78df" name="a48405fa64042edde48ab488b84ce78df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48405fa64042edde48ab488b84ce78df">&#9670;&#160;</a></span>createSphere() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">MeshType vcl::createSphere </td>
          <td>(</td>
          <td class="paramtype">const SphereConcept auto &amp;&#160;</td>
          <td class="paramname"><em>sp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvcl_1_1CreateSphereArgs.html">CreateSphereArgs</a> &amp;&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a <a class="el" href="classvcl_1_1Sphere.html">Sphere</a> <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a> centered in <code>center</code> point and having radius <code>radius</code>, using the generation method given in the argument args.mode (see <a href="https://github.com/caosdoar/spheres">https://github.com/caosdoar/spheres</a> for more details). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">center</td><td></td></tr>
    <tr><td class="paramname">radius</td><td></td></tr>
    <tr><td class="paramname">args</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a4fa15f02159bbc4db0b84ffa8978b154" name="a4fa15f02159bbc4db0b84ffa8978b154"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fa15f02159bbc4db0b84ffa8978b154">&#9670;&#160;</a></span>createSphereIcosahedron()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">MeshType vcl::createSphereIcosahedron </td>
          <td>(</td>
          <td class="paramtype">const SphereConcept auto &amp;&#160;</td>
          <td class="paramname"><em>sp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a>&#160;</td>
          <td class="paramname"><em>divisions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad6f54ee450c902f94c4185193d7bfed0" name="ad6f54ee450c902f94c4185193d7bfed0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6f54ee450c902f94c4185193d7bfed0">&#9670;&#160;</a></span>createSphereNormalizedCube()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">MeshType vcl::createSphereNormalizedCube </td>
          <td>(</td>
          <td class="paramtype">const SphereConcept auto &amp;&#160;</td>
          <td class="paramname"><em>sp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a>&#160;</td>
          <td class="paramname"><em>divisions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a964925e1a22e75db7dea160f6ca9b9bd" name="a964925e1a22e75db7dea160f6ca9b9bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a964925e1a22e75db7dea160f6ca9b9bd">&#9670;&#160;</a></span>createSphereSpherifiedCube()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">MeshType vcl::createSphereSpherifiedCube </td>
          <td>(</td>
          <td class="paramtype">const SphereConcept auto &amp;&#160;</td>
          <td class="paramname"><em>sp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a>&#160;</td>
          <td class="paramname"><em>divisions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a178428edf0329a0ed798ccc4b9a6feae" name="a178428edf0329a0ed798ccc4b9a6feae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a178428edf0329a0ed798ccc4b9a6feae">&#9670;&#160;</a></span>createSphereUV()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">MeshType vcl::createSphereUV </td>
          <td>(</td>
          <td class="paramtype">const SphereConcept auto &amp;&#160;</td>
          <td class="paramname"><em>sp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a>&#160;</td>
          <td class="paramname"><em>parallels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a>&#160;</td>
          <td class="paramname"><em>meridians</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3d38a6ecac2b2ab64dd11d53d78e98ca" name="a3d38a6ecac2b2ab64dd11d53d78e98ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d38a6ecac2b2ab64dd11d53d78e98ca">&#9670;&#160;</a></span>createTetrahedron() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">MeshType vcl::createTetrahedron </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>createTetrahedron creates a simple tetrahedron mesh with the following point coordinates: </p>
<p>( 1, 1, 1), (-1, 1, -1), (-1, -1, 1), ( 1, -1, -1)</p>
<p>Requirements:</p><ul>
<li><a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>:<ul>
<li>Vertices</li>
<li>Faces</li>
</ul>
</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a> containing a Tetrahedron. </dd></dl>

</div>
</div>
<a id="a7c70a856983dfae4697e3521825dce90" name="a7c70a856983dfae4697e3521825dce90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c70a856983dfae4697e3521825dce90">&#9670;&#160;</a></span>createTetrahedron() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType, PointConcept CoordType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">MeshType vcl::createTetrahedron </td>
          <td>(</td>
          <td class="paramtype">const CoordType &amp;&#160;</td>
          <td class="paramname"><em>p0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CoordType &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CoordType &amp;&#160;</td>
          <td class="paramname"><em>p2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CoordType &amp;&#160;</td>
          <td class="paramname"><em>p3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>createTetrahedron createTetrahedron creates a simple tetrahedron mesh with the given points. The function assumes that the points p0, p1 and p2 are in counterclockwise order, and does not perform any sanity check about the validity of the points. </p>
<p>Requirements:</p><ul>
<li><a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>:<ul>
<li>Vertices</li>
<li>Faces</li>
</ul>
</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p0</td><td></td></tr>
    <tr><td class="paramname">p1</td><td></td></tr>
    <tr><td class="paramname">p2</td><td></td></tr>
    <tr><td class="paramname">p3</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a> containing a Tetrahedron. </dd></dl>

</div>
</div>
<a id="a3109cc4c0e2128888f2a3fa6ae27a98f" name="a3109cc4c0e2128888f2a3fa6ae27a98f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3109cc4c0e2128888f2a3fa6ae27a98f">&#9670;&#160;</a></span>detachAdjacentFacesOnEdge()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceConcept FaceType&gt; <br />
requires comp::HasAdjacentFaces&lt;FaceType&gt;</div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::detachAdjacentFacesOnEdge </td>
          <td>(</td>
          <td class="paramtype">FaceType &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a>&#160;</td>
          <td class="paramname"><em>edge</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Detaches the face <code>f</code> on the given edge, which consists on updating adjacent faces such that any face that was linking the face <code>f</code> won't link it anymore. It manages also non-manifold edges. </p>
<p>If the given pair face-edge is on border, nothing is done. If the given pair face-edge is a normal manifold edge, this operation will set nullptr as adjacent face of f (making edge a border) and vice versa on the adjacent face. If the given pair face-edge is a non-manifold edge, the function will "remove" the current face from the ring of faces incident on the edge. The given face f will have the given edge set as a border (nullptr).</p>
<p>This function is designed to work with faces that have an enabled "AdjacentFaces" component. If the component is not enabled, a <a class="el" href="classvcl_1_1MissingComponentException.html">MissingComponentException</a> is thrown.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FaceType</td><td>the type of the face that satisfies the FaceConcept.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>The face to detach on the given edge. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">edge</td><td>The index of the edge to detach the face from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classvcl_1_1MissingComponentException.html">vcl::MissingComponentException</a></td><td>If the "AdjacentFaces" component is not enabled on <code>f</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af67d9147410404febe19163fb506397d" name="af67d9147410404febe19163fb506397d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af67d9147410404febe19163fb506397d">&#9670;&#160;</a></span>detachFace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceConcept FaceType&gt; <br />
requires comp::HasAdjacentFaces&lt;FaceType&gt;</div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::detachFace </td>
          <td>(</td>
          <td class="paramtype">FaceType &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Detaches the given face from all its adjacent vertices and adjacent faces. </p>
<p>The detachFace function detaches the given face from all its adjacent vertices and adjacent faces. This means that every vertex and face will no longer link to the face <code>f</code> as an adjacent face, and <code>f</code> will no longer have any adjacent faces (all their values are set to nullptr). The vertices of the face <code>f</code> are unchanged.</p>
<p>This function is designed to work with faces that have an enabled "Adjacent Faces" component. If the component is not enabled, a <a class="el" href="classvcl_1_1MissingComponentException.html">MissingComponentException</a> is thrown.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FaceType</td><td>the type of the face that satisfies the FaceConcept.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>The face to detach from its vertices and adjacent faces.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classvcl_1_1MissingComponentException.html">MissingComponentException</a></td><td>if the adjacent faces component is not enabled on the face. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a63f7958bed5f73548d28f436c7eb7b35" name="a63f7958bed5f73548d28f436c7eb7b35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63f7958bed5f73548d28f436c7eb7b35">&#9670;&#160;</a></span>distFunction()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Obj1 , typename Obj2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto vcl::distFunction </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a proper dist function between a Obj1 object and an Obj2 object. </p>
<p>The function will return a function called <code>distFun</code> defined in a specialization of the struct <a class="el" href="structvcl_1_1DistFunctionStruct.html">DistFunctionStruct</a>.</p>
<p>The returned function is a std::function that takes in input two const references of the desired types and returns a scalar that is the distance between the two objects.</p>
<p>If the distance function for your types is not defined, you can write your own <a class="el" href="structvcl_1_1DistFunctionStruct.html">DistFunctionStruct</a> specialization that defines a proper <code>static const inline</code> object called <code>distFun</code> of <code>std::function</code> type. </p>

</div>
</div>
<a id="abe81dae5e15d5acbb8c959e3d2208d49" name="abe81dae5e15d5acbb8c959e3d2208d49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe81dae5e15d5acbb8c959e3d2208d49">&#9670;&#160;</a></span>drawArrow3()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vcl::drawArrow3 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__space.html#gabb47c1364fb2fe1464a54417684f011e">Point3d</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__space.html#gabb47c1364fb2fe1464a54417684f011e">Point3d</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>bottom_radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvcl_1_1Color.html">Color</a> &amp;&#160;</td>
          <td class="paramname"><em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>slices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>stacks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>drawArrow </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td></td></tr>
    <tr><td class="paramname">b</td><td></td></tr>
    <tr><td class="paramname">bottom_radius</td><td></td></tr>
    <tr><td class="paramname">color</td><td></td></tr>
    <tr><td class="paramname">slices</td><td></td></tr>
    <tr><td class="paramname">stacks</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a650b9887818f5833f6784a0a879ca2b6" name="a650b9887818f5833f6784a0a879ca2b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a650b9887818f5833f6784a0a879ca2b6">&#9670;&#160;</a></span>drawBox3() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vcl::drawBox3 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__space.html#gabb47c1364fb2fe1464a54417684f011e">Point3d</a> &amp;&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__space.html#gabb47c1364fb2fe1464a54417684f011e">Point3d</a> &amp;&#160;</td>
          <td class="paramname"><em>max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvcl_1_1Color.html">Color</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>drawBox3 </p>
<p>Draws an axis aligned 3D box using opengl lines.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">min</td><td></td></tr>
    <tr><td class="paramname">max</td><td></td></tr>
    <tr><td class="paramname">c</td><td></td></tr>
    <tr><td class="paramname">width</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a983e11aa618329af3a02f60b6375d72c" name="a983e11aa618329af3a02f60b6375d72c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a983e11aa618329af3a02f60b6375d72c">&#9670;&#160;</a></span>drawBox3() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vcl::drawBox3 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__space.html#gabb47c1364fb2fe1464a54417684f011e">Point3d</a> &amp;&#160;</td>
          <td class="paramname"><em>p0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__space.html#gabb47c1364fb2fe1464a54417684f011e">Point3d</a> &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__space.html#gabb47c1364fb2fe1464a54417684f011e">Point3d</a> &amp;&#160;</td>
          <td class="paramname"><em>p2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__space.html#gabb47c1364fb2fe1464a54417684f011e">Point3d</a> &amp;&#160;</td>
          <td class="paramname"><em>p3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__space.html#gabb47c1364fb2fe1464a54417684f011e">Point3d</a> &amp;&#160;</td>
          <td class="paramname"><em>p4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__space.html#gabb47c1364fb2fe1464a54417684f011e">Point3d</a> &amp;&#160;</td>
          <td class="paramname"><em>p5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__space.html#gabb47c1364fb2fe1464a54417684f011e">Point3d</a> &amp;&#160;</td>
          <td class="paramname"><em>p6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__space.html#gabb47c1364fb2fe1464a54417684f011e">Point3d</a> &amp;&#160;</td>
          <td class="paramname"><em>p7</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvcl_1_1Color.html">Color</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>drawBox3 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p0</td><td></td></tr>
    <tr><td class="paramname">p1</td><td></td></tr>
    <tr><td class="paramname">p2</td><td></td></tr>
    <tr><td class="paramname">p3</td><td></td></tr>
    <tr><td class="paramname">p4</td><td></td></tr>
    <tr><td class="paramname">p5</td><td></td></tr>
    <tr><td class="paramname">p6</td><td></td></tr>
    <tr><td class="paramname">p7</td><td></td></tr>
    <tr><td class="paramname">c</td><td></td></tr>
    <tr><td class="paramname">width</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3189cf637794b419973820f73bd2ac0d" name="a3189cf637794b419973820f73bd2ac0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3189cf637794b419973820f73bd2ac0d">&#9670;&#160;</a></span>drawBox3() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vcl::drawBox3 </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="group__space.html#gabb47c1364fb2fe1464a54417684f011e">Point3d</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvcl_1_1Color.html">Color</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>drawBox3 </p>
<p>draws the box composed by the first 8 point contained on the vector passed as parameter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td></td></tr>
    <tr><td class="paramname">c</td><td></td></tr>
    <tr><td class="paramname">width</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4ccdd454b5ec361dc7783be5ab01dcc2" name="a4ccdd454b5ec361dc7783be5ab01dcc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ccdd454b5ec361dc7783be5ab01dcc2">&#9670;&#160;</a></span>drawCylinder()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vcl::drawCylinder </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__space.html#gabb47c1364fb2fe1464a54417684f011e">Point3d</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__space.html#gabb47c1364fb2fe1464a54417684f011e">Point3d</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>top_radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>bottom_radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvcl_1_1Color.html">Color</a> &amp;&#160;</td>
          <td class="paramname"><em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>slices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>stacks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>drawCylinder </p>
<p>Draws a cylinder with opengl. The cylinder links the two points passed as parameters</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>first point of the cylinder </td></tr>
    <tr><td class="paramname">b</td><td>second point of the cylinder </td></tr>
    <tr><td class="paramname">top_radius</td><td>radius at the "a" point </td></tr>
    <tr><td class="paramname">bottom_radius</td><td>radius at the "b" point </td></tr>
    <tr><td class="paramname">color</td><td>color of the cylinder </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4d6d6df1422f4d638b9f6d61b2163005" name="a4d6d6df1422f4d638b9f6d61b2163005"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d6d6df1422f4d638b9f6d61b2163005">&#9670;&#160;</a></span>drawDashedLine3()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vcl::drawDashedLine3 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__space.html#gabb47c1364fb2fe1464a54417684f011e">Point3d</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__space.html#gabb47c1364fb2fe1464a54417684f011e">Point3d</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvcl_1_1Color.html">Color</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>drawDashedLine </p>
<p>Draws a dashed line with opengl that links the two points passed as parameters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>first point of the dashed line </td></tr>
    <tr><td class="paramname">b</td><td>second point of the dashed line </td></tr>
    <tr><td class="paramname">c</td><td>color of the dashed line </td></tr>
    <tr><td class="paramname">width</td><td>width of the dashed line (default: 3) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a692ed5f64fdbbc22a85818682bd6ec79" name="a692ed5f64fdbbc22a85818682bd6ec79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a692ed5f64fdbbc22a85818682bd6ec79">&#9670;&#160;</a></span>drawLine2()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vcl::drawLine2 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__space.html#ga4b02e85ff4d51fe7d689f8dd0e87ecd5">Point2d</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__space.html#ga4b02e85ff4d51fe7d689f8dd0e87ecd5">Point2d</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvcl_1_1Color.html">Color</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>drawLine2 </p>
<p>Draws a line with opengl on the plane (z=0 if 3D). It links the two points passed as parameters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>first point of the line </td></tr>
    <tr><td class="paramname">b</td><td>second point of the line </td></tr>
    <tr><td class="paramname">c</td><td>color of the line </td></tr>
    <tr><td class="paramname">width</td><td>width of the line (default: 3) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae16b4f65fcbf4d8d8168e0e16f1a47b7" name="ae16b4f65fcbf4d8d8168e0e16f1a47b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae16b4f65fcbf4d8d8168e0e16f1a47b7">&#9670;&#160;</a></span>drawLine3()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vcl::drawLine3 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__space.html#gabb47c1364fb2fe1464a54417684f011e">Point3d</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__space.html#gabb47c1364fb2fe1464a54417684f011e">Point3d</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvcl_1_1Color.html">Color</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>drawLine </p>
<p>Draws a line with opengl that links the two points passed as parameters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>first point of the line </td></tr>
    <tr><td class="paramname">b</td><td>second point of the line </td></tr>
    <tr><td class="paramname">c</td><td>color of the line </td></tr>
    <tr><td class="paramname">width</td><td>width of the line (default: 3) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a516ae081ca79f1afbf5a77883613be72" name="a516ae081ca79f1afbf5a77883613be72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a516ae081ca79f1afbf5a77883613be72">&#9670;&#160;</a></span>drawPoint2()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vcl::drawPoint2 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__space.html#ga4b02e85ff4d51fe7d689f8dd0e87ecd5">Point2d</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvcl_1_1Color.html">Color</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em> = <code>8</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>drawPoint2 </p>
<p>Draws a point on the plane (coord z = 0 if 3D).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>coordinates of the point </td></tr>
    <tr><td class="paramname">c</td><td>color of the point </td></tr>
    <tr><td class="paramname">size</td><td>size of the point (default: 8) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5e3c74a0c0e3fa706fa71a222971abac" name="a5e3c74a0c0e3fa706fa71a222971abac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e3c74a0c0e3fa706fa71a222971abac">&#9670;&#160;</a></span>drawPoint3()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vcl::drawPoint3 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__space.html#gabb47c1364fb2fe1464a54417684f011e">Point3d</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvcl_1_1Color.html">Color</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draws a point on the plane (coord z = 0 if 3D). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>coordinates of the point </td></tr>
    <tr><td class="paramname">c</td><td>color of the point </td></tr>
    <tr><td class="paramname">size</td><td>size of the point (default: 8) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3e4e098e07b2cacca973fd8683f48c72" name="a3e4e098e07b2cacca973fd8683f48c72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e4e098e07b2cacca973fd8683f48c72">&#9670;&#160;</a></span>drawQuad2() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vcl::drawQuad2 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__space.html#ga4b02e85ff4d51fe7d689f8dd0e87ecd5">Point2d</a> &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__space.html#ga4b02e85ff4d51fe7d689f8dd0e87ecd5">Point2d</a> &amp;&#160;</td>
          <td class="paramname"><em>p2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__space.html#ga4b02e85ff4d51fe7d689f8dd0e87ecd5">Point2d</a> &amp;&#160;</td>
          <td class="paramname"><em>p3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__space.html#ga4b02e85ff4d51fe7d689f8dd0e87ecd5">Point2d</a> &amp;&#160;</td>
          <td class="paramname"><em>p4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvcl_1_1Color.html">Color</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fill</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>drawQuad2D </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p1</td><td></td></tr>
    <tr><td class="paramname">p2</td><td></td></tr>
    <tr><td class="paramname">p3</td><td></td></tr>
    <tr><td class="paramname">p4</td><td></td></tr>
    <tr><td class="paramname">c</td><td></td></tr>
    <tr><td class="paramname">width</td><td></td></tr>
    <tr><td class="paramname">fill</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1a355ec6a3dc7d99e96765a4e30f6610" name="a1a355ec6a3dc7d99e96765a4e30f6610"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a355ec6a3dc7d99e96765a4e30f6610">&#9670;&#160;</a></span>drawQuad2() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vcl::drawQuad2 </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; <a class="el" href="group__space.html#ga4b02e85ff4d51fe7d689f8dd0e87ecd5">Point2d</a>, 4 &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvcl_1_1Color.html">Color</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fill</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>drawQuad2 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td></td></tr>
    <tr><td class="paramname">c</td><td></td></tr>
    <tr><td class="paramname">width</td><td></td></tr>
    <tr><td class="paramname">fill</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3fb32ee3ac1da460849e059415520f17" name="a3fb32ee3ac1da460849e059415520f17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fb32ee3ac1da460849e059415520f17">&#9670;&#160;</a></span>drawQuad3()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vcl::drawQuad3 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__space.html#gabb47c1364fb2fe1464a54417684f011e">Point3d</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__space.html#gabb47c1364fb2fe1464a54417684f011e">Point3d</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__space.html#gabb47c1364fb2fe1464a54417684f011e">Point3d</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__space.html#gabb47c1364fb2fe1464a54417684f011e">Point3d</a> &amp;&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>drawQuad3 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td></td></tr>
    <tr><td class="paramname">b</td><td></td></tr>
    <tr><td class="paramname">c</td><td></td></tr>
    <tr><td class="paramname">d</td><td></td></tr>
    <tr><td class="paramname">width</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7f7d585e242c1ea867826bdffeff032b" name="a7f7d585e242c1ea867826bdffeff032b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f7d585e242c1ea867826bdffeff032b">&#9670;&#160;</a></span>drawSegment3()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vcl::drawSegment3 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__space.html#gabb47c1364fb2fe1464a54417684f011e">Point3d</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__space.html#gabb47c1364fb2fe1464a54417684f011e">Point3d</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvcl_1_1Color.html">Color</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacevcl.html#ae16b4f65fcbf4d8d8168e0e16f1a47b7" title="drawLine">drawLine3</a> </dd></dl>

</div>
</div>
<a id="ac7eed248a4465f8e5b2c1db86515e27b" name="ac7eed248a4465f8e5b2c1db86515e27b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7eed248a4465f8e5b2c1db86515e27b">&#9670;&#160;</a></span>drawSphere()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vcl::drawSphere </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__space.html#gabb47c1364fb2fe1464a54417684f011e">Point3d</a> &amp;&#160;</td>
          <td class="paramname"><em>center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvcl_1_1Color.html">Color</a> &amp;&#160;</td>
          <td class="paramname"><em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>precision</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draws a sphere with opengl. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">center</td><td>coordinates of the center of the sphere </td></tr>
    <tr><td class="paramname">radius</td><td>radius of the sphere </td></tr>
    <tr><td class="paramname">color</td><td>color of the sphere </td></tr>
    <tr><td class="paramname">precision</td><td>precision of the rendered sphere (default: 4) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab78db3f7c64deb1008fb9e8b7f881e2d" name="ab78db3f7c64deb1008fb9e8b7f881e2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab78db3f7c64deb1008fb9e8b7f881e2d">&#9670;&#160;</a></span>drawTriangle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vcl::drawTriangle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__space.html#gabb47c1364fb2fe1464a54417684f011e">Point3d</a> &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__space.html#gabb47c1364fb2fe1464a54417684f011e">Point3d</a> &amp;&#160;</td>
          <td class="paramname"><em>p2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__space.html#gabb47c1364fb2fe1464a54417684f011e">Point3d</a> &amp;&#160;</td>
          <td class="paramname"><em>p3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvcl_1_1Color.html">Color</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fill</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>drawTriangle </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p1</td><td></td></tr>
    <tr><td class="paramname">p2</td><td></td></tr>
    <tr><td class="paramname">p3</td><td></td></tr>
    <tr><td class="paramname">c</td><td></td></tr>
    <tr><td class="paramname">width</td><td></td></tr>
    <tr><td class="paramname">fill</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad939bbe736d6a065e65c0b84b88b04d4" name="ad939bbe736d6a065e65c0b84b88b04d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad939bbe736d6a065e65c0b84b88b04d4">&#9670;&#160;</a></span>drawTriangle2() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vcl::drawTriangle2 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__space.html#ga4b02e85ff4d51fe7d689f8dd0e87ecd5">Point2d</a> &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__space.html#ga4b02e85ff4d51fe7d689f8dd0e87ecd5">Point2d</a> &amp;&#160;</td>
          <td class="paramname"><em>p2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__space.html#ga4b02e85ff4d51fe7d689f8dd0e87ecd5">Point2d</a> &amp;&#160;</td>
          <td class="paramname"><em>p3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvcl_1_1Color.html">Color</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fill</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>drawTriangle2 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p1</td><td></td></tr>
    <tr><td class="paramname">p2</td><td></td></tr>
    <tr><td class="paramname">p3</td><td></td></tr>
    <tr><td class="paramname">c</td><td></td></tr>
    <tr><td class="paramname">width</td><td></td></tr>
    <tr><td class="paramname">fill</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af62e633fc49d9f0d17b0c72b10ca6e8d" name="af62e633fc49d9f0d17b0c72b10ca6e8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af62e633fc49d9f0d17b0c72b10ca6e8d">&#9670;&#160;</a></span>drawTriangle2() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vcl::drawTriangle2 </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; <a class="el" href="group__space.html#ga4b02e85ff4d51fe7d689f8dd0e87ecd5">Point2d</a>, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvcl_1_1Color.html">Color</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fill</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>drawTriangle2 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arr</td><td></td></tr>
    <tr><td class="paramname">c</td><td></td></tr>
    <tr><td class="paramname">width</td><td></td></tr>
    <tr><td class="paramname">fill</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3983ab4b434d669a765240b81daa236e" name="a3983ab4b434d669a765240b81daa236e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3983ab4b434d669a765240b81daa236e">&#9670;&#160;</a></span>earCut()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceConcept Face&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> &gt; vcl::earCut </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvcl_1_1Face.html">Face</a> &amp;&#160;</td>
          <td class="paramname"><em>polygon</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the earcut algorithm of a 3D <em>planar</em> polygon, that returns a triangulation of the polygon. </p>
<p>Returns a list of indices in which each index is the index of a point of the 3D input polgon, organized in triplets, each one of these is a triangle of the resulting triangulation.</p>
<p>This algorithm first computes the normal of the given polygon, then projects it in a 2D plane and executes the classic 2D EarCut algorithm.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="el" href="classvcl_1_1Face.html" title="The Face class.">Face</a></td><td>the type of the face that satisfies the FaceConcept.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">polygon</td><td>A (polygonal) face of a <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">vcl::Mesh</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of indices, representing the triplets of the triangulation of the polygon. </dd></dl>

</div>
</div>
<a id="a77bd6f212cc6ca4ad37ce181c2ba6d1b" name="a77bd6f212cc6ca4ad37ce181c2ba6d1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77bd6f212cc6ca4ad37ce181c2ba6d1b">&#9670;&#160;</a></span>edgeAdjacentFacesNumber()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceConcept FaceType&gt; <br />
requires comp::HasAdjacentFaces&lt;FaceType&gt;</div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> vcl::edgeAdjacentFacesNumber </td>
          <td>(</td>
          <td class="paramtype">const FaceType &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a>&#160;</td>
          <td class="paramname"><em>edge</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of adjacent faces to the given edge of the face f. </p>
<p>If the given edge is manifold, the returned number will be 1 (if the edge is on border - just one face) or 2 (two adjacent faces on the edge). If the edge is non manifold, the number of faces adjacent to the given face will be counted.</p>
<p>This function requires AdjacentFaces component, that must be enabled and computed before calling this function.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FaceType</td><td>the type of the face that satisfies the FaceConcept.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>the face containing the edge </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">edge</td><td>the index of the edge of the face </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of adjacent faces to the given edge of the face <code>f</code> </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classvcl_1_1MissingComponentException.html">vcl::MissingComponentException</a></td><td>If the "AdjacentFaces" component is not enabled on <code>f</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a59d8e830fa317191e2d02ff5cafc7149" name="a59d8e830fa317191e2d02ff5cafc7149"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59d8e830fa317191e2d02ff5cafc7149">&#9670;&#160;</a></span>edgeMatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matrix , EdgeMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Matrix vcl::edgeMatrix </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a #V*3 Matrix of scalars containing the coordinates of the vertices of a <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>. The function is templated on the Matrix itself. </p>
<p>This function works with every Matrix type that:</p><ul>
<li>has a constructor with rows and columns numbers;</li>
<li>has the <code>()</code> operator to acces to the (i,j) element (e.g.: <code>M(i,j) = 0;</code>).</li>
</ul>
<p>Usage example with Eigen Matrix:</p>
<div class="fragment"><div class="line">   Eigen::MatrixX3d V = vcl::vertexMatrix&lt;Eigen::MatrixX3d&gt;(myMesh);</div>
<div class="line">   <span class="keyword">@end</span><span class="keywordflow">if</span></div>
<div class="line">  </div>
<div class="line">   Requirements:</div>
<div class="line">   - Mesh:</div>
<div class="line">     - Vertices</div>
<div class="line">  </div>
<div class="line">   @param[in] mesh: input mesh</div>
<div class="line">   @<span class="keywordflow">return</span> #V*3 matrix of scalars (vertex coordinates)</div>
<div class="line">  /</div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Matrix, MeshConcept MeshType&gt;</div>
<div class="line">Matrix <a class="code hl_function" href="namespacevcl.html#aa7b813fbc070c26bf20205c4d9adb98a">vertexMatrix</a>(<span class="keyword">const</span> MeshType&amp; mesh)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">using </span>VertexType = <span class="keyword">typename</span> MeshType::VertexType;</div>
<div class="line"> </div>
<div class="line">    Matrix V(mesh.vertexNumber(), 3);</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_typedef" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> i = 0;</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> VertexType&amp; v : mesh.vertices()) {</div>
<div class="line">        <span class="keywordflow">for</span> (<a class="code hl_typedef" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> j = 0; j &lt; 3; ++j) {</div>
<div class="line">            V(i, j) = v.coord()[j];</div>
<div class="line">        }</div>
<div class="line">        ++i;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> V;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Matrix, FaceMeshConcept MeshType&gt;</div>
<div class="line">Matrix <a class="code hl_function" href="namespacevcl.html#a3d24eb3ce9ebe9df51ee8862901f7d70">faceMatrix</a>(<span class="keyword">const</span> MeshType&amp; mesh)</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_function" href="namespacevcl.html#ae5e94dd9b89e9bc4fb21701af6e788ca">vcl::requireVertexContainerCompactness</a>(mesh);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">using </span>VertexType = <span class="keyword">typename</span> MeshType::VertexType;</div>
<div class="line">    <span class="keyword">using </span>FaceType = <span class="keyword">typename</span> MeshType::FaceType;</div>
<div class="line"> </div>
<div class="line">    Matrix F(mesh.faceNumber(), 3);</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_typedef" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> i = 0;</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> FaceType&amp; f : mesh.faces()){</div>
<div class="line">        <span class="comment">// check if this face is greater than the cols of the matrix</span></div>
<div class="line">        <span class="keywordflow">if</span> (f.vertexNumber() &gt; F.cols()) { <span class="comment">// need to resize</span></div>
<div class="line">            <a class="code hl_typedef" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> oldCols = F.cols(); <span class="comment">// save old cols number</span></div>
<div class="line">            F.conservativeResize(F.rows(), f.vertexNumber());</div>
<div class="line">            <span class="comment">// need to set to -1 all the previous rows that have been resized</span></div>
<div class="line">            <span class="keywordflow">for</span> (<a class="code hl_typedef" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> k = 0; k &lt; i; ++k){</div>
<div class="line">                <span class="keywordflow">for</span> (<a class="code hl_typedef" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> j = oldCols; j &lt; F.cols(); ++j)</div>
<div class="line">                    F(k, j) = -1;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">        <a class="code hl_typedef" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> j = 0;</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> VertexType* v : f.vertices()){</div>
<div class="line">            F(i, j) = mesh.index(v);</div>
<div class="line">            j++;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">for</span> (; j &lt; F.cols(); ++j) <span class="comment">// remaining vertices set to -1</span></div>
<div class="line">            F(i, j ) = -1;</div>
<div class="line">        ++i; <span class="comment">// go to next face/row</span></div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> F;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="ttc" id="anamespacevcl_html_a3d24eb3ce9ebe9df51ee8862901f7d70"><div class="ttname"><a href="namespacevcl.html#a3d24eb3ce9ebe9df51ee8862901f7d70">vcl::faceMatrix</a></div><div class="ttdeci">Matrix faceMatrix(const MeshType &amp;m)</div></div>
<div class="ttc" id="anamespacevcl_html_aa7b813fbc070c26bf20205c4d9adb98a"><div class="ttname"><a href="namespacevcl.html#aa7b813fbc070c26bf20205c4d9adb98a">vcl::vertexMatrix</a></div><div class="ttdeci">Matrix vertexMatrix(const MeshType &amp;m)</div></div>
<div class="ttc" id="anamespacevcl_html_ae5e94dd9b89e9bc4fb21701af6e788ca"><div class="ttname"><a href="namespacevcl.html#ae5e94dd9b89e9bc4fb21701af6e788ca">vcl::requireVertexContainerCompactness</a></div><div class="ttdeci">void requireVertexContainerCompactness(const MeshType &amp;m)</div><div class="ttdef"><b>Definition:</b> vertex_requirements.cpp:292</div></div>
</div><!-- fragment --><p>Requirements:</p><ul>
<li><a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>:<ul>
<li>Edges</li>
<li>Vertices<ul>
<li>Compactness</li>
</ul>
</li>
</ul>
</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>input mesh </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>#E*2 matrix of integers (edge indices) </dd></dl>

</div>
</div>
<a id="acb30f645e6cc1b2c1d8655f445bf1843" name="acb30f645e6cc1b2c1d8655f445bf1843"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb30f645e6cc1b2c1d8655f445bf1843">&#9670;&#160;</a></span>enableIfPerFaceAdjacentFacesOptional()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool vcl::enableIfPerFaceAdjacentFacesOptional </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af3262073d55561ee24b5cfcc22250ee1" name="af3262073d55561ee24b5cfcc22250ee1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3262073d55561ee24b5cfcc22250ee1">&#9670;&#160;</a></span>enableIfPerFaceColorOptional()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool vcl::enableIfPerFaceColorOptional </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0efcb1c23b82c5c20f26149672806012" name="a0efcb1c23b82c5c20f26149672806012"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0efcb1c23b82c5c20f26149672806012">&#9670;&#160;</a></span>enableIfPerFaceMarkOptional()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool vcl::enableIfPerFaceMarkOptional </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af07e8fad913b41d5db61c140e24d35c4" name="af07e8fad913b41d5db61c140e24d35c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af07e8fad913b41d5db61c140e24d35c4">&#9670;&#160;</a></span>enableIfPerFaceNormalOptional()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool vcl::enableIfPerFaceNormalOptional </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7e4d93cc27448070bbb26df5cf3c200a" name="a7e4d93cc27448070bbb26df5cf3c200a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e4d93cc27448070bbb26df5cf3c200a">&#9670;&#160;</a></span>enableIfPerFacePrincipalCurvatureOptional()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool vcl::enableIfPerFacePrincipalCurvatureOptional </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac0eb8cf1210036e1819699354a854a76" name="ac0eb8cf1210036e1819699354a854a76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0eb8cf1210036e1819699354a854a76">&#9670;&#160;</a></span>enableIfPerFaceScalarOptional()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool vcl::enableIfPerFaceScalarOptional </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af2bc7d8c340f922fda76e1d01588433c" name="af2bc7d8c340f922fda76e1d01588433c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2bc7d8c340f922fda76e1d01588433c">&#9670;&#160;</a></span>enableIfPerFaceWedgeColorsOptional()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool vcl::enableIfPerFaceWedgeColorsOptional </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5cfd1a61b06b32978aa70024f8b8e8f3" name="a5cfd1a61b06b32978aa70024f8b8e8f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cfd1a61b06b32978aa70024f8b8e8f3">&#9670;&#160;</a></span>enableIfPerFaceWedgeTexCoordsOptional()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool vcl::enableIfPerFaceWedgeTexCoordsOptional </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab916befe515685645779ed6e6496ef7f" name="ab916befe515685645779ed6e6496ef7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab916befe515685645779ed6e6496ef7f">&#9670;&#160;</a></span>enableIfPerHalfEdgeColorOptional()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;DcelMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool vcl::enableIfPerHalfEdgeColorOptional </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abb7133d4f4f203243589a002605dcbc3" name="abb7133d4f4f203243589a002605dcbc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb7133d4f4f203243589a002605dcbc3">&#9670;&#160;</a></span>enableIfPerHalfEdgeMarkOptional()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;DcelMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool vcl::enableIfPerHalfEdgeMarkOptional </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a45ba8ec2901d287606faca1bb8c8c224" name="a45ba8ec2901d287606faca1bb8c8c224"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45ba8ec2901d287606faca1bb8c8c224">&#9670;&#160;</a></span>enableIfPerHalfEdgeScalarOptional()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;DcelMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool vcl::enableIfPerHalfEdgeScalarOptional </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9c874ee251571b905630d390b33a566c" name="a9c874ee251571b905630d390b33a566c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c874ee251571b905630d390b33a566c">&#9670;&#160;</a></span>enableIfPerHalfEdgeTexCoordOptional()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;DcelMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool vcl::enableIfPerHalfEdgeTexCoordOptional </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a617cf756eac51fcf6b566ce5d4c09393" name="a617cf756eac51fcf6b566ce5d4c09393"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a617cf756eac51fcf6b566ce5d4c09393">&#9670;&#160;</a></span>enableIfPerVertexAdjacentFacesOptional()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool vcl::enableIfPerVertexAdjacentFacesOptional </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6e15c93274d1207f45bb0673fce3ba8a" name="a6e15c93274d1207f45bb0673fce3ba8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e15c93274d1207f45bb0673fce3ba8a">&#9670;&#160;</a></span>enableIfPerVertexAdjacentVerticesOptional()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool vcl::enableIfPerVertexAdjacentVerticesOptional </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a802d56a620a24d04972ba5d483a2730a" name="a802d56a620a24d04972ba5d483a2730a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a802d56a620a24d04972ba5d483a2730a">&#9670;&#160;</a></span>enableIfPerVertexColorOptional()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool vcl::enableIfPerVertexColorOptional </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a64bde18cc07f8804c0c96e5def984f26" name="a64bde18cc07f8804c0c96e5def984f26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64bde18cc07f8804c0c96e5def984f26">&#9670;&#160;</a></span>enableIfPerVertexMarkOptional()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool vcl::enableIfPerVertexMarkOptional </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af4a7a739d6f30a2e4768b7b12c663418" name="af4a7a739d6f30a2e4768b7b12c663418"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4a7a739d6f30a2e4768b7b12c663418">&#9670;&#160;</a></span>enableIfPerVertexNormalOptional()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool vcl::enableIfPerVertexNormalOptional </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a579b161f8a4132e5106608bebc70e363" name="a579b161f8a4132e5106608bebc70e363"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a579b161f8a4132e5106608bebc70e363">&#9670;&#160;</a></span>enableIfPerVertexPrincipalCurvatureOptional()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool vcl::enableIfPerVertexPrincipalCurvatureOptional </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad25a1b222bdd0347c1cdfa9d25ffa191" name="ad25a1b222bdd0347c1cdfa9d25ffa191"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad25a1b222bdd0347c1cdfa9d25ffa191">&#9670;&#160;</a></span>enableIfPerVertexScalarOptional()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool vcl::enableIfPerVertexScalarOptional </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a369d2067cce035b7b4a710c5b364a28c" name="a369d2067cce035b7b4a710c5b364a28c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a369d2067cce035b7b4a710c5b364a28c">&#9670;&#160;</a></span>enableIfPerVertexTexCoordOptional()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool vcl::enableIfPerVertexTexCoordOptional </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2dc92e18b3bf638868ab5a3fa204a54d" name="a2dc92e18b3bf638868ab5a3fa204a54d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2dc92e18b3bf638868ab5a3fa204a54d">&#9670;&#160;</a></span>epsilonCompare()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool vcl::epsilonCompare </td>
          <td>(</td>
          <td class="paramtype">Scalar&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Scalar&#160;</td>
          <td class="paramname"><em>p2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Scalar&#160;</td>
          <td class="paramname"><em>epsilon</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a12529598a32a7b21eac27744b3578600" name="a12529598a32a7b21eac27744b3578600"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12529598a32a7b21eac27744b3578600">&#9670;&#160;</a></span>faceAngleOnVertexRad()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceConcept FaceType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto vcl::faceAngleOnVertexRad </td>
          <td>(</td>
          <td class="paramtype">const FaceType &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a>&#160;</td>
          <td class="paramname"><em>vi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the internal angle (in radians) of the vi-th vertex of the face. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FaceType</td><td>the type of the face that satisfies the FaceConcept.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>the input face. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vi</td><td>the index of the vertex in the face on which calculate the angle </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the angle in radians at the vi-th vertex. </dd></dl>

</div>
</div>
<a id="a9fc3b9cae851d7a729f40dc2f4ebe824" name="a9fc3b9cae851d7a729f40dc2f4ebe824"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fc3b9cae851d7a729f40dc2f4ebe824">&#9670;&#160;</a></span>faceArea()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceConcept FaceType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto vcl::faceArea </td>
          <td>(</td>
          <td class="paramtype">const FaceType &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the area of a face. Works both for triangle and polygonal faces, and it is optimized in case of triangle faces. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FaceType</td><td>the type of the face that satisfies the FaceConcept.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>the input face. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the area of the face. </dd></dl>

</div>
</div>
<a id="a53b4f63db0979e578ebfa4b9e8b41f8a" name="a53b4f63db0979e578ebfa4b9e8b41f8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53b4f63db0979e578ebfa4b9e8b41f8a">&#9670;&#160;</a></span>faceBarycenter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceConcept FaceType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">FaceType::VertexType::CoordType vcl::faceBarycenter </td>
          <td>(</td>
          <td class="paramtype">const FaceType &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the barycenter of a face. Works both for triangle and polygonal faces, and it is optimized in case of triangle faces. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FaceType</td><td>the type of the face that satisfies the FaceConcept.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>the input face. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the barycenter of the face. </dd></dl>

</div>
</div>
<a id="abb99398069d243b6bb7b09e55a279792" name="abb99398069d243b6bb7b09e55a279792"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb99398069d243b6bb7b09e55a279792">&#9670;&#160;</a></span>faceBoxIntersect()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceConcept FaceType, PointConcept PointType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool vcl::faceBoxIntersect </td>
          <td>(</td>
          <td class="paramtype">const FaceType &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvcl_1_1Box.html">Box</a>&lt; PointType &gt; &amp;&#160;</td>
          <td class="paramname"><em>box</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa89dee93752905adc3252463a187c046" name="aa89dee93752905adc3252463a187c046"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa89dee93752905adc3252463a187c046">&#9670;&#160;</a></span>faceCoords()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceConcept FaceType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto vcl::faceCoords </td>
          <td>(</td>
          <td class="paramtype">const FaceType &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2177afd92cfc4dbe6468aa05892b016f" name="a2177afd92cfc4dbe6468aa05892b016f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2177afd92cfc4dbe6468aa05892b016f">&#9670;&#160;</a></span>faceDihedralAngleOnEdge()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceConcept FaceType&gt; <br />
requires comp::HasAdjacentFaces&lt;FaceType&gt;</div>
      <table class="memname">
        <tr>
          <td class="memname">auto vcl::faceDihedralAngleOnEdge </td>
          <td>(</td>
          <td class="paramtype">const FaceType &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a>&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the signed dihedral angle between the normals of the given face and its adjacent face on the edge <code>e</code>. </p>
<p>*</p>
<p>The angle between the normal is signed according to the concavity/convexity of the dihedral angle: negative if the edge shared between the two faces is concave, positive otherwise. The surface it is assumend to be oriented. It simply use the projection of the opposite vertex onto the plane of the other one. It does not assume anything on face normals.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FaceType</td><td>the type of the face that satisfies the FaceConcept.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>The face for which to compute the dihedral angle on an edge. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">e</td><td>The index of the edge shared between the two faces. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The signed dihedral angle between the normals of the given face and its adjacent face on the edge e. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classvcl_1_1MissingComponentException.html">vcl::MissingComponentException</a></td><td>If the "AdjacentFaces" component is not enabled on <code>f</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a711865422c63688724ec6328b4e7c4cd" name="a711865422c63688724ec6328b4e7c4cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a711865422c63688724ec6328b4e7c4cd">&#9670;&#160;</a></span>faceEdgesOnBorderNumber()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceConcept FaceType&gt; <br />
requires comp::HasAdjacentFaces&lt;FaceType&gt;</div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> vcl::faceEdgesOnBorderNumber </td>
          <td>(</td>
          <td class="paramtype">const FaceType &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of edges that are on border (no adjacent faces) on the given face. </p>
<p>This function requires AdjacentFaces component, that must be enabled and computed before calling this function.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FaceType</td><td>the type of the face that satisfies the FaceConcept.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>The face to check for border edges. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of edges on the border of the face.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classvcl_1_1MissingComponentException.html">vcl::MissingComponentException</a></td><td>If the "AdjacentFaces" component is not enabled on <code>f</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3d24eb3ce9ebe9df51ee8862901f7d70" name="a3d24eb3ce9ebe9df51ee8862901f7d70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d24eb3ce9ebe9df51ee8862901f7d70">&#9670;&#160;</a></span>faceMatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matrix , FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Matrix vcl::faceMatrix </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a350d3edc324e0bef955a2c2ef8e20859" name="a350d3edc324e0bef955a2c2ef8e20859"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a350d3edc324e0bef955a2c2ef8e20859">&#9670;&#160;</a></span>faceNormal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceConcept FaceType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">FaceType::VertexType::CoordType vcl::faceNormal </td>
          <td>(</td>
          <td class="paramtype">const FaceType &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the normal of a face, without modifying the face. Works both for triangle and polygonal faces, and it is optimized in case of triangle faces. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FaceType</td><td>the type of the face that satisfies the FaceConcept.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>the input face. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the normal of the face. </dd></dl>

</div>
</div>
<a id="a1dccfede16e36e5ded5213fb13643943" name="a1dccfede16e36e5ded5213fb13643943"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dccfede16e36e5ded5213fb13643943">&#9670;&#160;</a></span>facePerimeter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceConcept FaceType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto vcl::facePerimeter </td>
          <td>(</td>
          <td class="paramtype">const FaceType &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the perimeter of a face. Works both for triangle and polygonal faces, and it is optimized in case of triangle faces. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FaceType</td><td>the type of the face that satisfies the FaceConcept.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>the input face. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the perimeter of the face. </dd></dl>

</div>
</div>
<a id="a2325a44d0d3b56eb04cd498d4a233ae5" name="a2325a44d0d3b56eb04cd498d4a233ae5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2325a44d0d3b56eb04cd498d4a233ae5">&#9670;&#160;</a></span>faceScalarAverage()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">MeshType::FaceType::ScalarType vcl::faceScalarAverage </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a scalar that is the average of the face scalars. </p>
<p>Requirements:</p><ul>
<li><a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>:<ul>
<li>Faces:<ul>
<li>Scalar</li>
</ul>
</li>
</ul>
</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>the input <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a> on which compute the average of the scalars. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The average of the face scalars of the given mesh. </dd></dl>

</div>
</div>
<a id="a841b98019d6492c95446f2ae39917934" name="a841b98019d6492c95446f2ae39917934"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a841b98019d6492c95446f2ae39917934">&#9670;&#160;</a></span>faceScalarHistogram()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType, typename HScalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Histogram.html">Histogram</a>&lt; HScalar &gt; vcl::faceScalarHistogram </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>selectionOnly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a>&#160;</td>
          <td class="paramname"><em>histSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8aea6a69e2b5319acebef66b06bd6692" name="a8aea6a69e2b5319acebef66b06bd6692"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8aea6a69e2b5319acebef66b06bd6692">&#9670;&#160;</a></span>faceScalarMinMax()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; typename MeshType::FaceType::ScalarType, typename MeshType::FaceType::ScalarType &gt; vcl::faceScalarMinMax </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a pair containing the min and the maximum face scalars. </p>
<p>Requirements:</p><ul>
<li><a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>:<ul>
<li>Faces:<ul>
<li>Scalar</li>
</ul>
</li>
</ul>
</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>the input <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a> on which compute the minimum and the maximum scalars. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code>std::pair</code> having as first element the minimum, and as second element the maximum scalar. </dd></dl>

</div>
</div>
<a id="a5585995167e0f9338ebb153314c0067b" name="a5585995167e0f9338ebb153314c0067b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5585995167e0f9338ebb153314c0067b">&#9670;&#160;</a></span>faceSelectionNumber()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> vcl::faceSelectionNumber </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9a74b10bc09834d0a2d787336a5f7823" name="a9a74b10bc09834d0a2d787336a5f7823"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a74b10bc09834d0a2d787336a5f7823">&#9670;&#160;</a></span>faceSphereItersect() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceConcept FaceType, typename SScalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool vcl::faceSphereItersect </td>
          <td>(</td>
          <td class="paramtype">const FaceType &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvcl_1_1Sphere.html">Sphere</a>&lt; SScalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>sphere</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the intersection between a sphere and a face, that may be also polygonal. </p>
<p>If the face is a triangle, the triangleSphereIntersect function will be used. If the face is polygonal, the face is first triangulated using an earcut algorithm, and then for each triangle, the triangleSphereIntersect is computed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>the input face </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sphere</td><td>the input sphere </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true iff there is an intersection between the sphere and the face </dd></dl>

</div>
</div>
<a id="a0cec6eee8e30eefd8783a997a48127fa" name="a0cec6eee8e30eefd8783a997a48127fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cec6eee8e30eefd8783a997a48127fa">&#9670;&#160;</a></span>faceSphereItersect() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceConcept FaceType, PointConcept PointType, typename SScalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool vcl::faceSphereItersect </td>
          <td>(</td>
          <td class="paramtype">const FaceType &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvcl_1_1Sphere.html">Sphere</a>&lt; SScalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>sphere</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PointType &amp;&#160;</td>
          <td class="paramname"><em>witness</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::pair&lt; SScalar, SScalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>res</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the intersection between a sphere and a face, that may be also polygonal. </p>
<p>If the face is a triangle, the triangleSphereIntersect function will be used. If the face is polygonal, the face is first triangulated using an earcut algorithm, and then for each triangle, the triangleSphereIntersect is computed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>the input face </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sphere</td><td>the input sphere </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">witness</td><td>the point on the triangle nearest to the center of the sphere (even when there isn't intersection) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">res</td><td>if not null, in the first item is stored the minimum distance between the face and the sphere, while in the second item is stored the penetration depth </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true iff there is an intersection between the sphere and the face </dd></dl>

</div>
</div>
<a id="a3049b170706391972a31e8d746877e55" name="a3049b170706391972a31e8d746877e55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3049b170706391972a31e8d746877e55">&#9670;&#160;</a></span>fillAndShuffleFaceIndexVector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> &gt; vcl::fillAndShuffleFaceIndexVector </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>deterministic</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acf22261daf1773fd04458b9df1c56500" name="acf22261daf1773fd04458b9df1c56500"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf22261daf1773fd04458b9df1c56500">&#9670;&#160;</a></span>fillAndShuffleFacePointerVector() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; const typename MeshType::FaceType * &gt; vcl::fillAndShuffleFacePointerVector </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>deterministic</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2dcdb951920e460a95c3aa6b85fda047" name="a2dcdb951920e460a95c3aa6b85fda047"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2dcdb951920e460a95c3aa6b85fda047">&#9670;&#160;</a></span>fillAndShuffleFacePointerVector() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; typename MeshType::FaceType * &gt; vcl::fillAndShuffleFacePointerVector </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>deterministic</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abfd59977983dd4b0f0dc907c6b88c66b" name="abfd59977983dd4b0f0dc907c6b88c66b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfd59977983dd4b0f0dc907c6b88c66b">&#9670;&#160;</a></span>fillAndShuffleVertexIndexVector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> &gt; vcl::fillAndShuffleVertexIndexVector </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>deterministic</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a59d8791cc0d0b3f02cb4d41a0d5882a4" name="a59d8791cc0d0b3f02cb4d41a0d5882a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59d8791cc0d0b3f02cb4d41a0d5882a4">&#9670;&#160;</a></span>fillAndShuffleVertexPointerVector() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; const typename MeshType::VertexType * &gt; vcl::fillAndShuffleVertexPointerVector </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>deterministic</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1de4c115d6d43fdd8ace65d0cc333222" name="a1de4c115d6d43fdd8ace65d0cc333222"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1de4c115d6d43fdd8ace65d0cc333222">&#9670;&#160;</a></span>fillAndShuffleVertexPointerVector() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; typename MeshType::VertexType * &gt; vcl::fillAndShuffleVertexPointerVector </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>deterministic</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a88fd48e496c91294c52b286f8d9abd97" name="a88fd48e496c91294c52b286f8d9abd97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88fd48e496c91294c52b286f8d9abd97">&#9670;&#160;</a></span>fillAndSortMeshEdgeUtilVector() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classvcl_1_1ConstMeshEdgeUtil.html">ConstMeshEdgeUtil</a>&lt; MeshType &gt; &gt; vcl::fillAndSortMeshEdgeUtilVector </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>includeFauxEdges</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af62bcbd9846a668e72b01f6f06df4962" name="af62bcbd9846a668e72b01f6f06df4962"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af62bcbd9846a668e72b01f6f06df4962">&#9670;&#160;</a></span>fillAndSortMeshEdgeUtilVector() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classvcl_1_1MeshEdgeUtil.html">MeshEdgeUtil</a>&lt; MeshType &gt; &gt; vcl::fillAndSortMeshEdgeUtilVector </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>includeFauxEdges</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abbf2dd04b5f4477ba07ab217dd603d14" name="abbf2dd04b5f4477ba07ab217dd603d14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbf2dd04b5f4477ba07ab217dd603d14">&#9670;&#160;</a></span>fitPlaneToPointCloud()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Plane.html">Plane</a>&lt; Scalar &gt; vcl::fitPlaneToPointCloud </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="group__space.html#ga13f2718b0763def563b8bd9f65982833">Point3</a>&lt; Scalar &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>pointVec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the plane best fitting a set of points The algorithm used is the classical Covariance matrix eigenvector approach. </p>

</div>
</div>
<a id="af8d724d35f1e65a0966e980fc544364f" name="af8d724d35f1e65a0966e980fc544364f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8d724d35f1e65a0966e980fc544364f">&#9670;&#160;</a></span>fitPlaneToWeightedPointCloud()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Plane.html">Plane</a>&lt; Scalar &gt; vcl::fitPlaneToWeightedPointCloud </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="group__space.html#ga13f2718b0763def563b8bd9f65982833">Point3</a>&lt; Scalar &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>pointVec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the plane best fitting a wighted set of points The algorithm used is the wighted Covariance matrix eigenvector approach. </p>

</div>
</div>
<a id="a58a47028bed1d2e5df56ae17dccaeced" name="a58a47028bed1d2e5df56ae17dccaeced"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58a47028bed1d2e5df56ae17dccaeced">&#9670;&#160;</a></span>generateMeshFromFaceBoolVector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept InMeshType, MeshConcept OutMeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OutMeshType vcl::generateMeshFromFaceBoolVector </td>
          <td>(</td>
          <td class="paramtype">const InMeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; bool &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>saveBirthIndicesInCustomComponent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates and returns a new mesh that is composed of the faces of the input mesh <code>m</code> having their value in the input vector of booleans <code>vec</code> set to true. Only vertices belonging to the imported faces will be imported in the output mesh. </p>
<p>By default, the type of the output mesh will be the same of the input mesh type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>input mesh </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vec</td><td>vector of booleans that will tell which faces put in the output mesh. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">saveBirthIndicesInCustomComponent</td><td>if <code>true</code> (default), and if the output mesh type has the per vertex and/or per face CustomComponents component, will set a per vertex/per face custom component of type <code>uint</code> in the output mesh telling, for each vertex/face, the index of its birth vertex/birth face in the input mesh. The names of the custom components are <code>"birthVertex"</code> and <code>"birthFace"</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a667ab307eae18191ae03623ea329be05" name="a667ab307eae18191ae03623ea329be05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a667ab307eae18191ae03623ea329be05">&#9670;&#160;</a></span>generateMeshFromVertexBoolVector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept InMeshType, MeshConcept OutMeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OutMeshType vcl::generateMeshFromVertexBoolVector </td>
          <td>(</td>
          <td class="paramtype">const InMeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; bool &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>saveBirthIndicesInCustomComponent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates and returns a new mesh that is composed of the vertices of the input mesh <code>m</code> having their value in the input vector of booleans <code>vec</code> set to true. </p>
<p>By default, the type of the output mesh will be the same of the input mesh type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>input mesh </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vec</td><td>vector of booleans that will tell which vertices put in the output mesh. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">saveBirthIndicesInCustomComponent</td><td>if <code>true</code> (default), and if the output mesh type has the per vertex CustomComponents component, will set a per vertex custom component of type <code>uint</code> in the output mesh telling, for each vertex, the index of its birth vertex in the input mesh. The name of the custom component is <code>"birthVertex"</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="aeb189433c1c9d7bf52a96ff359f364ec" name="aeb189433c1c9d7bf52a96ff359f364ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb189433c1c9d7bf52a96ff359f364ec">&#9670;&#160;</a></span>hashCombine()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... Rest&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::hashCombine </td>
          <td>(</td>
          <td class="paramtype">std::size_t &amp;&#160;</td>
          <td class="paramname"><em>seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Rest &amp;...&#160;</td>
          <td class="paramname"><em>rest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starting from a seed, computes the hash of a series of objects. </p>
<p><a href="https://stackoverflow.com/a/57595105/5851101">https://stackoverflow.com/a/57595105/5851101</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">[in/out]</td><td>seed: input seed and output hash </td></tr>
    <tr><td class="paramname">v</td><td>first argument object </td></tr>
    <tr><td class="paramname">rest</td><td>rest of the argument objects </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a88893f1c397d1d0aca42ccb3e360c1db" name="a88893f1c397d1d0aca42ccb3e360c1db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88893f1c397d1d0aca42ccb3e360c1db">&#9670;&#160;</a></span>hausdorffDistance()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType1, MeshConcept MeshType2, LoggerConcept LogType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvcl_1_1HausdorffDistResult.html">HausdorffDistResult</a> vcl::hausdorffDistance </td>
          <td>(</td>
          <td class="paramtype">const MeshType1 &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MeshType2 &amp;&#160;</td>
          <td class="paramname"><em>m2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LogType &amp;&#160;</td>
          <td class="paramname"><em>log</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacevcl.html#a5a4e8376b2d47797f9167f2a8dd6fb0e">HausdorffSamplingMethod</a>&#160;</td>
          <td class="paramname"><em>sampMethod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a>&#160;</td>
          <td class="paramname"><em>nSamples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>deterministic</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae01694fdca8b252384be3296f82fa946" name="ae01694fdca8b252384be3296f82fa946"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae01694fdca8b252384be3296f82fa946">&#9670;&#160;</a></span>indexInTypePack()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename... Us&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> vcl::indexInTypePack </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a70dad48ffd4a840c11d422b0c3121393" name="a70dad48ffd4a840c11d422b0c3121393"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70dad48ffd4a840c11d422b0c3121393">&#9670;&#160;</a></span>intersectFunction()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Obj1 , typename Obj2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto vcl::intersectFunction </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a proper intersect function between a Obj1 object and an Obj2 object. </p>
<p>This function will return a function defined in a specialization of the struct <a class="el" href="structvcl_1_1IntersFunctionStruct.html">IntersFunctionStruct</a>.</p>
<p>The returned function is a std::function that takes in input two const references of the desired types and returns a boolean that tells if the two objects intersect.</p>
<p>If the intersection function for your types is not defined, you can write your own <a class="el" href="structvcl_1_1IntersFunctionStruct.html">IntersFunctionStruct</a> specialization that defines a proper <code>static const inline</code> object called <code>intersFun</code> of <code>std::function</code> type. </p>

</div>
</div>
<a id="acb9fbe7647f2b656ab871e2bb20b8c33" name="acb9fbe7647f2b656ab871e2bb20b8c33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb9fbe7647f2b656ab871e2bb20b8c33">&#9670;&#160;</a></span>isCompact()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool vcl::isCompact </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if a <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a> is compact, that is if it does not contains deleted elements. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <code>m</code> is compact, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="a33948b0cb8e44bec17d4b0dfef8bd254" name="a33948b0cb8e44bec17d4b0dfef8bd254"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33948b0cb8e44bec17d4b0dfef8bd254">&#9670;&#160;</a></span>isDegenerate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool vcl::isDegenerate </td>
          <td>(</td>
          <td class="paramtype">Scalar&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aca827384c3a3069cf55d77dc48e3f4fa" name="aca827384c3a3069cf55d77dc48e3f4fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca827384c3a3069cf55d77dc48e3f4fa">&#9670;&#160;</a></span>isFaceContainerCompact()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool vcl::isFaceContainerCompact </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>true</code> if the given mesh has its <a class="el" href="classvcl_1_1Face.html" title="The Face class.">Face</a> Container compact. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>input mesh on which test if the its <a class="el" href="classvcl_1_1Face.html" title="The Face class.">Face</a> Container is compact. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the <a class="el" href="classvcl_1_1Face.html" title="The Face class.">Face</a> Container of the mesh is compact. </dd></dl>

</div>
</div>
<a id="af888cb13421f6fb92d776927f302518b" name="af888cb13421f6fb92d776927f302518b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af888cb13421f6fb92d776927f302518b">&#9670;&#160;</a></span>isFaceEdgeOnBorder()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceConcept FaceType&gt; <br />
requires comp::HasAdjacentFaces&lt;FaceType&gt;</div>
      <table class="memname">
        <tr>
          <td class="memname">bool vcl::isFaceEdgeOnBorder </td>
          <td>(</td>
          <td class="paramtype">const FaceType &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a>&#160;</td>
          <td class="paramname"><em>edge</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if an edge in the given face is on the border. </p>
<p>An edge is considered to be on the border if it is not shared by another face.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FaceType</td><td>the type of the face that satisfies the FaceConcept.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>The face to check. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">edge</td><td>The index of the edge to check.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the edge is on the border, false otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classvcl_1_1MissingComponentException.html">vcl::MissingComponentException</a></td><td>If the "AdjacentFaces" component is not enabled on <code>f</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a25a86f4bcf104c60099849828d71e06f" name="a25a86f4bcf104c60099849828d71e06f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25a86f4bcf104c60099849828d71e06f">&#9670;&#160;</a></span>isFaceManifoldOnEdge()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceConcept FaceType&gt; <br />
requires comp::HasAdjacentFaces&lt;FaceType&gt;</div>
      <table class="memname">
        <tr>
          <td class="memname">bool vcl::isFaceManifoldOnEdge </td>
          <td>(</td>
          <td class="paramtype">const FaceType &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a>&#160;</td>
          <td class="paramname"><em>edge</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if an edge in the given face is manifold. </p>
<p>An edge is considered manifold if it is either a boundary edge or if it is shared by exactly two faces.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FaceType</td><td>the type of the face that satisfies the FaceConcept.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>The face to check. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">edge</td><td>The index of the edge to check.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the edge is manifold, false otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classvcl_1_1MissingComponentException.html">vcl::MissingComponentException</a></td><td>If the "AdjacentFaces" component is not enabled on <code>f</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6bce10c7a1576d043e084010b0481369" name="a6bce10c7a1576d043e084010b0481369"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bce10c7a1576d043e084010b0481369">&#9670;&#160;</a></span>isHalfEdgeContainerCompact()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;DcelMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool vcl::isHalfEdgeContainerCompact </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>true</code> if the given mesh has its <a class="el" href="classvcl_1_1HalfEdge.html" title="The HalfEdge class.">HalfEdge</a> Container compact. Returns <code>false</code> if the mesh has no <a class="el" href="classvcl_1_1HalfEdge.html" title="The HalfEdge class.">HalfEdge</a> Container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>input mesh on which test if the its <a class="el" href="classvcl_1_1HalfEdge.html" title="The HalfEdge class.">HalfEdge</a> Container is compact. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the <a class="el" href="classvcl_1_1HalfEdge.html" title="The HalfEdge class.">HalfEdge</a> Container of the mesh is compact. </dd></dl>

</div>
</div>
<a id="a9692d4f1afe48a370a2fe551d5ea55d4" name="a9692d4f1afe48a370a2fe551d5ea55d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9692d4f1afe48a370a2fe551d5ea55d4">&#9670;&#160;</a></span>isLoggerValid()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;LoggerConcept T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool vcl::isLoggerValid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The <a class="el" href="namespacevcl.html#a9692d4f1afe48a370a2fe551d5ea55d4" title="The isLoggerValid() function returns true if the type T is not the NullLogger type.">isLoggerValid()</a> function returns true if the type T is not the <a class="el" href="classvcl_1_1NullLogger.html" title="The NullLogger class is an empty class that is used as default type in all the library functions that...">NullLogger</a> type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the type to test if is a valid <a class="el" href="classvcl_1_1Logger.html">Logger</a>. It must satisfy the LoggerConcept.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true it T is a valid <a class="el" href="classvcl_1_1Logger.html">Logger</a> type. </dd></dl>

</div>
</div>
<a id="a0486aed98c9b93d69825d29579c8cefa" name="a0486aed98c9b93d69825d29579c8cefa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0486aed98c9b93d69825d29579c8cefa">&#9670;&#160;</a></span>isPerFaceAdjacentFacesEnabled()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool vcl::isPerFaceAdjacentFacesEnabled </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af39819c217b9f787d0c228d1c570d327" name="af39819c217b9f787d0c228d1c570d327"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af39819c217b9f787d0c228d1c570d327">&#9670;&#160;</a></span>isPerFaceColorEnabled()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool vcl::isPerFaceColorEnabled </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a882e488c25ef1d9a8de741319f5ab35e" name="a882e488c25ef1d9a8de741319f5ab35e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a882e488c25ef1d9a8de741319f5ab35e">&#9670;&#160;</a></span>isPerFaceMarkEnabled()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool vcl::isPerFaceMarkEnabled </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab2d03c59d458283eca7e0eb2fbaf7053" name="ab2d03c59d458283eca7e0eb2fbaf7053"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2d03c59d458283eca7e0eb2fbaf7053">&#9670;&#160;</a></span>isPerFaceNormalEnabled()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool vcl::isPerFaceNormalEnabled </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a66bf0c5e88fa00f72ef1ed429d1bf9c8" name="a66bf0c5e88fa00f72ef1ed429d1bf9c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66bf0c5e88fa00f72ef1ed429d1bf9c8">&#9670;&#160;</a></span>isPerFacePrincipalCurvatureEnabled()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool vcl::isPerFacePrincipalCurvatureEnabled </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2103ff0400b90b291072164ef4112794" name="a2103ff0400b90b291072164ef4112794"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2103ff0400b90b291072164ef4112794">&#9670;&#160;</a></span>isPerFaceScalarEnabled()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool vcl::isPerFaceScalarEnabled </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a24cf22a3269f6c86954cd90f452f6a91" name="a24cf22a3269f6c86954cd90f452f6a91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24cf22a3269f6c86954cd90f452f6a91">&#9670;&#160;</a></span>isPerFaceWedgeColorsEnabled()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool vcl::isPerFaceWedgeColorsEnabled </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aea40a37467f4117bc1d84760bbc8e082" name="aea40a37467f4117bc1d84760bbc8e082"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea40a37467f4117bc1d84760bbc8e082">&#9670;&#160;</a></span>isPerFaceWedgeTexCoordsEnabled()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool vcl::isPerFaceWedgeTexCoordsEnabled </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0de31119b41b551829bcec648f3e299e" name="a0de31119b41b551829bcec648f3e299e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0de31119b41b551829bcec648f3e299e">&#9670;&#160;</a></span>isPerHalfEdgeColorEnabled()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;DcelMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool vcl::isPerHalfEdgeColorEnabled </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a242bcb896ac0bb33e925c7b70ea3b283" name="a242bcb896ac0bb33e925c7b70ea3b283"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a242bcb896ac0bb33e925c7b70ea3b283">&#9670;&#160;</a></span>isPerHalfEdgeMarkEnabled()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;DcelMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool vcl::isPerHalfEdgeMarkEnabled </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab1ef3fad09c2f9fa34d0473f0a447c1d" name="ab1ef3fad09c2f9fa34d0473f0a447c1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1ef3fad09c2f9fa34d0473f0a447c1d">&#9670;&#160;</a></span>isPerHalfEdgeScalarEnabled()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;DcelMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool vcl::isPerHalfEdgeScalarEnabled </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae3c37ce92676691df1c039d463d48db6" name="ae3c37ce92676691df1c039d463d48db6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3c37ce92676691df1c039d463d48db6">&#9670;&#160;</a></span>isPerHalfEdgeTexCoordEnabled()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;DcelMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool vcl::isPerHalfEdgeTexCoordEnabled </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a32903e0a292bcdaa77ab10536316c531" name="a32903e0a292bcdaa77ab10536316c531"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32903e0a292bcdaa77ab10536316c531">&#9670;&#160;</a></span>isPerVertexAdjacentFacesEnabled()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool vcl::isPerVertexAdjacentFacesEnabled </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2b69a485cf086be8551cc40210172e6a" name="a2b69a485cf086be8551cc40210172e6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b69a485cf086be8551cc40210172e6a">&#9670;&#160;</a></span>isPerVertexAdjacentVerticesEnabled()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool vcl::isPerVertexAdjacentVerticesEnabled </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="accfcf562d26791650dbddf9910105e26" name="accfcf562d26791650dbddf9910105e26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accfcf562d26791650dbddf9910105e26">&#9670;&#160;</a></span>isPerVertexColorEnabled()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool vcl::isPerVertexColorEnabled </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3d1e8025d3ef60421266da65134a4311" name="a3d1e8025d3ef60421266da65134a4311"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d1e8025d3ef60421266da65134a4311">&#9670;&#160;</a></span>isPerVertexMarkEnabled()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool vcl::isPerVertexMarkEnabled </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7a42ac0f4ca25059bc805e9a5238a083" name="a7a42ac0f4ca25059bc805e9a5238a083"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a42ac0f4ca25059bc805e9a5238a083">&#9670;&#160;</a></span>isPerVertexNormalEnabled()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool vcl::isPerVertexNormalEnabled </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0120edd84580c8e6bd446c913937c937" name="a0120edd84580c8e6bd446c913937c937"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0120edd84580c8e6bd446c913937c937">&#9670;&#160;</a></span>isPerVertexPrincipalCurvatureEnabled()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool vcl::isPerVertexPrincipalCurvatureEnabled </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a394d8b695689371fc986ddd3a64161dd" name="a394d8b695689371fc986ddd3a64161dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a394d8b695689371fc986ddd3a64161dd">&#9670;&#160;</a></span>isPerVertexScalarEnabled()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool vcl::isPerVertexScalarEnabled </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad553855e74ee03b94f8c7e11c3085cf8" name="ad553855e74ee03b94f8c7e11c3085cf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad553855e74ee03b94f8c7e11c3085cf8">&#9670;&#160;</a></span>isPerVertexTexCoordEnabled()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool vcl::isPerVertexTexCoordEnabled </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1878ac13ce283e3535efd93d254d1843" name="a1878ac13ce283e3535efd93d254d1843"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1878ac13ce283e3535efd93d254d1843">&#9670;&#160;</a></span>isQuadMesh()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool vcl::isQuadMesh </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks <em>at run time</em> if the mesh is composed of quads. If the size of the <a class="el" href="classvcl_1_1Face.html" title="The Face class.">Face</a> <a class="el" href="classvcl_1_1Vertex.html" title="The Vertex class.">Vertex</a> References is 4, this check is immediate. If it is not 4, the functions checks for each face if it has 4 vertices. </p>
<p>Complexity: <em>O(n)</em></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>the mesh on which check if each face has 4 vertices. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if every face of the mesh is composed of 4 vertices. </dd></dl>

</div>
</div>
<a id="a2f44643cdd6a934b9ab5f60315e6f01a" name="a2f44643cdd6a934b9ab5f60315e6f01a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f44643cdd6a934b9ab5f60315e6f01a">&#9670;&#160;</a></span>isTriangleMesh()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool vcl::isTriangleMesh </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks <em>at run time</em> if the mesh m is composed of triangles. If the size of the <a class="el" href="classvcl_1_1Face.html" title="The Face class.">Face</a> <a class="el" href="classvcl_1_1Vertex.html" title="The Vertex class.">Vertex</a> References is 3, this check is immediate. If it is not 3, the functions checks for each face if it has 3 vertices. </p>
<p>Complexity: <em>O(n)</em></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>the mesh on which check if each face has 3 vertices. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if every face of the mesh is composed of 3 vertices. </dd></dl>

</div>
</div>
<a id="af71077b0dd03e109c80a05dc1bcafdf5" name="af71077b0dd03e109c80a05dc1bcafdf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af71077b0dd03e109c80a05dc1bcafdf5">&#9670;&#160;</a></span>isVertexContainerCompact()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool vcl::isVertexContainerCompact </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>true</code> if the given mesh has its <a class="el" href="classvcl_1_1Vertex.html" title="The Vertex class.">Vertex</a> Container compact. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>input mesh on which test if the its <a class="el" href="classvcl_1_1Vertex.html" title="The Vertex class.">Vertex</a> Container is compact. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the <a class="el" href="classvcl_1_1Vertex.html" title="The Vertex class.">Vertex</a> Container of the mesh is compact. </dd></dl>

</div>
</div>
<a id="ab7606be147f292f38e1e22a709708a19" name="ab7606be147f292f38e1e22a709708a19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7606be147f292f38e1e22a709708a19">&#9670;&#160;</a></span>KDTree() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1KDTree.html">vcl::KDTree</a> </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td> -&gt;  <a class="el" href="classvcl_1_1KDTree.html">KDTree</a>&lt; typename MeshType::VertexType::CoordType &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab1ec171b583b3872ae8b1b5e6a513b49" name="ab1ec171b583b3872ae8b1b5e6a513b49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1ec171b583b3872ae8b1b5e6a513b49">&#9670;&#160;</a></span>KDTree() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1KDTree.html">vcl::KDTree</a> </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a>&#160;</td>
          <td class="paramname"><em>pointsPerCell</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  <a class="el" href="classvcl_1_1KDTree.html">KDTree</a>&lt; typename MeshType::VertexType::CoordType &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae5c4a6423ece2f30e5d81a3f5b0026b9" name="ae5c4a6423ece2f30e5d81a3f5b0026b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5c4a6423ece2f30e5d81a3f5b0026b9">&#9670;&#160;</a></span>KDTree() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1KDTree.html">vcl::KDTree</a> </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a>&#160;</td>
          <td class="paramname"><em>pointsPerCell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a>&#160;</td>
          <td class="paramname"><em>maxDepth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  <a class="el" href="classvcl_1_1KDTree.html">KDTree</a>&lt; typename MeshType::VertexType::CoordType &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae9e8e92d81c40489de3567c10b3db44c" name="ae9e8e92d81c40489de3567c10b3db44c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9e8e92d81c40489de3567c10b3db44c">&#9670;&#160;</a></span>KDTree() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1KDTree.html">vcl::KDTree</a> </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a>&#160;</td>
          <td class="paramname"><em>pointsPerCell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a>&#160;</td>
          <td class="paramname"><em>maxDepth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>balanced</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  <a class="el" href="classvcl_1_1KDTree.html">KDTree</a>&lt; typename MeshType::VertexType::CoordType &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5136cc5ad6e21d0ae63aeb217983ff55" name="a5136cc5ad6e21d0ae63aeb217983ff55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5136cc5ad6e21d0ae63aeb217983ff55">&#9670;&#160;</a></span>laplacianSmoothing()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::laplacianSmoothing </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a>&#160;</td>
          <td class="paramname"><em>step</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>smoothSelected</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>cotangentWeight</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>vertexCoordLaplacianSmoothing the classical Laplacian smoothing. Each vertex is moved onto the average of the adjacent vertices. </p>
<p>Requirements:</p><ul>
<li><a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>:<ul>
<li>Vertices</li>
<li>Faces</li>
</ul>
</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>the mesh that will be smoothed </td></tr>
    <tr><td class="paramname">step</td><td></td></tr>
    <tr><td class="paramname">smoothSelected</td><td></td></tr>
    <tr><td class="paramname">cotangentWeight</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a86d25b0ff01d215f96bcdf6084299684" name="a86d25b0ff01d215f96bcdf6084299684"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86d25b0ff01d215f96bcdf6084299684">&#9670;&#160;</a></span>lnOfFactorial() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double vcl::lnOfFactorial </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes and caches the result of the natural logarithm of n! </p>
<p>If n &gt; 1024, uses the Stirling approximation. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a86d25b0ff01d215f96bcdf6084299684" name="a86d25b0ff01d215f96bcdf6084299684"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86d25b0ff01d215f96bcdf6084299684">&#9670;&#160;</a></span>lnOfFactorial() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double vcl::lnOfFactorial </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a212fbf643d263ad106507f7aa462cf46" name="a212fbf643d263ad106507f7aa462cf46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a212fbf643d263ad106507f7aa462cf46">&#9670;&#160;</a></span>max() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Head , typename... Tail&gt; <br />
requires (sizeof...(tail) &gt; 0)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto vcl::max </td>
          <td>(</td>
          <td class="paramtype">const Head &amp;&#160;</td>
          <td class="paramname"><em>head0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Head &amp;&#160;</td>
          <td class="paramname"><em>head1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Tail &amp;...&#160;</td>
          <td class="paramname"><em>tail</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a49a9bdba85989ec5842081c5c84d4fc7" name="a49a9bdba85989ec5842081c5c84d4fc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49a9bdba85989ec5842081c5c84d4fc7">&#9670;&#160;</a></span>max() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;PointConcept PointType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto vcl::max </td>
          <td>(</td>
          <td class="paramtype">const PointType &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PointType &amp;&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a69cc63a5ad2974d082145ed1dee7846b" name="a69cc63a5ad2974d082145ed1dee7846b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69cc63a5ad2974d082145ed1dee7846b">&#9670;&#160;</a></span>max() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto vcl::max </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>el1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>el2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="adac28fe9c51f808b6120eb2d9387484b" name="adac28fe9c51f808b6120eb2d9387484b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adac28fe9c51f808b6120eb2d9387484b">&#9670;&#160;</a></span>meshPlaneIntersection()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;EdgeMeshConcept EdgeMesh, FaceMeshConcept MeshType, PlaneConcept PlaneType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacevcl.html#aadd5d4f0adc881097d2c62b003a449cc">EdgeMesh</a> vcl::meshPlaneIntersection </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlaneType &amp;&#160;</td>
          <td class="paramname"><em>pl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Takes a mesh and a plane as inputs and computes the intersection between the mesh and the plane. It creates a new EdgeMesh to represent the intersection edges. </p>
<p>First, for each vertex in the original mesh, it computes its distance to the plane and stores it in a vector. Then, for each face in the original mesh, it checks each of its edges to see if they intersect the plane. If an edge intersects the plane, the intersection point is computed and added to a vector of intersection points. If the edge lies exactly on the plane, its vertices are added to the intersection points.</p>
<p>Once all intersection points have been computed, the function creates a new edge mesh and adds an edge between each pair of consecutive intersection points that forms a line segment on the plane. If the original mesh has per-vertex normals, the function also computes and stores the normal at each intersection point.</p>
<p>Requirements:</p><ul>
<li>EdgeMesh:<ul>
<li>Vertices<ul>
<li>Normals (optional)</li>
</ul>
</li>
<li>Edges</li>
</ul>
</li>
<li>MeshType:<ul>
<li>Vertices<ul>
<li>Normals (optional)</li>
</ul>
</li>
<li>Faces</li>
</ul>
</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td></td></tr>
    <tr><td class="paramname">pl</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the intersection between the original mesh and the plane as a collection of line segments with optional normal vectors. </dd></dl>

</div>
</div>
<a id="a5da120ef4b6039bf54902d14cb8b7519" name="a5da120ef4b6039bf54902d14cb8b7519"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5da120ef4b6039bf54902d14cb8b7519">&#9670;&#160;</a></span>meshSphereIntersection() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType, typename SScalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">MeshType vcl::meshSphereIntersection </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvcl_1_1Sphere.html">vcl::Sphere</a>&lt; SScalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>sphere</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as meshSphereIntersection(MeshType, Sphere, double);. </p>
<p>The tolerance is set as 1/10^5*2*pi*radius. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td></td></tr>
    <tr><td class="paramname">sphere</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a1e4c155f781f7c3e6fca2b922398fb82" name="a1e4c155f781f7c3e6fca2b922398fb82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e4c155f781f7c3e6fca2b922398fb82">&#9670;&#160;</a></span>meshSphereIntersection() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType, typename SScalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">MeshType vcl::meshSphereIntersection </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvcl_1_1Sphere.html">vcl::Sphere</a>&lt; SScalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>sphere</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the intersection between a mesh and a ball. </p>
<p>given a mesh return a new mesh made by a copy of all the faces entirely includeded in the ball plus new faces created by refining the ones intersected by the ball border. It works by recursively splitting the triangles that cross the border, as long as their area is greater than a given value tol. NOTE: the returned mesh is a triangle soup</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td></td></tr>
    <tr><td class="paramname">sphere</td><td></td></tr>
    <tr><td class="paramname">tol</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a9c1835cef3addd7dbae2b21a43523f3a" name="a9c1835cef3addd7dbae2b21a43523f3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c1835cef3addd7dbae2b21a43523f3a">&#9670;&#160;</a></span>min() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Head , typename... Tail&gt; <br />
requires (sizeof...(tail) &gt; 0)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto vcl::min </td>
          <td>(</td>
          <td class="paramtype">const Head &amp;&#160;</td>
          <td class="paramname"><em>head0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Head &amp;&#160;</td>
          <td class="paramname"><em>head1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Tail &amp;...&#160;</td>
          <td class="paramname"><em>tail</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac11460526cb6d79733a8dfe0e15614f4" name="ac11460526cb6d79733a8dfe0e15614f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac11460526cb6d79733a8dfe0e15614f4">&#9670;&#160;</a></span>min() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;PointConcept PointType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto vcl::min </td>
          <td>(</td>
          <td class="paramtype">const PointType &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PointType &amp;&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3edcb561672a6be17e9453bd1ea446d5" name="a3edcb561672a6be17e9453bd1ea446d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3edcb561672a6be17e9453bd1ea446d5">&#9670;&#160;</a></span>min() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto vcl::min </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>el1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>el2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae925bc10e1eec9a48761c6b852756e42" name="ae925bc10e1eec9a48761c6b852756e42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae925bc10e1eec9a48761c6b852756e42">&#9670;&#160;</a></span>multiplyPerFaceNormalsByMatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType, typename MScalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::multiplyPerFaceNormalsByMatrix </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacevcl.html#ad82a126b390f21b2e9658c73e7a795ee">vcl::Matrix44</a>&lt; MScalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>removeScalingFromMatrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiplies the <a class="el" href="classvcl_1_1Face.html" title="The Face class.">Face</a> Normals by the given TRS 4x4 Matrix. By default, the scale component is removed from the matrix. </p>
<p>Requirements:</p><ul>
<li><a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>:<ul>
<li>Faces<ul>
<li>Normal</li>
</ul>
</li>
</ul>
</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">mesh</td><td>the mesh on which multiply the face normals. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mat</td><td>the 4x4 TRS matrix that is multiplied to the normals. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">removeScalingFromMatrix</td><td>if true (default), the scale component is removed from the matrix. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7c520689bfd82598aafdae321530c762" name="a7c520689bfd82598aafdae321530c762"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c520689bfd82598aafdae321530c762">&#9670;&#160;</a></span>multiplyPerVertexNormalsByMatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType, typename MScalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::multiplyPerVertexNormalsByMatrix </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacevcl.html#ad82a126b390f21b2e9658c73e7a795ee">vcl::Matrix44</a>&lt; MScalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>removeScalingFromMatrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiplies the <a class="el" href="classvcl_1_1Vertex.html" title="The Vertex class.">Vertex</a> Normals by the given TRS 4x4 Matrix. By default, the scale component is removed from the matrix. </p>
<p>Requirements:</p><ul>
<li><a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>:<ul>
<li>Vertices:<ul>
<li>Normal</li>
</ul>
</li>
</ul>
</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">mesh</td><td>the mesh on which multiply the vertex normals. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mat</td><td>the 4x4 TRS matrix that is multiplied to the normals. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">removeScalingFromMatrix</td><td>if true (default), the scale component is removed from the matrix. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae3ccefcbb94fc15319e388a1183f3925" name="ae3ccefcbb94fc15319e388a1183f3925"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3ccefcbb94fc15319e388a1183f3925">&#9670;&#160;</a></span>normalizePerFaceNormals()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::normalizePerFaceNormals </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Normalizes the length of the face normals. </p>
<p>Requirements:</p><ul>
<li><a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>:<ul>
<li>Faces:<ul>
<li>Normal</li>
</ul>
</li>
</ul>
</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">m</td><td>the mesh on which normalize the face normals. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acac925494e3e17b45b0a352bcd2c5961" name="acac925494e3e17b45b0a352bcd2c5961"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acac925494e3e17b45b0a352bcd2c5961">&#9670;&#160;</a></span>normalizePerFaceScalar()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::normalizePerFaceScalar </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename MeshType::FaceType::ScalarType&#160;</td>
          <td class="paramname"><em>minS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename MeshType::FaceType::ScalarType&#160;</td>
          <td class="paramname"><em>maxS</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Normalizes the face scalars of a mesh in a given interval (default [0, 1]). </p>
<p>Requirements:</p><ul>
<li><a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>:<ul>
<li>Faces:<ul>
<li>Scalar</li>
</ul>
</li>
</ul>
</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">m</td><td>mesh on which normalize the face scalars </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">minS</td><td>minimum value of the normalizing interval, default 0 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxS</td><td>maximum value of the normalizing interval, default 1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0c7590577a9732afcd1dc3639b3965b6" name="a0c7590577a9732afcd1dc3639b3965b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c7590577a9732afcd1dc3639b3965b6">&#9670;&#160;</a></span>normalizePerVertexNormals()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::normalizePerVertexNormals </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Normalizes the length of the vertex normals. </p>
<p>Requirements:</p><ul>
<li><a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>:<ul>
<li>Vertices:<ul>
<li>Normal</li>
</ul>
</li>
</ul>
</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">m</td><td>the mesh on which normalize the vertex normals. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab3955ddf9f13739cc169caca71a2db88" name="ab3955ddf9f13739cc169caca71a2db88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3955ddf9f13739cc169caca71a2db88">&#9670;&#160;</a></span>normalizePerVertexScalar()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::normalizePerVertexScalar </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename MeshType::VertexType::ScalarType&#160;</td>
          <td class="paramname"><em>minS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename MeshType::VertexType::ScalarType&#160;</td>
          <td class="paramname"><em>maxS</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Normalizes the vertex scalars of a mesh in a given interval (default [0, 1]). </p>
<p>Requirements:</p><ul>
<li><a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>:<ul>
<li>Vertices:<ul>
<li>Scalar</li>
</ul>
</li>
</ul>
</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">m</td><td>mesh on which normalize the vertex scalars </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">minS</td><td>minimum value of the normalizing interval, default 0 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxS</td><td>maximum value of the normalizing interval, default 1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a25bd91133ba21843329a21218fa52069" name="a25bd91133ba21843329a21218fa52069"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25bd91133ba21843329a21218fa52069">&#9670;&#160;</a></span>operator*()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;EigenMatrixConcept MatrixType, PointConcept PointType&gt; <br />
requires ( MatrixType::RowsAtCompileTime == PointType::DIM &amp;&amp; MatrixType::ColsAtCompileTime == PointType::DIM)</div>
      <table class="memname">
        <tr>
          <td class="memname">PointType vcl::operator* </td>
          <td>(</td>
          <td class="paramtype">const MatrixType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PointType &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiplies a matrix and a point. </p>
<p>This function multiplies a matrix and a point and returns the resulting point.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MatrixType</td><td>A type that satisfies the EigenMatrixConcept </td></tr>
    <tr><td class="paramname">PointType</td><td>A type that satisfies the PointConcept</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>The matrix to be multiplied with the point </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>The point to be multiplied with the matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting point after multiplying the matrix and point</dd></dl>
<p>@requires MatrixType::RowsAtCompileTime == PointType::DIM &amp;&amp; MatrixType::ColsAtCompileTime == PointType::DIM </p>

</div>
</div>
<a id="a10783cb155a40826adff62ef42123efe" name="a10783cb155a40826adff62ef42123efe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10783cb155a40826adff62ef42123efe">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; vcl::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvcl_1_1Array.html">Array</a>&lt; Scalar, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a05dd102880d029a4ce6a952207559088" name="a05dd102880d029a4ce6a952207559088"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05dd102880d029a4ce6a952207559088">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; vcl::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvcl_1_1Color.html">Color</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overload of stream operator to allow a pretty print of a <a class="el" href="classvcl_1_1Color.html" title="The Color class represents an RGBA color.">vcl::Color</a>. </p>

</div>
</div>
<a id="aa2b5fc956b8e7b0ed2fe7f1846a6a74d" name="aa2b5fc956b8e7b0ed2fe7f1846a6a74d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2b5fc956b8e7b0ed2fe7f1846a6a74d">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar , <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; vcl::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvcl_1_1Point.html">Point</a>&lt; Scalar, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>p1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes this point to an output stream. </p>
<p>This operator writes this point to an output stream and returns the output stream. The point is written as a column vector of its coordinates.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">out</td><td>The output stream to write to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p1</td><td>The point to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The output stream after the point is written. </dd></dl>

</div>
</div>
<a id="ac74faed2021a2b157f5b80757ee694d8" name="ac74faed2021a2b157f5b80757ee694d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac74faed2021a2b157f5b80757ee694d8">&#9670;&#160;</a></span>parallelFor() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator , typename Lambda &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::parallelFor </td>
          <td>(</td>
          <td class="paramtype">const Iterator &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Iterator &amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Lambda &amp;&amp;&#160;</td>
          <td class="paramname"><em>F</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function executes a parallel (vectorized) for over the elements iterated between <code>begin</code> and <code>end</code> iterators, if parallel requirements have been found in the system. </p>
<p>Example of usage on a <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">vcl::Mesh</a>, iterating over vertices:</p>
<div class="fragment"><div class="line"><a class="code hl_function" href="namespacevcl.html#abde6b767fa0b116a5fd8b2a5fa0af488">vcl::parallelFor</a>(m.vertices().begin(), m.vertices().end(), [&amp;](VertexType&amp; v) {</div>
<div class="line">    <span class="comment">// make some computing on v</span></div>
<div class="line">});</div>
<div class="ttc" id="anamespacevcl_html_abde6b767fa0b116a5fd8b2a5fa0af488"><div class="ttname"><a href="namespacevcl.html#abde6b767fa0b116a5fd8b2a5fa0af488">vcl::parallelFor</a></div><div class="ttdeci">void parallelFor(Iterator &amp;&amp;begin, Iterator &amp;&amp;end, Lambda &amp;&amp;F)</div><div class="ttdoc">This function executes a parallel (vectorized) for over the elements iterated between begin and end i...</div><div class="ttdef"><b>Definition:</b> parallel.cpp:48</div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">begin</td><td>iterator of the first element to iterate </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">end</td><td>iterator of the end of the iterated container </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>lambda function that takes the iterated type as input </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad43b0e6c5acf9f903daf25853361a24c" name="ad43b0e6c5acf9f903daf25853361a24c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad43b0e6c5acf9f903daf25853361a24c">&#9670;&#160;</a></span>parallelFor() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="conceptvcl_1_1Range.html">vcl::Range</a> Rng, typename Lambda &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::parallelFor </td>
          <td>(</td>
          <td class="paramtype">const Rng &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Lambda &amp;&amp;&#160;</td>
          <td class="paramname"><em>F</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function executes a parallel (vectorized) for over a range if parallel requirements have been found in the system. </p>
<p>Example of usage on a <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">vcl::Mesh</a>, iterating over vertices:</p>
<div class="fragment"><div class="line"><a class="code hl_function" href="namespacevcl.html#abde6b767fa0b116a5fd8b2a5fa0af488">vcl::parallelFor</a>(m.vertices(), [&amp;](VertexType&amp; v) {</div>
<div class="line">    <span class="comment">// make some computing on v</span></div>
<div class="line">});</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">r</td><td>a range having begin() and end() functions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>lambda function that takes the iterated type as input </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abde6b767fa0b116a5fd8b2a5fa0af488" name="abde6b767fa0b116a5fd8b2a5fa0af488"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abde6b767fa0b116a5fd8b2a5fa0af488">&#9670;&#160;</a></span>parallelFor() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator , typename Lambda &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::parallelFor </td>
          <td>(</td>
          <td class="paramtype">Iterator &amp;&amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator &amp;&amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Lambda &amp;&amp;&#160;</td>
          <td class="paramname"><em>F</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function executes a parallel (vectorized) for over the elements iterated between <code>begin</code> and <code>end</code> iterators, if parallel requirements have been found in the system. </p>
<p>Example of usage on a <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">vcl::Mesh</a>, iterating over vertices:</p>
<div class="fragment"><div class="line"><a class="code hl_function" href="namespacevcl.html#abde6b767fa0b116a5fd8b2a5fa0af488">vcl::parallelFor</a>(m.vertices().begin(), m.vertices().end(), [&amp;](VertexType&amp; v) {</div>
<div class="line">    <span class="comment">// make some computing on v</span></div>
<div class="line">});</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">begin</td><td>iterator of the first element to iterate </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">end</td><td>iterator of the end of the iterated container </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>lambda function that takes the iterated type as input </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0bbb25a5a74276bc05a251ab860a286d" name="a0bbb25a5a74276bc05a251ab860a286d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bbb25a5a74276bc05a251ab860a286d">&#9670;&#160;</a></span>parallelFor() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="conceptvcl_1_1Range.html">vcl::Range</a> Rng, typename Lambda &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::parallelFor </td>
          <td>(</td>
          <td class="paramtype">Rng &amp;&amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Lambda &amp;&amp;&#160;</td>
          <td class="paramname"><em>F</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function executes a parallel (vectorized) for over a range if parallel requirements have been found in the system. </p>
<p>Example of usage on a <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">vcl::Mesh</a>, iterating over vertices:</p>
<div class="fragment"><div class="line"><a class="code hl_function" href="namespacevcl.html#abde6b767fa0b116a5fd8b2a5fa0af488">vcl::parallelFor</a>(m.vertices(), [&amp;](VertexType&amp; v) {</div>
<div class="line">    <span class="comment">// make some computing on v</span></div>
<div class="line">});</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">r</td><td>a range having begin() and end() functions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>lambda function that takes the iterated type as input </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afc2f93864498c3b143e13c1b0009bdc4" name="afc2f93864498c3b143e13c1b0009bdc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc2f93864498c3b143e13c1b0009bdc4">&#9670;&#160;</a></span>perlinNoise()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double vcl::perlinNoise </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>3D Perlin noise, returns a value in the [-1,1] range with period 255 </p>
<p>based on the java reference implementation published on <a href="http://mrl.nyu.edu/~perlin/noise/">http://mrl.nyu.edu/~perlin/noise/</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td></td></tr>
    <tr><td class="paramname">y</td><td></td></tr>
    <tr><td class="paramname">z</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a27474522dfcc3be4ce96d6a8b44fcc09" name="a27474522dfcc3be4ce96d6a8b44fcc09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27474522dfcc3be4ce96d6a8b44fcc09">&#9670;&#160;</a></span>planeBoxIntersect()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;PlaneConcept PlaneType, Box3Concept BoxType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool vcl::planeBoxIntersect </td>
          <td>(</td>
          <td class="paramtype">const PlaneType &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BoxType &amp;&#160;</td>
          <td class="paramname"><em>box</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if a plane intersects with a box. </p>
<p>Uses the algorithm from <a href="https://gdbooks.gitbooks.io/3dcollisions/content/Chapter2/static_aabb_plane.html">https://gdbooks.gitbooks.io/3dcollisions/content/Chapter2/static_aabb_plane.html</a></p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">PlaneType</td><td>The type of plane used in the intersection check </td></tr>
    <tr><td class="paramname">BoxType</td><td>The type of box used in the intersection check, must satisfy the Box3Concept</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>The plane to check intersection with </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">box</td><td>The box to check intersection with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the plane intersects with the box, false otherwise </dd></dl>

</div>
</div>
<a id="a5603e96ba08d11993828c0e47f2657b2" name="a5603e96ba08d11993828c0e47f2657b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5603e96ba08d11993828c0e47f2657b2">&#9670;&#160;</a></span>planeSegmentIntersect() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;PlaneConcept PlaneType, Segment3Concept SegmentType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool vcl::planeSegmentIntersect </td>
          <td>(</td>
          <td class="paramtype">const PlaneType &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SegmentType &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function computes the intersection between a plane and a 3D segment. If the intersection exists, it returns true, otherwise, it returns false. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>the plane to compute the intersection with. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>the 3D segment to compute the intersection with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A boolean value indicating whether an intersection was found or not. </dd></dl>

</div>
</div>
<a id="a095d688d385405cbf305d7f501f672a6" name="a095d688d385405cbf305d7f501f672a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a095d688d385405cbf305d7f501f672a6">&#9670;&#160;</a></span>planeSegmentIntersect() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;PlaneConcept PlaneType, Segment3Concept SegmentType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool vcl::planeSegmentIntersect </td>
          <td>(</td>
          <td class="paramtype">const PlaneType &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SegmentType &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename SegmentType::PointType &amp;&#160;</td>
          <td class="paramname"><em>intersection</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function computes the intersection between a plane and a 3D segment. If the intersection exists, it returns true and stores the intersection point in the output parameter intersection, otherwise, it returns false. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>the plane to compute the intersection with. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>the 3D segment to compute the intersection with. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">intersection</td><td>A reference to the point that stores the resulting intersection between the plane and the segment. This parameter is only written to if the function returns true. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A boolean value indicating whether an intersection was found or not. </dd></dl>

</div>
</div>
<a id="aaf860b9816e4dc7fc87d0bf27aaa0670" name="aaf860b9816e4dc7fc87d0bf27aaa0670"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf860b9816e4dc7fc87d0bf27aaa0670">&#9670;&#160;</a></span>Point()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename S , typename... Scalars&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Point.html">vcl::Point</a> </td>
          <td>(</td>
          <td class="paramtype">S&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Scalars...&#160;</td>
          <td class="paramname"><em>scalars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  <a class="el" href="classvcl_1_1Point.html">Point</a>&lt; S, sizeof...(Scalars)+1 &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afdfe6ef5ae382e3727241bb20d8f1e3c" name="afdfe6ef5ae382e3727241bb20d8f1e3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdfe6ef5ae382e3727241bb20d8f1e3c">&#9670;&#160;</a></span>pointFaceDistance() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Point3Concept PointType, FaceConcept FaceType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto vcl::pointFaceDistance </td>
          <td>(</td>
          <td class="paramtype">const PointType &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FaceType &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>signedDist</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the distance between a 3D point and a 3D triangle face. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">PointType</td><td>The type of point. Must satisfy the Point3Concept. </td></tr>
    <tr><td class="paramname">FaceType</td><td>The type of face. Must satisfy the FaceConcept.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>The point to calculate the distance from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>The face to calculate the distance to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">signedDist</td><td>Whether to calculate the signed distance. Default is false. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The distance between the point and the face. </dd></dl>

</div>
</div>
<a id="a6d852efcb4d8028aa9c9e70af2c92cff" name="a6d852efcb4d8028aa9c9e70af2c92cff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d852efcb4d8028aa9c9e70af2c92cff">&#9670;&#160;</a></span>pointFaceDistance() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Point3Concept PointType, FaceConcept FaceType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto vcl::pointFaceDistance </td>
          <td>(</td>
          <td class="paramtype">const PointType &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FaceType &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PointType &amp;&#160;</td>
          <td class="paramname"><em>closest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>signedDist</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8004a267a203fab97954933935d7fe8a" name="a8004a267a203fab97954933935d7fe8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8004a267a203fab97954933935d7fe8a">&#9670;&#160;</a></span>pointFaceDistance() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Point3Concept PointType, FaceConcept FaceType, typename ScalarType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto vcl::pointFaceDistance </td>
          <td>(</td>
          <td class="paramtype">const PointType &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FaceType &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScalarType&#160;</td>
          <td class="paramname"><em>maxDist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>signedDist</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad3b70ae405303e6bc3c6b36ccd2f2cd9" name="ad3b70ae405303e6bc3c6b36ccd2f2cd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3b70ae405303e6bc3c6b36ccd2f2cd9">&#9670;&#160;</a></span>pointFaceDistance() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Point3Concept PointType, FaceConcept FaceType, typename ScalarType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto vcl::pointFaceDistance </td>
          <td>(</td>
          <td class="paramtype">const PointType &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FaceType &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScalarType&#160;</td>
          <td class="paramname"><em>maxDist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PointType &amp;&#160;</td>
          <td class="paramname"><em>closest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>signedDist</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the distance between a 3D point and a 3D triangle face. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">PointType</td><td>The type of point. Must satisfy the Point3Concept. </td></tr>
    <tr><td class="paramname">FaceType</td><td>The type of face. Must satisfy the FaceConcept.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>The point to calculate the distance from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>The face to calculate the distance to. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">closest</td><td>The closest point on the triangle to the given point. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">signedDist</td><td>Whether to calculate the signed distance. Default is false. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The distance between the point and the face. </dd></dl>

</div>
</div>
<a id="a142e6d7ccfbbece897edecff226ced45" name="a142e6d7ccfbbece897edecff226ced45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a142e6d7ccfbbece897edecff226ced45">&#9670;&#160;</a></span>pointPlaneDistance()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Point3Concept PointType, PlaneConcept PlaneType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto vcl::pointPlaneDistance </td>
          <td>(</td>
          <td class="paramtype">const PointType &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlaneType &amp;&#160;</td>
          <td class="paramname"><em>plane</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>signedDist</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7e95f3d99f53e335c7e17af14b42f991" name="a7e95f3d99f53e335c7e17af14b42f991"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e95f3d99f53e335c7e17af14b42f991">&#9670;&#160;</a></span>pointSegmentDistance() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;PointConcept PointType, SegmentConcept SegmentType&gt; <br />
requires (PointType::DIM == SegmentType::DIM)</div>
      <table class="memname">
        <tr>
          <td class="memname">auto vcl::pointSegmentDistance </td>
          <td>(</td>
          <td class="paramtype">const PointType &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SegmentType &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1d8430571d9a6027e6d7e3bac4816b95" name="a1d8430571d9a6027e6d7e3bac4816b95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d8430571d9a6027e6d7e3bac4816b95">&#9670;&#160;</a></span>pointSegmentDistance() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;PointConcept PointType, SegmentConcept SegmentType&gt; <br />
requires (PointType::DIM == SegmentType::DIM)</div>
      <table class="memname">
        <tr>
          <td class="memname">auto vcl::pointSegmentDistance </td>
          <td>(</td>
          <td class="paramtype">const PointType &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SegmentType &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PointType &amp;&#160;</td>
          <td class="paramname"><em>closest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aee130ece16518760ce1f2c1a9da3a6e1" name="aee130ece16518760ce1f2c1a9da3a6e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee130ece16518760ce1f2c1a9da3a6e1">&#9670;&#160;</a></span>poissonRandomNumber() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int vcl::poissonRandomNumber </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lambda</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a212c052ae1efd3426a5ea49051f8011c" name="a212c052ae1efd3426a5ea49051f8011c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a212c052ae1efd3426a5ea49051f8011c">&#9670;&#160;</a></span>poissonRandomNumber() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int vcl::poissonRandomNumber </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::mt19937 &amp;&#160;</td>
          <td class="paramname"><em>gen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>algorithm poisson random number (Knuth): init: Let L ← e^−λ, k ← 0 and p ← 1. do: k ← k + 1. Generate uniform random number u in [0,1] and let p ← p × u. while p &gt; L. return k − 1. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lambda</td><td></td></tr>
    <tr><td class="paramname">gen</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="aef13acb79205bb8fe990f66e1fa203f3" name="aef13acb79205bb8fe990f66e1fa203f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef13acb79205bb8fe990f66e1fa203f3">&#9670;&#160;</a></span>poissonRatioOfUniformsInteger() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int vcl::poissonRatioOfUniformsInteger </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>L</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2cc1884dbb897a34716178c7b06e7bb2" name="a2cc1884dbb897a34716178c7b06e7bb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cc1884dbb897a34716178c7b06e7bb2">&#9670;&#160;</a></span>poissonRatioOfUniformsInteger() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int vcl::poissonRatioOfUniformsInteger </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::mt19937 &amp;&#160;</td>
          <td class="paramname"><em>gen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This subfunction generates a integer with the poisson distribution using the ratio-of-uniforms rejection method (PRUAt). This approach is STABLE even for large L (e.g. it does not suffer from the overflow limit of the classical Knuth implementation) Execution time does not depend on L, except that it matters whether is within the range where ln(n!) is tabulated. </p>
<p>Reference:</p>
<p>E. Stadlober "The ratio of uniforms approach for generating discrete random variates". Journal of Computational and Applied Mathematics, vol. 31, no. 1, 1990, pp. 181-189.</p>
<p>Partially adapted/inspired from some subfunctions of the Agner Fog stocc library ( www.agner.org/random ) Same licensing scheme.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">L</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a3d0305c02567d29d5bc48a0cdbaacda3" name="a3d0305c02567d29d5bc48a0cdbaacda3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d0305c02567d29d5bc48a0cdbaacda3">&#9670;&#160;</a></span>randomPolygonBarycentricCoordinate() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ScalarType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; ScalarType &gt; vcl::randomPolygonBarycentricCoordinate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a>&#160;</td>
          <td class="paramname"><em>polySize</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7c7c00f108bb07302bfb7643c66f3ef4" name="a7c7c00f108bb07302bfb7643c66f3ef4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c7c00f108bb07302bfb7643c66f3ef4">&#9670;&#160;</a></span>randomPolygonBarycentricCoordinate() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ScalarType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; ScalarType &gt; vcl::randomPolygonBarycentricCoordinate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a>&#160;</td>
          <td class="paramname"><em>polySize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::mt19937 &amp;&#160;</td>
          <td class="paramname"><em>gen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad7b855bdab068b3fee59bc40914436e2" name="ad7b855bdab068b3fee59bc40914436e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7b855bdab068b3fee59bc40914436e2">&#9670;&#160;</a></span>randomTriangleBarycentricCoordinate() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ScalarType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__space.html#ga13f2718b0763def563b8bd9f65982833">vcl::Point3</a>&lt; ScalarType &gt; vcl::randomTriangleBarycentricCoordinate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a06f5b66d996c91397fab66781fc73402" name="a06f5b66d996c91397fab66781fc73402"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06f5b66d996c91397fab66781fc73402">&#9670;&#160;</a></span>randomTriangleBarycentricCoordinate() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ScalarType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__space.html#ga13f2718b0763def563b8bd9f65982833">vcl::Point3</a>&lt; ScalarType &gt; vcl::randomTriangleBarycentricCoordinate </td>
          <td>(</td>
          <td class="paramtype">std::mt19937 &amp;&#160;</td>
          <td class="paramname"><em>gen</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate the barycentric coords of a random point over a triangle, with a uniform distribution over the triangle. It uses the parallelogram folding trick. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gen</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a1420d0b9ba83dea9e692db635533f46c" name="a1420d0b9ba83dea9e692db635533f46c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1420d0b9ba83dea9e692db635533f46c">&#9670;&#160;</a></span>RegularGrid()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;PointConcept PointType, typename D &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1RegularGrid.html">vcl::RegularGrid</a> </td>
          <td>(</td>
          <td class="paramtype">PointType&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PointType&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">D&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  <a class="el" href="classvcl_1_1RegularGrid.html">RegularGrid</a>&lt; typename PointType::ScalarType, PointType::DIM &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a84e84c881525f5d76599d6ef8d4a0933" name="a84e84c881525f5d76599d6ef8d4a0933"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84e84c881525f5d76599d6ef8d4a0933">&#9670;&#160;</a></span>requireCompactness()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::requireCompactness </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa5e8d79003b3a928d430219d244a4855" name="aa5e8d79003b3a928d430219d244a4855"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5e8d79003b3a928d430219d244a4855">&#9670;&#160;</a></span>requireFaceContainerCompactness()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::requireFaceContainerCompactness </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a609b362469e59878aa3bba0097a3a00d" name="a609b362469e59878aa3bba0097a3a00d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a609b362469e59878aa3bba0097a3a00d">&#9670;&#160;</a></span>requireHalfEdgeContainerCompactness()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;DcelMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::requireHalfEdgeContainerCompactness </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aff3602e750a1d1c93374f642be47a6b0" name="aff3602e750a1d1c93374f642be47a6b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff3602e750a1d1c93374f642be47a6b0">&#9670;&#160;</a></span>requirePerFaceAdjacentFaces()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; <br />
requires HasPerFaceAdjacentFaces&lt;MeshType&gt;</div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::requirePerFaceAdjacentFaces </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae6372afb65d4cb206aed162aff2d71c3" name="ae6372afb65d4cb206aed162aff2d71c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6372afb65d4cb206aed162aff2d71c3">&#9670;&#160;</a></span>requirePerFaceColor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; <br />
requires HasPerFaceColor&lt;MeshType&gt;</div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::requirePerFaceColor </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac96a0a92c22ced9c629b174dade3dd70" name="ac96a0a92c22ced9c629b174dade3dd70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac96a0a92c22ced9c629b174dade3dd70">&#9670;&#160;</a></span>requirePerFaceMark()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; <br />
requires HasPerFaceMark&lt;MeshType&gt;</div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::requirePerFaceMark </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac641c6af53b47b21fe2b1b85f1b1c8c4" name="ac641c6af53b47b21fe2b1b85f1b1c8c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac641c6af53b47b21fe2b1b85f1b1c8c4">&#9670;&#160;</a></span>requirePerFaceNormal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; <br />
requires HasPerFaceNormal&lt;MeshType&gt;</div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::requirePerFaceNormal </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a880bfabf90d17524361cc4115587db56" name="a880bfabf90d17524361cc4115587db56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a880bfabf90d17524361cc4115587db56">&#9670;&#160;</a></span>requirePerFacePrincipalCurvature()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; <br />
requires HasPerFacePrincipalCurvature&lt;MeshType&gt;</div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::requirePerFacePrincipalCurvature </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5b27fb34180501bde527a828cf281479" name="a5b27fb34180501bde527a828cf281479"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b27fb34180501bde527a828cf281479">&#9670;&#160;</a></span>requirePerFaceScalar()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; <br />
requires HasPerFaceScalar&lt;MeshType&gt;</div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::requirePerFaceScalar </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aef39ab9380581074304975fc0cb49570" name="aef39ab9380581074304975fc0cb49570"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef39ab9380581074304975fc0cb49570">&#9670;&#160;</a></span>requirePerFaceWedgeColors()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; <br />
requires HasPerFaceWedgeColors&lt;MeshType&gt;</div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::requirePerFaceWedgeColors </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7f262a65d84b84b17a5d41b13fa98329" name="a7f262a65d84b84b17a5d41b13fa98329"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f262a65d84b84b17a5d41b13fa98329">&#9670;&#160;</a></span>requirePerFaceWedgeTexCoords()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; <br />
requires HasPerFaceWedgeTexCoords&lt;MeshType&gt;</div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::requirePerFaceWedgeTexCoords </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad3e1c6b6d6d73a6d542084c7c47ea858" name="ad3e1c6b6d6d73a6d542084c7c47ea858"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3e1c6b6d6d73a6d542084c7c47ea858">&#9670;&#160;</a></span>requirePerHalfEdgeColor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;DcelMeshConcept MeshType&gt; <br />
requires HasPerHalfEdgeColor&lt;MeshType&gt;</div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::requirePerHalfEdgeColor </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aacdeb06385ef42c65be942ce79ebdd2f" name="aacdeb06385ef42c65be942ce79ebdd2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacdeb06385ef42c65be942ce79ebdd2f">&#9670;&#160;</a></span>requirePerHalfEdgeMark()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;DcelMeshConcept MeshType&gt; <br />
requires HasPerHalfEdgeMark&lt;MeshType&gt;</div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::requirePerHalfEdgeMark </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a07b74f9a0baee35bd34e5ee925270440" name="a07b74f9a0baee35bd34e5ee925270440"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07b74f9a0baee35bd34e5ee925270440">&#9670;&#160;</a></span>requirePerHalfEdgeScalar()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;DcelMeshConcept MeshType&gt; <br />
requires HasPerHalfEdgeScalar&lt;MeshType&gt;</div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::requirePerHalfEdgeScalar </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2535d580dc788c502bc75f04f9e648b6" name="a2535d580dc788c502bc75f04f9e648b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2535d580dc788c502bc75f04f9e648b6">&#9670;&#160;</a></span>requirePerHalfEdgeTexCoord()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;DcelMeshConcept MeshType&gt; <br />
requires HasPerHalfEdgeTexCoord&lt;MeshType&gt;</div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::requirePerHalfEdgeTexCoord </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1f6666a7b9cd7293ab07aaf6cbc1dc4c" name="a1f6666a7b9cd7293ab07aaf6cbc1dc4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f6666a7b9cd7293ab07aaf6cbc1dc4c">&#9670;&#160;</a></span>requirePerVertexAdjacentFaces()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MeshType &gt; <br />
requires HasPerVertexAdjacentFaces&lt;MeshType&gt;</div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::requirePerVertexAdjacentFaces </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a224534742afebeedf036df597231c700" name="a224534742afebeedf036df597231c700"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a224534742afebeedf036df597231c700">&#9670;&#160;</a></span>requirePerVertexAdjacentVertices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MeshType &gt; <br />
requires HasPerVertexAdjacentVertices&lt;MeshType&gt;</div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::requirePerVertexAdjacentVertices </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3fc65a005474dd6f983d5f9b235b5387" name="a3fc65a005474dd6f983d5f9b235b5387"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fc65a005474dd6f983d5f9b235b5387">&#9670;&#160;</a></span>requirePerVertexColor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MeshType &gt; <br />
requires HasPerVertexColor&lt;MeshType&gt;</div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::requirePerVertexColor </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad1b0cb92a48a555d7084bb6fb94ef359" name="ad1b0cb92a48a555d7084bb6fb94ef359"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1b0cb92a48a555d7084bb6fb94ef359">&#9670;&#160;</a></span>requirePerVertexMark()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MeshType &gt; <br />
requires HasPerVertexMark&lt;MeshType&gt;</div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::requirePerVertexMark </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab43f884f6ca679c8f57255e11ddaa768" name="ab43f884f6ca679c8f57255e11ddaa768"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab43f884f6ca679c8f57255e11ddaa768">&#9670;&#160;</a></span>requirePerVertexNormal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MeshType &gt; <br />
requires HasPerVertexNormal&lt;MeshType&gt;</div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::requirePerVertexNormal </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af330a765b2c7772ff85378f617ade27b" name="af330a765b2c7772ff85378f617ade27b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af330a765b2c7772ff85378f617ade27b">&#9670;&#160;</a></span>requirePerVertexPrincipalCurvature()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MeshType &gt; <br />
requires HasPerVertexPrincipalCurvature&lt;MeshType&gt;</div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::requirePerVertexPrincipalCurvature </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aba5f0aba238fdf49f79c8986cee2bfa9" name="aba5f0aba238fdf49f79c8986cee2bfa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba5f0aba238fdf49f79c8986cee2bfa9">&#9670;&#160;</a></span>requirePerVertexScalar()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MeshType &gt; <br />
requires HasPerVertexScalar&lt;MeshType&gt;</div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::requirePerVertexScalar </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5f20fd534d1bb822fe5b13f2515025ee" name="a5f20fd534d1bb822fe5b13f2515025ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f20fd534d1bb822fe5b13f2515025ee">&#9670;&#160;</a></span>requirePerVertexTexCoord()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MeshType &gt; <br />
requires HasPerVertexTexCoord&lt;MeshType&gt;</div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::requirePerVertexTexCoord </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa713300521a68b8fe8bf5154fdae27b8" name="aa713300521a68b8fe8bf5154fdae27b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa713300521a68b8fe8bf5154fdae27b8">&#9670;&#160;</a></span>requireQuadMesh()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::requireQuadMesh </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3f347e31d2e1fd9471cc98f46668c64c" name="a3f347e31d2e1fd9471cc98f46668c64c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f347e31d2e1fd9471cc98f46668c64c">&#9670;&#160;</a></span>requireTriangleMesh()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::requireTriangleMesh </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae5e94dd9b89e9bc4fb21701af6e788ca" name="ae5e94dd9b89e9bc4fb21701af6e788ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5e94dd9b89e9bc4fb21701af6e788ca">&#9670;&#160;</a></span>requireVertexContainerCompactness()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::requireVertexContainerCompactness </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aefa0051d67bdf4a551140929a2cc0b2f" name="aefa0051d67bdf4a551140929a2cc0b2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefa0051d67bdf4a551140929a2cc0b2f">&#9670;&#160;</a></span>rotationMatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType , PointConcept PointType, typename ScalarType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">MatrixType vcl::rotationMatrix </td>
          <td>(</td>
          <td class="paramtype">const PointType &amp;&#160;</td>
          <td class="paramname"><em>axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ScalarType &amp;&#160;</td>
          <td class="paramname"><em>angleRad</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given an 3D axis and an angle expressed in randiants, returns a transform matrix that represents the rotation matrix of the given axis/angle. </p>
<p>The MatrixType must be at least a 3x3 matrix having the setIdentity() member function. If the matrix is a higher than 3x3 (e.g. 4x4), only the 3x3 submatrix will be set, leaving the identity values in the other cells of the matrix.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">axis</td><td></td></tr>
    <tr><td class="paramname">angleRad</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a7f6b127154a5e14946cb66492d214de8" name="a7f6b127154a5e14946cb66492d214de8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f6b127154a5e14946cb66492d214de8">&#9670;&#160;</a></span>rotationMatrixDeg()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType , PointConcept PointType, typename ScalarType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">MatrixType vcl::rotationMatrixDeg </td>
          <td>(</td>
          <td class="paramtype">const PointType &amp;&#160;</td>
          <td class="paramname"><em>axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ScalarType &amp;&#160;</td>
          <td class="paramname"><em>angleDeg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given an 3D axis and an angle expressed in degrees, fills the given matrix with a transform matrix that represents the rotation matrix of the given axis/angle. </p>
<p>The given matrix must be at least a 3x3 matrix. If the matrix is a higher than 3x3 (e.g. 4x4), only the 3x3 submatrix will be set, leaving unchanged the other values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">axis</td><td></td></tr>
    <tr><td class="paramname">angleDeg</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="ab8f881fa3253b964c05b23dae03a2462" name="ab8f881fa3253b964c05b23dae03a2462"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8f881fa3253b964c05b23dae03a2462">&#9670;&#160;</a></span>save() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::save </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>binary</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0face38d71aff86d6af2bb2ee7e35d9a" name="a0face38d71aff86d6af2bb2ee7e35d9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0face38d71aff86d6af2bb2ee7e35d9a">&#9670;&#160;</a></span>save() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType, LoggerConcept LogType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::save </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvcl_1_1FileMeshInfo.html">FileMeshInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LogType &amp;&#160;</td>
          <td class="paramname"><em>log</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>binary</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4d724a376d90559c72f63a862d0bc895" name="a4d724a376d90559c72f63a862d0bc895"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d724a376d90559c72f63a862d0bc895">&#9670;&#160;</a></span>save() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType, LoggerConcept LogType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::save </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LogType &amp;&#160;</td>
          <td class="paramname"><em>log</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>binary</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a63bff22265d64d974b4fe4267b6dbac0" name="a63bff22265d64d974b4fe4267b6dbac0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63bff22265d64d974b4fe4267b6dbac0">&#9670;&#160;</a></span>scalarWeightedBarycenter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">MeshType::VertexType::CoordType vcl::scalarWeightedBarycenter </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the barycenter of the mesh weighted on the per vertex scalar values. </p>
<p>The output baryceter is computed as a weighted average of the vertices of the mesh, using the per <a class="el" href="classvcl_1_1Vertex.html" title="The Vertex class.">Vertex</a> Scalar values as weights.</p>
<p>Requirements:</p><ul>
<li><a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>:<ul>
<li>Vertices:<ul>
<li>Scalar</li>
</ul>
</li>
</ul>
</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>input mesh on which compute the barycenter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The barycenter weighted on the per vertex scalats. </dd></dl>

</div>
</div>
<a id="a5217f309d49911db6e36a4f6d31acdaa" name="a5217f309d49911db6e36a4f6d31acdaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5217f309d49911db6e36a4f6d31acdaa">&#9670;&#160;</a></span>scale() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType, PointConcept PointType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::scale </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PointType &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad7f4da00ff716cc6e58e2e9ade275d6a" name="ad7f4da00ff716cc6e58e2e9ade275d6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7f4da00ff716cc6e58e2e9ade275d6a">&#9670;&#160;</a></span>scale() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType, typename Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::scale </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scalar &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aaec6c356404a0bf3eb24a29e867004df" name="aaec6c356404a0bf3eb24a29e867004df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaec6c356404a0bf3eb24a29e867004df">&#9670;&#160;</a></span>selectNonManifoldVertices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::selectNonManifoldVertices </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>clearSelectionFirst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2cb661aee95c85d26bcd064375b3c7dd" name="a2cb661aee95c85d26bcd064375b3c7dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cb661aee95c85d26bcd064375b3c7dd">&#9670;&#160;</a></span>setMeshColor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;HasColor MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::setMeshColor </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Color.html">vcl::Color</a>&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the color component of a mesh. </p>
<p>Requirements:</p><ul>
<li><a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>:<ul>
<li><a class="el" href="classvcl_1_1Color.html" title="The Color class represents an RGBA color.">Color</a></li>
</ul>
</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">m</td><td>the mesh on which set the color. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>the color to set to the mesh. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a236951d11e297e90a0a316f64c77e749" name="a236951d11e297e90a0a316f64c77e749"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a236951d11e297e90a0a316f64c77e749">&#9670;&#160;</a></span>setPerFaceColor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::setPerFaceColor </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Color.html">vcl::Color</a>&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>onlySelected</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the color of the faces. If the <code>onlySelected</code> flag is set to <code>true</code>, only the color of the selected faces will be set. Otherwise, all the faces will have the same color. </p>
<p>Requirements:</p><ul>
<li><a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>:<ul>
<li>Faces:<ul>
<li><a class="el" href="classvcl_1_1Color.html" title="The Color class represents an RGBA color.">Color</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">m</td><td>the mesh on which set the face color. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>the color to set to the faces of the mesh. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">onlySelected</td><td>if <code>true</code>, the color will be set just on the selected faces. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a39a8c9027a5e7c936518969bda799f71" name="a39a8c9027a5e7c936518969bda799f71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39a8c9027a5e7c936518969bda799f71">&#9670;&#160;</a></span>setPerFaceColorFromConnectedComponents() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::setPerFaceColorFromConnectedComponents </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets face colors according from connected components of the mesh. Each connected component will have a different per face color. Since this function will need to compute connected components of the mesh, also per <a class="el" href="classvcl_1_1Face.html" title="The Face class.">Face</a> AdjacentFaces component is required. </p>
<p>Requirements:</p><ul>
<li><a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>:<ul>
<li>Faces:<ul>
<li>AdjacentFaces</li>
<li><a class="el" href="classvcl_1_1Color.html" title="The Color class represents an RGBA color.">Color</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">m</td><td>the mesh on which set the face colors according to its connected components. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aefda81ff00c7e8d3b5ff19c9e90c03bf" name="aefda81ff00c7e8d3b5ff19c9e90c03bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefda81ff00c7e8d3b5ff19c9e90c03bf">&#9670;&#160;</a></span>setPerFaceColorFromConnectedComponents() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::setPerFaceColorFromConnectedComponents </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::set&lt; <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>connectedComponents</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given an already computed vector of sets of connected components (see vcl::connectedComponents(m) in <code><a class="el" href="clean_8h.html">vclib/algorithms/clean.h</a></code>), sets face colors according from connected components of the mesh. Each connected component will have a different per face color. </p>
<p>Requirements:</p><ul>
<li><a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>:<ul>
<li>Faces:<ul>
<li><a class="el" href="classvcl_1_1Color.html" title="The Color class represents an RGBA color.">Color</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">m</td><td>the mesh on which set the face colors according to its connected components. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">connectedComponents</td><td>a vector of sets, each one of them containing the face ids of a connected component. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae93eb0f4de91d15f5de763f2372a046a" name="ae93eb0f4de91d15f5de763f2372a046a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae93eb0f4de91d15f5de763f2372a046a">&#9670;&#160;</a></span>setPerFaceColorFromScalar()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::setPerFaceColorFromScalar </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Color.html#a32ace7bd7fccf742b39f6cd83042a10f">vcl::Color::ColorMap</a>&#160;</td>
          <td class="paramname"><em>colorMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename MeshType::FaceType::ScalarType&#160;</td>
          <td class="paramname"><em>minScalar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename MeshType::FaceType::ScalarType&#160;</td>
          <td class="paramname"><em>maxScalar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the face colors from the scalar values by computing a shading in the given color map (default is Red to Blue color map), in the given interval [minScalar, maxScalar]. </p>
<p>If minScalar and maxScalar are not set (or if they are equal), the range is automatically computed.</p>
<p>Requirements:</p><ul>
<li><a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>:<ul>
<li>Faces:<ul>
<li><a class="el" href="classvcl_1_1Color.html" title="The Color class represents an RGBA color.">Color</a></li>
<li>Scalar</li>
</ul>
</li>
</ul>
</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">m</td><td>mesh on which compute the face color. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">colorMap</td><td>the colormap to use to color the faces of the mesh (default: RedBlue). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">minScalar</td><td>the minimum value of the range to use for coloring (default: 0). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxScalar</td><td>the maximum value of the range to use for coloring (default: 0). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a698e981e0c5fd646f3401579735e7825" name="a698e981e0c5fd646f3401579735e7825"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a698e981e0c5fd646f3401579735e7825">&#9670;&#160;</a></span>setPerFaceColorFromVertexColor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::setPerFaceColorFromVertexColor </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the face colors from its incident vertex colors, computing a plain average of the vertex colors. </p>
<p>Requirements:</p><ul>
<li><a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>:<ul>
<li>Vertices:<ul>
<li><a class="el" href="classvcl_1_1Color.html" title="The Color class represents an RGBA color.">Color</a></li>
</ul>
</li>
<li>Faces:<ul>
<li><a class="el" href="classvcl_1_1Color.html" title="The Color class represents an RGBA color.">Color</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">m</td><td>mesh on which transfer the vertex color into the face color. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af02be2fb7f65c872e8dde9bd8565bc09" name="af02be2fb7f65c872e8dde9bd8565bc09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af02be2fb7f65c872e8dde9bd8565bc09">&#9670;&#160;</a></span>setPerFaceColorScattering()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::setPerFaceColorScattering </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a>&#160;</td>
          <td class="paramname"><em>nColors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>checkFauxEdges</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function colors each face of the mesh using a given number of scattering colors (default number is 50). By default, colors uniformely adjacent faces having faux edges in common. This check is made only if the option <code>checkFauxEdges</code> is set to true, and if the per <a class="el" href="classvcl_1_1Face.html" title="The Face class.">Face</a> AdjacentFaces component is available in the mesh. </p>
<p>Requirements:</p><ul>
<li><a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>:<ul>
<li>Faces:<ul>
<li><a class="el" href="classvcl_1_1Color.html" title="The Color class represents an RGBA color.">Color</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Optional:</p><ul>
<li><a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>:<ul>
<li>Faces:<ul>
<li>AdjacentFaces</li>
</ul>
</li>
</ul>
</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">m</td><td>mesh on which set the face colors. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nColors</td><td>number of colors used for the scattering (default 50). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">checkFauxEdges</td><td>if true, colors uniformely adjacent faces with faux edges (default <code>true</code>). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a325958d633ef2b4e07217615993933af" name="a325958d633ef2b4e07217615993933af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a325958d633ef2b4e07217615993933af">&#9670;&#160;</a></span>setPerFaceScalar()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::setPerFaceScalar </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename MeshType::FaceType::ScalarType&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets a constant value to all the face scalars of the mesh. </p>
<p>Requirements:</p><ul>
<li><a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>:<ul>
<li>Faces:<ul>
<li>Scalar</li>
</ul>
</li>
</ul>
</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">m</td><td>mesh on which set the face scalars </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>scalar value to set </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae1d1835fbdfdc91928dee5eb7234b8ba" name="ae1d1835fbdfdc91928dee5eb7234b8ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1d1835fbdfdc91928dee5eb7234b8ba">&#9670;&#160;</a></span>setPerFaceScalarFromFaceArea()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::setPerFaceScalarFromFaceArea </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assign to the face scalars of the mesh the area of each face. </p>
<p>Requirements:</p><ul>
<li><a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>:<ul>
<li>Faces</li>
</ul>
</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">m</td><td>mesh on which set the face scalars to the face area </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa643c00b32840296da8c9dbe4932dabb" name="aa643c00b32840296da8c9dbe4932dabb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa643c00b32840296da8c9dbe4932dabb">&#9670;&#160;</a></span>setPerVertexColor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::setPerVertexColor </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Color.html">vcl::Color</a>&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>onlySelected</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the color of the vertices. If the <code>onlySelected</code> flag is set to <code>true</code>, only the color of the selected vertices will be set. Otherwise, all the vertices will have the same color. </p>
<p>Requirements:</p><ul>
<li><a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>:<ul>
<li>Vertices:<ul>
<li><a class="el" href="classvcl_1_1Color.html" title="The Color class represents an RGBA color.">Color</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">m</td><td>the mesh on which set the vertex color. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>the color to set to the vertices of the mesh. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">onlySelected</td><td>if <code>true</code>, the color will be set just on the selected vertices. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8af505d2c161282e28934d6be34a3cfc" name="a8af505d2c161282e28934d6be34a3cfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8af505d2c161282e28934d6be34a3cfc">&#9670;&#160;</a></span>setPerVertexColorFromFaceBorderFlag()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::setPerVertexColorFromFaceBorderFlag </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Color.html">Color</a>&#160;</td>
          <td class="paramname"><em>borderColor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Color.html">Color</a>&#160;</td>
          <td class="paramname"><em>internalColor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Color.html">Color</a>&#160;</td>
          <td class="paramname"><em>mixColor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classvcl_1_1Color.html" title="The Color class represents an RGBA color.">Color</a> the vertices of the mesh that are on border, using the border flags of the faces. </p>
<p>Before using this function, you should update the face border flags accordingly.</p>
<p>Requirements:</p><ul>
<li><a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>:<ul>
<li>Vertices:<ul>
<li><a class="el" href="classvcl_1_1Color.html" title="The Color class represents an RGBA color.">Color</a></li>
</ul>
</li>
<li>Faces:<ul>
<li>TriangleFlags/PolygonFlags</li>
</ul>
</li>
</ul>
</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">m</td><td>the mesh on which update the vertex color from the border face flags. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">borderColor</td><td>the color of the vertices that are part of edges that are all marked as on border. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">internalColor</td><td>the color of the vertices that are part of edges that are all marked as non on border. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mixColor</td><td>the color of vertices that are part of edges that are both on border and non on border. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a003227edc01710ea2a42c6e326b34698" name="a003227edc01710ea2a42c6e326b34698"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a003227edc01710ea2a42c6e326b34698">&#9670;&#160;</a></span>setPerVertexColorFromFaceColor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::setPerVertexColorFromFaceColor </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the vertex colors from its incident face colors, computing a plain average of the face colors. </p>
<p>Requirements:</p><ul>
<li><a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>:<ul>
<li>Vertices:<ul>
<li><a class="el" href="classvcl_1_1Color.html" title="The Color class represents an RGBA color.">Color</a></li>
</ul>
</li>
<li>Faces:<ul>
<li><a class="el" href="classvcl_1_1Color.html" title="The Color class represents an RGBA color.">Color</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">m</td><td>mesh on which transfer the face color into the vertex color. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac937d4372b4e0784cc9cf85b33fc1e61" name="ac937d4372b4e0784cc9cf85b33fc1e61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac937d4372b4e0784cc9cf85b33fc1e61">&#9670;&#160;</a></span>setPerVertexColorFromScalar()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::setPerVertexColorFromScalar </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Color.html#a32ace7bd7fccf742b39f6cd83042a10f">vcl::Color::ColorMap</a>&#160;</td>
          <td class="paramname"><em>colorMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename MeshType::VertexType::ScalarType&#160;</td>
          <td class="paramname"><em>minScalar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename MeshType::VertexType::ScalarType&#160;</td>
          <td class="paramname"><em>maxScalar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the vertex colors from the scalar values by computing a shading in the given color map (default is Red to Blue color map), in the given interval [minScalar, maxScalar]. </p>
<p>If minScalar and maxScalar are not set (or if they are equal), the range is automatically computed.</p>
<p>Requirements:</p><ul>
<li><a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>:<ul>
<li>Vertices:<ul>
<li><a class="el" href="classvcl_1_1Color.html" title="The Color class represents an RGBA color.">Color</a></li>
<li>Scalar</li>
</ul>
</li>
</ul>
</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">m</td><td>mesh on which compute the vertex color. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">colorMap</td><td>the colormap to use to color the vertices of the mesh (default: RedBlue). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">minScalar</td><td>the minimum value of the range to use for coloring (default: 0). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxScalar</td><td>the maximum value of the range to use for coloring (default: 0). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0c2fd97be0605b1e7a49d2b5611f51aa" name="a0c2fd97be0605b1e7a49d2b5611f51aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c2fd97be0605b1e7a49d2b5611f51aa">&#9670;&#160;</a></span>setPerVertexColorPerlinNoise()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType, PointConcept PointType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::setPerVertexColorPerlinNoise </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PointType&#160;</td>
          <td class="paramname"><em>period</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PointType&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>onSelected</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the vertex color according to a perlin noise computed on the vertex coordinates. </p>
<p>To make things weirder each color band can have its own offset and frequency. Period is expressed in absolute terms. So as period it is meaningful could be to use something in the range of 1/10 of the bbox diag.</p>
<p>Requirements:</p><ul>
<li><a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>:<ul>
<li>Vertices:<ul>
<li><a class="el" href="classvcl_1_1Color.html" title="The Color class represents an RGBA color.">Color</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td></td></tr>
    <tr><td class="paramname">period</td><td></td></tr>
    <tr><td class="paramname">offset</td><td></td></tr>
    <tr><td class="paramname">onSelected</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae27dccedeec719d7d3f0e7f1f084a84e" name="ae27dccedeec719d7d3f0e7f1f084a84e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae27dccedeec719d7d3f0e7f1f084a84e">&#9670;&#160;</a></span>setPerVertexPerlinColor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType, PointConcept PointType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::setPerVertexPerlinColor </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>period</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PointType&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Color.html">Color</a>&#160;</td>
          <td class="paramname"><em>color1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Color.html">Color</a>&#160;</td>
          <td class="paramname"><em>color2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>onSelected</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Simple Perlin color mixing. <code>color1</code> and <code>color2</code> are mixed according the perlin noise function, with period and offset. </p>
<p>Requirements:</p><ul>
<li><a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>:<ul>
<li>Vertices:<ul>
<li><a class="el" href="classvcl_1_1Color.html" title="The Color class represents an RGBA color.">Color</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td></td></tr>
    <tr><td class="paramname">period</td><td></td></tr>
    <tr><td class="paramname">offset</td><td></td></tr>
    <tr><td class="paramname">color1</td><td></td></tr>
    <tr><td class="paramname">color2</td><td></td></tr>
    <tr><td class="paramname">onSelected</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7d78bdbe3ba40a15958c4606980cdc36" name="a7d78bdbe3ba40a15958c4606980cdc36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d78bdbe3ba40a15958c4606980cdc36">&#9670;&#160;</a></span>setPerVertexScalar()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::setPerVertexScalar </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename MeshType::VertexType::ScalarType&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets a constant value to all the vertex scalars of the mesh. </p>
<p>Requirements:</p><ul>
<li><a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>:<ul>
<li>Vertices:<ul>
<li>Scalar</li>
</ul>
</li>
</ul>
</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">m</td><td>mesh on which set the vertex scalars </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>scalar value to set </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a91859f211d5a934ec05e85d4824c1259" name="a91859f211d5a934ec05e85d4824c1259"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91859f211d5a934ec05e85d4824c1259">&#9670;&#160;</a></span>setPerVertexScalarFromPrincipalCurvatureCurvedness()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::setPerVertexScalarFromPrincipalCurvatureCurvedness </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the Curvedness C from the Principal Curvature, as defined by [Koenderink 1992] and stores it in the per-vertex scalar. </p>
<p>C = Sqrt((k1*k1+k2*k2)/2.0)</p>
<p>J. Koenderink and A. van Doorn. Surface shape and curvature scales. <a class="el" href="classvcl_1_1Image.html">Image</a> and vision computing, 10(8):557–565, 1992. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aff1028f512578880b9d45e7557df8478" name="aff1028f512578880b9d45e7557df8478"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff1028f512578880b9d45e7557df8478">&#9670;&#160;</a></span>setPerVertexScalarFromPrincipalCurvatureGaussian()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::setPerVertexScalarFromPrincipalCurvatureGaussian </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae1398a1d87b760f96ad7a9ffc63e9dcd" name="ae1398a1d87b760f96ad7a9ffc63e9dcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1398a1d87b760f96ad7a9ffc63e9dcd">&#9670;&#160;</a></span>setPerVertexScalarFromPrincipalCurvatureMaxValue()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::setPerVertexScalarFromPrincipalCurvatureMaxValue </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4a5fcab23abe4e1e0206dc195499f5ba" name="a4a5fcab23abe4e1e0206dc195499f5ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a5fcab23abe4e1e0206dc195499f5ba">&#9670;&#160;</a></span>setPerVertexScalarFromPrincipalCurvatureMean()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::setPerVertexScalarFromPrincipalCurvatureMean </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0b39039c4d3a1cdf840bd91d66739359" name="a0b39039c4d3a1cdf840bd91d66739359"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b39039c4d3a1cdf840bd91d66739359">&#9670;&#160;</a></span>setPerVertexScalarFromPrincipalCurvatureMinValue()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::setPerVertexScalarFromPrincipalCurvatureMinValue </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a82d7eb86556357c67e9e4d9bc26e743a" name="a82d7eb86556357c67e9e4d9bc26e743a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82d7eb86556357c67e9e4d9bc26e743a">&#9670;&#160;</a></span>setPerVertexScalarFromPrincipalCurvatureShapeIndex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::setPerVertexScalarFromPrincipalCurvatureShapeIndex </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the Shape Index S from the Principal Curvature, as defined by [Koenderink 1992] and stores it in the per-vertex scalar. </p>
<p>S = 2/pi atan(k1+k2/k1-k2)</p>
<p>J. Koenderink and A. van Doorn. Surface shape and curvature scales. <a class="el" href="classvcl_1_1Image.html">Image</a> and vision computing, 10(8):557–565, 1992. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2e4d00c0f0dfb599819e7cf5b1e6c746" name="a2e4d00c0f0dfb599819e7cf5b1e6c746"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e4d00c0f0dfb599819e7cf5b1e6c746">&#9670;&#160;</a></span>setPerVertexScalarFromVertexValence()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::setPerVertexScalarFromVertexValence </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assign to the vertex scalars of the mesh the valence of each vertex, that is the number of adjacent faces of the vertex. </p>
<p>Requirements:</p><ul>
<li><a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>:<ul>
<li>Vertices:<ul>
<li>Scalar</li>
</ul>
</li>
<li>Faces</li>
</ul>
</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">m</td><td>mesh on which set the vertex scalars to the vertex valence </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a24901186f1a77f31a23d64f30f0b0dc3" name="a24901186f1a77f31a23d64f30f0b0dc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24901186f1a77f31a23d64f30f0b0dc3">&#9670;&#160;</a></span>setTransformMatrixRotation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType , PointConcept PointType, typename ScalarType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::setTransformMatrixRotation </td>
          <td>(</td>
          <td class="paramtype">MatrixType &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PointType&#160;</td>
          <td class="paramname"><em>axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ScalarType &amp;&#160;</td>
          <td class="paramname"><em>angleRad</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given an 3D axis and an angle expressed in randiants, fills the given matrix with a transform matrix that represents the rotation matrix of the given axis/angle. </p>
<p>The given matrix must be at least a 3x3 matrix. If the matrix is a higher than 3x3 (e.g. 4x4), only the 3x3 submatrix will be set, leaving unchanged the other values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix</td><td></td></tr>
    <tr><td class="paramname">axis</td><td></td></tr>
    <tr><td class="paramname">angleRad</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="abd5d95d87600e42a0da835735e35ea99" name="abd5d95d87600e42a0da835735e35ea99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd5d95d87600e42a0da835735e35ea99">&#9670;&#160;</a></span>setTransformMatrixRotationDeg()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType , PointConcept PointType, typename ScalarType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::setTransformMatrixRotationDeg </td>
          <td>(</td>
          <td class="paramtype">MatrixType &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PointType&#160;</td>
          <td class="paramname"><em>axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ScalarType &amp;&#160;</td>
          <td class="paramname"><em>angleDeg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given an 3D axis and an angle expressed in degrees, fills the given matrix with a transform matrix that represents the rotation matrix of the given axis/angle. </p>
<p>The given matrix must be at least a 3x3 matrix. If the matrix is a higher than 3x3 (e.g. 4x4), only the 3x3 submatrix will be set, leaving unchanged the other values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix</td><td></td></tr>
    <tr><td class="paramname">axis</td><td></td></tr>
    <tr><td class="paramname">angleDeg</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="af5a78d0411b7f20298f45618c3e2aff5" name="af5a78d0411b7f20298f45618c3e2aff5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5a78d0411b7f20298f45618c3e2aff5">&#9670;&#160;</a></span>setTrasformMatrixScale()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ScalarType , PointConcept PointType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::setTrasformMatrixScale </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacevcl.html#ad82a126b390f21b2e9658c73e7a795ee">Matrix44</a>&lt; ScalarType &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PointType &amp;&#160;</td>
          <td class="paramname"><em>scale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="adbb9f1401057fda582e6b0cda2a36b18" name="adbb9f1401057fda582e6b0cda2a36b18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbb9f1401057fda582e6b0cda2a36b18">&#9670;&#160;</a></span>setTrasformMatrixTranslation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ScalarType , PointConcept PointType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::setTrasformMatrixTranslation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacevcl.html#ad82a126b390f21b2e9658c73e7a795ee">Matrix44</a>&lt; ScalarType &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PointType &amp;&#160;</td>
          <td class="paramname"><em>translation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aecc52dfd02e09e49a5dd1612183a2cb8" name="aecc52dfd02e09e49a5dd1612183a2cb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecc52dfd02e09e49a5dd1612183a2cb8">&#9670;&#160;</a></span>shellBarycenter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">MeshType::VertexType::CoordType vcl::shellBarycenter </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the barycenter of the surface thin-shell. E.g. it assume a 'empty' model where all the mass is located on the surface and compute the barycenter of that thinshell. Works for any polygonal model (no problem with open, nonmanifold selfintersecting models). Useful for computing the barycenter of 2D planar figures. </p>
<p>Requirements:</p><ul>
<li><a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>:<ul>
<li>Vertices</li>
<li>Faces</li>
</ul>
</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a33f84f8e28d1adf77369c920bb0e46b5" name="a33f84f8e28d1adf77369c920bb0e46b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33f84f8e28d1adf77369c920bb0e46b5">&#9670;&#160;</a></span>smoothPerVertexNormalsPointCloud() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType, PointConcept PointType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::smoothPerVertexNormalsPointCloud </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvcl_1_1KDTree.html">KDTree</a>&lt; PointType &gt; &amp;&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a>&#160;</td>
          <td class="paramname"><em>neighborNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a>&#160;</td>
          <td class="paramname"><em>iterNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>smoothPerVertexNormalsPointCloud </p>
<p>Requirements:</p><ul>
<li><a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>:<ul>
<li>Vertices:<ul>
<li>Normal</li>
</ul>
</li>
</ul>
</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td></td></tr>
    <tr><td class="paramname">tree</td><td></td></tr>
    <tr><td class="paramname">neighborNum</td><td></td></tr>
    <tr><td class="paramname">iterNum</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9a2005cb82322d607914a2e2dcd63e66" name="a9a2005cb82322d607914a2e2dcd63e66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a2005cb82322d607914a2e2dcd63e66">&#9670;&#160;</a></span>smoothPerVertexNormalsPointCloud() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::smoothPerVertexNormalsPointCloud </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a>&#160;</td>
          <td class="paramname"><em>neighborNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a>&#160;</td>
          <td class="paramname"><em>iterNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>smoothPerVertexNormalsPointCloud </p>
<p>Requirements:</p><ul>
<li><a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>:<ul>
<li>Vertices:<ul>
<li>Normal</li>
</ul>
</li>
</ul>
</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td></td></tr>
    <tr><td class="paramname">neighborNum</td><td></td></tr>
    <tr><td class="paramname">iterNum</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0a1a624c7abe7c703618b7f512c33039" name="a0a1a624c7abe7c703618b7f512c33039"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a1a624c7abe7c703618b7f512c33039">&#9670;&#160;</a></span>Sphere()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Point3Concept P, typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Sphere.html">vcl::Sphere</a> </td>
          <td>(</td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  <a class="el" href="classvcl_1_1Sphere.html">Sphere</a>&lt; typename P::ScalarType &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9349b9ea771a0058a9cb4a57eedd624b" name="a9349b9ea771a0058a9cb4a57eedd624b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9349b9ea771a0058a9cb4a57eedd624b">&#9670;&#160;</a></span>sphereBoxIntersect()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SphereConcept SphereType, Box3Concept BoxType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool vcl::sphereBoxIntersect </td>
          <td>(</td>
          <td class="paramtype">const SphereType &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BoxType &amp;&#160;</td>
          <td class="paramname"><em>box</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks if a sphere intersects with a box in 3D space.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SphereType</td><td>A type that satisfies the SphereConcept concept. </td></tr>
    <tr><td class="paramname">BoxType</td><td>A type that satisfies the Box3Concept concept.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>The sphere to check for intersection. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">box</td><td>The box to check for intersection. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the sphere intersects with the box, false otherwise. </dd></dl>

</div>
</div>
<a id="a438da980623645640c78105766bde287" name="a438da980623645640c78105766bde287"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a438da980623645640c78105766bde287">&#9670;&#160;</a></span>sphericalFibonacciPointSet()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Point3Concept PointType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; PointType &gt; vcl::sphericalFibonacciPointSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a>&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a vector of <code>n</code> points distributed in a unit sphere. </p>
<p>This function returns a vector of <code>n</code> points that are uniformly distributed on a unit sphere, using the Spherical Fibonacci <a class="el" href="classvcl_1_1Point.html" title="The Point class represents an N-dimensional point containing N scalar values.">Point</a> Sets algorithm described in the paper "Spherical Fibonacci
Mapping" by Benjamin Keinert, Matthias Innmann, Michael Sanger, and Marc Stamminger (TOG 2015).</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">PointType</td><td>The type of the point to generate. This type must satisfy the <code>Point3Concept</code> concept.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>The number of points to generate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of <code>n</code> points distributed in a unit sphere. </dd></dl>

</div>
</div>
<a id="ab1f5ecc820f6ab64fb437ba12296601c" name="ab1f5ecc820f6ab64fb437ba12296601c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1f5ecc820f6ab64fb437ba12296601c">&#9670;&#160;</a></span>StaticGrid() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;PointIteratorConcept It&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1StaticGrid.html">vcl::StaticGrid</a> </td>
          <td>(</td>
          <td class="paramtype">It&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">It&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  <a class="el" href="classvcl_1_1StaticGrid.html">StaticGrid</a>&lt; <a class="el" href="classvcl_1_1RegularGrid.html">RegularGrid</a>&lt; typename It::value_type, It::value_type::DIM &gt;, typename It::value_type::ScalarType &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7586ced2cedb8cd2aa668c8136b24603" name="a7586ced2cedb8cd2aa668c8136b24603"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7586ced2cedb8cd2aa668c8136b24603">&#9670;&#160;</a></span>StaticGrid() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;PointIteratorConcept It, typename F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1StaticGrid.html">vcl::StaticGrid</a> </td>
          <td>(</td>
          <td class="paramtype">It&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">It&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  <a class="el" href="classvcl_1_1StaticGrid.html">StaticGrid</a>&lt; <a class="el" href="classvcl_1_1RegularGrid.html">RegularGrid</a>&lt; typename It::value_type, It::value_type::DIM &gt;, typename It::value_type::ScalarType &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae6d4557abc45cc5daf2fe2e389b91ce9" name="ae6d4557abc45cc5daf2fe2e389b91ce9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6d4557abc45cc5daf2fe2e389b91ce9">&#9670;&#160;</a></span>StaticGrid() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;VertexPointerRangeConcept Rng&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1StaticGrid.html">vcl::StaticGrid</a> </td>
          <td>(</td>
          <td class="paramtype">Rng&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt;  <a class="el" href="classvcl_1_1StaticGrid.html">StaticGrid</a>&lt; <a class="el" href="classvcl_1_1RegularGrid.html">RegularGrid</a>&lt; typename std::remove_pointer_t&lt; typename std::ranges::iterator_t&lt; Rng &gt;::value_type &gt;::CoordType::ScalarType, 3 &gt;, typename std::ranges::iterator_t&lt; Rng &gt;::value_type &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4e6de171a0b26281abfdfcf8d8873391" name="a4e6de171a0b26281abfdfcf8d8873391"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e6de171a0b26281abfdfcf8d8873391">&#9670;&#160;</a></span>stratifiedMontecarloPointSampling()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SamplerConcept SamplerType, FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">SamplerType vcl::stratifiedMontecarloPointSampling </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a>&#160;</td>
          <td class="paramname"><em>nSamples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>deterministic</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5dfa8d4e30b457c12c3e5e21b4fc123a" name="a5dfa8d4e30b457c12c3e5e21b4fc123a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5dfa8d4e30b457c12c3e5e21b4fc123a">&#9670;&#160;</a></span>surfaceArea()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double vcl::surfaceArea </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the surface area of the given <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>, that is the sum of the areas of each face of the mesh. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>mesh on which compute the surface area. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The surface area of the given mesh. </dd></dl>

</div>
</div>
<a id="a29085f23ae80546ea3ba0e9f6da41a90" name="a29085f23ae80546ea3ba0e9f6da41a90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29085f23ae80546ea3ba0e9f6da41a90">&#9670;&#160;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vcl::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1DrawableObjectVector.html">DrawableObjectVector</a> &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1DrawableObjectVector.html">DrawableObjectVector</a> &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab4be0c0af294a129f49f266a45ee51c9" name="ab4be0c0af294a129f49f266a45ee51c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4be0c0af294a129f49f266a45ee51c9">&#9670;&#160;</a></span>taubinSmoothing()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::taubinSmoothing </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a>&#160;</td>
          <td class="paramname"><em>step</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>smoothSelected</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1578b48cbfdb04c6675ac5a3b535bb83" name="a1578b48cbfdb04c6675ac5a3b535bb83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1578b48cbfdb04c6675ac5a3b535bb83">&#9670;&#160;</a></span>toDeg()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Scalar vcl::toDeg </td>
          <td>(</td>
          <td class="paramtype">const Scalar &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a53f705e848cce98dd23542a2d109e55b" name="a53f705e848cce98dd23542a2d109e55b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53f705e848cce98dd23542a2d109e55b">&#9670;&#160;</a></span>toRad()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Scalar vcl::toRad </td>
          <td>(</td>
          <td class="paramtype">const Scalar &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7c4a60eeed3ddead3611508975cb6045" name="a7c4a60eeed3ddead3611508975cb6045"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c4a60eeed3ddead3611508975cb6045">&#9670;&#160;</a></span>translate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType, PointConcept PointType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::translate </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PointType &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9b3c4b3e9c618082e4fbd063afafccb4" name="a9b3c4b3e9c618082e4fbd063afafccb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b3c4b3e9c618082e4fbd063afafccb4">&#9670;&#160;</a></span>triangleBoxIntersect()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ConstTriangle3Concept TriangleType, Box3Concept BoxType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool vcl::triangleBoxIntersect </td>
          <td>(</td>
          <td class="paramtype">const TriangleType &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BoxType &amp;&#160;</td>
          <td class="paramname"><em>box</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if a triangle intersects with a box. <a href="https://gist.github.com/jflipts/fc68d4eeacfcc04fbdb2bf38e0911850">https://gist.github.com/jflipts/fc68d4eeacfcc04fbdb2bf38e0911850</a>. </p>

</div>
</div>
<a id="ab78be5dc0d03ed32cde7a2262b506c74" name="ab78be5dc0d03ed32cde7a2262b506c74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab78be5dc0d03ed32cde7a2262b506c74">&#9670;&#160;</a></span>trianglePointIntersect()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ConstTriangle2Concept TriangleType, Point2Concept PointType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool vcl::trianglePointIntersect </td>
          <td>(</td>
          <td class="paramtype">const TriangleType &amp;&#160;</td>
          <td class="paramname"><em>tr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PointType &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks if a 2D point intersects with/is inside a given 2D triangle having its points in counterclockwise order.</p>
<p>The function checks if a point lies within a given triangle using barycentric coordinates. It first calculates the area of the triangle, and then calculates the barycentric coordinates of the point with respect to the triangle. If the barycentric coordinates satisfy certain conditions, then the point is considered to intersect with the triangle.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TriangleType</td><td>A type that satisfies the ConstTriangle2Concept concept. </td></tr>
    <tr><td class="paramname">PointType</td><td>A type that satisfies the Point2Concept concept.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tr</td><td>The triangle to test for intersection. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>The point to test for intersection with the triangle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the point intersects with/is inside the triangle, false otherwise.</dd></dl>
<p>Checks if a 3D point intersects/is inside a 3D triangle having its points in counterclockwise order.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TriangleType</td><td>A type that satisfies the ConstTriangle3Concept concept. </td></tr>
    <tr><td class="paramname">PointType</td><td>A type that satisfies the Point3Concept concept.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>The triangle to test for intersection. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>The point to test for intersection with the triangle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the point intersects with/is inside the triangle, false otherwise. </dd></dl>

</div>
</div>
<a id="af510b267910115525d77a6b4539ca3cd" name="af510b267910115525d77a6b4539ca3cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af510b267910115525d77a6b4539ca3cd">&#9670;&#160;</a></span>triangleSphereItersect() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ConstTriangle3Concept TriangleType, SphereConcept SphereType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool vcl::triangleSphereItersect </td>
          <td>(</td>
          <td class="paramtype">const TriangleType &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SphereType &amp;&#160;</td>
          <td class="paramname"><em>sphere</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the intersection between a sphere and a triangle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>the 3D input triangle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sphere</td><td>the input sphere </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true iff there is an intersection between the sphere and the triangle </dd></dl>

</div>
</div>
<a id="afef4c14e85563ae0db11815309e9a5cc" name="afef4c14e85563ae0db11815309e9a5cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afef4c14e85563ae0db11815309e9a5cc">&#9670;&#160;</a></span>triangleSphereItersect() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ConstTriangle3Concept TriangleType, SphereConcept SphereType, Point3Concept PointType, typename ScalarType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool vcl::triangleSphereItersect </td>
          <td>(</td>
          <td class="paramtype">const TriangleType &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SphereType &amp;&#160;</td>
          <td class="paramname"><em>sphere</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PointType &amp;&#160;</td>
          <td class="paramname"><em>witness</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::pair&lt; ScalarType, ScalarType &gt; &amp;&#160;</td>
          <td class="paramname"><em>res</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the intersection between a sphere and a triangle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>the 3D input triangle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sphere</td><td>the input sphere </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">witness</td><td>the point on the triangle nearest to the center of the sphere (even when there isn't intersection) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">res</td><td>if not null, in the first item is stored the minimum distance between the triangle and the sphere, while in the second item is stored the penetration depth </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true iff there is an intersection between the sphere and the triangle </dd></dl>

</div>
</div>
<a id="a08ddfb40632cb38ec4750610e0e2ebaa" name="a08ddfb40632cb38ec4750610e0e2ebaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08ddfb40632cb38ec4750610e0e2ebaa">&#9670;&#160;</a></span>tupleIndexByType()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename... Us&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> vcl::tupleIndexByType </td>
          <td>(</td>
          <td class="paramtype">const std::tuple&lt; U, Us... &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the index of a type T in a std::tuple&lt;U, Us...&gt; passed as parameter; Returns UINT_NULL if the type T is not found in the tuple. </p>

</div>
</div>
<a id="a359b253b8af6d1ae3ac24625e8ac7a56" name="a359b253b8af6d1ae3ac24625e8ac7a56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a359b253b8af6d1ae3ac24625e8ac7a56">&#9670;&#160;</a></span>updateBorder()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::updateBorder </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes per-face border flags without requiring any kind of topology info. </p>
<p>Requirements:</p><ul>
<li><a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>:<ul>
<li>Vertices</li>
<li>Faces</li>
</ul>
</li>
</ul>
<p>Complexity: O(NF log (NF))</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>the mesh on which the border flags will be updated </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8ecd18a495232ac86d4c81913a1ad3f7" name="a8ecd18a495232ac86d4c81913a1ad3f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ecd18a495232ac86d4c81913a1ad3f7">&#9670;&#160;</a></span>updateBoundingBox()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;HasBoundingBox MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::updateBoundingBox </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates the bounding box of the mesh. </p>
<p>Requirements:</p><ul>
<li><a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>:<ul>
<li>Vertices</li>
<li>BoundingBox</li>
</ul>
</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3db69fc234fc8072747aabf1724f9b92" name="a3db69fc234fc8072747aabf1724f9b92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3db69fc234fc8072747aabf1724f9b92">&#9670;&#160;</a></span>updatePerFaceAdjacentFaces()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::updatePerFaceAdjacentFaces </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates the per face adjacent face component. </p>
<p>All the faces that does not have an adjacent face (border) will have the adjacent face set to nullptr.</p>
<p>If there are non-manifold edges (edges on which there are more than two incident faces), then a chain-link composed of all the incident faces is built.</p>
<p>Assuming that we have 3 faces f0, f1 and f2 on the same edge composed of vi and vj, we can define the edge indices in the three faces as:</p>
<div class="fragment"><div class="line">e0 = f0.indexOfEdge(vi, vj);</div>
<div class="line">e1 = f1.indexOfEdge(vi, vj);</div>
<div class="line">e2 = f2.indexOfEdge(vi, vj);</div>
</div><!-- fragment --><p>The adjacencies will cycle like:</p>
<div class="fragment"><div class="line">f0-&gt;adjFace(e0) == f1;</div>
<div class="line">f1-&gt;adjFace(e1) == f2;</div>
<div class="line">f2-&gt;adjFace(e2) == f0;</div>
</div><!-- fragment --><p>or a similar permutation of the faces.</p>
<p>In general, an edge is non-manifold if it is true the expression:</p>
<div class="fragment"><div class="line">fj = fi-&gt;adjFace(ei);</div>
<div class="line">fj-&gt;adjFace(ej) != fi; <span class="comment">// if true, the edge is non-manifold</span></div>
</div><!-- fragment --><p>Requirements:</p><ul>
<li><a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>:<ul>
<li>Faces:<ul>
<li>AdjacentFaces</li>
</ul>
</li>
</ul>
</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>the mesh on which update the per face adjacent faces. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9a15ac19d4224a7a140430d7c209203c" name="a9a15ac19d4224a7a140430d7c209203c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a15ac19d4224a7a140430d7c209203c">&#9670;&#160;</a></span>updatePerFaceNormals()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::updatePerFaceNormals </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>normalize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>updatePerFaceNormals </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">m</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">normalize</td><td>if true (default), normals are normalized after computation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af3ecae45cc9e58f948dc04178fd6669b" name="af3ecae45cc9e58f948dc04178fd6669b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3ecae45cc9e58f948dc04178fd6669b">&#9670;&#160;</a></span>updatePerVertexAdjacentFaces()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::updatePerVertexAdjacentFaces </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates the adjacent faces of each vertex of the mesh. </p>
<p>Requirements:</p><ul>
<li><a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>:<ul>
<li>Vertices:<ul>
<li>AdjacentFaces</li>
</ul>
</li>
<li>Faces</li>
</ul>
</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>the mesh on which update the per vertex adjacent faces. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6b6e8d46b2b867729d95c72ab1925df2" name="a6b6e8d46b2b867729d95c72ab1925df2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b6e8d46b2b867729d95c72ab1925df2">&#9670;&#160;</a></span>updatePerVertexAdjacentVertices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::updatePerVertexAdjacentVertices </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates the adjacent vertices of each vertex of the mesh. </p>
<p>Requirements:</p><ul>
<li><a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>:<ul>
<li>Vertices:<ul>
<li>AdjacentVertices</li>
</ul>
</li>
<li>Faces</li>
</ul>
</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>the mesh on which update the per vertex adjacent faces. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5ffafa25128bbb020b17d135d5f1ac30" name="a5ffafa25128bbb020b17d135d5f1ac30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ffafa25128bbb020b17d135d5f1ac30">&#9670;&#160;</a></span>updatePerVertexNormals()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::updatePerVertexNormals </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>normalize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the vertex normal as the classic area weighted average. </p>
<p>This function does not need or exploit current face normals. Unreferenced vertex normals are left unchanged.</p>
<p>Requirements:</p><ul>
<li><a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>:<ul>
<li>Vertices:<ul>
<li>Normal</li>
</ul>
</li>
<li>Faces</li>
</ul>
</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">m</td><td>the mesh on which compute the vertex normals. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">normalize</td><td>if true (default), normals are normalized after computation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abed9b2152933865a0d095b9ff2e28087" name="abed9b2152933865a0d095b9ff2e28087"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abed9b2152933865a0d095b9ff2e28087">&#9670;&#160;</a></span>updatePerVertexNormalsAngleWeighted()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::updatePerVertexNormalsAngleWeighted </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>normalize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the vertex normal as an angle weighted average. </p>
<p>The normal of a vertex <code>v</code> computed as a weighted sum the incident face normals. The weight is simlply the angle of the involved wedge. Described in:</p>
<div class="fragment"><div class="line">G. Thurmer, C. A. Wuthrich</div>
<div class="line">  <span class="stringliteral">&quot;Computing vertex normals from polygonal facets&quot;</span></div>
<div class="line">  Journal of Graphics Tools, 1998</div>
</div><!-- fragment --><p>This function does not need or exploit current face normals. Unreferenced vertex normals are left unchanged.</p>
<p>Requirements:</p><ul>
<li><a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>:<ul>
<li>Vertices:<ul>
<li>Normal</li>
</ul>
</li>
<li>Faces</li>
</ul>
</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">m</td><td>the mesh on which compute the angle weighted vertex normals. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">normalize</td><td>if true (default), normals are normalized after computation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a174b88dbc14a78799d856505b061a2cb" name="a174b88dbc14a78799d856505b061a2cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a174b88dbc14a78799d856505b061a2cb">&#9670;&#160;</a></span>updatePerVertexNormalsFromFaceNormals()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::updatePerVertexNormalsFromFaceNormals </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>normalize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the vertex normal as the sum of the adjacent faces normals. </p>
<p>Unreferenced vertex normals are left unchanged.</p>
<p>Requirements:</p><ul>
<li><a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>:<ul>
<li>Vertices:<ul>
<li>Normal</li>
</ul>
</li>
<li>Faces<ul>
<li>Normal</li>
</ul>
</li>
</ul>
</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">m</td><td>the mesh on which compute the vertex normals. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">normalize</td><td>if true (default), normals are normalized after computation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac81b97996fdfb6ff64cf8f42688b9ebc" name="ac81b97996fdfb6ff64cf8f42688b9ebc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac81b97996fdfb6ff64cf8f42688b9ebc">&#9670;&#160;</a></span>updatePerVertexNormalsNelsonMaxWeighted()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::updatePerVertexNormalsNelsonMaxWeighted </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>normalize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the vertex normal using the Max et al. weighting scheme. </p>
<p>The normal of a vertex v is computed according to the formula described in:</p>
<div class="fragment"><div class="line">Max, N.,</div>
<div class="line">  <span class="stringliteral">&quot;Weights for Computing Vertex Normals from Facet Normals&quot;</span>,</div>
<div class="line">  Journal of Graphics Tools, 4(2) (1999)</div>
</div><!-- fragment --><p>The weight for each wedge is the cross product of the two edge over the product of the square of the two edge lengths. According to the original paper it is perfect only for spherical surface, but it should perform well...</p>
<p>This function does not need or exploit current face normals. Unreferenced vertex normals are left unchanged.</p>
<p>Requirements:</p><ul>
<li><a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>:<ul>
<li>Vertices:<ul>
<li>Normal</li>
</ul>
</li>
<li>Faces</li>
</ul>
</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">m</td><td>the mesh on which compute the Max et al. weighted vertex normals. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">normalize</td><td>if true (default), normals are normalized after computation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a187f29d4ba3ddfbf954bab8ad61967d1" name="a187f29d4ba3ddfbf954bab8ad61967d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a187f29d4ba3ddfbf954bab8ad61967d1">&#9670;&#160;</a></span>updatePrincipalCurvature() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType, LoggerConcept LogType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::updatePrincipalCurvature </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LogType &amp;&#160;</td>
          <td class="paramname"><em>log</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0d231fe4d9706e7a951c377995688079" name="a0d231fe4d9706e7a951c377995688079"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d231fe4d9706e7a951c377995688079">&#9670;&#160;</a></span>updatePrincipalCurvature() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType, LoggerConcept LogType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::updatePrincipalCurvature </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacevcl.html#aaca879a6bfd47ff8429d6b2f6cfa9440">VCLibPrincipalCurvatureAlgorithm</a>&#160;</td>
          <td class="paramname"><em>alg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LogType &amp;&#160;</td>
          <td class="paramname"><em>log</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6f5267f974ec6b9fef98556736bbe9ea" name="a6f5267f974ec6b9fef98556736bbe9ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f5267f974ec6b9fef98556736bbe9ea">&#9670;&#160;</a></span>updatePrincipalCurvaturePCA()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType, LoggerConcept LogType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::updatePrincipalCurvaturePCA </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename MeshType::VertexType::ScalarType&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>montecarloSampling</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LogType &amp;&#160;</td>
          <td class="paramname"><em>log</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the Principal Curvature meseaure as described in the paper: Robust principal curvatures on Multiple Scales, Yong-Liang Yang, Yu-Kun Lai, Shi-Min Hu Helmut Pottmann SGP 2004. If montecarloSampling==true the covariance is computed by montecarlo sampling on the mesh (faster); If montecarloSampling==false the covariance is computed by (analytic)integration over the surface (slower). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td></td></tr>
    <tr><td class="paramname">radius</td><td></td></tr>
    <tr><td class="paramname">montecarloSampling</td><td></td></tr>
    <tr><td class="paramname">log</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0953cccb4f94dded63edb630530e2197" name="a0953cccb4f94dded63edb630530e2197"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0953cccb4f94dded63edb630530e2197">&#9670;&#160;</a></span>updatePrincipalCurvatureTaubin95()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType, LoggerConcept LogType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::updatePrincipalCurvatureTaubin95 </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LogType &amp;&#160;</td>
          <td class="paramname"><em>log</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa7b813fbc070c26bf20205c4d9adb98a" name="aa7b813fbc070c26bf20205c4d9adb98a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7b813fbc070c26bf20205c4d9adb98a">&#9670;&#160;</a></span>vertexMatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matrix , MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Matrix vcl::vertexMatrix </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8fdd1423f72e851ab3c51fecda888b60" name="a8fdd1423f72e851ab3c51fecda888b60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fdd1423f72e851ab3c51fecda888b60">&#9670;&#160;</a></span>vertexNormalsMatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matrix , MeshConcept MeshType&gt; <br />
requires HasPerVertexNormal&lt;MeshType&gt;</div>
      <table class="memname">
        <tr>
          <td class="memname">Matrix vcl::vertexNormalsMatrix </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a #V*3 Matrix of scalars containing the normals of the vertices of a <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>. The function is templated on the Matrix itself. </p>
<p>This function works with every Matrix type that:</p><ul>
<li>has a constructor with rows and columns numbers;</li>
<li>has the <code>()</code> operator to acces to the (i,j) element (e.g.: <code>M(i,j) = 0;</code>).</li>
</ul>
<p>Usage example with Eigen Matrix:</p>
<div class="fragment"><div class="line">Eigen::MatrixX3d VN = vcl::vertexNormalsMatrix&lt;Eigen::MatrixX3d&gt;(myMesh);</div>
</div><!-- fragment --><p>Requirements:</p><ul>
<li><a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>:<ul>
<li>Vertices<ul>
<li>Normals</li>
</ul>
</li>
</ul>
</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>input mesh </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>#V*3 matrix of scalars (vertex normals) </dd></dl>

</div>
</div>
<a id="ad2f710a404acc6926e189fab8c987a38" name="ad2f710a404acc6926e189fab8c987a38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2f710a404acc6926e189fab8c987a38">&#9670;&#160;</a></span>vertexRadiusFromScalar()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; typename MeshType::VertexType::ScalarType &gt; vcl::vertexRadiusFromScalar </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>diskRadius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>radiusVariance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>invert</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>When performing an adptive pruning for each sample we expect a varying radius to be removed. The radius is a PerVertex attribute that we compute from the current per vertex scalar component. The expected radius of the sample is computed so that it linearly maps the quality between diskradius and diskradius*variance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td></td></tr>
    <tr><td class="paramname">diskRadius</td><td></td></tr>
    <tr><td class="paramname">radiusVariance</td><td></td></tr>
    <tr><td class="paramname">invert</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="aca01bc85ddb1d1380f67edccbc1de874" name="aca01bc85ddb1d1380f67edccbc1de874"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca01bc85ddb1d1380f67edccbc1de874">&#9670;&#160;</a></span>vertexRadiusFromWeights()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType, typename ScalarType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; ScalarType &gt; vcl::vertexRadiusFromWeights </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; ScalarType &gt; &amp;&#160;</td>
          <td class="paramname"><em>weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>diskRadius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>radiusVariance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>invert</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>When performing an adptive pruning for each sample we expect a varying radius to be removed. The radius is a PerVertex attribute that we compute from the current per vertex weights given as argument. The expected radius of the sample is computed so that it linearly maps the quality between diskradius and diskradius*variance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td></td></tr>
    <tr><td class="paramname">weights</td><td></td></tr>
    <tr><td class="paramname">diskRadius</td><td></td></tr>
    <tr><td class="paramname">radiusVariance</td><td></td></tr>
    <tr><td class="paramname">invert</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a75ed72afa568f487bd2a4cc2f6839c93" name="a75ed72afa568f487bd2a4cc2f6839c93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75ed72afa568f487bd2a4cc2f6839c93">&#9670;&#160;</a></span>vertexScalarAverage()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">MeshType::VertexType::ScalarType vcl::vertexScalarAverage </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a scalar that is the average of the vertex scalars. </p>
<p>Requirements:</p><ul>
<li><a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>:<ul>
<li>Vertices:<ul>
<li>Scalar</li>
</ul>
</li>
</ul>
</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>the input <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a> on which compute the average of the scalars. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The average of the vertex scalars of the given mesh. </dd></dl>

</div>
</div>
<a id="ad6593afbf201de1ecd2c075ec374092d" name="ad6593afbf201de1ecd2c075ec374092d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6593afbf201de1ecd2c075ec374092d">&#9670;&#160;</a></span>vertexScalarHistogram()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType, typename HScalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Histogram.html">Histogram</a>&lt; HScalar &gt; vcl::vertexScalarHistogram </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>selectionOnly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a>&#160;</td>
          <td class="paramname"><em>histSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4a8d317c143b86f988742f1d171fcf0e" name="a4a8d317c143b86f988742f1d171fcf0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a8d317c143b86f988742f1d171fcf0e">&#9670;&#160;</a></span>vertexScalarMinMax()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; typename MeshType::VertexType::ScalarType, typename MeshType::VertexType::ScalarType &gt; vcl::vertexScalarMinMax </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a pair containing the min and the maximum vertex scalars. </p>
<p>Requirements:</p><ul>
<li><a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>:<ul>
<li>Vertices:<ul>
<li>Scalar</li>
</ul>
</li>
</ul>
</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>the input <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a> on which compute the minimum and the maximum scalars. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code>std::pair</code> having as first element the minimum, and as second element the maximum scalar. </dd></dl>

</div>
</div>
<a id="a6ae1dec894859f749aaff3df2b173f32" name="a6ae1dec894859f749aaff3df2b173f32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ae1dec894859f749aaff3df2b173f32">&#9670;&#160;</a></span>vertexScalarWeightedMontecarloPointSampling()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SamplerConcept SamplerType, FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">SamplerType vcl::vertexScalarWeightedMontecarloPointSampling </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a>&#160;</td>
          <td class="paramname"><em>nSamples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>variance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>deterministic</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7ebad55b87f91b27b05663d9ce7ad406" name="a7ebad55b87f91b27b05663d9ce7ad406"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ebad55b87f91b27b05663d9ce7ad406">&#9670;&#160;</a></span>vertexSelectionNumber()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> vcl::vertexSelectionNumber </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac85dcd1cf45edec73080b696eec3b979" name="ac85dcd1cf45edec73080b696eec3b979"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac85dcd1cf45edec73080b696eec3b979">&#9670;&#160;</a></span>vertexWeightedMontecarloPointSampling()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SamplerConcept SamplerType, FaceMeshConcept MeshType, typename ScalarType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">SamplerType vcl::vertexWeightedMontecarloPointSampling </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; ScalarType &gt; &amp;&#160;</td>
          <td class="paramname"><em>weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a>&#160;</td>
          <td class="paramname"><em>nSamples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>variance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>deterministic</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9a3eb7aeb0da02be51ca136620616b43" name="a9a3eb7aeb0da02be51ca136620616b43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a3eb7aeb0da02be51ca136620616b43">&#9670;&#160;</a></span>volume()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double vcl::volume </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the volume of a closed surface <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>. Returned value is meaningful only if the input mesh is watertight. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>closed mesh on which compute the volume. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The volume of the given mesh. </dd></dl>

</div>
</div>
<a id="abe0d3154bb94af5fb7d34bd186eba0b3" name="abe0d3154bb94af5fb7d34bd186eba0b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe0d3154bb94af5fb7d34bd186eba0b3">&#9670;&#160;</a></span>weightedCovarianceMatrixOfPointCloud()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;PointConcept PointType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto vcl::weightedCovarianceMatrixOfPointCloud </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; PointType &gt; &amp;&#160;</td>
          <td class="paramname"><em>pointVec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; typename PointType::ScalarType &gt; &amp;&#160;</td>
          <td class="paramname"><em>weights</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the weighted covariance matrix of a set of points. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pointVec</td><td></td></tr>
    <tr><td class="paramname">weights</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a519b68bed74d2385e33a29e725601002" name="a519b68bed74d2385e33a29e725601002"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a519b68bed74d2385e33a29e725601002">&#9670;&#160;</a></span>UINT_NULL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> vcl::UINT_NULL = std::numeric_limits&lt;<a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a>&gt;<a class="el" href="namespacevcl.html#a69cc63a5ad2974d082145ed1dee7846b">::max</a>()</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacevcl.html">vcl</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6 </li>
  </ul>
</div>
</body>
</html>
