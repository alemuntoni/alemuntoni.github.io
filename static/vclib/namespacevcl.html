<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Visual Computing Library: vcl Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
       <script type="text/javascript">
           DoxygenAwesomeDarkModeToggle.init()
       </script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Visual Computing Library
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('namespacevcl.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#concepts">Concepts</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">vcl Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacevcl_1_1comp" id="r_namespacevcl_1_1comp"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl_1_1comp.html">comp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacevcl_1_1edge" id="r_namespacevcl_1_1edge"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl_1_1edge.html">edge</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacevcl_1_1edgemesh" id="r_namespacevcl_1_1edgemesh"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl_1_1edgemesh.html">edgemesh</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacevcl_1_1face" id="r_namespacevcl_1_1face"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl_1_1face.html">face</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacevcl_1_1io" id="r_namespacevcl_1_1io"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl_1_1io.html">io</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacevcl_1_1mesh" id="r_namespacevcl_1_1mesh"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl_1_1mesh.html">mesh</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacevcl_1_1pointcloud" id="r_namespacevcl_1_1pointcloud"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl_1_1pointcloud.html">pointcloud</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacevcl_1_1polyedgemesh" id="r_namespacevcl_1_1polyedgemesh"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl_1_1polyedgemesh.html">polyedgemesh</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacevcl_1_1polymesh" id="r_namespacevcl_1_1polymesh"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl_1_1polymesh.html">polymesh</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacevcl_1_1proc" id="r_namespacevcl_1_1proc"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl_1_1proc.html">proc</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacevcl_1_1triedgemesh" id="r_namespacevcl_1_1triedgemesh"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl_1_1triedgemesh.html">triedgemesh</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacevcl_1_1trimesh" id="r_namespacevcl_1_1trimesh"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl_1_1trimesh.html">trimesh</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacevcl_1_1vc" id="r_namespacevcl_1_1vc"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl_1_1vc.html">vc</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacevcl_1_1vert" id="r_namespacevcl_1_1vert"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl_1_1vert.html">vert</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacevcl_1_1views" id="r_namespacevcl_1_1views"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl_1_1views.html">views</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1AbstractGrid.html">AbstractGrid</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classvcl_1_1AbstractGrid.html" title="The AbstractGrid class describes a generic Spatial Data Structure organized on a regular grid,...">AbstractGrid</a> class describes a generic Spatial Data Structure organized on a regular grid, that allows to store elements (ValueType) in a particular way that will be managed by its derived classes (e.g. <a class="el" href="classvcl_1_1StaticGrid.html">StaticGrid</a>, <a class="el" href="classvcl_1_1HashTableGrid.html" title="The HashTableGrid class stores N-Dimensional spatial elements (that could be anything on which it can...">HashTableGrid</a>).  <a href="classvcl_1_1AbstractGrid.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1AbstractLogger.html">AbstractLogger</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classvcl_1_1AbstractLogger.html" title="The AbstractLogger class is used as common ancestor class for all the logger types in the library.">AbstractLogger</a> class is used as common ancestor class for all the logger types in the library.  <a href="classvcl_1_1AbstractLogger.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1Array.html">Array</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classvcl_1_1Array.html" title="The Array class is a dynamically allocated N-dimensional array stored in RowWise mode.">Array</a> class is a dynamically allocated N-dimensional array stored in RowWise mode.  <a href="classvcl_1_1Array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1BadCustomComponentTypeException.html">BadCustomComponentTypeException</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1BadVertexIndexException.html">BadVertexIndexException</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1BipartiteGraph.html">BipartiteGraph</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1BitProxy.html">BitProxy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classvcl_1_1BitProxy.html" title="The BitProxy class allows to access to a bool reference from a bit saved in a mask,...">BitProxy</a> class allows to access to a bool reference from a bit saved in a mask, and then allow assignment.  <a href="classvcl_1_1BitProxy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1BitSet.html">BitSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classvcl_1_1BitSet.html" title="The BitSet class allows to treat an integral type as an array of booleans of a guaranteed size.">BitSet</a> class allows to treat an integral type as an array of booleans of a guaranteed size.  <a href="classvcl_1_1BitSet.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1Box.html">Box</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class representing a box in N-dimensional space.  <a href="classvcl_1_1Box.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1CannotOpenFileException.html">CannotOpenFileException</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1CellIterator.html">CellIterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1Color.html">Color</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classvcl_1_1Color.html" title="The Color class represents a 32 bit color.">Color</a> class represents a 32 bit color.  <a href="classvcl_1_1Color.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvcl_1_1CompId.html">CompId</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="structvcl_1_1CompId.html" title="The CompId struct enumerates the components that can compose a element or a mesh.">CompId</a> struct enumerates the components that can compose a element or a mesh.  <a href="structvcl_1_1CompId.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvcl_1_1ComponentString.html">ComponentString</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="structvcl_1_1ComponentString.html" title="The ComponentString class is used to retrieve the string associated to a COMP_ID value,...">ComponentString</a> class is used to retrieve the string associated to a COMP_ID value, trough its member 'str'.  <a href="structvcl_1_1ComponentString.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1ConsoleLogger.html">ConsoleLogger</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1ConstMeshEdgeUtil.html">ConstMeshEdgeUtil</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1ConstPointerIterator.html">ConstPointerIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classvcl_1_1ConstPointerIterator.html" title="The ConstPointerIterator class is a utility class that wraps an iterator of a container of [shared] p...">ConstPointerIterator</a> class is a utility class that wraps an iterator of a container of [shared] pointers, and returns a const [shared] pointer when dereferencing the iterator.  <a href="classvcl_1_1ConstPointerIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1ConstStaticGridIterator.html">ConstStaticGridIterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvcl_1_1CreateSphereArgs.html">CreateSphereArgs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="structvcl_1_1CreateSphereArgs.html" title="The CreateSphereArgs structs contains a series of parameters to generate a sphere.">CreateSphereArgs</a> structs contains a series of parameters to generate a sphere.  <a href="structvcl_1_1CreateSphereArgs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1CustomComponentVectorHandle.html">CustomComponentVectorHandle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows to access directly to a custom component.  <a href="classvcl_1_1CustomComponentVectorHandle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvcl_1_1DistFunctionStruct.html">DistFunctionStruct</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvcl_1_1DistFunctionStruct_3_01Obj1_00_01Obj2_00_01ScalarType_01_4.html">DistFunctionStruct&lt; Obj1, Obj2, ScalarType &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1Distribution.html">Distribution</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classvcl_1_1Distribution.html" title="The Distribution class allows to collect a set of values and then compute some statistics like averag...">Distribution</a> class allows to collect a set of values and then compute some statistics like average, variance, standardDeviation, and percentiles.  <a href="classvcl_1_1Distribution.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1Edge.html">Edge</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classvcl_1_1Edge.html" title="The Edge class represents an Edge element of the vcl::Mesh class.">Edge</a> class represents an <a class="el" href="classvcl_1_1Edge.html" title="The Edge class represents an Edge element of the vcl::Mesh class.">Edge</a> element of the <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">vcl::Mesh</a> class.  <a href="classvcl_1_1Edge.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1Edge_3_01MeshType_00_01TypeWrapper_3_01Comps_8_8_8_01_4_01_4.html">Edge&lt; MeshType, TypeWrapper&lt; Comps... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1EdgeAdjFaceIterator.html">EdgeAdjFaceIterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1EdgeMeshT.html">EdgeMeshT</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1Element.html">Element</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classvcl_1_1Element.html" title="The Element class.">Element</a> class.  <a href="classvcl_1_1Element.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1ElementContainerIterator.html">ElementContainerIterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvcl_1_1ElementString.html">ElementString</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="structvcl_1_1ElementString.html" title="The ElementString class is used to retrieve the string associated to a ELEM_ID value,...">ElementString</a> class is used to retrieve the string associated to a ELEM_ID value, trough its member 'str'.  <a href="structvcl_1_1ElementString.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvcl_1_1ElemId.html">ElemId</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="structvcl_1_1ElemId.html" title="The ElemId struct enumerates the elements that can compose a mesh.">ElemId</a> struct enumerates the elements that can compose a mesh.  <a href="structvcl_1_1ElemId.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1Face.html">Face</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classvcl_1_1Face.html" title="The Face class represents an Face element of the vcl::Mesh class.">Face</a> class represents an <a class="el" href="classvcl_1_1Face.html" title="The Face class represents an Face element of the vcl::Mesh class.">Face</a> element of the <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">vcl::Mesh</a> class.  <a href="classvcl_1_1Face.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1Face_3_01MeshType_00_01TypeWrapper_3_01Comps_8_8_8_01_4_01_4.html">Face&lt; MeshType, TypeWrapper&lt; Comps... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1FakePointerWithValue.html">FakePointerWithValue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple utility class to represent a pointer with a value.  <a href="classvcl_1_1FakePointerWithValue.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1FileFormat.html">FileFormat</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classvcl_1_1FileFormat.html" title="The FileFormat class represents a file format.">FileFormat</a> class represents a file format.  <a href="classvcl_1_1FileFormat.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1FileInfo.html">FileInfo</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvcl_1_1FileType.html">FileType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class that defines whether a file is binary or text, and (if binary) the endianness of the file.  <a href="structvcl_1_1FileType.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvcl_1_1FilterTypesByCondition.html">FilterTypesByCondition</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all types that do not satisfy a condition, and get them as a tuple.  <a href="structvcl_1_1FilterTypesByCondition.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvcl_1_1FilterTypesByCondition_3_01Pred_00_01Head_00_01Tail_8_8_8_01_4.html">FilterTypesByCondition&lt; Pred, Head, Tail... &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all types that do not satisfy a condition, and get them as a tuple.    <a href="structvcl_1_1FilterTypesByCondition_3_01Pred_00_01Head_00_01Tail_8_8_8_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvcl_1_1FilterTypesByCondition_3_01Pred_00_01TypeWrapper_3_01Tail_8_8_8_01_4_01_4.html">FilterTypesByCondition&lt; Pred, TypeWrapper&lt; Tail... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all types that do not satisfy a condition, and get them as a tuple.    <a href="structvcl_1_1FilterTypesByCondition_3_01Pred_00_01TypeWrapper_3_01Tail_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvcl_1_1FirstElementPairComparator.html">FirstElementPairComparator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="structvcl_1_1FirstElementPairComparator.html" title="The FirstElementPairComparator struct is an utility comparator that allow to sort std::pair (or any t...">FirstElementPairComparator</a> struct is an utility comparator that allow to sort std::pair (or any type that has a sortable member called 'first') using only its first element. The second element of the Pair type is ignored and won't be considered by the comparator. This means that pairs having equal first elements but different second elements will be considered as equals.  <a href="structvcl_1_1FirstElementPairComparator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1FirstRefPair.html">FirstRefPair</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvcl_1_1FirstType.html">FirstType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the first type of a pack of types (variadic templates) or a <a class="el" href="structvcl_1_1TypeWrapper.html" title="A simple structure that wraps a list of variadic templates, without instantiating anything....">TypeWrapper</a>.  <a href="structvcl_1_1FirstType.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvcl_1_1FirstType_3_01TypeWrapper_3_01Args_8_8_8_01_4_01_4.html">FirstType&lt; TypeWrapper&lt; Args... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the first type of a pack of types (variadic templates) or a <a class="el" href="structvcl_1_1TypeWrapper.html" title="A simple structure that wraps a list of variadic templates, without instantiating anything....">TypeWrapper</a>.    <a href="structvcl_1_1FirstType_3_01TypeWrapper_3_01Args_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvcl_1_1ForEachType.html">ForEachType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows to apply a function to each type in a variadic template pack.  <a href="structvcl_1_1ForEachType.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvcl_1_1ForEachType_3_01TypeWrapper_3_01T_8_8_8_01_4_01_4.html">ForEachType&lt; TypeWrapper&lt; T... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvcl_1_1GetTypeByCondition.html">GetTypeByCondition</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The the first type of a pack that satisfies the given condition.  <a href="structvcl_1_1GetTypeByCondition.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvcl_1_1GetTypeByCondition_3_01Pred_00_01TypeWrapper_3_01Args_8_8_8_01_4_01_4.html">GetTypeByCondition&lt; Pred, TypeWrapper&lt; Args... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The the first type of a pack that satisfies the given condition.    <a href="structvcl_1_1GetTypeByCondition_3_01Pred_00_01TypeWrapper_3_01Args_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1HashTableGrid.html">HashTableGrid</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classvcl_1_1HashTableGrid.html" title="The HashTableGrid class stores N-Dimensional spatial elements (that could be anything on which it can...">HashTableGrid</a> class stores N-Dimensional spatial elements (that could be anything on which it can be computed a N-dimensional bounding box) in a regular grid, using a Hash Table having the Cell Grid coordinate as key type.  <a href="classvcl_1_1HashTableGrid.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvcl_1_1HausdorffDistResult.html">HausdorffDistResult</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1Histogram.html">Histogram</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1Image.html">Image</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classvcl_1_1Image.html" title="The Image class stores an Image in 4 bytes RGBA format.">Image</a> class stores an <a class="el" href="classvcl_1_1Image.html" title="The Image class stores an Image in 4 bytes RGBA format.">Image</a> in 4 bytes RGBA format.  <a href="classvcl_1_1Image.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1InconsistentMeshException.html">InconsistentMeshException</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1IndexFromPointerIterator.html">IndexFromPointerIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This iterator is used to iterate over a container of pointers to elements and return the index of the element.  <a href="classvcl_1_1IndexFromPointerIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvcl_1_1IndexInTypes.html">IndexInTypes</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvcl_1_1IndexInTypes_3_01T_00_01TypeWrapper_3_01Us_8_8_8_01_4_01_4.html">IndexInTypes&lt; T, TypeWrapper&lt; Us... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvcl_1_1IntersFunctionStruct.html">IntersFunctionStruct</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvcl_1_1IntersFunctionStruct_3_01Obj1_00_01Obj2_01_4.html">IntersFunctionStruct&lt; Obj1, Obj2 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1KDTree.html">KDTree</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1KeyRefValueRefPair.html">KeyRefValueRefPair</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1KeyValueRefPair.html">KeyValueRefPair</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvcl_1_1LoadSettings.html">LoadSettings</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="structvcl_1_1LoadSettings.html" title="The LoadSettings structure contains the settings that can be used to load a mesh from a stream/file.">LoadSettings</a> structure contains the settings that can be used to load a mesh from a stream/file.  <a href="structvcl_1_1LoadSettings.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1Logger.html">Logger</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvcl_1_1MakeConstPointer.html">MakeConstPointer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility type that makes possible to treat const pointers in a templated class that can treat a both const and non-const pointer type.  <a href="structvcl_1_1MakeConstPointer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>MakeConstPointer&lt; std::shared_ptr&lt; T &gt; &gt;</b></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility type that makes possible to treat const pointers in a templated class that can treat a both const and non-const pointer type.   <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvcl_1_1MakeConstPointer_3_01T_01_5_01_4.html">MakeConstPointer&lt; T * &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility type that makes possible to treat const pointers in a templated class that can treat a both const and non-const pointer type.    <a href="structvcl_1_1MakeConstPointer_3_01T_01_5_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1MalformedFileException.html">MalformedFileException</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1Matrix.html">Matrix</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1Mesh.html">Mesh</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a> class represents a generic 3D mesh. A mesh is composed of a generic number of containers of Elements (which can be vertices, faces, edges...), plus some other components.  <a href="classvcl_1_1Mesh.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1MeshEdgeUtil.html">MeshEdgeUtil</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility class that represents a edge in a <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>.  <a href="classvcl_1_1MeshEdgeUtil.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1MeshInertia.html">MeshInertia</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classvcl_1_1MeshInertia.html" title="The MeshInertia class provides several for computing Polyhedral Mass properties (like inertia tensor,...">MeshInertia</a> class provides several for computing Polyhedral Mass properties (like inertia tensor, volume, etc).  <a href="classvcl_1_1MeshInertia.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1MeshInfo.html">MeshInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple class that allows to store which elements and their components have been imported/loaded or are going to be exported/saved on a mesh file or some other data structure.  <a href="classvcl_1_1MeshInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1MeshPos.html">MeshPos</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classvcl_1_1MeshPos.html" title="The MeshPos class describes a &quot;Position in a Mesh&quot; that can be identified with a triplet of Face-Vert...">MeshPos</a> class describes a "Position in a Mesh" that can be identified with a triplet of Face-Vertex-Edge, where:  <a href="classvcl_1_1MeshPos.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1MeshSampler.html">MeshSampler</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1MissingCompactnessException.html">MissingCompactnessException</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1MissingComponentException.html">MissingComponentException</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1MissingPolygonalRequirementException.html">MissingPolygonalRequirementException</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1MissingPreconditionException.html">MissingPreconditionException</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1MissingQuadRequirementException.html">MissingQuadRequirementException</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1MissingTriangularRequirementException.html">MissingTriangularRequirementException</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1NestedInitializerListsProcessor.html">NestedInitializerListsProcessor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classvcl_1_1NestedInitializerListsProcessor.html" title="The NestedInitializerListsProcessor class.">NestedInitializerListsProcessor</a> class.  <a href="classvcl_1_1NestedInitializerListsProcessor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1NestedInitializerListsProcessor_3_01T_00_011_01_4.html">NestedInitializerListsProcessor&lt; T, 1 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1NodeIterator.html">NodeIterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1NoIntersectionException.html">NoIntersectionException</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1NullLogger.html">NullLogger</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classvcl_1_1NullLogger.html" title="The NullLogger class is used as default type in all the library functions that take as input a logger...">NullLogger</a> class is used as default type in all the library functions that take as input a logger type.  <a href="classvcl_1_1NullLogger.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvcl_1_1NumberOfTypes.html">NumberOfTypes</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvcl_1_1NumberOfTypes_3_01TypeWrapper_3_01Args_8_8_8_01_4_01_4.html">NumberOfTypes&lt; TypeWrapper&lt; Args... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvcl_1_1PairComparator.html">PairComparator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="structvcl_1_1PairComparator.html" title="The PairComparator struct is an utility comparator to allow to sort pairs in lexical order.">PairComparator</a> struct is an utility comparator to allow to sort pairs in lexical order.  <a href="structvcl_1_1PairComparator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1Plane.html">Plane</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classvcl_1_1Plane.html" title="The Plane class represent a 2D plane in 3D space.">Plane</a> class represent a 2D plane in 3D space.  <a href="classvcl_1_1Plane.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1Point.html">Point</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classvcl_1_1Point.html" title="The Point class represents an N-dimensional point containing N scalar values.">Point</a> class represents an N-dimensional point containing N scalar values.  <a href="classvcl_1_1Point.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1PointCloudT.html">PointCloudT</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1PointerFromIndexIterator.html">PointerFromIndexIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This iterator is used to iterate over a container of pointers to elements and return the index of the element.  <a href="classvcl_1_1PointerFromIndexIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1PointerVector.html">PointerVector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <code><a class="el" href="classvcl_1_1PointerVector.html" title="The PointerVector class is a utility container that stores a sequence of pointers that preserve their...">PointerVector</a></code> class is a utility container that stores a sequence of pointers that preserve their constness when the container is constant.  <a href="classvcl_1_1PointerVector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1PointSampler.html">PointSampler</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1PolyEdgeMeshT.html">PolyEdgeMeshT</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classvcl_1_1PolyEdgeMeshT.html" title="The PolyEdgeMeshT is a Polygonal Mesh type that stores Vertices, Faces and Edges as elements.">PolyEdgeMeshT</a> is a Polygonal <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a> type that stores Vertices, Faces and Edges as elements.  <a href="classvcl_1_1PolyEdgeMeshT.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1Polygon.html">Polygon</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1PolyMeshT.html">PolyMeshT</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1PolymorphicObjectVector.html">PolymorphicObjectVector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classvcl_1_1PolymorphicObjectVector.html" title="The PolymorphicObjectVector class is a container that stores a collection of polymorphic objects,...">PolymorphicObjectVector</a> class is a container that stores a collection of polymorphic objects, having a common base class T.  <a href="classvcl_1_1PolymorphicObjectVector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvcl_1_1PrimitiveType.html">PrimitiveType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple type that enumerates the main primitive types.  <a href="structvcl_1_1PrimitiveType.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1PrincipalCurvature.html">PrincipalCurvature</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classvcl_1_1PrincipalCurvature.html" title="The PrincipalCurvature class stores the principal curvature directions and values at a point on a sur...">PrincipalCurvature</a> class stores the principal curvature directions and values at a point on a surface.  <a href="classvcl_1_1PrincipalCurvature.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1Quaternion.html">Quaternion</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classvcl_1_1Quaternion.html" title="Quaternion class.">Quaternion</a> class.  <a href="classvcl_1_1Quaternion.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1RefPair.html">RefPair</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1RegularGrid.html">RegularGrid</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvcl_1_1SaveSettings.html">SaveSettings</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="structvcl_1_1SaveSettings.html" title="The SaveSettings structure contains the settings that can be used to save a mesh to a stream/file.">SaveSettings</a> structure contains the settings that can be used to save a mesh to a stream/file.  <a href="structvcl_1_1SaveSettings.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1SecondRefPair.html">SecondRefPair</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1Segment.html">Segment</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class representing a line segment in n-dimensional space. The class is parameterized by a <code>PointConcept</code>, which must provide the <code>DIM</code> constant and the <code>[]</code> operator for accessing the point coordinates.  <a href="classvcl_1_1Segment.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1Sphere.html">Sphere</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1StaticGrid.html">StaticGrid</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1StaticGridIterator.html">StaticGridIterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1TexCoord.html">TexCoord</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1Texture.html">Texture</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1Timer.html">Timer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classvcl_1_1Timer.html" title="The Timer class allows to instantiate simple Timer objects that can be used everywhere.">Timer</a> class allows to instantiate simple <a class="el" href="classvcl_1_1Timer.html" title="The Timer class allows to instantiate simple Timer objects that can be used everywhere.">Timer</a> objects that can be used everywhere.  <a href="classvcl_1_1Timer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1Tokenizer.html">Tokenizer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classvcl_1_1Tokenizer.html" title="The Tokenizer class.">Tokenizer</a> class.  <a href="classvcl_1_1Tokenizer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1Triangle.html">Triangle</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1TriangleWrapper.html">TriangleWrapper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classvcl_1_1TriangleWrapper.html" title="The TriangleWrapper class is a wrapper around a N-Dimensional triangle.">TriangleWrapper</a> class is a wrapper around a N-Dimensional triangle.  <a href="classvcl_1_1TriangleWrapper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1TriEdgeMeshT.html">TriEdgeMeshT</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classvcl_1_1TriEdgeMeshT.html" title="The TriEdgeMeshT is a Mesh type that stores Vertices, Faces and Edges as elements.">TriEdgeMeshT</a> is a <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a> type that stores Vertices, Faces and Edges as elements.  <a href="classvcl_1_1TriEdgeMeshT.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1TriMeshT.html">TriMeshT</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classvcl_1_1TriMeshT.html" title="The TriMeshT class.">TriMeshT</a> class.  <a href="classvcl_1_1TriMeshT.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1TriPolyIndexBiMap.html">TriPolyIndexBiMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classvcl_1_1TriPolyIndexBiMap.html" title="The TriPolyIndexBiMap class allows to store a bidirectional mapping between a Polygon Mesh and a Tria...">TriPolyIndexBiMap</a> class allows to store a bidirectional mapping between a <a class="el" href="classvcl_1_1Polygon.html">Polygon</a> <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a> and a <a class="el" href="classvcl_1_1Triangle.html">Triangle</a> <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a> generated by the polygon mesh.  <a href="classvcl_1_1TriPolyIndexBiMap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvcl_1_1TypesSatisfyCondition.html">TypesSatisfyCondition</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Its value is set to true if there is at least one type in the given pack Args... that satisfies the given condition.  <a href="structvcl_1_1TypesSatisfyCondition.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvcl_1_1TypesSatisfyCondition_3_01Pred_00_01TypeWrapper_3_01Args_8_8_8_01_4_01_4.html">TypesSatisfyCondition&lt; Pred, TypeWrapper&lt; Args... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Its value is set to true if there is at least one type in the given pack Args... that satisfies the given condition.    <a href="structvcl_1_1TypesSatisfyCondition_3_01Pred_00_01TypeWrapper_3_01Args_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvcl_1_1TypeWrapper.html">TypeWrapper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple structure that wraps a list of variadic templates, without instantiating anything. Useful when you need to wrap a list of types, and consider them as a single type.  <a href="structvcl_1_1TypeWrapper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1UndirectedNode.html">UndirectedNode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1UnknownFileFormatException.html">UnknownFileFormatException</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvcl_1_1UnorderedPairComparator.html">UnorderedPairComparator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="structvcl_1_1UnorderedPairComparator.html" title="The UnorderedPairComparator struct is an utility comparator to allow to sort unordered std::pair&lt;T,...">UnorderedPairComparator</a> struct is an utility comparator to allow to sort unordered std::pair&lt;T, T&gt;, that means that it is not important the order of the first and the second element of the pair. This menas that pairs (1, 2) and (2, 1) are considered equal, and (3, 1) &lt; (2, 3).  <a href="structvcl_1_1UnorderedPairComparator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1Vector.html">Vector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classvcl_1_1Vector.html" title="The Vector class is a generic container of objects of type T, that could have fixed or dynamic size,...">Vector</a> class is a generic container of objects of type <code>T</code>, that could have fixed or dynamic size, depending on the templated size <code>N</code>.  <a href="classvcl_1_1Vector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1Vertex.html">Vertex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classvcl_1_1Vertex.html" title="The Vertex class represents an Vertex element of the vcl::Mesh class.">Vertex</a> class represents an <a class="el" href="classvcl_1_1Vertex.html" title="The Vertex class represents an Vertex element of the vcl::Mesh class.">Vertex</a> element of the <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">vcl::Mesh</a> class.  <a href="classvcl_1_1Vertex.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1Vertex_3_01MeshType_00_01TypeWrapper_3_01Comps_8_8_8_01_4_01_4.html">Vertex&lt; MeshType, TypeWrapper&lt; Comps... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1View.html">View</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classvcl_1_1View.html" title="The View class is a simple class that stores and exposes two iterators begin and end.">View</a> class is a simple class that stores and exposes two iterators begin and end.  <a href="classvcl_1_1View.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1WrongSizeException.html">WrongSizeException</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="concepts" name="concepts"></a>
Concepts</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1IsConst.html">IsConst</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility concept that is evaluated true if T is const or it is a pointer to const. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1IteratorConcept.html">IteratorConcept</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility concept that is evaluated true if T is an iterator. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1IteratesOverClass.html">IteratesOverClass</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility concept that is evaluated true if T is an iterator having its value_type that is a class. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1IteratesOverPointer.html">IteratesOverPointer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility concept that is evaluated true if T is an iterator having its value_type that is a pointer. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1LoggerConcept.html">LoggerConcept</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The LoggerConcept is evaluated to true when the input type is a valid Logger type. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1HasEdges.html">HasEdges</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">HasEdges concepts is satisfied when at least one of its template types is (or inherits from) a <a class="el" href="classvcl_1_1mesh_1_1EdgeContainer.html">vcl::mesh::EdgeContainer</a>. It can be used both to check if a Mesh has edges, or if in a list of types there is a EdgeContainer. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1HasFaces.html">HasFaces</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">HasFaces concepts is satisfied when at least one of its template types is (or inherits from) a <a class="el" href="classvcl_1_1mesh_1_1FaceContainer.html">vcl::mesh::FaceContainer</a>. It can be used both to check if a Mesh has faces, or if in a list of types there is a FaceContainer. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1HasVertices.html">HasVertices</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">HasVertices concepts is satisfied when at least one of its types is (or inherits from) a <a class="el" href="classvcl_1_1mesh_1_1VertexContainer.html">vcl::mesh::VertexContainer</a>. It can be used both to check if a Mesh has vertices, or if in a list of types there is a VertexContainer. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1EdgeMeshConcept.html">EdgeMeshConcept</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1EdgeConcept.html">EdgeConcept</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The EdgeConcept describes how a Edge element that can be used for a EdgeContainer should be organized. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1ElementConcept.html">ElementConcept</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1FaceConcept.html">FaceConcept</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The FaceConcept describes how a Face element that can be used for a FaceContainer should be organized. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1TriangleFaceConcept.html">TriangleFaceConcept</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1PolygonFaceConcept.html">PolygonFaceConcept</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The PolygonFaceConcept describes how a Face element class should be organized to be a polygonal face with dynamic size. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1VertexConcept.html">VertexConcept</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The VertexConcept describes how a Vertex element that can be used for a VertexContainer should be organized. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1HasTriangles.html">HasTriangles</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1HasQuads.html">HasQuads</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1HasPolygons.html">HasPolygons</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1FaceMeshConcept.html">FaceMeshConcept</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1TriangleMeshConcept.html">TriangleMeshConcept</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1QuadMeshConcept.html">QuadMeshConcept</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1PolygonMeshConcept.html">PolygonMeshConcept</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1MeshConcept.html">MeshConcept</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Mesh Concept is evaluated to true when the type is a Mesh. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1ElementOrMeshConcept.html">ElementOrMeshConcept</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">the ElementOrMesh Concept is evaluated to true when the type is either a Mesh or an Element. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1HasPerEdgeAdjacentEdges.html">HasPerEdgeAdjacentEdges</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept that checks if a Mesh has the per Edge AdjacentEdges component. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1HasPerEdgeAdjacentFaces.html">HasPerEdgeAdjacentFaces</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept that checks if a Mesh has the per Edge AdjacentFaces component. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1HasPerEdgeBitFlags.html">HasPerEdgeBitFlags</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept that checks if a Mesh has the per Edge BitFlags component. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1HasPerEdgeColor.html">HasPerEdgeColor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept that checks if a Mesh has the per Edge Color component. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1HasPerEdgeCustomComponents.html">HasPerEdgeCustomComponents</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept that checks if a Mesh has the per Edge CustomComponents component. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1HasPerEdgeMark.html">HasPerEdgeMark</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept that checks if a Mesh has the per Edge Mark component. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1HasPerEdgeNormal.html">HasPerEdgeNormal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept that checks if a Mesh has the per Edge Normal component. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1HasPerEdgeQuality.html">HasPerEdgeQuality</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept that checks if a Mesh has the per Edge Quality component. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1HasPerEdgeVertexPointers.html">HasPerEdgeVertexPointers</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept that checks if a Mesh has the per Edge VertexPointers component. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1HasPerFaceAdjacentEdges.html">HasPerFaceAdjacentEdges</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept that checks if a Mesh has the per Face AdjacentEdges component. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1HasPerFaceAdjacentFaces.html">HasPerFaceAdjacentFaces</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept that checks if a Mesh has the per Face AdjacentFaces component. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1HasPerFaceBitFlags.html">HasPerFaceBitFlags</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept that checks if a Mesh has the per Face BitFlags component. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1HasPerFaceColor.html">HasPerFaceColor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept that checks if a Mesh has the per Face Color component. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1HasPerFaceCustomComponents.html">HasPerFaceCustomComponents</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept that checks if a Mesh has the per Face CustomComponents component. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1HasPerFaceMark.html">HasPerFaceMark</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept that checks if a Mesh has the per Face Mark component. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1HasPerFaceNormal.html">HasPerFaceNormal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept that checks if a Mesh has the per Face Normal component. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1HasPerFacePolygonBitFlags.html">HasPerFacePolygonBitFlags</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept that checks if a Mesh has the per Face PolygonBitFlags component. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1HasPerFacePrincipalCurvature.html">HasPerFacePrincipalCurvature</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept that checks if a Mesh has the per Face PrincipalCurvature component. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1HasPerFaceQuality.html">HasPerFaceQuality</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept that checks if a Mesh has the per Face Quality component. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1HasPerFaceTriangleBitFlags.html">HasPerFaceTriangleBitFlags</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept that checks if a Mesh has the per Face TriangleBitFlags component. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1HasPerFaceVertexReferences.html">HasPerFaceVertexReferences</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept that checks if a Mesh has the per Face VertexPointers component. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1HasPerFaceWedgeColors.html">HasPerFaceWedgeColors</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept that checks if a Mesh has the per Face WedgeColors component. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1HasPerFaceWedgeTexCoords.html">HasPerFaceWedgeTexCoords</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept that checks if a Mesh has the per Face WedgeTexCoords component. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1HasBoundingBox.html">HasBoundingBox</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept that is evaluated true if a Mesh has the BoundingBox component. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1HasColor.html">HasColor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept that is evaluated true if a Mesh has the Color component. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1HasCustomComponents.html">HasCustomComponents</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept that is evaluated true if a Mesh has the CustomComponents component. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1HasMark.html">HasMark</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept that is evaluated true if a Mesh has the Mark component. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1HasName.html">HasName</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept that checks if a Mesh has the Name component. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1HasTextureImages.html">HasTextureImages</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept that checks if a Mesh has the TextureImages component. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1HasTexturePaths.html">HasTexturePaths</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept that checks if a Mesh has the TexturePaths component. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1HasTransformMatrix.html">HasTransformMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept that checks if a Mesh has the TransformMatrix component. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1HasPerVertexAdjacentEdges.html">HasPerVertexAdjacentEdges</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept that checks if a Mesh has the per Vertex AdjacentEdges component. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1HasPerVertexAdjacentFaces.html">HasPerVertexAdjacentFaces</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept that checks if a Mesh has the per Vertex AdjacentFaces component. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1HasPerVertexAdjacentVertices.html">HasPerVertexAdjacentVertices</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept that checks if a Mesh has the per Vertex AdjacentVertices component. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1HasPerVertexColor.html">HasPerVertexColor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept that checks if a Mesh has the per Vertex Color component. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1HasPerVertexMark.html">HasPerVertexMark</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept that checks if a Mesh has the per Vertex Mark component. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1HasPerVertexNormal.html">HasPerVertexNormal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept that checks if a Mesh has the per Vertex Normal component. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1HasPerVertexPrincipalCurvature.html">HasPerVertexPrincipalCurvature</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept that checks if a Mesh has the per Vertex PrincipalCurvature component. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1HasPerVertexQuality.html">HasPerVertexQuality</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept that checks if a Mesh has the per Vertex Quality component. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1HasPerVertexTexCoord.html">HasPerVertexTexCoord</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept that checks if a Mesh has the per Vertex TexCoord component. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1HasPerVertexCustomComponents.html">HasPerVertexCustomComponents</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept that checks if a Mesh has the per Vertex CustomComponents. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1IsPointer.html">IsPointer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility concept that is evaluated true if T is a Pointer, even if the type T is a reference to a pointer. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1IsSharedPointer.html">IsSharedPointer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility concept that is evaluated true if T is a shared pointer. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1IsAnyPointer.html">IsAnyPointer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility concept that is evaluated true if T is a Pointer or a shared pointer. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1IsPointerToConst.html">IsPointerToConst</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility concept that is evaluated true if T is a Pointer to a constant object. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1IsSharedPointerToConst.html">IsSharedPointerToConst</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility concept that is evaluated true if T is a shared pointer to a constant object. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1IsAnyPointerToConst.html">IsAnyPointerToConst</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility concept that is evaluated true if T is a Pointer or a shared pointer to a constant object. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1Cloneable.html">Cloneable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept that is evaluated true if T is a cloneable object. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1EdgeRangeConcept.html">EdgeRangeConcept</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The EdgeRangeConcept evaluates to true if Rng is a valid Range on Edges. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1EdgePointerRangeConcept.html">EdgePointerRangeConcept</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The EdgePointerRangeConcept evaluates to true if Rng is a valid Range on Edge Pointers. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1FaceRangeConcept.html">FaceRangeConcept</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The FaceRangeConcept evaluates to true if Rng is a valid Range on Faces. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1FacePointerRangeConcept.html">FacePointerRangeConcept</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The FacePointerRangeConcept evaluates to true if Rng is a valid Range on Face Pointers. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1VertexRangeConcept.html">VertexRangeConcept</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The VertexRangeConcept evaluates to true if Rng is a valid Range on Vertices. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1VertexPointerRangeConcept.html">VertexPointerRangeConcept</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The VertexPointerRangeConcept evaluates to true if Rng is a valid Range on Vertex Pointers. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1Range.html">Range</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility concept that is evaluated true if T is a range, e.g. if has a begin and an end. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1RangeOf.html">RangeOf</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility concept that is evaluated true the Range R has a value_type that is T. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1RangeOfConvertibleTo.html">RangeOfConvertibleTo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility concept that is evaluated true the Range R has a value_type that is convertible to T. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1OutputStreamable.html">OutputStreamable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept that is evaluated true if T is an output streamable type. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1InputStreamable.html">InputStreamable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept that is evaluated true if T is an input streamable type. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1Serializable.html">Serializable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept that is evaluated true if T is serializable. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1ArrayConcept.html">ArrayConcept</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A concept representing a N-dimensional array. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1Array2Concept.html">Array2Concept</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A concept representing a 2-dimensional array. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1Array3Concept.html">Array3Concept</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A concept representing a 3-dimensional array. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1Array4Concept.html">Array4Concept</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A concept representing a 4-dimensional array. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1BoxConcept.html">BoxConcept</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A concept representing a N-Dimensional Box. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1Box2Concept.html">Box2Concept</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A concept that requires a type to satisfy the BoxConcept and have a dimension of 2. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1Box3Concept.html">Box3Concept</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A concept that requires a type to satisfy the BoxConcept and have a dimension of 3. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1ColorConcept.html">ColorConcept</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">ColorConcept is satisfied only if a class provides the member functions specified in this concept. These member functions allows to access to the color components of a given color. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1ImageConcept.html">ImageConcept</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1EigenMatrixConcept.html">EigenMatrixConcept</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept for Eigen matrices. It is satisfied when <code>T</code> is an Eigen matrix. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1ResizableEigenMatrixConceipt.html">ResizableEigenMatrixConceipt</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept for Eigen matrices that can be resized. It is satisfied when <code>T</code> is an Eigen matrix. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1MatrixConcept.html">MatrixConcept</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept for 2D arrays (matrices). It is satisfied when <code>T</code> is a matrix, no matter its sizes. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1PlaneConcept.html">PlaneConcept</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A C++ concept that requires a type to represent a plane in 3D space. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1PointConcept.html">PointConcept</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept for types representing points in Euclidean space. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1Point2Concept.html">Point2Concept</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A concept for points in two-dimensional space. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1Point3Concept.html">Point3Concept</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A concept for points in three-dimensional space. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1Point4Concept.html">Point4Concept</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A concept for points in four-dimensional space. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1PointIteratorConcept.html">PointIteratorConcept</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept for iterators that iterate over Points (class that satisfies the PointConcept). <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1Point2IteratorConcept.html">Point2IteratorConcept</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept for iterators that iterate over 2D Points (class that satisfies the Point2Concept). <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1Point3IteratorConcept.html">Point3IteratorConcept</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept for iterators that iterate over 3D Points (class that satisfies the Point3Concept). <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1Point4IteratorConcept.html">Point4IteratorConcept</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept for iterators that iterate over 4D Points (class that satisfies the Point4Concept). <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1PolygonConcept.html">PolygonConcept</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1Polygon2Concept.html">Polygon2Concept</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1Polygon3Concept.html">Polygon3Concept</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1SamplerConcept.html">SamplerConcept</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A concept for a container that stores Point samples. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1SegmentConcept.html">SegmentConcept</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept for types representing line segments in Euclidean space. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1Segment2Concept.html">Segment2Concept</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A concept to check whether a type meets the requirements of a 2D segment. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1Segment3Concept.html">Segment3Concept</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A concept to check whether a type meets the requirements of a 3D segment. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1SphereConcept.html">SphereConcept</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept for types representing spheres in Euclidean space. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1TextureConcept.html">TextureConcept</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1ConstTriangleConcept.html">ConstTriangleConcept</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1TriangleConcept.html">TriangleConcept</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1ConstTriangle2Concept.html">ConstTriangle2Concept</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1Triangle2Concept.html">Triangle2Concept</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1ConstTriangle3Concept.html">ConstTriangle3Concept</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1Triangle3Concept.html">Triangle3Concept</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1IntegralOrEnum.html">IntegralOrEnum</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept for types that can be used as indices. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1NonBoolIntegralOrEnum.html">NonBoolIntegralOrEnum</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept for types that can be used as indices, excluding bool. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1IsClass.html">IsClass</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept that is evaluated true if T is a class. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1IsNotClass.html">IsNotClass</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept that is evaluated true if T is not a class. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a294d3a64b949108ec1f6381b950945e9" id="r_a294d3a64b949108ec1f6381b950945e9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a294d3a64b949108ec1f6381b950945e9">Histogramf</a> = <a class="el" href="classvcl_1_1Histogram.html">Histogram</a>&lt; <a class="el" href="classvcl_1_1Matrix.html">float</a> &gt;</td></tr>
<tr class="separator:a294d3a64b949108ec1f6381b950945e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7eaa15c791dc5118a8eea9677c6ba9b7" id="r_a7eaa15c791dc5118a8eea9677c6ba9b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a7eaa15c791dc5118a8eea9677c6ba9b7">Histogramd</a> = <a class="el" href="classvcl_1_1Histogram.html">Histogram</a>&lt; <a class="el" href="classvcl_1_1Matrix.html">double</a> &gt;</td></tr>
<tr class="separator:a7eaa15c791dc5118a8eea9677c6ba9b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae166b0242a891e25bde6507bf6776730" id="r_ae166b0242a891e25bde6507bf6776730"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classvcl_1_1Matrix.html">typename</a> T &gt; </td></tr>
<tr class="memitem:ae166b0242a891e25bde6507bf6776730"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ae166b0242a891e25bde6507bf6776730">ConstCustomComponentVectorHandle</a> = <a class="el" href="classvcl_1_1CustomComponentVectorHandle.html">CustomComponentVectorHandle</a>&lt; <a class="el" href="classvcl_1_1Matrix.html">const</a> T &gt;</td></tr>
<tr class="separator:ae166b0242a891e25bde6507bf6776730"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e6e68e7341953400d9440b6fc569452" id="r_a6e6e68e7341953400d9440b6fc569452"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classvcl_1_1Matrix.html">typename</a> Iterator , <a class="el" href="classvcl_1_1Matrix.html">typename</a> ElementType , <a class="el" href="classvcl_1_1Matrix.html">typename</a> <a class="el" href="classvcl_1_1Matrix.html">ParentElement</a> &gt; </td></tr>
<tr class="memitem:a6e6e68e7341953400d9440b6fc569452"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a6e6e68e7341953400d9440b6fc569452">ConstPointerFromIndexIterator</a> = <a class="el" href="classvcl_1_1PointerFromIndexIterator.html">PointerFromIndexIterator</a>&lt; Iterator, ElementType, <a class="el" href="classvcl_1_1Matrix.html">ParentElement</a>, <a class="el" href="classvcl_1_1Matrix.html">true</a> &gt;</td></tr>
<tr class="separator:a6e6e68e7341953400d9440b6fc569452"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa909fb65065f7aa1f08e7ae17265653d" id="r_aa909fb65065f7aa1f08e7ae17265653d"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classvcl_1_1Matrix.html">template</a>&lt; <a class="el" href="classvcl_1_1Matrix.html">typename</a>, typename... &gt; <a class="el" href="classvcl_1_1Matrix.html">typename</a> Container, <a class="el" href="classvcl_1_1Matrix.html">typename</a> T &gt; </td></tr>
<tr class="memitem:aa909fb65065f7aa1f08e7ae17265653d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#aa909fb65065f7aa1f08e7ae17265653d">ConstElementContainerIterator</a> = <a class="el" href="classvcl_1_1ElementContainerIterator.html">ElementContainerIterator</a>&lt; Container, T, <a class="el" href="classvcl_1_1Matrix.html">true</a> &gt;</td></tr>
<tr class="separator:aa909fb65065f7aa1f08e7ae17265653d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70592efcf2670361a337c528b34e4dfb" id="r_a70592efcf2670361a337c528b34e4dfb"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classvcl_1_1Matrix.html">typename</a> FaceType &gt; </td></tr>
<tr class="memitem:a70592efcf2670361a337c528b34e4dfb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a70592efcf2670361a337c528b34e4dfb">ConstEdgeAdjFaceIterator</a> = <a class="el" href="classvcl_1_1EdgeAdjFaceIterator.html">EdgeAdjFaceIterator</a>&lt; FaceType, <a class="el" href="classvcl_1_1Matrix.html">true</a> &gt;</td></tr>
<tr class="separator:a70592efcf2670361a337c528b34e4dfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80bd96a312570b98777680da87ba0232" id="r_a80bd96a312570b98777680da87ba0232"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classvcl_1_1Matrix.html">typename</a> T , std::size_t L&gt; </td></tr>
<tr class="memitem:a80bd96a312570b98777680da87ba0232"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a80bd96a312570b98777680da87ba0232">NestedInitializerLists</a> = detail::NestedInitializerListsTraits&lt; T, <a class="el" href="classvcl_1_1Matrix.html">L</a> &gt;::type</td></tr>
<tr class="memdesc:a80bd96a312570b98777680da87ba0232"><td class="mdescLeft">&#160;</td><td class="mdescRight">The NestedInitializerLists class manages nested std::initializer_list&lt;T&gt; types of L levels L must be known at compile time, and compilation will fail if the NestedInitializerLists used does not correspond to the number of used levels.  <br /></td></tr>
<tr class="separator:a80bd96a312570b98777680da87ba0232"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85b2f3d72f837560dc3dac7b128dd286" id="r_a85b2f3d72f837560dc3dac7b128dd286"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classvcl_1_1Matrix.html">typename</a> ValueType , <a class="el" href="classvcl_1_1Matrix.html">typename</a> ScalarType  = double, <a class="el" href="classvcl_1_1Matrix.html">bool</a> AllowDuplicates = true&gt; </td></tr>
<tr class="memitem:a85b2f3d72f837560dc3dac7b128dd286"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a85b2f3d72f837560dc3dac7b128dd286">HashTableGrid2</a> = <a class="el" href="classvcl_1_1HashTableGrid.html">HashTableGrid</a>&lt; <a class="el" href="namespacevcl.html#acf35775c9f8314906299b1b19f6c5f9b">RegularGrid2</a>&lt; ScalarType &gt;, ValueType, <a class="el" href="classvcl_1_1Matrix.html">AllowDuplicates</a> &gt;</td></tr>
<tr class="separator:a85b2f3d72f837560dc3dac7b128dd286"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4258b9247c46311b39535faa3c2cfaa7" id="r_a4258b9247c46311b39535faa3c2cfaa7"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classvcl_1_1Matrix.html">typename</a> ValueType , <a class="el" href="classvcl_1_1Matrix.html">typename</a> ScalarType  = double, <a class="el" href="classvcl_1_1Matrix.html">bool</a> AllowDuplicates = true&gt; </td></tr>
<tr class="memitem:a4258b9247c46311b39535faa3c2cfaa7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a4258b9247c46311b39535faa3c2cfaa7">HashTableGrid3</a> = <a class="el" href="classvcl_1_1HashTableGrid.html">HashTableGrid</a>&lt; <a class="el" href="namespacevcl.html#a8d7cc878c7f7ccb25c576ebf7ad2df5b">RegularGrid3</a>&lt; ScalarType &gt;, ValueType, <a class="el" href="classvcl_1_1Matrix.html">AllowDuplicates</a> &gt;</td></tr>
<tr class="separator:a4258b9247c46311b39535faa3c2cfaa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf35775c9f8314906299b1b19f6c5f9b" id="r_acf35775c9f8314906299b1b19f6c5f9b"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classvcl_1_1Matrix.html">typename</a> Scalar &gt; </td></tr>
<tr class="memitem:acf35775c9f8314906299b1b19f6c5f9b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#acf35775c9f8314906299b1b19f6c5f9b">RegularGrid2</a> = <a class="el" href="classvcl_1_1RegularGrid.html">RegularGrid</a>&lt; Scalar, 2 &gt;</td></tr>
<tr class="separator:acf35775c9f8314906299b1b19f6c5f9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d7cc878c7f7ccb25c576ebf7ad2df5b" id="r_a8d7cc878c7f7ccb25c576ebf7ad2df5b"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classvcl_1_1Matrix.html">typename</a> Scalar &gt; </td></tr>
<tr class="memitem:a8d7cc878c7f7ccb25c576ebf7ad2df5b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a8d7cc878c7f7ccb25c576ebf7ad2df5b">RegularGrid3</a> = <a class="el" href="classvcl_1_1RegularGrid.html">RegularGrid</a>&lt; Scalar, 3 &gt;</td></tr>
<tr class="separator:a8d7cc878c7f7ccb25c576ebf7ad2df5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bbbace04824cfa901027d8e90d830c6" id="r_a2bbbace04824cfa901027d8e90d830c6"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classvcl_1_1Matrix.html">typename</a> ValueType , <a class="el" href="classvcl_1_1Matrix.html">typename</a> ScalarType  = double&gt; </td></tr>
<tr class="memitem:a2bbbace04824cfa901027d8e90d830c6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a2bbbace04824cfa901027d8e90d830c6">StaticGrid2</a> = <a class="el" href="classvcl_1_1StaticGrid.html">StaticGrid</a>&lt; <a class="el" href="namespacevcl.html#acf35775c9f8314906299b1b19f6c5f9b">RegularGrid2</a>&lt; ScalarType &gt;, ValueType &gt;</td></tr>
<tr class="separator:a2bbbace04824cfa901027d8e90d830c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa27c3398ca14cd8a5a7e1423d7a68cd" id="r_afa27c3398ca14cd8a5a7e1423d7a68cd"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classvcl_1_1Matrix.html">typename</a> ValueType , <a class="el" href="classvcl_1_1Matrix.html">typename</a> ScalarType  = double&gt; </td></tr>
<tr class="memitem:afa27c3398ca14cd8a5a7e1423d7a68cd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#afa27c3398ca14cd8a5a7e1423d7a68cd">StaticGrid3</a> = <a class="el" href="classvcl_1_1StaticGrid.html">StaticGrid</a>&lt; <a class="el" href="namespacevcl.html#a8d7cc878c7f7ccb25c576ebf7ad2df5b">RegularGrid3</a>&lt; ScalarType &gt;, ValueType &gt;</td></tr>
<tr class="separator:afa27c3398ca14cd8a5a7e1423d7a68cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06db57219f01121229b9d6a138d3a24f" id="r_a06db57219f01121229b9d6a138d3a24f"><td class="memTemplParams" colspan="2">template&lt;VertexConcept VertexType&gt; </td></tr>
<tr class="memitem:a06db57219f01121229b9d6a138d3a24f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a06db57219f01121229b9d6a138d3a24f">VertexSampler</a> = detail::VertexSampler&lt; VertexType, <a class="el" href="classvcl_1_1Matrix.html">false</a> &gt;</td></tr>
<tr class="separator:a06db57219f01121229b9d6a138d3a24f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c937acb41381e0ce8bb27471da48d24" id="r_a6c937acb41381e0ce8bb27471da48d24"><td class="memTemplParams" colspan="2">template&lt;VertexConcept VertexType&gt; </td></tr>
<tr class="memitem:a6c937acb41381e0ce8bb27471da48d24"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a6c937acb41381e0ce8bb27471da48d24">ConstVertexSampler</a> = detail::VertexSampler&lt; VertexType, <a class="el" href="classvcl_1_1Matrix.html">true</a> &gt;</td></tr>
<tr class="separator:a6c937acb41381e0ce8bb27471da48d24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba483b2c91a7c9b1505b87003bdf14d9" id="r_gaba483b2c91a7c9b1505b87003bdf14d9"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classvcl_1_1Matrix.html">typename</a> Scalar &gt; </td></tr>
<tr class="memitem:gaba483b2c91a7c9b1505b87003bdf14d9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__space__core.html#gaba483b2c91a7c9b1505b87003bdf14d9">Array2</a> = <a class="el" href="classvcl_1_1Array.html">Array</a>&lt; Scalar, 2 &gt;</td></tr>
<tr class="memdesc:gaba483b2c91a7c9b1505b87003bdf14d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience alias for a 2-dimensional <a class="el" href="classvcl_1_1Array.html" title="The Array class is a dynamically allocated N-dimensional array stored in RowWise mode.">Array</a>.  <br /></td></tr>
<tr class="separator:gaba483b2c91a7c9b1505b87003bdf14d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e4b5482856d73dda9465ed9cb7111ea" id="r_ga6e4b5482856d73dda9465ed9cb7111ea"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classvcl_1_1Matrix.html">typename</a> Scalar &gt; </td></tr>
<tr class="memitem:ga6e4b5482856d73dda9465ed9cb7111ea"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__space__core.html#ga6e4b5482856d73dda9465ed9cb7111ea">Array3</a> = <a class="el" href="classvcl_1_1Array.html">Array</a>&lt; Scalar, 3 &gt;</td></tr>
<tr class="memdesc:ga6e4b5482856d73dda9465ed9cb7111ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience alias for a 3-dimensional <a class="el" href="classvcl_1_1Array.html" title="The Array class is a dynamically allocated N-dimensional array stored in RowWise mode.">Array</a>.  <br /></td></tr>
<tr class="separator:ga6e4b5482856d73dda9465ed9cb7111ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab8fae8ad3697a3fd5f463d428f1b99d0" id="r_gab8fae8ad3697a3fd5f463d428f1b99d0"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classvcl_1_1Matrix.html">typename</a> Scalar &gt; </td></tr>
<tr class="memitem:gab8fae8ad3697a3fd5f463d428f1b99d0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__space__core.html#gab8fae8ad3697a3fd5f463d428f1b99d0">Array4</a> = <a class="el" href="classvcl_1_1Array.html">Array</a>&lt; Scalar, 4 &gt;</td></tr>
<tr class="memdesc:gab8fae8ad3697a3fd5f463d428f1b99d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience alias for a 4-dimensional <a class="el" href="classvcl_1_1Array.html" title="The Array class is a dynamically allocated N-dimensional array stored in RowWise mode.">Array</a>.  <br /></td></tr>
<tr class="separator:gab8fae8ad3697a3fd5f463d428f1b99d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadae55ab660469ee37aa80a2b619527fa" id="r_gadae55ab660469ee37aa80a2b619527fa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__space__core.html#gadae55ab660469ee37aa80a2b619527fa">BitSet8</a> = <a class="el" href="classvcl_1_1BitSet.html">BitSet</a>&lt; <a class="el" href="classvcl_1_1Matrix.html">char</a> &gt;</td></tr>
<tr class="memdesc:gadae55ab660469ee37aa80a2b619527fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">BitSet8 is a <a class="el" href="classvcl_1_1BitSet.html" title="The BitSet class allows to treat an integral type as an array of booleans of a guaranteed size.">BitSet</a> of 8 bits.  <br /></td></tr>
<tr class="separator:gadae55ab660469ee37aa80a2b619527fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga786ec6ce6be37c1142bbf8869a43bad2" id="r_ga786ec6ce6be37c1142bbf8869a43bad2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__space__core.html#ga786ec6ce6be37c1142bbf8869a43bad2">BitSet16</a> = <a class="el" href="classvcl_1_1BitSet.html">BitSet</a>&lt; <a class="el" href="classvcl_1_1Matrix.html">short</a> &gt;</td></tr>
<tr class="memdesc:ga786ec6ce6be37c1142bbf8869a43bad2"><td class="mdescLeft">&#160;</td><td class="mdescRight">BitSet16 is a <a class="el" href="classvcl_1_1BitSet.html" title="The BitSet class allows to treat an integral type as an array of booleans of a guaranteed size.">BitSet</a> of 16 bits.  <br /></td></tr>
<tr class="separator:ga786ec6ce6be37c1142bbf8869a43bad2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec46141b5b3ac113188412f11ebe977e" id="r_gaec46141b5b3ac113188412f11ebe977e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__space__core.html#gaec46141b5b3ac113188412f11ebe977e">BitSet32</a> = <a class="el" href="classvcl_1_1BitSet.html">BitSet</a>&lt; <a class="el" href="classvcl_1_1Matrix.html">int</a> &gt;</td></tr>
<tr class="memdesc:gaec46141b5b3ac113188412f11ebe977e"><td class="mdescLeft">&#160;</td><td class="mdescRight">BitSet32 is a <a class="el" href="classvcl_1_1BitSet.html" title="The BitSet class allows to treat an integral type as an array of booleans of a guaranteed size.">BitSet</a> of 32 bits.  <br /></td></tr>
<tr class="separator:gaec46141b5b3ac113188412f11ebe977e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga63e94ce4d048118f147e2fb0c8c1eeaa" id="r_ga63e94ce4d048118f147e2fb0c8c1eeaa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__space__core.html#ga63e94ce4d048118f147e2fb0c8c1eeaa">BitSet64</a> = <a class="el" href="classvcl_1_1BitSet.html">BitSet</a>&lt; std::size_t &gt;</td></tr>
<tr class="memdesc:ga63e94ce4d048118f147e2fb0c8c1eeaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">BitSet64 is a <a class="el" href="classvcl_1_1BitSet.html" title="The BitSet class allows to treat an integral type as an array of booleans of a guaranteed size.">BitSet</a> of 64 bits.  <br /></td></tr>
<tr class="separator:ga63e94ce4d048118f147e2fb0c8c1eeaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad892770b57d7187fe007fc5c7b8e28c6" id="r_ad892770b57d7187fe007fc5c7b8e28c6"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classvcl_1_1Matrix.html">typename</a> <a class="el" href="classvcl_1_1Matrix.html">S</a> &gt; </td></tr>
<tr class="memitem:ad892770b57d7187fe007fc5c7b8e28c6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ad892770b57d7187fe007fc5c7b8e28c6">Box2</a> = <a class="el" href="classvcl_1_1Box.html">Box</a>&lt; <a class="el" href="group__space__core.html#ga6d15a5d1bc87330938ae9b8a55373334">Point2</a>&lt; <a class="el" href="classvcl_1_1Matrix.html">S</a> &gt; &gt;</td></tr>
<tr class="separator:ad892770b57d7187fe007fc5c7b8e28c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43d66b66fa1219da110325fc3c9020f9" id="r_a43d66b66fa1219da110325fc3c9020f9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a43d66b66fa1219da110325fc3c9020f9">Box2i</a> = <a class="el" href="classvcl_1_1Box.html">Box</a>&lt; <a class="el" href="group__space__core.html#ga94bdb300286f9b4bf31987102e011f8d">Point2i</a> &gt;</td></tr>
<tr class="separator:a43d66b66fa1219da110325fc3c9020f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6dc1589c361fc5f1b6444b74aae377d" id="r_ae6dc1589c361fc5f1b6444b74aae377d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ae6dc1589c361fc5f1b6444b74aae377d">Box2f</a> = <a class="el" href="classvcl_1_1Box.html">Box</a>&lt; <a class="el" href="group__space__core.html#gac9560ad588438ce539ec3fdc5658746a">Point2f</a> &gt;</td></tr>
<tr class="separator:ae6dc1589c361fc5f1b6444b74aae377d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77d7b12e8258d508469b505f056917f1" id="r_a77d7b12e8258d508469b505f056917f1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a77d7b12e8258d508469b505f056917f1">Box2d</a> = <a class="el" href="classvcl_1_1Box.html">Box</a>&lt; <a class="el" href="group__space__core.html#ga4b02e85ff4d51fe7d689f8dd0e87ecd5">Point2d</a> &gt;</td></tr>
<tr class="separator:a77d7b12e8258d508469b505f056917f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6539e58b4183d50e78e631047cd7ad12" id="r_a6539e58b4183d50e78e631047cd7ad12"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classvcl_1_1Matrix.html">typename</a> <a class="el" href="classvcl_1_1Matrix.html">S</a> &gt; </td></tr>
<tr class="memitem:a6539e58b4183d50e78e631047cd7ad12"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a6539e58b4183d50e78e631047cd7ad12">Box3</a> = <a class="el" href="classvcl_1_1Box.html">Box</a>&lt; <a class="el" href="group__space__core.html#ga13f2718b0763def563b8bd9f65982833">Point3</a>&lt; <a class="el" href="classvcl_1_1Matrix.html">S</a> &gt; &gt;</td></tr>
<tr class="separator:a6539e58b4183d50e78e631047cd7ad12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84825556201de0537b996b08d1f8aeca" id="r_a84825556201de0537b996b08d1f8aeca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a84825556201de0537b996b08d1f8aeca">Box3i</a> = <a class="el" href="classvcl_1_1Box.html">Box</a>&lt; <a class="el" href="group__space__core.html#ga54b0dffe79fabd0458fc78332c91e73a">Point3i</a> &gt;</td></tr>
<tr class="separator:a84825556201de0537b996b08d1f8aeca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad03a804ee48eb9b3cd5aaf47f7641b3f" id="r_ad03a804ee48eb9b3cd5aaf47f7641b3f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ad03a804ee48eb9b3cd5aaf47f7641b3f">Box3f</a> = <a class="el" href="classvcl_1_1Box.html">Box</a>&lt; <a class="el" href="group__space__core.html#gae19b0e9639a4f90c91e46910ee66f54c">Point3f</a> &gt;</td></tr>
<tr class="separator:ad03a804ee48eb9b3cd5aaf47f7641b3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d5a81b5a74bca25157b2bf0de2c3f6d" id="r_a4d5a81b5a74bca25157b2bf0de2c3f6d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a4d5a81b5a74bca25157b2bf0de2c3f6d">Box3d</a> = <a class="el" href="classvcl_1_1Box.html">Box</a>&lt; <a class="el" href="group__space__core.html#gabb47c1364fb2fe1464a54417684f011e">Point3d</a> &gt;</td></tr>
<tr class="separator:a4d5a81b5a74bca25157b2bf0de2c3f6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada2232ee49c1d1e75935719367a0c808" id="r_ada2232ee49c1d1e75935719367a0c808"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classvcl_1_1Matrix.html">typename</a> Scalar &gt; </td></tr>
<tr class="memitem:ada2232ee49c1d1e75935719367a0c808"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ada2232ee49c1d1e75935719367a0c808">Affine3</a> = Eigen::Transform&lt; Scalar, 3, Eigen::Affine &gt;</td></tr>
<tr class="separator:ada2232ee49c1d1e75935719367a0c808"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe93ad031cdf070985559c710c0cccfe" id="r_abe93ad031cdf070985559c710c0cccfe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#abe93ad031cdf070985559c710c0cccfe">Affine3i</a> = <a class="el" href="namespacevcl.html#ada2232ee49c1d1e75935719367a0c808">Affine3</a>&lt; <a class="el" href="classvcl_1_1Matrix.html">int</a> &gt;</td></tr>
<tr class="separator:abe93ad031cdf070985559c710c0cccfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae91948353bf6e59ce4fd22962d6aca50" id="r_ae91948353bf6e59ce4fd22962d6aca50"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ae91948353bf6e59ce4fd22962d6aca50">Affine3f</a> = <a class="el" href="namespacevcl.html#ada2232ee49c1d1e75935719367a0c808">Affine3</a>&lt; <a class="el" href="classvcl_1_1Matrix.html">float</a> &gt;</td></tr>
<tr class="separator:ae91948353bf6e59ce4fd22962d6aca50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8b4caa657856dfd9fe6e9fc93a12afd" id="r_ac8b4caa657856dfd9fe6e9fc93a12afd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ac8b4caa657856dfd9fe6e9fc93a12afd">Affine3d</a> = <a class="el" href="namespacevcl.html#ada2232ee49c1d1e75935719367a0c808">Affine3</a>&lt; <a class="el" href="classvcl_1_1Matrix.html">double</a> &gt;</td></tr>
<tr class="separator:ac8b4caa657856dfd9fe6e9fc93a12afd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b8b0e2e4450f76fb433f95326f85e6d" id="r_a2b8b0e2e4450f76fb433f95326f85e6d"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classvcl_1_1Matrix.html">typename</a> Scalar &gt; </td></tr>
<tr class="memitem:a2b8b0e2e4450f76fb433f95326f85e6d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a2b8b0e2e4450f76fb433f95326f85e6d">Matrix33</a> = <a class="el" href="classvcl_1_1Matrix.html">Matrix</a>&lt; Scalar, 3, 3 &gt;</td></tr>
<tr class="separator:a2b8b0e2e4450f76fb433f95326f85e6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2e70d03403788ee68a3f150a70d8039" id="r_aa2e70d03403788ee68a3f150a70d8039"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#aa2e70d03403788ee68a3f150a70d8039">Matrix33i</a> = <a class="el" href="namespacevcl.html#a2b8b0e2e4450f76fb433f95326f85e6d">Matrix33</a>&lt; <a class="el" href="classvcl_1_1Matrix.html">int</a> &gt;</td></tr>
<tr class="separator:aa2e70d03403788ee68a3f150a70d8039"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac96c7ac5d789e9dbf055e35fa5a24835" id="r_ac96c7ac5d789e9dbf055e35fa5a24835"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ac96c7ac5d789e9dbf055e35fa5a24835">Matrix33f</a> = <a class="el" href="namespacevcl.html#a2b8b0e2e4450f76fb433f95326f85e6d">Matrix33</a>&lt; <a class="el" href="classvcl_1_1Matrix.html">float</a> &gt;</td></tr>
<tr class="separator:ac96c7ac5d789e9dbf055e35fa5a24835"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21e274a73f9088730a856902ede6ee37" id="r_a21e274a73f9088730a856902ede6ee37"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a21e274a73f9088730a856902ede6ee37">Matrix33d</a> = <a class="el" href="namespacevcl.html#a2b8b0e2e4450f76fb433f95326f85e6d">Matrix33</a>&lt; <a class="el" href="classvcl_1_1Matrix.html">double</a> &gt;</td></tr>
<tr class="separator:a21e274a73f9088730a856902ede6ee37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ebaf363f3eba42f665854a59613068c" id="r_a1ebaf363f3eba42f665854a59613068c"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classvcl_1_1Matrix.html">typename</a> Scalar &gt; </td></tr>
<tr class="memitem:a1ebaf363f3eba42f665854a59613068c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a1ebaf363f3eba42f665854a59613068c">Matrix44</a> = <a class="el" href="classvcl_1_1Matrix.html">Matrix</a>&lt; Scalar, 4, 4 &gt;</td></tr>
<tr class="separator:a1ebaf363f3eba42f665854a59613068c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af09e528e12eb6fb1fc6e596b46da8beb" id="r_af09e528e12eb6fb1fc6e596b46da8beb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#af09e528e12eb6fb1fc6e596b46da8beb">Matrix44i</a> = <a class="el" href="namespacevcl.html#a1ebaf363f3eba42f665854a59613068c">Matrix44</a>&lt; <a class="el" href="classvcl_1_1Matrix.html">int</a> &gt;</td></tr>
<tr class="separator:af09e528e12eb6fb1fc6e596b46da8beb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6891233f7166ae9569a840d151cfe140" id="r_a6891233f7166ae9569a840d151cfe140"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a6891233f7166ae9569a840d151cfe140">Matrix44f</a> = <a class="el" href="namespacevcl.html#a1ebaf363f3eba42f665854a59613068c">Matrix44</a>&lt; <a class="el" href="classvcl_1_1Matrix.html">float</a> &gt;</td></tr>
<tr class="separator:a6891233f7166ae9569a840d151cfe140"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c9537d456b6db5dc5f2216dfc8bccdc" id="r_a0c9537d456b6db5dc5f2216dfc8bccdc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a0c9537d456b6db5dc5f2216dfc8bccdc">Matrix44d</a> = <a class="el" href="namespacevcl.html#a1ebaf363f3eba42f665854a59613068c">Matrix44</a>&lt; <a class="el" href="classvcl_1_1Matrix.html">double</a> &gt;</td></tr>
<tr class="separator:a0c9537d456b6db5dc5f2216dfc8bccdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fa66e0f1a04578cf69387027e898c8d" id="r_a6fa66e0f1a04578cf69387027e898c8d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a6fa66e0f1a04578cf69387027e898c8d">Planef</a> = <a class="el" href="classvcl_1_1Plane.html">Plane</a>&lt; <a class="el" href="classvcl_1_1Matrix.html">float</a> &gt;</td></tr>
<tr class="separator:a6fa66e0f1a04578cf69387027e898c8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08ef90973b043cbb709bec85607f8313" id="r_a08ef90973b043cbb709bec85607f8313"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a08ef90973b043cbb709bec85607f8313">Planed</a> = <a class="el" href="classvcl_1_1Plane.html">Plane</a>&lt; <a class="el" href="classvcl_1_1Matrix.html">double</a> &gt;</td></tr>
<tr class="separator:a08ef90973b043cbb709bec85607f8313"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d15a5d1bc87330938ae9b8a55373334" id="r_ga6d15a5d1bc87330938ae9b8a55373334"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classvcl_1_1Matrix.html">typename</a> Scalar &gt; </td></tr>
<tr class="memitem:ga6d15a5d1bc87330938ae9b8a55373334"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__space__core.html#ga6d15a5d1bc87330938ae9b8a55373334">Point2</a> = <a class="el" href="classvcl_1_1Point.html">Point</a>&lt; Scalar, 2 &gt;</td></tr>
<tr class="memdesc:ga6d15a5d1bc87330938ae9b8a55373334"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience alias for a 2-dimensional <a class="el" href="classvcl_1_1Point.html" title="The Point class represents an N-dimensional point containing N scalar values.">Point</a>.  <br /></td></tr>
<tr class="separator:ga6d15a5d1bc87330938ae9b8a55373334"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga94bdb300286f9b4bf31987102e011f8d" id="r_ga94bdb300286f9b4bf31987102e011f8d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__space__core.html#ga94bdb300286f9b4bf31987102e011f8d">Point2i</a> = <a class="el" href="group__space__core.html#ga6d15a5d1bc87330938ae9b8a55373334">Point2</a>&lt; <a class="el" href="classvcl_1_1Matrix.html">int</a> &gt;</td></tr>
<tr class="memdesc:ga94bdb300286f9b4bf31987102e011f8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience alias for a 2-dimensional <a class="el" href="classvcl_1_1Point.html" title="The Point class represents an N-dimensional point containing N scalar values.">Point</a> with integer components.  <br /></td></tr>
<tr class="separator:ga94bdb300286f9b4bf31987102e011f8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac9560ad588438ce539ec3fdc5658746a" id="r_gac9560ad588438ce539ec3fdc5658746a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__space__core.html#gac9560ad588438ce539ec3fdc5658746a">Point2f</a> = <a class="el" href="group__space__core.html#ga6d15a5d1bc87330938ae9b8a55373334">Point2</a>&lt; <a class="el" href="classvcl_1_1Matrix.html">float</a> &gt;</td></tr>
<tr class="memdesc:gac9560ad588438ce539ec3fdc5658746a"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience alias for a 2-dimensional <a class="el" href="classvcl_1_1Point.html" title="The Point class represents an N-dimensional point containing N scalar values.">Point</a> with floating-point components.  <br /></td></tr>
<tr class="separator:gac9560ad588438ce539ec3fdc5658746a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b02e85ff4d51fe7d689f8dd0e87ecd5" id="r_ga4b02e85ff4d51fe7d689f8dd0e87ecd5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__space__core.html#ga4b02e85ff4d51fe7d689f8dd0e87ecd5">Point2d</a> = <a class="el" href="group__space__core.html#ga6d15a5d1bc87330938ae9b8a55373334">Point2</a>&lt; <a class="el" href="classvcl_1_1Matrix.html">double</a> &gt;</td></tr>
<tr class="memdesc:ga4b02e85ff4d51fe7d689f8dd0e87ecd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience alias for a 2-dimensional <a class="el" href="classvcl_1_1Point.html" title="The Point class represents an N-dimensional point containing N scalar values.">Point</a> with double-precision floating-point components.  <br /></td></tr>
<tr class="separator:ga4b02e85ff4d51fe7d689f8dd0e87ecd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga13f2718b0763def563b8bd9f65982833" id="r_ga13f2718b0763def563b8bd9f65982833"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classvcl_1_1Matrix.html">typename</a> Scalar &gt; </td></tr>
<tr class="memitem:ga13f2718b0763def563b8bd9f65982833"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__space__core.html#ga13f2718b0763def563b8bd9f65982833">Point3</a> = <a class="el" href="classvcl_1_1Point.html">Point</a>&lt; Scalar, 3 &gt;</td></tr>
<tr class="memdesc:ga13f2718b0763def563b8bd9f65982833"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience alias for a 3-dimensional <a class="el" href="classvcl_1_1Point.html" title="The Point class represents an N-dimensional point containing N scalar values.">Point</a>.  <br /></td></tr>
<tr class="separator:ga13f2718b0763def563b8bd9f65982833"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga54b0dffe79fabd0458fc78332c91e73a" id="r_ga54b0dffe79fabd0458fc78332c91e73a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__space__core.html#ga54b0dffe79fabd0458fc78332c91e73a">Point3i</a> = <a class="el" href="group__space__core.html#ga13f2718b0763def563b8bd9f65982833">Point3</a>&lt; <a class="el" href="classvcl_1_1Matrix.html">int</a> &gt;</td></tr>
<tr class="memdesc:ga54b0dffe79fabd0458fc78332c91e73a"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience alias for a 3-dimensional <a class="el" href="classvcl_1_1Point.html" title="The Point class represents an N-dimensional point containing N scalar values.">Point</a> with integer components.  <br /></td></tr>
<tr class="separator:ga54b0dffe79fabd0458fc78332c91e73a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae19b0e9639a4f90c91e46910ee66f54c" id="r_gae19b0e9639a4f90c91e46910ee66f54c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__space__core.html#gae19b0e9639a4f90c91e46910ee66f54c">Point3f</a> = <a class="el" href="group__space__core.html#ga13f2718b0763def563b8bd9f65982833">Point3</a>&lt; <a class="el" href="classvcl_1_1Matrix.html">float</a> &gt;</td></tr>
<tr class="memdesc:gae19b0e9639a4f90c91e46910ee66f54c"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience alias for a 3-dimensional <a class="el" href="classvcl_1_1Point.html" title="The Point class represents an N-dimensional point containing N scalar values.">Point</a> with floating-point components.  <br /></td></tr>
<tr class="separator:gae19b0e9639a4f90c91e46910ee66f54c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb47c1364fb2fe1464a54417684f011e" id="r_gabb47c1364fb2fe1464a54417684f011e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__space__core.html#gabb47c1364fb2fe1464a54417684f011e">Point3d</a> = <a class="el" href="group__space__core.html#ga13f2718b0763def563b8bd9f65982833">Point3</a>&lt; <a class="el" href="classvcl_1_1Matrix.html">double</a> &gt;</td></tr>
<tr class="memdesc:gabb47c1364fb2fe1464a54417684f011e"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience alias for a 3-dimensional <a class="el" href="classvcl_1_1Point.html" title="The Point class represents an N-dimensional point containing N scalar values.">Point</a> with double-precision floating-point components.  <br /></td></tr>
<tr class="separator:gabb47c1364fb2fe1464a54417684f011e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga13715e1b62b4c051146f46d84e04afbc" id="r_ga13715e1b62b4c051146f46d84e04afbc"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classvcl_1_1Matrix.html">typename</a> Scalar &gt; </td></tr>
<tr class="memitem:ga13715e1b62b4c051146f46d84e04afbc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__space__core.html#ga13715e1b62b4c051146f46d84e04afbc">Point4</a> = <a class="el" href="classvcl_1_1Point.html">Point</a>&lt; Scalar, 4 &gt;</td></tr>
<tr class="memdesc:ga13715e1b62b4c051146f46d84e04afbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience alias for a 4-dimensional <a class="el" href="classvcl_1_1Point.html" title="The Point class represents an N-dimensional point containing N scalar values.">Point</a>.  <br /></td></tr>
<tr class="separator:ga13715e1b62b4c051146f46d84e04afbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac86981d787ccd11247f7774e3be3c7b2" id="r_gac86981d787ccd11247f7774e3be3c7b2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__space__core.html#gac86981d787ccd11247f7774e3be3c7b2">Point4i</a> = <a class="el" href="group__space__core.html#ga13715e1b62b4c051146f46d84e04afbc">Point4</a>&lt; <a class="el" href="classvcl_1_1Matrix.html">int</a> &gt;</td></tr>
<tr class="memdesc:gac86981d787ccd11247f7774e3be3c7b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience alias for a 4-dimensional <a class="el" href="classvcl_1_1Point.html" title="The Point class represents an N-dimensional point containing N scalar values.">Point</a> with integer components.  <br /></td></tr>
<tr class="separator:gac86981d787ccd11247f7774e3be3c7b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga876dce2d8f1042f58d6ee413cd66b2e1" id="r_ga876dce2d8f1042f58d6ee413cd66b2e1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__space__core.html#ga876dce2d8f1042f58d6ee413cd66b2e1">Point4f</a> = <a class="el" href="group__space__core.html#ga13715e1b62b4c051146f46d84e04afbc">Point4</a>&lt; <a class="el" href="classvcl_1_1Matrix.html">float</a> &gt;</td></tr>
<tr class="memdesc:ga876dce2d8f1042f58d6ee413cd66b2e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience alias for a 4-dimensional <a class="el" href="classvcl_1_1Point.html" title="The Point class represents an N-dimensional point containing N scalar values.">Point</a> with floating-point components.  <br /></td></tr>
<tr class="separator:ga876dce2d8f1042f58d6ee413cd66b2e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga648562f0e0989c853d13b8b0338f3646" id="r_ga648562f0e0989c853d13b8b0338f3646"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__space__core.html#ga648562f0e0989c853d13b8b0338f3646">Point4d</a> = <a class="el" href="group__space__core.html#ga13715e1b62b4c051146f46d84e04afbc">Point4</a>&lt; <a class="el" href="classvcl_1_1Matrix.html">double</a> &gt;</td></tr>
<tr class="memdesc:ga648562f0e0989c853d13b8b0338f3646"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience alias for a 4-dimensional <a class="el" href="classvcl_1_1Point.html" title="The Point class represents an N-dimensional point containing N scalar values.">Point</a> with double-precision floating-point components.  <br /></td></tr>
<tr class="separator:ga648562f0e0989c853d13b8b0338f3646"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a924ac7eb7740e67b7701c82f079ca13b" id="r_a924ac7eb7740e67b7701c82f079ca13b"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classvcl_1_1Matrix.html">typename</a> Scalar &gt; </td></tr>
<tr class="memitem:a924ac7eb7740e67b7701c82f079ca13b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a924ac7eb7740e67b7701c82f079ca13b">Polygon2</a> = <a class="el" href="classvcl_1_1Polygon.html">Polygon</a>&lt; <a class="el" href="group__space__core.html#ga6d15a5d1bc87330938ae9b8a55373334">Point2</a>&lt; Scalar &gt; &gt;</td></tr>
<tr class="separator:a924ac7eb7740e67b7701c82f079ca13b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d13400e95eb6871c2e4f6169ef08c23" id="r_a2d13400e95eb6871c2e4f6169ef08c23"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a2d13400e95eb6871c2e4f6169ef08c23">Polygon2f</a> = <a class="el" href="classvcl_1_1Polygon.html">Polygon</a>&lt; <a class="el" href="group__space__core.html#gac9560ad588438ce539ec3fdc5658746a">Point2f</a> &gt;</td></tr>
<tr class="separator:a2d13400e95eb6871c2e4f6169ef08c23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a386fd968f85ff551b4d58e109c21db9a" id="r_a386fd968f85ff551b4d58e109c21db9a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a386fd968f85ff551b4d58e109c21db9a">Polygon2d</a> = <a class="el" href="classvcl_1_1Polygon.html">Polygon</a>&lt; <a class="el" href="group__space__core.html#ga4b02e85ff4d51fe7d689f8dd0e87ecd5">Point2d</a> &gt;</td></tr>
<tr class="separator:a386fd968f85ff551b4d58e109c21db9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac04b9a59a6c30f22d15b0d1932e60457" id="r_ac04b9a59a6c30f22d15b0d1932e60457"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classvcl_1_1Matrix.html">typename</a> Scalar &gt; </td></tr>
<tr class="memitem:ac04b9a59a6c30f22d15b0d1932e60457"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ac04b9a59a6c30f22d15b0d1932e60457">Polygon3</a> = <a class="el" href="classvcl_1_1Polygon.html">Polygon</a>&lt; <a class="el" href="group__space__core.html#ga13f2718b0763def563b8bd9f65982833">Point3</a>&lt; Scalar &gt; &gt;</td></tr>
<tr class="separator:ac04b9a59a6c30f22d15b0d1932e60457"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a359353bfe1b3e56f12a750b2de4abc" id="r_a4a359353bfe1b3e56f12a750b2de4abc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a4a359353bfe1b3e56f12a750b2de4abc">Polygon3f</a> = <a class="el" href="classvcl_1_1Polygon.html">Polygon</a>&lt; <a class="el" href="group__space__core.html#gae19b0e9639a4f90c91e46910ee66f54c">Point3f</a> &gt;</td></tr>
<tr class="separator:a4a359353bfe1b3e56f12a750b2de4abc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac010b9e655ca9ca0c32f8c61b1eb56a2" id="r_ac010b9e655ca9ca0c32f8c61b1eb56a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ac010b9e655ca9ca0c32f8c61b1eb56a2">Polygon3d</a> = <a class="el" href="classvcl_1_1Polygon.html">Polygon</a>&lt; <a class="el" href="group__space__core.html#gabb47c1364fb2fe1464a54417684f011e">Point3d</a> &gt;</td></tr>
<tr class="separator:ac010b9e655ca9ca0c32f8c61b1eb56a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8c7ce5479499796837976d3247e4df8" id="r_af8c7ce5479499796837976d3247e4df8"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classvcl_1_1Matrix.html">typename</a> <a class="el" href="classvcl_1_1Matrix.html">S</a> &gt; </td></tr>
<tr class="memitem:af8c7ce5479499796837976d3247e4df8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#af8c7ce5479499796837976d3247e4df8">Segment2</a> = <a class="el" href="classvcl_1_1Segment.html">Segment</a>&lt; <a class="el" href="group__space__core.html#ga6d15a5d1bc87330938ae9b8a55373334">Point2</a>&lt; <a class="el" href="classvcl_1_1Matrix.html">S</a> &gt; &gt;</td></tr>
<tr class="separator:af8c7ce5479499796837976d3247e4df8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ca08e736f7887a86fa4fc2dd396cdc5" id="r_a9ca08e736f7887a86fa4fc2dd396cdc5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a9ca08e736f7887a86fa4fc2dd396cdc5">Segment2i</a> = <a class="el" href="classvcl_1_1Segment.html">Segment</a>&lt; <a class="el" href="group__space__core.html#ga94bdb300286f9b4bf31987102e011f8d">Point2i</a> &gt;</td></tr>
<tr class="separator:a9ca08e736f7887a86fa4fc2dd396cdc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83dc041e1243c07111706a89433af7a9" id="r_a83dc041e1243c07111706a89433af7a9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a83dc041e1243c07111706a89433af7a9">Segment2f</a> = <a class="el" href="classvcl_1_1Segment.html">Segment</a>&lt; <a class="el" href="group__space__core.html#gac9560ad588438ce539ec3fdc5658746a">Point2f</a> &gt;</td></tr>
<tr class="separator:a83dc041e1243c07111706a89433af7a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5da8472ea5b5275ab7109e52d50af04" id="r_ae5da8472ea5b5275ab7109e52d50af04"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ae5da8472ea5b5275ab7109e52d50af04">Segment2d</a> = <a class="el" href="classvcl_1_1Segment.html">Segment</a>&lt; <a class="el" href="group__space__core.html#ga4b02e85ff4d51fe7d689f8dd0e87ecd5">Point2d</a> &gt;</td></tr>
<tr class="separator:ae5da8472ea5b5275ab7109e52d50af04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc9c518fdcc207d621776ebeeedc0db5" id="r_afc9c518fdcc207d621776ebeeedc0db5"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classvcl_1_1Matrix.html">typename</a> <a class="el" href="classvcl_1_1Matrix.html">S</a> &gt; </td></tr>
<tr class="memitem:afc9c518fdcc207d621776ebeeedc0db5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#afc9c518fdcc207d621776ebeeedc0db5">Segment3</a> = <a class="el" href="classvcl_1_1Segment.html">Segment</a>&lt; <a class="el" href="group__space__core.html#ga13f2718b0763def563b8bd9f65982833">Point3</a>&lt; <a class="el" href="classvcl_1_1Matrix.html">S</a> &gt; &gt;</td></tr>
<tr class="separator:afc9c518fdcc207d621776ebeeedc0db5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0694142b42086cf347becff6f0db0c9c" id="r_a0694142b42086cf347becff6f0db0c9c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a0694142b42086cf347becff6f0db0c9c">Segment3i</a> = <a class="el" href="classvcl_1_1Segment.html">Segment</a>&lt; <a class="el" href="group__space__core.html#ga54b0dffe79fabd0458fc78332c91e73a">Point3i</a> &gt;</td></tr>
<tr class="separator:a0694142b42086cf347becff6f0db0c9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01b4f12a5cd0b2470b2abcd9890f1de1" id="r_a01b4f12a5cd0b2470b2abcd9890f1de1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a01b4f12a5cd0b2470b2abcd9890f1de1">Segment3f</a> = <a class="el" href="classvcl_1_1Segment.html">Segment</a>&lt; <a class="el" href="group__space__core.html#gae19b0e9639a4f90c91e46910ee66f54c">Point3f</a> &gt;</td></tr>
<tr class="separator:a01b4f12a5cd0b2470b2abcd9890f1de1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77d6ff7d119b08bd6bc8d5e84b9fe2ec" id="r_a77d6ff7d119b08bd6bc8d5e84b9fe2ec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a77d6ff7d119b08bd6bc8d5e84b9fe2ec">Segment3d</a> = <a class="el" href="classvcl_1_1Segment.html">Segment</a>&lt; <a class="el" href="group__space__core.html#gabb47c1364fb2fe1464a54417684f011e">Point3d</a> &gt;</td></tr>
<tr class="separator:a77d6ff7d119b08bd6bc8d5e84b9fe2ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a918b0af3e76ff4b82da382ddfab126d0" id="r_a918b0af3e76ff4b82da382ddfab126d0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a918b0af3e76ff4b82da382ddfab126d0">Spheref</a> = <a class="el" href="classvcl_1_1Sphere.html">Sphere</a>&lt; <a class="el" href="classvcl_1_1Matrix.html">float</a> &gt;</td></tr>
<tr class="separator:a918b0af3e76ff4b82da382ddfab126d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a125a3b42c101ab958048c730060aa8c8" id="r_a125a3b42c101ab958048c730060aa8c8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a125a3b42c101ab958048c730060aa8c8">Sphered</a> = <a class="el" href="classvcl_1_1Sphere.html">Sphere</a>&lt; <a class="el" href="classvcl_1_1Matrix.html">double</a> &gt;</td></tr>
<tr class="separator:a125a3b42c101ab958048c730060aa8c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a917984925513fc8634c94e269ee0cf82" id="r_a917984925513fc8634c94e269ee0cf82"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a917984925513fc8634c94e269ee0cf82">TexCoordi</a> = <a class="el" href="classvcl_1_1TexCoord.html">TexCoord</a>&lt; <a class="el" href="classvcl_1_1Matrix.html">int</a> &gt;</td></tr>
<tr class="separator:a917984925513fc8634c94e269ee0cf82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ccd8e32ef2f6bf0decb43463f41fb2b" id="r_a6ccd8e32ef2f6bf0decb43463f41fb2b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a6ccd8e32ef2f6bf0decb43463f41fb2b">TexCoordf</a> = <a class="el" href="classvcl_1_1TexCoord.html">TexCoord</a>&lt; <a class="el" href="classvcl_1_1Matrix.html">float</a> &gt;</td></tr>
<tr class="separator:a6ccd8e32ef2f6bf0decb43463f41fb2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec42e251f09249cda2fe0463b81c0f79" id="r_aec42e251f09249cda2fe0463b81c0f79"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#aec42e251f09249cda2fe0463b81c0f79">TexCoordd</a> = <a class="el" href="classvcl_1_1TexCoord.html">TexCoord</a>&lt; <a class="el" href="classvcl_1_1Matrix.html">double</a> &gt;</td></tr>
<tr class="separator:aec42e251f09249cda2fe0463b81c0f79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac0ef38a541827b51057bfae9e8c5039" id="r_aac0ef38a541827b51057bfae9e8c5039"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classvcl_1_1Matrix.html">typename</a> Scalar &gt; </td></tr>
<tr class="memitem:aac0ef38a541827b51057bfae9e8c5039"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#aac0ef38a541827b51057bfae9e8c5039">Triangle2</a> = <a class="el" href="classvcl_1_1Triangle.html">Triangle</a>&lt; <a class="el" href="group__space__core.html#ga6d15a5d1bc87330938ae9b8a55373334">Point2</a>&lt; Scalar &gt; &gt;</td></tr>
<tr class="separator:aac0ef38a541827b51057bfae9e8c5039"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1f6b217d733de32db193f0e751ece25" id="r_ad1f6b217d733de32db193f0e751ece25"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ad1f6b217d733de32db193f0e751ece25">Triangle2f</a> = <a class="el" href="classvcl_1_1Triangle.html">Triangle</a>&lt; <a class="el" href="group__space__core.html#gac9560ad588438ce539ec3fdc5658746a">Point2f</a> &gt;</td></tr>
<tr class="separator:ad1f6b217d733de32db193f0e751ece25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e9344ae874797a2a653deab133d870f" id="r_a8e9344ae874797a2a653deab133d870f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a8e9344ae874797a2a653deab133d870f">Triangle2d</a> = <a class="el" href="classvcl_1_1Triangle.html">Triangle</a>&lt; <a class="el" href="group__space__core.html#ga4b02e85ff4d51fe7d689f8dd0e87ecd5">Point2d</a> &gt;</td></tr>
<tr class="separator:a8e9344ae874797a2a653deab133d870f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae03921c36e8b060269d9ff90b068db39" id="r_ae03921c36e8b060269d9ff90b068db39"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classvcl_1_1Matrix.html">typename</a> Scalar &gt; </td></tr>
<tr class="memitem:ae03921c36e8b060269d9ff90b068db39"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ae03921c36e8b060269d9ff90b068db39">Triangle3</a> = <a class="el" href="classvcl_1_1Triangle.html">Triangle</a>&lt; <a class="el" href="group__space__core.html#ga13f2718b0763def563b8bd9f65982833">Point3</a>&lt; Scalar &gt; &gt;</td></tr>
<tr class="separator:ae03921c36e8b060269d9ff90b068db39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa2a67863f5edd83d508344306bd7bb3" id="r_afa2a67863f5edd83d508344306bd7bb3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#afa2a67863f5edd83d508344306bd7bb3">Triangle3f</a> = <a class="el" href="classvcl_1_1Triangle.html">Triangle</a>&lt; <a class="el" href="group__space__core.html#gae19b0e9639a4f90c91e46910ee66f54c">Point3f</a> &gt;</td></tr>
<tr class="separator:afa2a67863f5edd83d508344306bd7bb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02db1e7fb252318c4435c8ca9944401e" id="r_a02db1e7fb252318c4435c8ca9944401e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a02db1e7fb252318c4435c8ca9944401e">Triangle3d</a> = <a class="el" href="classvcl_1_1Triangle.html">Triangle</a>&lt; <a class="el" href="group__space__core.html#gabb47c1364fb2fe1464a54417684f011e">Point3d</a> &gt;</td></tr>
<tr class="separator:a02db1e7fb252318c4435c8ca9944401e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92c93a12005e031d04c92971247414ef" id="r_a92c93a12005e031d04c92971247414ef"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classvcl_1_1Matrix.html">typename</a> Scalar &gt; </td></tr>
<tr class="memitem:a92c93a12005e031d04c92971247414ef"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a92c93a12005e031d04c92971247414ef">TriangleWrapper2</a> = <a class="el" href="classvcl_1_1TriangleWrapper.html">TriangleWrapper</a>&lt; <a class="el" href="group__space__core.html#ga6d15a5d1bc87330938ae9b8a55373334">Point2</a>&lt; Scalar &gt; &gt;</td></tr>
<tr class="separator:a92c93a12005e031d04c92971247414ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ff16ee6b33f9bdd47405cb91f29e2d0" id="r_a5ff16ee6b33f9bdd47405cb91f29e2d0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a5ff16ee6b33f9bdd47405cb91f29e2d0">TriangleWrapper2f</a> = <a class="el" href="classvcl_1_1TriangleWrapper.html">TriangleWrapper</a>&lt; <a class="el" href="group__space__core.html#gac9560ad588438ce539ec3fdc5658746a">Point2f</a> &gt;</td></tr>
<tr class="separator:a5ff16ee6b33f9bdd47405cb91f29e2d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27931fc2ea467c03c1019dc025d218e5" id="r_a27931fc2ea467c03c1019dc025d218e5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a27931fc2ea467c03c1019dc025d218e5">TriangleWrapper2d</a> = <a class="el" href="classvcl_1_1TriangleWrapper.html">TriangleWrapper</a>&lt; <a class="el" href="group__space__core.html#ga4b02e85ff4d51fe7d689f8dd0e87ecd5">Point2d</a> &gt;</td></tr>
<tr class="separator:a27931fc2ea467c03c1019dc025d218e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a439efbe438907a52943d563d8a12daab" id="r_a439efbe438907a52943d563d8a12daab"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classvcl_1_1Matrix.html">typename</a> Scalar &gt; </td></tr>
<tr class="memitem:a439efbe438907a52943d563d8a12daab"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a439efbe438907a52943d563d8a12daab">TriangleWrapper3</a> = <a class="el" href="classvcl_1_1TriangleWrapper.html">TriangleWrapper</a>&lt; <a class="el" href="group__space__core.html#ga13f2718b0763def563b8bd9f65982833">Point3</a>&lt; Scalar &gt; &gt;</td></tr>
<tr class="separator:a439efbe438907a52943d563d8a12daab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a295b4c2f1ffcf361e32166b44a5a4476" id="r_a295b4c2f1ffcf361e32166b44a5a4476"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a295b4c2f1ffcf361e32166b44a5a4476">TriangleWrapper3f</a> = <a class="el" href="classvcl_1_1TriangleWrapper.html">TriangleWrapper</a>&lt; <a class="el" href="group__space__core.html#gae19b0e9639a4f90c91e46910ee66f54c">Point3f</a> &gt;</td></tr>
<tr class="separator:a295b4c2f1ffcf361e32166b44a5a4476"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace2761031333634f83908ed3d4e5fb19" id="r_ace2761031333634f83908ed3d4e5fb19"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ace2761031333634f83908ed3d4e5fb19">TriangleWrapper3d</a> = <a class="el" href="classvcl_1_1TriangleWrapper.html">TriangleWrapper</a>&lt; <a class="el" href="group__space__core.html#gabb47c1364fb2fe1464a54417684f011e">Point3d</a> &gt;</td></tr>
<tr class="separator:ace2761031333634f83908ed3d4e5fb19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af74b42dd9d759d565bb701a5b845d05c" id="r_af74b42dd9d759d565bb701a5b845d05c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a> = <a class="el" href="classvcl_1_1Matrix.html">unsigned</a> <a class="el" href="classvcl_1_1Matrix.html">int</a></td></tr>
<tr class="separator:af74b42dd9d759d565bb701a5b845d05c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ee777e6ef2036ffa4ea83d39f83663b" id="r_a5ee777e6ef2036ffa4ea83d39f83663b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a5ee777e6ef2036ffa4ea83d39f83663b">ushort</a> = <a class="el" href="classvcl_1_1Matrix.html">unsigned</a> <a class="el" href="classvcl_1_1Matrix.html">short</a></td></tr>
<tr class="separator:a5ee777e6ef2036ffa4ea83d39f83663b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaacc96304be3365c944d0239dd550f74e" id="r_gaacc96304be3365c944d0239dd550f74e"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classvcl_1_1Matrix.html">typename</a> T &gt; </td></tr>
<tr class="memitem:gaacc96304be3365c944d0239dd550f74e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__types.html#gaacc96304be3365c944d0239dd550f74e">MakeConstPointerT</a> = <a class="el" href="classvcl_1_1Matrix.html">typename</a> <a class="el" href="structvcl_1_1MakeConstPointer.html">MakeConstPointer</a>&lt; T &gt;::type</td></tr>
<tr class="memdesc:gaacc96304be3365c944d0239dd550f74e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility alias for the <a class="el" href="structvcl_1_1MakeConstPointer.html" title="Utility type that makes possible to treat const pointers in a templated class that can treat a both c...">MakeConstPointer</a> type.  <br /></td></tr>
<tr class="separator:gaacc96304be3365c944d0239dd550f74e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a37fc3ccf3b54b062d37fe46900e112" id="r_ga8a37fc3ccf3b54b062d37fe46900e112"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classvcl_1_1Matrix.html">typename</a> <a class="el" href="classvcl_1_1Matrix.html">derived</a> , <a class="el" href="classvcl_1_1Matrix.html">template</a>&lt; typename... &gt; <a class="el" href="classvcl_1_1Matrix.html">class</a> base&gt; </td></tr>
<tr class="memitem:ga8a37fc3ccf3b54b062d37fe46900e112"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__types.html#ga8a37fc3ccf3b54b062d37fe46900e112">IsDerivedFromTemplateSpecialization</a> = std::invoke_result&lt; detail::IsDerivedFromImplementation&lt; <a class="el" href="classvcl_1_1Matrix.html">base</a> &gt;, <a class="el" href="classvcl_1_1Matrix.html">typename</a> std::remove_cv&lt; <a class="el" href="classvcl_1_1Matrix.html">derived</a> &gt;::type * &gt;::type</td></tr>
<tr class="memdesc:ga8a37fc3ccf3b54b062d37fe46900e112"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility class that allows to check if given class 'Derived' is derived from a specialization of a templated class.  <br /></td></tr>
<tr class="separator:ga8a37fc3ccf3b54b062d37fe46900e112"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ec2f45ee6feff2a4aff0f15d6b0b0b0" id="r_ga2ec2f45ee6feff2a4aff0f15d6b0b0b0"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classvcl_1_1Matrix.html">typename</a> T &gt; </td></tr>
<tr class="memitem:ga2ec2f45ee6feff2a4aff0f15d6b0b0b0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__types.html#ga2ec2f45ee6feff2a4aff0f15d6b0b0b0">RemoveCVRefAndPointer</a> = <a class="el" href="classvcl_1_1Matrix.html">typename</a> std::remove_cvref_t&lt; std::remove_pointer_t&lt; T &gt; &gt;</td></tr>
<tr class="memdesc:ga2ec2f45ee6feff2a4aff0f15d6b0b0b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility alias to get clean type from an input type that could have a reference or a pointer.  <br /></td></tr>
<tr class="separator:ga2ec2f45ee6feff2a4aff0f15d6b0b0b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab15612cff0fdd71b4a6b22d62676ffe4" id="r_gab15612cff0fdd71b4a6b22d62676ffe4"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classvcl_1_1Matrix.html">typename</a> T &gt; </td></tr>
<tr class="memitem:gab15612cff0fdd71b4a6b22d62676ffe4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__types.html#gab15612cff0fdd71b4a6b22d62676ffe4">RemoveConstFromPointer</a> = std::conditional_t&lt; std::is_pointer_v&lt; T &gt;, std::add_pointer_t&lt; <a class="el" href="classvcl_1_1Matrix.html">typename</a> std::remove_cv_t&lt; <a class="el" href="classvcl_1_1Matrix.html">typename</a> std::remove_pointer_t&lt; T &gt; &gt; &gt;, T &gt;</td></tr>
<tr class="memdesc:gab15612cff0fdd71b4a6b22d62676ffe4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility alias to get a pointer type without the constness. e.g. If T is const int*, the resulting type is int* If the type is not a pointer, it is left as it was.  <br /></td></tr>
<tr class="separator:gab15612cff0fdd71b4a6b22d62676ffe4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga38c527736a2d0a3d7af0493e228227e3" id="r_ga38c527736a2d0a3d7af0493e228227e3"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:ga38c527736a2d0a3d7af0493e228227e3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__types.html#ga38c527736a2d0a3d7af0493e228227e3">FirstTypeT</a> = <a class="el" href="classvcl_1_1Matrix.html">typename</a> <a class="el" href="structvcl_1_1FirstType.html">FirstType</a>&lt; Args... &gt;::type</td></tr>
<tr class="memdesc:ga38c527736a2d0a3d7af0493e228227e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for the type of the first type in a pack of types.  <br /></td></tr>
<tr class="separator:ga38c527736a2d0a3d7af0493e228227e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a5a4e8376b2d47797f9167f2a8dd6fb0e" id="r_a5a4e8376b2d47797f9167f2a8dd6fb0e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a5a4e8376b2d47797f9167f2a8dd6fb0e">HausdorffSamplingMethod</a> { <a class="el" href="namespacevcl.html#a5a4e8376b2d47797f9167f2a8dd6fb0ea33aad0431cadce18cad82201cb732f49">HAUSDORFF_VERTEX_UNIFORM</a> = 0
, <a class="el" href="namespacevcl.html#a5a4e8376b2d47797f9167f2a8dd6fb0eac8770691ceb41b51c7ab63b70f1da9c6">HAUSDORFF_EDGE_UNIFORM</a>
, <a class="el" href="namespacevcl.html#a5a4e8376b2d47797f9167f2a8dd6fb0eaf9d0153b4af81b71be3972e5a9e3307a">HAUSDORFF_MONTECARLO</a>
 }</td></tr>
<tr class="separator:a5a4e8376b2d47797f9167f2a8dd6fb0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaca879a6bfd47ff8429d6b2f6cfa9440" id="r_aaca879a6bfd47ff8429d6b2f6cfa9440"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#aaca879a6bfd47ff8429d6b2f6cfa9440">VCLibPrincipalCurvatureAlgorithm</a> { <a class="el" href="namespacevcl.html#aaca879a6bfd47ff8429d6b2f6cfa9440a16e818963316b0b43fcbdec6d75f25ed">VCL_PRINCIPAL_CURVATURE_TAUBIN95</a>
, <a class="el" href="namespacevcl.html#aaca879a6bfd47ff8429d6b2f6cfa9440a2c812dad0f96c382657b60bb2d2f8180">VCL_PRINCIPAL_CURVATURE_PCA</a>
 }</td></tr>
<tr class="separator:aaca879a6bfd47ff8429d6b2f6cfa9440"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga1ad883eeb58e2a302d15ce6ba179752f" id="r_ga1ad883eeb58e2a302d15ce6ba179752f"><td class="memTemplParams" colspan="2">template&lt;PointConcept PointType&gt; </td></tr>
<tr class="memitem:ga1ad883eeb58e2a302d15ce6ba179752f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__core__bounding__box.html#ga1ad883eeb58e2a302d15ce6ba179752f">boundingBox</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> PointType &amp;<a class="el" href="classvcl_1_1Matrix.html">p</a>)</td></tr>
<tr class="memdesc:ga1ad883eeb58e2a302d15ce6ba179752f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the bounding box of a single point.  <br /></td></tr>
<tr class="separator:ga1ad883eeb58e2a302d15ce6ba179752f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga776dc863a78918d5a0f104907ab8a26f" id="r_ga776dc863a78918d5a0f104907ab8a26f"><td class="memTemplParams" colspan="2">template&lt;SegmentConcept SegmentType&gt; </td></tr>
<tr class="memitem:ga776dc863a78918d5a0f104907ab8a26f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__core__bounding__box.html#ga776dc863a78918d5a0f104907ab8a26f">boundingBox</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="classvcl_1_1Matrix.html">SegmentType</a> &amp;s)</td></tr>
<tr class="memdesc:ga776dc863a78918d5a0f104907ab8a26f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the bounding box of a line segment.  <br /></td></tr>
<tr class="separator:ga776dc863a78918d5a0f104907ab8a26f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab8f4fd4f0f5ffcf56b82e44e7bb6a1dd" id="r_gab8f4fd4f0f5ffcf56b82e44e7bb6a1dd"><td class="memTemplParams" colspan="2">template&lt;SphereConcept SphereType&gt; </td></tr>
<tr class="memitem:gab8f4fd4f0f5ffcf56b82e44e7bb6a1dd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__core__bounding__box.html#gab8f4fd4f0f5ffcf56b82e44e7bb6a1dd">boundingBox</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="classvcl_1_1Matrix.html">SphereType</a> &amp;s)</td></tr>
<tr class="memdesc:gab8f4fd4f0f5ffcf56b82e44e7bb6a1dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the bounding box of a sphere.  <br /></td></tr>
<tr class="separator:gab8f4fd4f0f5ffcf56b82e44e7bb6a1dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5394cef99570de3bb2538e6c4dae69f7" id="r_ga5394cef99570de3bb2538e6c4dae69f7"><td class="memTemplParams" colspan="2">template&lt;VertexConcept VertexType&gt; </td></tr>
<tr class="memitem:ga5394cef99570de3bb2538e6c4dae69f7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__core__bounding__box.html#ga5394cef99570de3bb2538e6c4dae69f7">boundingBox</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> VertexType &amp;v)</td></tr>
<tr class="memdesc:ga5394cef99570de3bb2538e6c4dae69f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the bounding box of a vertex.  <br /></td></tr>
<tr class="separator:ga5394cef99570de3bb2538e6c4dae69f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga65283494a83b003698a6f37d3157384a" id="r_ga65283494a83b003698a6f37d3157384a"><td class="memTemplParams" colspan="2">template&lt;VertexConcept VertexType&gt; </td></tr>
<tr class="memitem:ga65283494a83b003698a6f37d3157384a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__core__bounding__box.html#ga65283494a83b003698a6f37d3157384a">boundingBox</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> VertexType *v)</td></tr>
<tr class="memdesc:ga65283494a83b003698a6f37d3157384a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the bounding box of a vertex pointer.  <br /></td></tr>
<tr class="separator:ga65283494a83b003698a6f37d3157384a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf568c42e98a48937632002951ba1a0c7" id="r_gaf568c42e98a48937632002951ba1a0c7"><td class="memTemplParams" colspan="2">template&lt;FaceConcept FaceType&gt; </td></tr>
<tr class="memitem:gaf568c42e98a48937632002951ba1a0c7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__core__bounding__box.html#gaf568c42e98a48937632002951ba1a0c7">boundingBox</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> FaceType &amp;f)</td></tr>
<tr class="memdesc:gaf568c42e98a48937632002951ba1a0c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the bounding box of a face.  <br /></td></tr>
<tr class="separator:gaf568c42e98a48937632002951ba1a0c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafcd15ef8e31e650a8e3714feb5c6efcc" id="r_gafcd15ef8e31e650a8e3714feb5c6efcc"><td class="memTemplParams" colspan="2">template&lt;FaceConcept FaceType&gt; </td></tr>
<tr class="memitem:gafcd15ef8e31e650a8e3714feb5c6efcc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__core__bounding__box.html#gafcd15ef8e31e650a8e3714feb5c6efcc">boundingBox</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> FaceType *f)</td></tr>
<tr class="memdesc:gafcd15ef8e31e650a8e3714feb5c6efcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the bounding box of a face pointer.  <br /></td></tr>
<tr class="separator:gafcd15ef8e31e650a8e3714feb5c6efcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3364ecfcc22e860e202e0c4edc2bbc79" id="r_ga3364ecfcc22e860e202e0c4edc2bbc79"><td class="memTemplParams" colspan="2">template&lt;EdgeConcept EdgeType&gt; </td></tr>
<tr class="memitem:ga3364ecfcc22e860e202e0c4edc2bbc79"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__core__bounding__box.html#ga3364ecfcc22e860e202e0c4edc2bbc79">boundingBox</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> EdgeType &amp;e)</td></tr>
<tr class="memdesc:ga3364ecfcc22e860e202e0c4edc2bbc79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the bounding box of an edge.  <br /></td></tr>
<tr class="separator:ga3364ecfcc22e860e202e0c4edc2bbc79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac83361d6c2d4182da008a6e198fe4465" id="r_gac83361d6c2d4182da008a6e198fe4465"><td class="memTemplParams" colspan="2">template&lt;EdgeConcept EdgeType&gt; </td></tr>
<tr class="memitem:gac83361d6c2d4182da008a6e198fe4465"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__core__bounding__box.html#gac83361d6c2d4182da008a6e198fe4465">boundingBox</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> EdgeType *e)</td></tr>
<tr class="memdesc:gac83361d6c2d4182da008a6e198fe4465"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the bounding box of an edge pointer.  <br /></td></tr>
<tr class="separator:gac83361d6c2d4182da008a6e198fe4465"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c874831bf64431e53535e966bccb9e9" id="r_ga6c874831bf64431e53535e966bccb9e9"><td class="memTemplParams" colspan="2">template&lt;IteratorConcept Iterator&gt; </td></tr>
<tr class="memitem:ga6c874831bf64431e53535e966bccb9e9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__core__bounding__box.html#ga6c874831bf64431e53535e966bccb9e9">boundingBox</a> (Iterator begin, Iterator end)</td></tr>
<tr class="memdesc:ga6c874831bf64431e53535e966bccb9e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the bounding box of a set of objects.  <br /></td></tr>
<tr class="separator:ga6c874831bf64431e53535e966bccb9e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga780e912fa6dbf0a2a7d0e49445f65347" id="r_ga780e912fa6dbf0a2a7d0e49445f65347"><td class="memTemplParams" colspan="2">template&lt;Range Rng&gt; </td></tr>
<tr class="memitem:ga780e912fa6dbf0a2a7d0e49445f65347"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__core__bounding__box.html#ga780e912fa6dbf0a2a7d0e49445f65347">boundingBox</a> (<a class="el" href="classvcl_1_1Matrix.html">Rng</a> &amp;&amp;<a class="el" href="classvcl_1_1Matrix.html">r</a>)</td></tr>
<tr class="memdesc:ga780e912fa6dbf0a2a7d0e49445f65347"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the bounding box of a range of objects.  <br /></td></tr>
<tr class="separator:ga780e912fa6dbf0a2a7d0e49445f65347"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9abd2d46a87cb3d18987a37e11ed6ccc" id="r_a9abd2d46a87cb3d18987a37e11ed6ccc"><td class="memTemplParams" colspan="2">template&lt;Point3Concept PointType, FaceConcept FaceType, <a class="el" href="classvcl_1_1Matrix.html">typename</a> ScalarType &gt; </td></tr>
<tr class="memitem:a9abd2d46a87cb3d18987a37e11ed6ccc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a9abd2d46a87cb3d18987a37e11ed6ccc">pointFaceDistance</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> PointType &amp;<a class="el" href="classvcl_1_1Matrix.html">p</a>, <a class="el" href="classvcl_1_1Matrix.html">const</a> FaceType &amp;f, ScalarType maxDist, PointType &amp;<a class="el" href="classvcl_1_1Matrix.html">closest</a>, <a class="el" href="classvcl_1_1Matrix.html">bool</a> <a class="el" href="classvcl_1_1Matrix.html">signedDist</a>=<a class="el" href="classvcl_1_1Matrix.html">false</a>)</td></tr>
<tr class="memdesc:a9abd2d46a87cb3d18987a37e11ed6ccc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the distance between a 3D point and a 3D triangle face.  <br /></td></tr>
<tr class="separator:a9abd2d46a87cb3d18987a37e11ed6ccc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a294ad7cda738cd64d09b432874830c" id="r_a3a294ad7cda738cd64d09b432874830c"><td class="memTemplParams" colspan="2">template&lt;Point3Concept PointType, FaceConcept FaceType, <a class="el" href="classvcl_1_1Matrix.html">typename</a> ScalarType &gt; </td></tr>
<tr class="memitem:a3a294ad7cda738cd64d09b432874830c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a3a294ad7cda738cd64d09b432874830c">pointFaceDistance</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> PointType &amp;<a class="el" href="classvcl_1_1Matrix.html">p</a>, <a class="el" href="classvcl_1_1Matrix.html">const</a> FaceType &amp;f, ScalarType maxDist, <a class="el" href="classvcl_1_1Matrix.html">bool</a> <a class="el" href="classvcl_1_1Matrix.html">signedDist</a>=<a class="el" href="classvcl_1_1Matrix.html">false</a>)</td></tr>
<tr class="separator:a3a294ad7cda738cd64d09b432874830c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02f5dd6bd231e193440d954eee9d3aef" id="r_a02f5dd6bd231e193440d954eee9d3aef"><td class="memTemplParams" colspan="2">template&lt;Point3Concept PointType, FaceConcept FaceType&gt; </td></tr>
<tr class="memitem:a02f5dd6bd231e193440d954eee9d3aef"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a02f5dd6bd231e193440d954eee9d3aef">pointFaceDistance</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> PointType &amp;<a class="el" href="classvcl_1_1Matrix.html">p</a>, <a class="el" href="classvcl_1_1Matrix.html">const</a> FaceType &amp;f, PointType &amp;<a class="el" href="classvcl_1_1Matrix.html">closest</a>, <a class="el" href="classvcl_1_1Matrix.html">bool</a> <a class="el" href="classvcl_1_1Matrix.html">signedDist</a>=<a class="el" href="classvcl_1_1Matrix.html">false</a>)</td></tr>
<tr class="separator:a02f5dd6bd231e193440d954eee9d3aef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8efd5f55775e66de7f1f69b35bd1561a" id="r_a8efd5f55775e66de7f1f69b35bd1561a"><td class="memTemplParams" colspan="2">template&lt;Point3Concept PointType, FaceConcept FaceType&gt; </td></tr>
<tr class="memitem:a8efd5f55775e66de7f1f69b35bd1561a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a8efd5f55775e66de7f1f69b35bd1561a">pointFaceDistance</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> PointType &amp;<a class="el" href="classvcl_1_1Matrix.html">p</a>, <a class="el" href="classvcl_1_1Matrix.html">const</a> FaceType &amp;f, <a class="el" href="classvcl_1_1Matrix.html">bool</a> <a class="el" href="classvcl_1_1Matrix.html">signedDist</a>=<a class="el" href="classvcl_1_1Matrix.html">false</a>)</td></tr>
<tr class="memdesc:a8efd5f55775e66de7f1f69b35bd1561a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the distance between a 3D point and a 3D triangle face.  <br /></td></tr>
<tr class="separator:a8efd5f55775e66de7f1f69b35bd1561a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga63f7958bed5f73548d28f436c7eb7b35" id="r_ga63f7958bed5f73548d28f436c7eb7b35"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classvcl_1_1Matrix.html">typename</a> <a class="el" href="classvcl_1_1Matrix.html">Obj1</a> , <a class="el" href="classvcl_1_1Matrix.html">typename</a> <a class="el" href="classvcl_1_1Matrix.html">Obj2</a> &gt; </td></tr>
<tr class="memitem:ga63f7958bed5f73548d28f436c7eb7b35"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__distance.html#ga63f7958bed5f73548d28f436c7eb7b35">distFunction</a> ()</td></tr>
<tr class="memdesc:ga63f7958bed5f73548d28f436c7eb7b35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a proper dist function between a Obj1 object and an Obj2 object.  <br /></td></tr>
<tr class="separator:ga63f7958bed5f73548d28f436c7eb7b35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b9b1898fbdb7ba13f1e1adaf832ba4d" id="r_ga1b9b1898fbdb7ba13f1e1adaf832ba4d"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classvcl_1_1Matrix.html">typename</a> <a class="el" href="classvcl_1_1Matrix.html">Obj1</a> , <a class="el" href="classvcl_1_1Matrix.html">typename</a> <a class="el" href="classvcl_1_1Matrix.html">Obj2</a> , <a class="el" href="classvcl_1_1Matrix.html">typename</a> ScalarType  = double&gt; </td></tr>
<tr class="memitem:ga1b9b1898fbdb7ba13f1e1adaf832ba4d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__distance.html#ga1b9b1898fbdb7ba13f1e1adaf832ba4d">boundedDistFunction</a> ()</td></tr>
<tr class="memdesc:ga1b9b1898fbdb7ba13f1e1adaf832ba4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a proper dist function between a Obj1 object and an Obj2 object.  <br /></td></tr>
<tr class="separator:ga1b9b1898fbdb7ba13f1e1adaf832ba4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1826187003e1e307765b32879a69b748" id="r_a1826187003e1e307765b32879a69b748"><td class="memTemplParams" colspan="2">template&lt;Point3Concept PointType, PlaneConcept PlaneType&gt; </td></tr>
<tr class="memitem:a1826187003e1e307765b32879a69b748"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a1826187003e1e307765b32879a69b748">pointPlaneDistance</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> PointType &amp;<a class="el" href="classvcl_1_1Matrix.html">p</a>, <a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="classvcl_1_1Matrix.html">PlaneType</a> &amp;<a class="el" href="classvcl_1_1Matrix.html">plane</a>, <a class="el" href="classvcl_1_1Matrix.html">bool</a> <a class="el" href="classvcl_1_1Matrix.html">signedDist</a>=<a class="el" href="classvcl_1_1Matrix.html">false</a>)</td></tr>
<tr class="separator:a1826187003e1e307765b32879a69b748"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d8430571d9a6027e6d7e3bac4816b95" id="r_a1d8430571d9a6027e6d7e3bac4816b95"><td class="memTemplParams" colspan="2">template&lt;PointConcept PointType, SegmentConcept SegmentType&gt; <br />
requires (PointType::DIM == SegmentType::DIM)</td></tr>
<tr class="memitem:a1d8430571d9a6027e6d7e3bac4816b95"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a1d8430571d9a6027e6d7e3bac4816b95">pointSegmentDistance</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> PointType &amp;<a class="el" href="classvcl_1_1Matrix.html">p</a>, <a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="classvcl_1_1Matrix.html">SegmentType</a> &amp;s, PointType &amp;<a class="el" href="classvcl_1_1Matrix.html">closest</a>)</td></tr>
<tr class="separator:a1d8430571d9a6027e6d7e3bac4816b95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e95f3d99f53e335c7e17af14b42f991" id="r_a7e95f3d99f53e335c7e17af14b42f991"><td class="memTemplParams" colspan="2">template&lt;PointConcept PointType, SegmentConcept SegmentType&gt; <br />
requires (PointType::DIM == SegmentType::DIM)</td></tr>
<tr class="memitem:a7e95f3d99f53e335c7e17af14b42f991"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a7e95f3d99f53e335c7e17af14b42f991">pointSegmentDistance</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> PointType &amp;<a class="el" href="classvcl_1_1Matrix.html">p</a>, <a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="classvcl_1_1Matrix.html">SegmentType</a> &amp;s)</td></tr>
<tr class="separator:a7e95f3d99f53e335c7e17af14b42f991"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbf2dd04b5f4477ba07ab217dd603d14" id="r_abbf2dd04b5f4477ba07ab217dd603d14"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classvcl_1_1Matrix.html">typename</a> Scalar &gt; </td></tr>
<tr class="memitem:abbf2dd04b5f4477ba07ab217dd603d14"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Plane.html">Plane</a>&lt; Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#abbf2dd04b5f4477ba07ab217dd603d14">fitPlaneToPointCloud</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> std::vector&lt; <a class="el" href="group__space__core.html#ga13f2718b0763def563b8bd9f65982833">Point3</a>&lt; Scalar &gt; &gt; &amp;<a class="el" href="classvcl_1_1Matrix.html">pointVec</a>)</td></tr>
<tr class="memdesc:abbf2dd04b5f4477ba07ab217dd603d14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the plane best fitting a set of points The algorithm used is the classical Covariance matrix eigenvector approach.  <br /></td></tr>
<tr class="separator:abbf2dd04b5f4477ba07ab217dd603d14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a066ed60f6a8fcdc525e7038fd8d2a6f2" id="r_a066ed60f6a8fcdc525e7038fd8d2a6f2"><td class="memTemplParams" colspan="2">template&lt;Point3Concept PointType&gt; </td></tr>
<tr class="memitem:a066ed60f6a8fcdc525e7038fd8d2a6f2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Plane.html">Plane</a>&lt; <a class="el" href="classvcl_1_1Matrix.html">typename</a> PointType::ScalarType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a066ed60f6a8fcdc525e7038fd8d2a6f2">fitPlaneToWeightedPointCloud</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> std::vector&lt; PointType &gt; &amp;<a class="el" href="classvcl_1_1Matrix.html">pointVec</a>, <a class="el" href="classvcl_1_1Matrix.html">const</a> std::vector&lt; <a class="el" href="classvcl_1_1Matrix.html">typename</a> PointType::ScalarType &gt; &amp;<a class="el" href="classvcl_1_1Matrix.html">weights</a>)</td></tr>
<tr class="memdesc:a066ed60f6a8fcdc525e7038fd8d2a6f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the plane best fitting a wighted set of points The algorithm used is the wighted Covariance matrix eigenvector approach.  <br /></td></tr>
<tr class="separator:a066ed60f6a8fcdc525e7038fd8d2a6f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb99398069d243b6bb7b09e55a279792" id="r_abb99398069d243b6bb7b09e55a279792"><td class="memTemplParams" colspan="2">template&lt;FaceConcept FaceType, PointConcept PointType&gt; </td></tr>
<tr class="memitem:abb99398069d243b6bb7b09e55a279792"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#abb99398069d243b6bb7b09e55a279792">faceBoxIntersect</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> FaceType &amp;f, <a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="classvcl_1_1Box.html">Box</a>&lt; PointType &gt; &amp;<a class="el" href="classvcl_1_1Matrix.html">box</a>)</td></tr>
<tr class="separator:abb99398069d243b6bb7b09e55a279792"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9835f248a812a2d5010e4ab228f862f4" id="r_a9835f248a812a2d5010e4ab228f862f4"><td class="memTemplParams" colspan="2">template&lt;FaceConcept FaceType, PointConcept PointType, <a class="el" href="classvcl_1_1Matrix.html">typename</a> <a class="el" href="classvcl_1_1Matrix.html">SScalar</a> &gt; </td></tr>
<tr class="memitem:a9835f248a812a2d5010e4ab228f862f4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a9835f248a812a2d5010e4ab228f862f4">faceSphereIntersect</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> FaceType &amp;f, <a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="classvcl_1_1Sphere.html">Sphere</a>&lt; <a class="el" href="classvcl_1_1Matrix.html">SScalar</a> &gt; &amp;<a class="el" href="classvcl_1_1Matrix.html">sphere</a>, PointType &amp;<a class="el" href="classvcl_1_1Matrix.html">witness</a>, std::pair&lt; <a class="el" href="classvcl_1_1Matrix.html">SScalar</a>, <a class="el" href="classvcl_1_1Matrix.html">SScalar</a> &gt; &amp;<a class="el" href="classvcl_1_1Matrix.html">res</a>)</td></tr>
<tr class="memdesc:a9835f248a812a2d5010e4ab228f862f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the intersection between a sphere and a face, that may be also polygonal.  <br /></td></tr>
<tr class="separator:a9835f248a812a2d5010e4ab228f862f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab347f62d57311e2bc794dcca4a3809ee" id="r_ab347f62d57311e2bc794dcca4a3809ee"><td class="memTemplParams" colspan="2">template&lt;FaceConcept FaceType, <a class="el" href="classvcl_1_1Matrix.html">typename</a> <a class="el" href="classvcl_1_1Matrix.html">SScalar</a> &gt; </td></tr>
<tr class="memitem:ab347f62d57311e2bc794dcca4a3809ee"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ab347f62d57311e2bc794dcca4a3809ee">faceSphereIntersect</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> FaceType &amp;f, <a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="classvcl_1_1Sphere.html">Sphere</a>&lt; <a class="el" href="classvcl_1_1Matrix.html">SScalar</a> &gt; &amp;<a class="el" href="classvcl_1_1Matrix.html">sphere</a>)</td></tr>
<tr class="memdesc:ab347f62d57311e2bc794dcca4a3809ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the intersection between a sphere and a face, that may be also polygonal.  <br /></td></tr>
<tr class="separator:ab347f62d57311e2bc794dcca4a3809ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70dad48ffd4a840c11d422b0c3121393" id="r_a70dad48ffd4a840c11d422b0c3121393"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classvcl_1_1Matrix.html">typename</a> <a class="el" href="classvcl_1_1Matrix.html">Obj1</a> , <a class="el" href="classvcl_1_1Matrix.html">typename</a> <a class="el" href="classvcl_1_1Matrix.html">Obj2</a> &gt; </td></tr>
<tr class="memitem:a70dad48ffd4a840c11d422b0c3121393"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a70dad48ffd4a840c11d422b0c3121393">intersectFunction</a> ()</td></tr>
<tr class="memdesc:a70dad48ffd4a840c11d422b0c3121393"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a proper intersect function between a Obj1 object and an Obj2 object.  <br /></td></tr>
<tr class="separator:a70dad48ffd4a840c11d422b0c3121393"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27474522dfcc3be4ce96d6a8b44fcc09" id="r_a27474522dfcc3be4ce96d6a8b44fcc09"><td class="memTemplParams" colspan="2">template&lt;PlaneConcept PlaneType, Box3Concept BoxType&gt; </td></tr>
<tr class="memitem:a27474522dfcc3be4ce96d6a8b44fcc09"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a27474522dfcc3be4ce96d6a8b44fcc09">planeBoxIntersect</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="classvcl_1_1Matrix.html">PlaneType</a> &amp;<a class="el" href="classvcl_1_1Matrix.html">p</a>, <a class="el" href="classvcl_1_1Matrix.html">const</a> BoxType &amp;<a class="el" href="classvcl_1_1Matrix.html">box</a>)</td></tr>
<tr class="memdesc:a27474522dfcc3be4ce96d6a8b44fcc09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a plane intersects with a box.  <br /></td></tr>
<tr class="separator:a27474522dfcc3be4ce96d6a8b44fcc09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a095d688d385405cbf305d7f501f672a6" id="r_a095d688d385405cbf305d7f501f672a6"><td class="memTemplParams" colspan="2">template&lt;PlaneConcept PlaneType, Segment3Concept SegmentType&gt; </td></tr>
<tr class="memitem:a095d688d385405cbf305d7f501f672a6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a095d688d385405cbf305d7f501f672a6">planeSegmentIntersect</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="classvcl_1_1Matrix.html">PlaneType</a> &amp;<a class="el" href="classvcl_1_1Matrix.html">p</a>, <a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="classvcl_1_1Matrix.html">SegmentType</a> &amp;s, <a class="el" href="classvcl_1_1Matrix.html">typename</a> SegmentType::PointType &amp;intersection)</td></tr>
<tr class="memdesc:a095d688d385405cbf305d7f501f672a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function computes the intersection between a plane and a 3D segment. If the intersection exists, it returns true and stores the intersection point in the output parameter intersection, otherwise, it returns false.  <br /></td></tr>
<tr class="separator:a095d688d385405cbf305d7f501f672a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5603e96ba08d11993828c0e47f2657b2" id="r_a5603e96ba08d11993828c0e47f2657b2"><td class="memTemplParams" colspan="2">template&lt;PlaneConcept PlaneType, Segment3Concept SegmentType&gt; </td></tr>
<tr class="memitem:a5603e96ba08d11993828c0e47f2657b2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a5603e96ba08d11993828c0e47f2657b2">planeSegmentIntersect</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="classvcl_1_1Matrix.html">PlaneType</a> &amp;<a class="el" href="classvcl_1_1Matrix.html">p</a>, <a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="classvcl_1_1Matrix.html">SegmentType</a> &amp;s)</td></tr>
<tr class="memdesc:a5603e96ba08d11993828c0e47f2657b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function computes the intersection between a plane and a 3D segment. If the intersection exists, it returns true, otherwise, it returns false.  <br /></td></tr>
<tr class="separator:a5603e96ba08d11993828c0e47f2657b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9349b9ea771a0058a9cb4a57eedd624b" id="r_a9349b9ea771a0058a9cb4a57eedd624b"><td class="memTemplParams" colspan="2">template&lt;SphereConcept SphereType, Box3Concept BoxType&gt; </td></tr>
<tr class="memitem:a9349b9ea771a0058a9cb4a57eedd624b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a9349b9ea771a0058a9cb4a57eedd624b">sphereBoxIntersect</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="classvcl_1_1Matrix.html">SphereType</a> &amp;s, <a class="el" href="classvcl_1_1Matrix.html">const</a> BoxType &amp;<a class="el" href="classvcl_1_1Matrix.html">box</a>)</td></tr>
<tr class="separator:a9349b9ea771a0058a9cb4a57eedd624b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae809f70498bbba6366c684a9649c3fcf" id="r_ae809f70498bbba6366c684a9649c3fcf"><td class="memTemplParams" colspan="2">template&lt;ConstTriangle2Concept TriangleType, Point2Concept PointType&gt; </td></tr>
<tr class="memitem:ae809f70498bbba6366c684a9649c3fcf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ae809f70498bbba6366c684a9649c3fcf">trianglePointIntersect</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="classvcl_1_1Matrix.html">TriangleType</a> &amp;<a class="el" href="classvcl_1_1Matrix.html">t</a>, <a class="el" href="classvcl_1_1Matrix.html">const</a> PointType &amp;<a class="el" href="classvcl_1_1Matrix.html">p</a>)</td></tr>
<tr class="memdesc:ae809f70498bbba6366c684a9649c3fcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a 3D point intersects/is inside a 3D triangle having its points in counterclockwise order.  <br /></td></tr>
<tr class="separator:ae809f70498bbba6366c684a9649c3fcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b3c4b3e9c618082e4fbd063afafccb4" id="r_a9b3c4b3e9c618082e4fbd063afafccb4"><td class="memTemplParams" colspan="2">template&lt;ConstTriangle3Concept TriangleType, Box3Concept BoxType&gt; </td></tr>
<tr class="memitem:a9b3c4b3e9c618082e4fbd063afafccb4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a9b3c4b3e9c618082e4fbd063afafccb4">triangleBoxIntersect</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="classvcl_1_1Matrix.html">TriangleType</a> &amp;<a class="el" href="classvcl_1_1Matrix.html">t</a>, <a class="el" href="classvcl_1_1Matrix.html">const</a> BoxType &amp;<a class="el" href="classvcl_1_1Matrix.html">box</a>)</td></tr>
<tr class="memdesc:a9b3c4b3e9c618082e4fbd063afafccb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a triangle intersects with a box. <a href="https://gist.github.com/jflipts/fc68d4eeacfcc04fbdb2bf38e0911850">https://gist.github.com/jflipts/fc68d4eeacfcc04fbdb2bf38e0911850</a>.  <br /></td></tr>
<tr class="separator:a9b3c4b3e9c618082e4fbd063afafccb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10776247e8f8601139d42d7000b86cb3" id="r_a10776247e8f8601139d42d7000b86cb3"><td class="memTemplParams" colspan="2">template&lt;ConstTriangle3Concept TriangleType, SphereConcept SphereType, Point3Concept PointType, <a class="el" href="classvcl_1_1Matrix.html">typename</a> ScalarType &gt; </td></tr>
<tr class="memitem:a10776247e8f8601139d42d7000b86cb3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a10776247e8f8601139d42d7000b86cb3">triangleSphereIntersect</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="classvcl_1_1Matrix.html">TriangleType</a> &amp;<a class="el" href="classvcl_1_1Matrix.html">t</a>, <a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="classvcl_1_1Matrix.html">SphereType</a> &amp;<a class="el" href="classvcl_1_1Matrix.html">sphere</a>, PointType &amp;<a class="el" href="classvcl_1_1Matrix.html">witness</a>, std::pair&lt; ScalarType, ScalarType &gt; &amp;<a class="el" href="classvcl_1_1Matrix.html">res</a>)</td></tr>
<tr class="memdesc:a10776247e8f8601139d42d7000b86cb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the intersection between a sphere and a triangle.  <br /></td></tr>
<tr class="separator:a10776247e8f8601139d42d7000b86cb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30d36d085ff633eeb80dd0397fd620bc" id="r_a30d36d085ff633eeb80dd0397fd620bc"><td class="memTemplParams" colspan="2">template&lt;ConstTriangle3Concept TriangleType, SphereConcept SphereType&gt; </td></tr>
<tr class="memitem:a30d36d085ff633eeb80dd0397fd620bc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a30d36d085ff633eeb80dd0397fd620bc">triangleSphereIntersect</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="classvcl_1_1Matrix.html">TriangleType</a> &amp;<a class="el" href="classvcl_1_1Matrix.html">t</a>, <a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="classvcl_1_1Matrix.html">SphereType</a> &amp;<a class="el" href="classvcl_1_1Matrix.html">sphere</a>)</td></tr>
<tr class="memdesc:a30d36d085ff633eeb80dd0397fd620bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the intersection between a sphere and a triangle.  <br /></td></tr>
<tr class="separator:a30d36d085ff633eeb80dd0397fd620bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4dbcbe1f5e5f94f45c7830d6e08ade9" id="r_ac4dbcbe1f5e5f94f45c7830d6e08ade9"><td class="memTemplParams" colspan="2">template&lt;Polygon2Concept PolygonType&gt; </td></tr>
<tr class="memitem:ac4dbcbe1f5e5f94f45c7830d6e08ade9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">PolygonType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ac4dbcbe1f5e5f94f45c7830d6e08ade9">createCircle</a> (<a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a> <a class="el" href="classvcl_1_1Matrix.html">n</a>, <a class="el" href="classvcl_1_1Matrix.html">typename</a> PolygonType::ScalarType radius=1.0)</td></tr>
<tr class="memdesc:ac4dbcbe1f5e5f94f45c7830d6e08ade9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a 2D circle polygon with n vertices and the given radius.  <br /></td></tr>
<tr class="separator:ac4dbcbe1f5e5f94f45c7830d6e08ade9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a350d3edc324e0bef955a2c2ef8e20859" id="r_a350d3edc324e0bef955a2c2ef8e20859"><td class="memTemplParams" colspan="2">template&lt;FaceConcept FaceType&gt; </td></tr>
<tr class="memitem:a350d3edc324e0bef955a2c2ef8e20859"><td class="memTemplItemLeft" align="right" valign="top">FaceType::VertexType::CoordType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a350d3edc324e0bef955a2c2ef8e20859">faceNormal</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> FaceType &amp;f)</td></tr>
<tr class="memdesc:a350d3edc324e0bef955a2c2ef8e20859"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the normal of a face, without modifying the face. Works both for triangle and polygonal faces, and it is optimized in case of triangle faces.  <br /></td></tr>
<tr class="separator:a350d3edc324e0bef955a2c2ef8e20859"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53b4f63db0979e578ebfa4b9e8b41f8a" id="r_a53b4f63db0979e578ebfa4b9e8b41f8a"><td class="memTemplParams" colspan="2">template&lt;FaceConcept FaceType&gt; </td></tr>
<tr class="memitem:a53b4f63db0979e578ebfa4b9e8b41f8a"><td class="memTemplItemLeft" align="right" valign="top">FaceType::VertexType::CoordType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a53b4f63db0979e578ebfa4b9e8b41f8a">faceBarycenter</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> FaceType &amp;f)</td></tr>
<tr class="memdesc:a53b4f63db0979e578ebfa4b9e8b41f8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the barycenter of a face. Works both for triangle and polygonal faces, and it is optimized in case of triangle faces.  <br /></td></tr>
<tr class="separator:a53b4f63db0979e578ebfa4b9e8b41f8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fc3b9cae851d7a729f40dc2f4ebe824" id="r_a9fc3b9cae851d7a729f40dc2f4ebe824"><td class="memTemplParams" colspan="2">template&lt;FaceConcept FaceType&gt; </td></tr>
<tr class="memitem:a9fc3b9cae851d7a729f40dc2f4ebe824"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a9fc3b9cae851d7a729f40dc2f4ebe824">faceArea</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> FaceType &amp;f)</td></tr>
<tr class="memdesc:a9fc3b9cae851d7a729f40dc2f4ebe824"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the area of a face. Works both for triangle and polygonal faces, and it is optimized in case of triangle faces.  <br /></td></tr>
<tr class="separator:a9fc3b9cae851d7a729f40dc2f4ebe824"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dccfede16e36e5ded5213fb13643943" id="r_a1dccfede16e36e5ded5213fb13643943"><td class="memTemplParams" colspan="2">template&lt;FaceConcept FaceType&gt; </td></tr>
<tr class="memitem:a1dccfede16e36e5ded5213fb13643943"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a1dccfede16e36e5ded5213fb13643943">facePerimeter</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> FaceType &amp;f)</td></tr>
<tr class="memdesc:a1dccfede16e36e5ded5213fb13643943"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the perimeter of a face. Works both for triangle and polygonal faces, and it is optimized in case of triangle faces.  <br /></td></tr>
<tr class="separator:a1dccfede16e36e5ded5213fb13643943"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12529598a32a7b21eac27744b3578600" id="r_a12529598a32a7b21eac27744b3578600"><td class="memTemplParams" colspan="2">template&lt;FaceConcept FaceType&gt; </td></tr>
<tr class="memitem:a12529598a32a7b21eac27744b3578600"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a12529598a32a7b21eac27744b3578600">faceAngleOnVertexRad</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> FaceType &amp;f, <a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a> <a class="el" href="classvcl_1_1Matrix.html">vi</a>)</td></tr>
<tr class="memdesc:a12529598a32a7b21eac27744b3578600"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the internal angle (in radians) of the vi-th vertex of the face.  <br /></td></tr>
<tr class="separator:a12529598a32a7b21eac27744b3578600"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3983ab4b434d669a765240b81daa236e" id="r_a3983ab4b434d669a765240b81daa236e"><td class="memTemplParams" colspan="2">template&lt;FaceConcept Face&gt; </td></tr>
<tr class="memitem:a3983ab4b434d669a765240b81daa236e"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a3983ab4b434d669a765240b81daa236e">earCut</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="classvcl_1_1Face.html">Face</a> &amp;polygon)</td></tr>
<tr class="memdesc:a3983ab4b434d669a765240b81daa236e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the earcut algorithm of a 3D <em>planar</em> polygon, that returns a triangulation of the polygon.  <br /></td></tr>
<tr class="separator:a3983ab4b434d669a765240b81daa236e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9fd633374c0d8ab86df9e354a9a0fb5" id="r_af9fd633374c0d8ab86df9e354a9a0fb5"><td class="memTemplParams" colspan="2">template&lt;Point3Concept PointType&gt; </td></tr>
<tr class="memitem:af9fd633374c0d8ab86df9e354a9a0fb5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#af9fd633374c0d8ab86df9e354a9a0fb5">covarianceMatrixOfPointCloud</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> std::vector&lt; PointType &gt; &amp;<a class="el" href="classvcl_1_1Matrix.html">pointVec</a>)</td></tr>
<tr class="memdesc:af9fd633374c0d8ab86df9e354a9a0fb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the covariance matrix of a set of points.  <br /></td></tr>
<tr class="separator:af9fd633374c0d8ab86df9e354a9a0fb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe0d3154bb94af5fb7d34bd186eba0b3" id="r_abe0d3154bb94af5fb7d34bd186eba0b3"><td class="memTemplParams" colspan="2">template&lt;Point3Concept PointType&gt; </td></tr>
<tr class="memitem:abe0d3154bb94af5fb7d34bd186eba0b3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#abe0d3154bb94af5fb7d34bd186eba0b3">weightedCovarianceMatrixOfPointCloud</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> std::vector&lt; PointType &gt; &amp;<a class="el" href="classvcl_1_1Matrix.html">pointVec</a>, <a class="el" href="classvcl_1_1Matrix.html">const</a> std::vector&lt; <a class="el" href="classvcl_1_1Matrix.html">typename</a> PointType::ScalarType &gt; &amp;<a class="el" href="classvcl_1_1Matrix.html">weights</a>)</td></tr>
<tr class="memdesc:abe0d3154bb94af5fb7d34bd186eba0b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the weighted covariance matrix of a set of points.  <br /></td></tr>
<tr class="separator:abe0d3154bb94af5fb7d34bd186eba0b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3701f183f5eab726b026aebed8237d7e" id="r_a3701f183f5eab726b026aebed8237d7e"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a3701f183f5eab726b026aebed8237d7e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a3701f183f5eab726b026aebed8237d7e">checkMeshPointers</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;mesh)</td></tr>
<tr class="separator:a3701f183f5eab726b026aebed8237d7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed545a1f18ff8b6c2ee273c0d44c9b9f" id="r_gaed545a1f18ff8b6c2ee273c0d44c9b9f"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:gaed545a1f18ff8b6c2ee273c0d44c9b9f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__clean.html#gaed545a1f18ff8b6c2ee273c0d44c9b9f">numberUnreferencedVertices</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>)</td></tr>
<tr class="memdesc:gaed545a1f18ff8b6c2ee273c0d44c9b9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of non-deleted unreferenced vertices of the mesh.  <br /></td></tr>
<tr class="separator:gaed545a1f18ff8b6c2ee273c0d44c9b9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25c5d478a258364fa7a8215e7ffbb7d2" id="r_ga25c5d478a258364fa7a8215e7ffbb7d2"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga25c5d478a258364fa7a8215e7ffbb7d2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__clean.html#ga25c5d478a258364fa7a8215e7ffbb7d2">removeUnreferencedVertices</a> (MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>)</td></tr>
<tr class="memdesc:ga25c5d478a258364fa7a8215e7ffbb7d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marks as deleted all the non-deleted unreferenced vertices of the mesh.  <br /></td></tr>
<tr class="separator:ga25c5d478a258364fa7a8215e7ffbb7d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabce801a437aa06438837271fde16cb5a" id="r_gabce801a437aa06438837271fde16cb5a"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:gabce801a437aa06438837271fde16cb5a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__clean.html#gabce801a437aa06438837271fde16cb5a">removeDuplicatedVertices</a> (MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>)</td></tr>
<tr class="memdesc:gabce801a437aa06438837271fde16cb5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marks as deleted the duplicate vertices of the mesh, by looking only at their spatial positions.  <br /></td></tr>
<tr class="separator:gabce801a437aa06438837271fde16cb5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e771a075c5db04274b407af212d2c2b" id="r_ga6e771a075c5db04274b407af212d2c2b"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga6e771a075c5db04274b407af212d2c2b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__clean.html#ga6e771a075c5db04274b407af212d2c2b">removeDuplicatedFaces</a> (MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>)</td></tr>
<tr class="memdesc:ga6e771a075c5db04274b407af212d2c2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all duplicate faces of the mesh by looking only at their vertex references.  <br /></td></tr>
<tr class="separator:ga6e771a075c5db04274b407af212d2c2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga351485ba1c87c7bd1193917323921ba7" id="r_ga351485ba1c87c7bd1193917323921ba7"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga351485ba1c87c7bd1193917323921ba7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__clean.html#ga351485ba1c87c7bd1193917323921ba7">removeDegeneratedVertices</a> (MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>, <a class="el" href="classvcl_1_1Matrix.html">bool</a> <a class="el" href="classvcl_1_1Matrix.html">deleteAlsoFaces</a>)</td></tr>
<tr class="memdesc:ga351485ba1c87c7bd1193917323921ba7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all vertices that have coordinates with invalid floating point values (NaN or inf).  <br /></td></tr>
<tr class="separator:ga351485ba1c87c7bd1193917323921ba7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3561ea390b2dfc6fec49d12543ea60e7" id="r_ga3561ea390b2dfc6fec49d12543ea60e7"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga3561ea390b2dfc6fec49d12543ea60e7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__clean.html#ga3561ea390b2dfc6fec49d12543ea60e7">removeDegenerateFaces</a> (MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>)</td></tr>
<tr class="memdesc:ga3561ea390b2dfc6fec49d12543ea60e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all degenerate faces from the input mesh.  <br /></td></tr>
<tr class="separator:ga3561ea390b2dfc6fec49d12543ea60e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd1e4943610b0e15397196d5fc73b0da" id="r_gabd1e4943610b0e15397196d5fc73b0da"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:gabd1e4943610b0e15397196d5fc73b0da"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__clean.html#gabd1e4943610b0e15397196d5fc73b0da">numberNonManifoldVertices</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>)</td></tr>
<tr class="memdesc:gabd1e4943610b0e15397196d5fc73b0da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counts the number of non-manifold vertices in the input mesh.  <br /></td></tr>
<tr class="separator:gabd1e4943610b0e15397196d5fc73b0da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae4c34d80af91ce6339f86c6de2c702cd" id="r_gae4c34d80af91ce6339f86c6de2c702cd"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:gae4c34d80af91ce6339f86c6de2c702cd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__clean.html#gae4c34d80af91ce6339f86c6de2c702cd">isWaterTight</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>)</td></tr>
<tr class="memdesc:gae4c34d80af91ce6339f86c6de2c702cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the input mesh is water tight.  <br /></td></tr>
<tr class="separator:gae4c34d80af91ce6339f86c6de2c702cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c6de124adcaf9fb747b9c490667f093" id="r_ga4c6de124adcaf9fb747b9c490667f093"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; <br />
requires <a class="el" href="conceptvcl_1_1HasPerFaceAdjacentFaces.html">vcl::HasPerFaceAdjacentFaces</a>&lt;MeshType&gt;</td></tr>
<tr class="memitem:ga4c6de124adcaf9fb747b9c490667f093"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__clean.html#ga4c6de124adcaf9fb747b9c490667f093">numberHoles</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>)</td></tr>
<tr class="memdesc:ga4c6de124adcaf9fb747b9c490667f093"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counts the number of holes in the input mesh.  <br /></td></tr>
<tr class="separator:ga4c6de124adcaf9fb747b9c490667f093"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga774f9a47e9cef107d59b97d0434177f7" id="r_ga774f9a47e9cef107d59b97d0434177f7"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; <br />
requires <a class="el" href="conceptvcl_1_1HasPerFaceAdjacentFaces.html">vcl::HasPerFaceAdjacentFaces</a>&lt;MeshType&gt;</td></tr>
<tr class="memitem:ga774f9a47e9cef107d59b97d0434177f7"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::set&lt; <a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__clean.html#ga774f9a47e9cef107d59b97d0434177f7">connectedComponents</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>)</td></tr>
<tr class="memdesc:ga774f9a47e9cef107d59b97d0434177f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the connected components of the input mesh based on its topology.  <br /></td></tr>
<tr class="separator:ga774f9a47e9cef107d59b97d0434177f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf8a059b21f1238f6e531191f40685670" id="r_gaf8a059b21f1238f6e531191f40685670"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:gaf8a059b21f1238f6e531191f40685670"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__clean.html#gaf8a059b21f1238f6e531191f40685670">numberConnectedComponents</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>)</td></tr>
<tr class="memdesc:gaf8a059b21f1238f6e531191f40685670"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the number of connected components of the input mesh based on its topology.  <br /></td></tr>
<tr class="separator:gaf8a059b21f1238f6e531191f40685670"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dace96b8290fefb07363487ec841514" id="r_a6dace96b8290fefb07363487ec841514"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a6dace96b8290fefb07363487ec841514"><td class="memTemplItemLeft" align="right" valign="top">MeshType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a6dace96b8290fefb07363487ec841514">createCone</a> (<a class="el" href="classvcl_1_1Matrix.html">auto</a> <a class="el" href="classvcl_1_1Matrix.html">radiusBottom</a>, <a class="el" href="classvcl_1_1Matrix.html">auto</a> <a class="el" href="classvcl_1_1Matrix.html">radiusTop</a>, <a class="el" href="classvcl_1_1Matrix.html">auto</a> height, <a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a> <a class="el" href="classvcl_1_1Matrix.html">subdivisions</a>=36)</td></tr>
<tr class="separator:a6dace96b8290fefb07363487ec841514"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a712bfd97ace55544f86b53c6cce60a71" id="r_a712bfd97ace55544f86b53c6cce60a71"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a712bfd97ace55544f86b53c6cce60a71"><td class="memTemplItemLeft" align="right" valign="top">MeshType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a712bfd97ace55544f86b53c6cce60a71">createCylinder</a> (<a class="el" href="classvcl_1_1Matrix.html">auto</a> radius, <a class="el" href="classvcl_1_1Matrix.html">auto</a> height, <a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a> <a class="el" href="classvcl_1_1Matrix.html">subdivisions</a>=36)</td></tr>
<tr class="separator:a712bfd97ace55544f86b53c6cce60a71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed05ee87778462738625d7c0f6ac38e6" id="r_gaed05ee87778462738625d7c0f6ac38e6"><td class="memTemplParams" colspan="2">template&lt;PolygonMeshConcept MeshType, LoggerConcept LogType = NullLogger&gt; </td></tr>
<tr class="memitem:gaed05ee87778462738625d7c0f6ac38e6"><td class="memTemplItemLeft" align="right" valign="top">MeshType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__create.html#gaed05ee87778462738625d7c0f6ac38e6">createDodecahedron</a> (<a class="el" href="classvcl_1_1Matrix.html">LogType</a> &amp;log=<a class="el" href="group__miscellaneous.html#ga3377e3c875ec245e90ac5a395105ce99">nullLogger</a>)</td></tr>
<tr class="memdesc:gaed05ee87778462738625d7c0f6ac38e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates and returns a <a class="el" href="classvcl_1_1Polygon.html">Polygon</a> <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a> containing a Dodecahedron.  <br /></td></tr>
<tr class="separator:gaed05ee87778462738625d7c0f6ac38e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad27918bc874e941633aeeb83c09ef8bc" id="r_gad27918bc874e941633aeeb83c09ef8bc"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:gad27918bc874e941633aeeb83c09ef8bc"><td class="memTemplItemLeft" align="right" valign="top">MeshType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__create.html#gad27918bc874e941633aeeb83c09ef8bc">createHexahedron</a> ()</td></tr>
<tr class="memdesc:gad27918bc874e941633aeeb83c09ef8bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates and returns a hexahedron having as extremes the points <code>(-1, -1, -1)</code> and <code>(1, 1, 1)</code>.  <br /></td></tr>
<tr class="separator:gad27918bc874e941633aeeb83c09ef8bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga99aea140f795216e3bad1e4086ea3fe5" id="r_ga99aea140f795216e3bad1e4086ea3fe5"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType, Point3Concept CoordType&gt; </td></tr>
<tr class="memitem:ga99aea140f795216e3bad1e4086ea3fe5"><td class="memTemplItemLeft" align="right" valign="top">MeshType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__create.html#ga99aea140f795216e3bad1e4086ea3fe5">createHexahedron</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> CoordType &amp;<a class="el" href="namespacevcl.html#a3edcb561672a6be17e9453bd1ea446d5">min</a>, <a class="el" href="classvcl_1_1Matrix.html">const</a> CoordType &amp;<a class="el" href="namespacevcl.html#a69cc63a5ad2974d082145ed1dee7846b">max</a>)</td></tr>
<tr class="memdesc:ga99aea140f795216e3bad1e4086ea3fe5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates and returns a Hexahedron having as extremes points min and max given as arguments.  <br /></td></tr>
<tr class="separator:ga99aea140f795216e3bad1e4086ea3fe5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7383cbe54f93fa408ebd2f3e6f66ae21" id="r_ga7383cbe54f93fa408ebd2f3e6f66ae21"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType, Point3Concept CoordType&gt; </td></tr>
<tr class="memitem:ga7383cbe54f93fa408ebd2f3e6f66ae21"><td class="memTemplItemLeft" align="right" valign="top">MeshType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__create.html#ga7383cbe54f93fa408ebd2f3e6f66ae21">createCube</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> CoordType &amp;<a class="el" href="namespacevcl.html#a3edcb561672a6be17e9453bd1ea446d5">min</a>, <a class="el" href="classvcl_1_1Matrix.html">double</a> <a class="el" href="classvcl_1_1Matrix.html">edgeLength</a>)</td></tr>
<tr class="memdesc:ga7383cbe54f93fa408ebd2f3e6f66ae21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates and returns a Cube having <code>min</code> as minimum extreme and the given edge length.  <br /></td></tr>
<tr class="separator:ga7383cbe54f93fa408ebd2f3e6f66ae21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6fb4ccc7456d5cfc0b4dfa61775d43fd" id="r_ga6fb4ccc7456d5cfc0b4dfa61775d43fd"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga6fb4ccc7456d5cfc0b4dfa61775d43fd"><td class="memTemplItemLeft" align="right" valign="top">MeshType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__create.html#ga6fb4ccc7456d5cfc0b4dfa61775d43fd">createCube</a> ()</td></tr>
<tr class="memdesc:ga6fb4ccc7456d5cfc0b4dfa61775d43fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates and returns a Cube having <code>(-0.5, -0.5, -0.5)</code> as minimum extreme and 1 length.  <br /></td></tr>
<tr class="separator:ga6fb4ccc7456d5cfc0b4dfa61775d43fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6cf9b8ea5cd197d17f2a1bcf68c89050" id="r_ga6cf9b8ea5cd197d17f2a1bcf68c89050"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga6cf9b8ea5cd197d17f2a1bcf68c89050"><td class="memTemplItemLeft" align="right" valign="top">MeshType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__create.html#ga6cf9b8ea5cd197d17f2a1bcf68c89050">createIcosahedron</a> (<a class="el" href="classvcl_1_1Matrix.html">bool</a> <a class="el" href="classvcl_1_1Matrix.html">normalizeVertices</a>=<a class="el" href="classvcl_1_1Matrix.html">false</a>)</td></tr>
<tr class="memdesc:ga6cf9b8ea5cd197d17f2a1bcf68c89050"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates and returns an icosahedron mesh.  <br /></td></tr>
<tr class="separator:ga6cf9b8ea5cd197d17f2a1bcf68c89050"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0701cdc9e67076fe0c2267193305af66" id="r_ga0701cdc9e67076fe0c2267193305af66"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga0701cdc9e67076fe0c2267193305af66"><td class="memTemplItemLeft" align="right" valign="top">MeshType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__create.html#ga0701cdc9e67076fe0c2267193305af66">createSphereUV</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> SphereConcept <a class="el" href="classvcl_1_1Matrix.html">auto</a> &amp;<a class="el" href="classvcl_1_1Matrix.html">sp</a>, <a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a> parallels=10, <a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a> meridians=20)</td></tr>
<tr class="memdesc:ga0701cdc9e67076fe0c2267193305af66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates and returns a sphere mesh using the UV mode, starting from a sphere object.  <br /></td></tr>
<tr class="separator:ga0701cdc9e67076fe0c2267193305af66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad6f54ee450c902f94c4185193d7bfed0" id="r_gad6f54ee450c902f94c4185193d7bfed0"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:gad6f54ee450c902f94c4185193d7bfed0"><td class="memTemplItemLeft" align="right" valign="top">MeshType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__create.html#gad6f54ee450c902f94c4185193d7bfed0">createSphereNormalizedCube</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> SphereConcept <a class="el" href="classvcl_1_1Matrix.html">auto</a> &amp;<a class="el" href="classvcl_1_1Matrix.html">sp</a>, <a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a> divisions)</td></tr>
<tr class="memdesc:gad6f54ee450c902f94c4185193d7bfed0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates and returns a sphere mesh using the normalized cube mode, starting from a sphere object.  <br /></td></tr>
<tr class="separator:gad6f54ee450c902f94c4185193d7bfed0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga964925e1a22e75db7dea160f6ca9b9bd" id="r_ga964925e1a22e75db7dea160f6ca9b9bd"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga964925e1a22e75db7dea160f6ca9b9bd"><td class="memTemplItemLeft" align="right" valign="top">MeshType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__create.html#ga964925e1a22e75db7dea160f6ca9b9bd">createSphereSpherifiedCube</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> SphereConcept <a class="el" href="classvcl_1_1Matrix.html">auto</a> &amp;<a class="el" href="classvcl_1_1Matrix.html">sp</a>, <a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a> divisions)</td></tr>
<tr class="memdesc:ga964925e1a22e75db7dea160f6ca9b9bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates and returns a sphere mesh using the spherified cube mode, starting from a sphere object.  <br /></td></tr>
<tr class="separator:ga964925e1a22e75db7dea160f6ca9b9bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4fa15f02159bbc4db0b84ffa8978b154" id="r_ga4fa15f02159bbc4db0b84ffa8978b154"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga4fa15f02159bbc4db0b84ffa8978b154"><td class="memTemplItemLeft" align="right" valign="top">MeshType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__create.html#ga4fa15f02159bbc4db0b84ffa8978b154">createSphereIcosahedron</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> SphereConcept <a class="el" href="classvcl_1_1Matrix.html">auto</a> &amp;<a class="el" href="classvcl_1_1Matrix.html">sp</a>, <a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a> divisions)</td></tr>
<tr class="memdesc:ga4fa15f02159bbc4db0b84ffa8978b154"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates and returns a sphere mesh using the icosahedron mode, starting from a sphere object.  <br /></td></tr>
<tr class="separator:ga4fa15f02159bbc4db0b84ffa8978b154"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabff9f22d5dbda0bd9f591e893b80b4ce" id="r_gabff9f22d5dbda0bd9f591e893b80b4ce"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:gabff9f22d5dbda0bd9f591e893b80b4ce"><td class="memTemplItemLeft" align="right" valign="top">MeshType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__create.html#gabff9f22d5dbda0bd9f591e893b80b4ce">createSphere</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> SphereConcept <a class="el" href="classvcl_1_1Matrix.html">auto</a> &amp;<a class="el" href="classvcl_1_1Matrix.html">sp</a>, <a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="structvcl_1_1CreateSphereArgs.html">CreateSphereArgs</a> &amp;<a class="el" href="classvcl_1_1Matrix.html">args</a>=<a class="el" href="structvcl_1_1CreateSphereArgs.html">CreateSphereArgs</a>())</td></tr>
<tr class="memdesc:gabff9f22d5dbda0bd9f591e893b80b4ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="classvcl_1_1Sphere.html">Sphere</a> <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a> starting from a sphere object, using the generation method given in the argument <code>args.mode</code> (see <a href="https://github.com/caosdoar/spheres">https://github.com/caosdoar/spheres</a> for more details).  <br /></td></tr>
<tr class="separator:gabff9f22d5dbda0bd9f591e893b80b4ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga455a7abda2f207c424dd5946c30c48c6" id="r_ga455a7abda2f207c424dd5946c30c48c6"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga455a7abda2f207c424dd5946c30c48c6"><td class="memTemplItemLeft" align="right" valign="top">MeshType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__create.html#ga455a7abda2f207c424dd5946c30c48c6">createSphere</a> ()</td></tr>
<tr class="memdesc:ga455a7abda2f207c424dd5946c30c48c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="classvcl_1_1Sphere.html">Sphere</a> <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a> using the UV mode (<a href="https://github.com/caosdoar/spheres">https://github.com/caosdoar/spheres</a>), centered in (0, 0, 0), having radius 1, with 10 parallels and 20 meridias.  <br /></td></tr>
<tr class="separator:ga455a7abda2f207c424dd5946c30c48c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d38a6ecac2b2ab64dd11d53d78e98ca" id="r_ga3d38a6ecac2b2ab64dd11d53d78e98ca"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga3d38a6ecac2b2ab64dd11d53d78e98ca"><td class="memTemplItemLeft" align="right" valign="top">MeshType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__create.html#ga3d38a6ecac2b2ab64dd11d53d78e98ca">createTetrahedron</a> ()</td></tr>
<tr class="memdesc:ga3d38a6ecac2b2ab64dd11d53d78e98ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a simple tetrahedron mesh with the following point coordinates:  <br /></td></tr>
<tr class="separator:ga3d38a6ecac2b2ab64dd11d53d78e98ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c70a856983dfae4697e3521825dce90" id="r_ga7c70a856983dfae4697e3521825dce90"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType, Point3Concept CoordType&gt; </td></tr>
<tr class="memitem:ga7c70a856983dfae4697e3521825dce90"><td class="memTemplItemLeft" align="right" valign="top">MeshType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__create.html#ga7c70a856983dfae4697e3521825dce90">createTetrahedron</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> CoordType &amp;p0, <a class="el" href="classvcl_1_1Matrix.html">const</a> CoordType &amp;p1, <a class="el" href="classvcl_1_1Matrix.html">const</a> CoordType &amp;<a class="el" href="classvcl_1_1Matrix.html">p2</a>, <a class="el" href="classvcl_1_1Matrix.html">const</a> CoordType &amp;<a class="el" href="classvcl_1_1Matrix.html">p3</a>)</td></tr>
<tr class="memdesc:ga7c70a856983dfae4697e3521825dce90"><td class="mdescLeft">&#160;</td><td class="mdescRight">createTetrahedron createTetrahedron creates a simple tetrahedron mesh with the given points. The function assumes that the points p0, p1 and p2 are in counterclockwise order, and does not perform any sanity check about the validity of the points.  <br /></td></tr>
<tr class="separator:ga7c70a856983dfae4697e3521825dce90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9082710ebf39cdd11a256086220d007a" id="r_a9082710ebf39cdd11a256086220d007a"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType1, MeshConcept MeshType2, LoggerConcept LogType = NullLogger&gt; </td></tr>
<tr class="memitem:a9082710ebf39cdd11a256086220d007a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structvcl_1_1HausdorffDistResult.html">HausdorffDistResult</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a9082710ebf39cdd11a256086220d007a">hausdorffDistance</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="classvcl_1_1Matrix.html">MeshType1</a> &amp;<a class="el" href="classvcl_1_1Matrix.html">m1</a>, <a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="classvcl_1_1Matrix.html">MeshType2</a> &amp;<a class="el" href="classvcl_1_1Matrix.html">m2</a>, <a class="el" href="classvcl_1_1Matrix.html">LogType</a> &amp;log=<a class="el" href="group__miscellaneous.html#ga3377e3c875ec245e90ac5a395105ce99">nullLogger</a>, <a class="el" href="namespacevcl.html#a5a4e8376b2d47797f9167f2a8dd6fb0e">HausdorffSamplingMethod</a> <a class="el" href="classvcl_1_1Matrix.html">sampMethod</a>=<a class="el" href="namespacevcl.html#a5a4e8376b2d47797f9167f2a8dd6fb0ea33aad0431cadce18cad82201cb732f49">HAUSDORFF_VERTEX_UNIFORM</a>, <a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a> <a class="el" href="classvcl_1_1Matrix.html">nSamples</a>=0, <a class="el" href="classvcl_1_1Matrix.html">bool</a> <a class="el" href="classvcl_1_1Matrix.html">deterministic</a>=<a class="el" href="classvcl_1_1Matrix.html">false</a>)</td></tr>
<tr class="separator:a9082710ebf39cdd11a256086220d007a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25a86f4bcf104c60099849828d71e06f" id="r_a25a86f4bcf104c60099849828d71e06f"><td class="memTemplParams" colspan="2">template&lt;FaceConcept FaceType&gt; <br />
requires comp::HasAdjacentFaces&lt;FaceType&gt;</td></tr>
<tr class="memitem:a25a86f4bcf104c60099849828d71e06f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a25a86f4bcf104c60099849828d71e06f">isFaceManifoldOnEdge</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> FaceType &amp;f, <a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a> edge)</td></tr>
<tr class="memdesc:a25a86f4bcf104c60099849828d71e06f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if an edge in the given face is manifold.  <br /></td></tr>
<tr class="separator:a25a86f4bcf104c60099849828d71e06f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af888cb13421f6fb92d776927f302518b" id="r_af888cb13421f6fb92d776927f302518b"><td class="memTemplParams" colspan="2">template&lt;FaceConcept FaceType&gt; <br />
requires comp::HasAdjacentFaces&lt;FaceType&gt;</td></tr>
<tr class="memitem:af888cb13421f6fb92d776927f302518b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#af888cb13421f6fb92d776927f302518b">isFaceEdgeOnBorder</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> FaceType &amp;f, <a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a> edge)</td></tr>
<tr class="memdesc:af888cb13421f6fb92d776927f302518b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if an edge in the given face is on the border.  <br /></td></tr>
<tr class="separator:af888cb13421f6fb92d776927f302518b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47188a6c411a5a4fbd8542d5ce1525aa" id="r_a47188a6c411a5a4fbd8542d5ce1525aa"><td class="memTemplParams" colspan="2">template&lt;FaceConcept FaceType&gt; <br />
requires comp::HasAdjacentFaces&lt;FaceType&gt;</td></tr>
<tr class="memitem:a47188a6c411a5a4fbd8542d5ce1525aa"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a47188a6c411a5a4fbd8542d5ce1525aa">checkFlipEdge</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> FaceType &amp;f, <a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a> edge)</td></tr>
<tr class="memdesc:a47188a6c411a5a4fbd8542d5ce1525aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a boolean value indicating whether the edge flip operation is allowed or not.  <br /></td></tr>
<tr class="separator:a47188a6c411a5a4fbd8542d5ce1525aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77bd6f212cc6ca4ad37ce181c2ba6d1b" id="r_a77bd6f212cc6ca4ad37ce181c2ba6d1b"><td class="memTemplParams" colspan="2">template&lt;FaceConcept FaceType&gt; <br />
requires comp::HasAdjacentFaces&lt;FaceType&gt;</td></tr>
<tr class="memitem:a77bd6f212cc6ca4ad37ce181c2ba6d1b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a77bd6f212cc6ca4ad37ce181c2ba6d1b">edgeAdjacentFacesNumber</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> FaceType &amp;f, <a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a> edge)</td></tr>
<tr class="memdesc:a77bd6f212cc6ca4ad37ce181c2ba6d1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of adjacent faces to the given edge of the face f.  <br /></td></tr>
<tr class="separator:a77bd6f212cc6ca4ad37ce181c2ba6d1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a711865422c63688724ec6328b4e7c4cd" id="r_a711865422c63688724ec6328b4e7c4cd"><td class="memTemplParams" colspan="2">template&lt;FaceConcept FaceType&gt; <br />
requires comp::HasAdjacentFaces&lt;FaceType&gt;</td></tr>
<tr class="memitem:a711865422c63688724ec6328b4e7c4cd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a711865422c63688724ec6328b4e7c4cd">faceEdgesOnBorderNumber</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> FaceType &amp;f)</td></tr>
<tr class="memdesc:a711865422c63688724ec6328b4e7c4cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of edges that are on border (no adjacent faces) on the given face.  <br /></td></tr>
<tr class="separator:a711865422c63688724ec6328b4e7c4cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2177afd92cfc4dbe6468aa05892b016f" id="r_a2177afd92cfc4dbe6468aa05892b016f"><td class="memTemplParams" colspan="2">template&lt;FaceConcept FaceType&gt; <br />
requires comp::HasAdjacentFaces&lt;FaceType&gt;</td></tr>
<tr class="memitem:a2177afd92cfc4dbe6468aa05892b016f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a2177afd92cfc4dbe6468aa05892b016f">faceDihedralAngleOnEdge</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> FaceType &amp;f, <a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a> e)</td></tr>
<tr class="memdesc:a2177afd92cfc4dbe6468aa05892b016f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the signed dihedral angle between the normals of the given face and its adjacent face on the edge <code>e</code>.  <br /></td></tr>
<tr class="separator:a2177afd92cfc4dbe6468aa05892b016f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3109cc4c0e2128888f2a3fa6ae27a98f" id="r_a3109cc4c0e2128888f2a3fa6ae27a98f"><td class="memTemplParams" colspan="2">template&lt;FaceConcept FaceType&gt; <br />
requires comp::HasAdjacentFaces&lt;FaceType&gt;</td></tr>
<tr class="memitem:a3109cc4c0e2128888f2a3fa6ae27a98f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a3109cc4c0e2128888f2a3fa6ae27a98f">detachAdjacentFacesOnEdge</a> (FaceType &amp;f, <a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a> edge)</td></tr>
<tr class="memdesc:a3109cc4c0e2128888f2a3fa6ae27a98f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detaches the face <code>f</code> on the given edge, which consists on updating adjacent faces such that any face that was linking the face <code>f</code> won't link it anymore. It manages also non-manifold edges.  <br /></td></tr>
<tr class="separator:a3109cc4c0e2128888f2a3fa6ae27a98f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af67d9147410404febe19163fb506397d" id="r_af67d9147410404febe19163fb506397d"><td class="memTemplParams" colspan="2">template&lt;FaceConcept FaceType&gt; <br />
requires comp::HasAdjacentFaces&lt;FaceType&gt;</td></tr>
<tr class="memitem:af67d9147410404febe19163fb506397d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#af67d9147410404febe19163fb506397d">detachFace</a> (FaceType &amp;f)</td></tr>
<tr class="memdesc:af67d9147410404febe19163fb506397d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detaches the given face from all its adjacent vertices and adjacent faces.  <br /></td></tr>
<tr class="separator:af67d9147410404febe19163fb506397d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff5df6a9918702220e5134fc3602a67f" id="r_aff5df6a9918702220e5134fc3602a67f"><td class="memTemplParams" colspan="2">template&lt;MeshConcept InMeshType, MeshConcept OutMeshType = InMeshType&gt; </td></tr>
<tr class="memitem:aff5df6a9918702220e5134fc3602a67f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">OutMeshType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#aff5df6a9918702220e5134fc3602a67f">perVertexMeshFilter</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="classvcl_1_1Matrix.html">InMeshType</a> &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>, <a class="el" href="classvcl_1_1Matrix.html">const</a> std::function&lt; <a class="el" href="classvcl_1_1Matrix.html">bool</a>(<a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="classvcl_1_1Matrix.html">typename</a> InMeshType::VertexType &amp;)&gt; &amp;<a class="el" href="classvcl_1_1Matrix.html">vertexFilter</a>, <a class="el" href="classvcl_1_1Matrix.html">bool</a> <a class="el" href="classvcl_1_1Matrix.html">saveBirthIndicesInCustomComponent</a>=<a class="el" href="classvcl_1_1Matrix.html">true</a>)</td></tr>
<tr class="memdesc:aff5df6a9918702220e5134fc3602a67f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates and returns a new mesh that is composed of the vertices of the input mesh <code>m</code> filtered using the <code>vertexFilter</code> function.  <br /></td></tr>
<tr class="separator:aff5df6a9918702220e5134fc3602a67f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d3830ce96c420a6f11c93650c709fa6" id="r_a8d3830ce96c420a6f11c93650c709fa6"><td class="memTemplParams" colspan="2">template&lt;MeshConcept InMeshType, MeshConcept OutMeshType = InMeshType&gt; </td></tr>
<tr class="memitem:a8d3830ce96c420a6f11c93650c709fa6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">OutMeshType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a8d3830ce96c420a6f11c93650c709fa6">perVertexMeshFilter</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="classvcl_1_1Matrix.html">InMeshType</a> &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>, Range <a class="el" href="classvcl_1_1Matrix.html">auto</a> &amp;&amp;<a class="el" href="classvcl_1_1Matrix.html">vertexFilterRng</a>, <a class="el" href="classvcl_1_1Matrix.html">bool</a> <a class="el" href="classvcl_1_1Matrix.html">saveBirthIndicesInCustomComponent</a>=<a class="el" href="classvcl_1_1Matrix.html">true</a>)</td></tr>
<tr class="memdesc:a8d3830ce96c420a6f11c93650c709fa6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates and returns a new mesh that is composed of the vertices of the input mesh <code>m</code> filtered using the <code>vertexFilterRng</code> range.  <br /></td></tr>
<tr class="separator:a8d3830ce96c420a6f11c93650c709fa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87898c7e54aece94b1ce1f2e0066a682" id="r_a87898c7e54aece94b1ce1f2e0066a682"><td class="memTemplParams" colspan="2">template&lt;MeshConcept InMeshType, MeshConcept OutMeshType = InMeshType&gt; </td></tr>
<tr class="memitem:a87898c7e54aece94b1ce1f2e0066a682"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">OutMeshType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a87898c7e54aece94b1ce1f2e0066a682">perVertexSelectionMeshFilter</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="classvcl_1_1Matrix.html">InMeshType</a> &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>, <a class="el" href="classvcl_1_1Matrix.html">bool</a> <a class="el" href="classvcl_1_1Matrix.html">saveBirthIndicesInCustomComponent</a>=<a class="el" href="classvcl_1_1Matrix.html">true</a>)</td></tr>
<tr class="memdesc:a87898c7e54aece94b1ce1f2e0066a682"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates and returns a new mesh that is composed of the selected vertices of the input mesh <code>m</code>.  <br /></td></tr>
<tr class="separator:a87898c7e54aece94b1ce1f2e0066a682"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a107e67416dfe237c0209483eb0a85312" id="r_a107e67416dfe237c0209483eb0a85312"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept InMeshType, FaceMeshConcept OutMeshType = InMeshType&gt; </td></tr>
<tr class="memitem:a107e67416dfe237c0209483eb0a85312"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">OutMeshType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a107e67416dfe237c0209483eb0a85312">perFaceMeshFilter</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="classvcl_1_1Matrix.html">InMeshType</a> &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>, <a class="el" href="classvcl_1_1Matrix.html">const</a> std::function&lt; <a class="el" href="classvcl_1_1Matrix.html">bool</a>(<a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="classvcl_1_1Matrix.html">typename</a> InMeshType::FaceType &amp;)&gt; &amp;<a class="el" href="classvcl_1_1Matrix.html">faceFilter</a>, <a class="el" href="classvcl_1_1Matrix.html">bool</a> <a class="el" href="classvcl_1_1Matrix.html">saveBirthIndicesInCustomComponent</a>=<a class="el" href="classvcl_1_1Matrix.html">true</a>)</td></tr>
<tr class="memdesc:a107e67416dfe237c0209483eb0a85312"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates and returns a new mesh that is composed of the faces of the input mesh <code>m</code> filtered using the <code>faceFilter</code> function. Only vertices belonging to the imported faces will be imported in the output mesh.  <br /></td></tr>
<tr class="separator:a107e67416dfe237c0209483eb0a85312"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace4273fd5df9842c19d335bcab94d287" id="r_ace4273fd5df9842c19d335bcab94d287"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept InMeshType, FaceMeshConcept OutMeshType = InMeshType&gt; </td></tr>
<tr class="memitem:ace4273fd5df9842c19d335bcab94d287"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">OutMeshType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ace4273fd5df9842c19d335bcab94d287">perFaceMeshFilter</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="classvcl_1_1Matrix.html">InMeshType</a> &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>, Range <a class="el" href="classvcl_1_1Matrix.html">auto</a> &amp;&amp;<a class="el" href="classvcl_1_1Matrix.html">faceFilterRng</a>, <a class="el" href="classvcl_1_1Matrix.html">bool</a> <a class="el" href="classvcl_1_1Matrix.html">saveBirthIndicesInCustomComponent</a>=<a class="el" href="classvcl_1_1Matrix.html">true</a>)</td></tr>
<tr class="memdesc:ace4273fd5df9842c19d335bcab94d287"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates and returns a new mesh that is composed of the faces of the input mesh <code>m</code> filtered using the <code>faceFilterRng</code> range. Only vertices belonging to the imported faces will be imported in the output mesh.  <br /></td></tr>
<tr class="separator:ace4273fd5df9842c19d335bcab94d287"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86df839f39f7541f73198a9e5c6e921f" id="r_a86df839f39f7541f73198a9e5c6e921f"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept InMeshType, FaceMeshConcept OutMeshType = InMeshType&gt; </td></tr>
<tr class="memitem:a86df839f39f7541f73198a9e5c6e921f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">OutMeshType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a86df839f39f7541f73198a9e5c6e921f">perFaceSelectionMeshFilter</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="classvcl_1_1Matrix.html">InMeshType</a> &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>, <a class="el" href="classvcl_1_1Matrix.html">bool</a> <a class="el" href="classvcl_1_1Matrix.html">saveBirthIndicesInCustomComponent</a>=<a class="el" href="classvcl_1_1Matrix.html">true</a>)</td></tr>
<tr class="memdesc:a86df839f39f7541f73198a9e5c6e921f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates and returns a new mesh that is composed of the selected faces of the input mesh <code>m</code>. Only vertices belonging to the imported faces will be imported in the output mesh.  <br /></td></tr>
<tr class="separator:a86df839f39f7541f73198a9e5c6e921f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1ac25199a4bfa15b8fe336c1c6486b2" id="r_ab1ac25199a4bfa15b8fe336c1c6486b2"><td class="memTemplParams" colspan="2">template&lt;EdgeMeshConcept InMeshType, EdgeMeshConcept OutMeshType = InMeshType&gt; </td></tr>
<tr class="memitem:ab1ac25199a4bfa15b8fe336c1c6486b2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">OutMeshType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ab1ac25199a4bfa15b8fe336c1c6486b2">perEdgeMeshFilter</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="classvcl_1_1Matrix.html">InMeshType</a> &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>, <a class="el" href="classvcl_1_1Matrix.html">const</a> std::function&lt; <a class="el" href="classvcl_1_1Matrix.html">bool</a>(<a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="classvcl_1_1Matrix.html">typename</a> InMeshType::EdgeType &amp;)&gt; &amp;<a class="el" href="classvcl_1_1Matrix.html">edgeFilter</a>, <a class="el" href="classvcl_1_1Matrix.html">bool</a> <a class="el" href="classvcl_1_1Matrix.html">saveBirthIndicesInCustomComponent</a>=<a class="el" href="classvcl_1_1Matrix.html">true</a>)</td></tr>
<tr class="memdesc:ab1ac25199a4bfa15b8fe336c1c6486b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates and returns a new mesh that is composed of the edges of the input mesh <code>m</code> filtered using the <code>edgeFilter</code> function. Only vertices belonging to the imported edges will be imported in the output mesh.  <br /></td></tr>
<tr class="separator:ab1ac25199a4bfa15b8fe336c1c6486b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1323394fc4f4b4636d074c5235a48986" id="r_a1323394fc4f4b4636d074c5235a48986"><td class="memTemplParams" colspan="2">template&lt;EdgeMeshConcept InMeshType, EdgeMeshConcept OutMeshType = InMeshType&gt; </td></tr>
<tr class="memitem:a1323394fc4f4b4636d074c5235a48986"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">OutMeshType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a1323394fc4f4b4636d074c5235a48986">perEdgeMeshFilter</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="classvcl_1_1Matrix.html">InMeshType</a> &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>, Range <a class="el" href="classvcl_1_1Matrix.html">auto</a> &amp;&amp;<a class="el" href="classvcl_1_1Matrix.html">edgeFilterRng</a>, <a class="el" href="classvcl_1_1Matrix.html">bool</a> <a class="el" href="classvcl_1_1Matrix.html">saveBirthIndicesInCustomComponent</a>=<a class="el" href="classvcl_1_1Matrix.html">true</a>)</td></tr>
<tr class="memdesc:a1323394fc4f4b4636d074c5235a48986"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates and returns a new mesh that is composed of the edges of the input mesh <code>m</code> filtered using the <code>edgeFilterRng</code> range. Only vertices belonging to the imported edges will be imported in the output mesh.  <br /></td></tr>
<tr class="separator:a1323394fc4f4b4636d074c5235a48986"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac48b7e9d567cbcd77636fd03df2b6471" id="r_ac48b7e9d567cbcd77636fd03df2b6471"><td class="memTemplParams" colspan="2">template&lt;EdgeMeshConcept InMeshType, EdgeMeshConcept OutMeshType = InMeshType&gt; </td></tr>
<tr class="memitem:ac48b7e9d567cbcd77636fd03df2b6471"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">OutMeshType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ac48b7e9d567cbcd77636fd03df2b6471">perEdgeSelectionMeshFilter</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="classvcl_1_1Matrix.html">InMeshType</a> &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>, <a class="el" href="classvcl_1_1Matrix.html">bool</a> <a class="el" href="classvcl_1_1Matrix.html">saveBirthIndicesInCustomComponent</a>=<a class="el" href="classvcl_1_1Matrix.html">true</a>)</td></tr>
<tr class="memdesc:ac48b7e9d567cbcd77636fd03df2b6471"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates and returns a new mesh that is composed of the selected edges of the input mesh <code>m</code>. Only vertices belonging to the imported edges will be imported in the output mesh.  <br /></td></tr>
<tr class="separator:ac48b7e9d567cbcd77636fd03df2b6471"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cb9e347987116b6b9c58d6da2732c15" id="r_a4cb9e347987116b6b9c58d6da2732c15"><td class="memTemplParams" colspan="2">template&lt;EdgeMeshConcept OutMeshType, FaceMeshConcept InMeshType&gt; </td></tr>
<tr class="memitem:a4cb9e347987116b6b9c58d6da2732c15"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">OutMeshType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a4cb9e347987116b6b9c58d6da2732c15">perFaceEdgeMeshFilter</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="classvcl_1_1Matrix.html">InMeshType</a> &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>, <a class="el" href="classvcl_1_1Matrix.html">const</a> std::function&lt; <a class="el" href="classvcl_1_1Matrix.html">bool</a>(<a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="classvcl_1_1Matrix.html">typename</a> InMeshType::FaceType &amp;, <a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a>)&gt; &amp;<a class="el" href="classvcl_1_1Matrix.html">faceEdgeFilter</a>, <a class="el" href="classvcl_1_1Matrix.html">bool</a> <a class="el" href="classvcl_1_1Matrix.html">dontDuplicateEdges</a>=<a class="el" href="classvcl_1_1Matrix.html">true</a>, <a class="el" href="classvcl_1_1Matrix.html">bool</a> <a class="el" href="classvcl_1_1Matrix.html">saveBirthIndicesInCustomComponent</a>=<a class="el" href="classvcl_1_1Matrix.html">true</a>)</td></tr>
<tr class="memdesc:a4cb9e347987116b6b9c58d6da2732c15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates and returns a new mesh that is composed of the edges computed from the face edges of the input mesh <code>m</code> filtered using the <code>faceEdgeFilter</code> function. Only vertices belonging to the imported face edges will be imported in the output mesh.  <br /></td></tr>
<tr class="separator:a4cb9e347987116b6b9c58d6da2732c15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a5f7e2e6ea0896a34c2c2f633c8ba16" id="r_a4a5f7e2e6ea0896a34c2c2f633c8ba16"><td class="memTemplParams" colspan="2">template&lt;EdgeMeshConcept OutMeshType, FaceMeshConcept InMeshType&gt; </td></tr>
<tr class="memitem:a4a5f7e2e6ea0896a34c2c2f633c8ba16"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">OutMeshType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a4a5f7e2e6ea0896a34c2c2f633c8ba16">perFaceEdgeMeshFilter</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="classvcl_1_1Matrix.html">InMeshType</a> &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>, <a class="el" href="classvcl_1_1Matrix.html">const</a> std::function&lt; <a class="el" href="classvcl_1_1Matrix.html">bool</a>(<a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a>, <a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a>)&gt; &amp;<a class="el" href="classvcl_1_1Matrix.html">faceEdgeFilter</a>, <a class="el" href="classvcl_1_1Matrix.html">bool</a> <a class="el" href="classvcl_1_1Matrix.html">dontDuplicateEdges</a>=<a class="el" href="classvcl_1_1Matrix.html">true</a>, <a class="el" href="classvcl_1_1Matrix.html">bool</a> <a class="el" href="classvcl_1_1Matrix.html">saveBirthIndicesInCustomComponent</a>=<a class="el" href="classvcl_1_1Matrix.html">true</a>)</td></tr>
<tr class="memdesc:a4a5f7e2e6ea0896a34c2c2f633c8ba16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates and returns a new mesh that is composed of the edges computed from the face edges of the input mesh <code>m</code> filtered using the <code>faceEdgeFilter</code> function. Only vertices belonging to the imported face edges will be imported in the output mesh.  <br /></td></tr>
<tr class="separator:a4a5f7e2e6ea0896a34c2c2f633c8ba16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a273be5bb8149e465275c9e441cd6869d" id="r_a273be5bb8149e465275c9e441cd6869d"><td class="memTemplParams" colspan="2">template&lt;EdgeMeshConcept OutMeshType, FaceMeshConcept InMeshType&gt; </td></tr>
<tr class="memitem:a273be5bb8149e465275c9e441cd6869d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">OutMeshType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a273be5bb8149e465275c9e441cd6869d">perFaceEdgeSelectionMeshFilter</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="classvcl_1_1Matrix.html">InMeshType</a> &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>, <a class="el" href="classvcl_1_1Matrix.html">bool</a> <a class="el" href="classvcl_1_1Matrix.html">dontDuplicateEdges</a>=<a class="el" href="classvcl_1_1Matrix.html">true</a>, <a class="el" href="classvcl_1_1Matrix.html">bool</a> <a class="el" href="classvcl_1_1Matrix.html">saveBirthIndicesInCustomComponent</a>=<a class="el" href="classvcl_1_1Matrix.html">true</a>)</td></tr>
<tr class="memdesc:a273be5bb8149e465275c9e441cd6869d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates and returns a new mesh that is composed of the edges computed from the selected face edges of the input mesh <code>m</code>. Only vertices belonging to the imported face edges will be imported in the output mesh.  <br /></td></tr>
<tr class="separator:a273be5bb8149e465275c9e441cd6869d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59d8e830fa317191e2d02ff5cafc7149" id="r_a59d8e830fa317191e2d02ff5cafc7149"><td class="memTemplParams" colspan="2">template&lt;MatrixConcept Matrix, EdgeMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a59d8e830fa317191e2d02ff5cafc7149"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">Matrix</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a59d8e830fa317191e2d02ff5cafc7149">edgeMatrix</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;mesh)</td></tr>
<tr class="memdesc:a59d8e830fa317191e2d02ff5cafc7149"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a #V*3 <a class="el" href="classvcl_1_1Matrix.html">Matrix</a> of scalars containing the coordinates of the vertices of a <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>. The function is templated on the <a class="el" href="classvcl_1_1Matrix.html">Matrix</a> itself.  <br /></td></tr>
<tr class="separator:a59d8e830fa317191e2d02ff5cafc7149"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0aeda48720e2d34688e56a6ab79b7600" id="r_a0aeda48720e2d34688e56a6ab79b7600"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a> ELEM_ID, MatrixConcept Matrix, MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a0aeda48720e2d34688e56a6ab79b7600"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">Matrix</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a0aeda48720e2d34688e56a6ab79b7600">elementNormalsMatrix</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;mesh)</td></tr>
<tr class="memdesc:a0aeda48720e2d34688e56a6ab79b7600"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a #E <a class="el" href="classvcl_1_1Vector.html" title="The Vector class is a generic container of objects of type T, that could have fixed or dynamic size,...">Vector</a> of booleans (or integers) containing the selection status of the elements identified by <code>ELEM_ID</code> of a <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>. The function is templated on the <a class="el" href="classvcl_1_1Vector.html" title="The Vector class is a generic container of objects of type T, that could have fixed or dynamic size,...">Vector</a> itself.  <br /></td></tr>
<tr class="separator:a0aeda48720e2d34688e56a6ab79b7600"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed0e167ce00c4dd8cf2b6400ceb24da3" id="r_aed0e167ce00c4dd8cf2b6400ceb24da3"><td class="memTemplParams" colspan="2">template&lt;MatrixConcept Matrix, MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:aed0e167ce00c4dd8cf2b6400ceb24da3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">Matrix</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#aed0e167ce00c4dd8cf2b6400ceb24da3">vertexNormalsMatrix</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;mesh)</td></tr>
<tr class="memdesc:aed0e167ce00c4dd8cf2b6400ceb24da3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a #V*3 <a class="el" href="classvcl_1_1Matrix.html">Matrix</a> of scalars containing the normals of the vertices of a <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>. The function is templated on the <a class="el" href="classvcl_1_1Matrix.html">Matrix</a> itself.  <br /></td></tr>
<tr class="separator:aed0e167ce00c4dd8cf2b6400ceb24da3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bc50612a1185ec7d1add143f93eb0ec" id="r_a6bc50612a1185ec7d1add143f93eb0ec"><td class="memTemplParams" colspan="2">template&lt;MatrixConcept Matrix, FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a6bc50612a1185ec7d1add143f93eb0ec"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">Matrix</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a6bc50612a1185ec7d1add143f93eb0ec">faceNormalsMatrix</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;mesh)</td></tr>
<tr class="memdesc:a6bc50612a1185ec7d1add143f93eb0ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a #F*3 <a class="el" href="classvcl_1_1Matrix.html">Matrix</a> of scalars containing the normals of the faces of a <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>. The function is templated on the <a class="el" href="classvcl_1_1Matrix.html">Matrix</a> itself.  <br /></td></tr>
<tr class="separator:a6bc50612a1185ec7d1add143f93eb0ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add776c0c02e7ef2d7657fce701c437e7" id="r_add776c0c02e7ef2d7657fce701c437e7"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a> ELEM_ID, MatrixConcept Matrix, MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:add776c0c02e7ef2d7657fce701c437e7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">Matrix</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#add776c0c02e7ef2d7657fce701c437e7">elementColorsMatrix</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;mesh)</td></tr>
<tr class="memdesc:add776c0c02e7ef2d7657fce701c437e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a #E*4 <a class="el" href="classvcl_1_1Matrix.html">Matrix</a> of integers containing the colors of the elements identified by <code>ELEM_ID</code> of a <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>. The function is templated on the <a class="el" href="classvcl_1_1Matrix.html">Matrix</a> itself.  <br /></td></tr>
<tr class="separator:add776c0c02e7ef2d7657fce701c437e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01810ffdfe2df3aa87e9de9c783a32a6" id="r_a01810ffdfe2df3aa87e9de9c783a32a6"><td class="memTemplParams" colspan="2">template&lt;MatrixConcept Matrix, MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a01810ffdfe2df3aa87e9de9c783a32a6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">Matrix</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a01810ffdfe2df3aa87e9de9c783a32a6">vertexColorsMatrix</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;mesh)</td></tr>
<tr class="memdesc:a01810ffdfe2df3aa87e9de9c783a32a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a #V*4 <a class="el" href="classvcl_1_1Matrix.html">Matrix</a> of integers containing the colors of the vertices of a <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>. The function is templated on the <a class="el" href="classvcl_1_1Matrix.html">Matrix</a> itself.  <br /></td></tr>
<tr class="separator:a01810ffdfe2df3aa87e9de9c783a32a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a480cf1413039e05d9065485c52076ce9" id="r_a480cf1413039e05d9065485c52076ce9"><td class="memTemplParams" colspan="2">template&lt;MatrixConcept Matrix, FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a480cf1413039e05d9065485c52076ce9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">Matrix</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a480cf1413039e05d9065485c52076ce9">faceColorsMatrix</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;mesh)</td></tr>
<tr class="memdesc:a480cf1413039e05d9065485c52076ce9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a #F*4 <a class="el" href="classvcl_1_1Matrix.html">Matrix</a> of integers containing the colors of the faces of a <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>. The function is templated on the <a class="el" href="classvcl_1_1Matrix.html">Matrix</a> itself.  <br /></td></tr>
<tr class="separator:a480cf1413039e05d9065485c52076ce9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e07fcb626e0c670f8f92e930d0b2c46" id="r_a8e07fcb626e0c670f8f92e930d0b2c46"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a> ELEM_ID, <a class="el" href="classvcl_1_1Matrix.html">typename</a> <a class="el" href="classvcl_1_1Matrix.html">Vect</a> , MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a8e07fcb626e0c670f8f92e930d0b2c46"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">Vect</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a8e07fcb626e0c670f8f92e930d0b2c46">elementQualityVector</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;mesh)</td></tr>
<tr class="memdesc:a8e07fcb626e0c670f8f92e930d0b2c46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a #E <a class="el" href="classvcl_1_1Vector.html" title="The Vector class is a generic container of objects of type T, that could have fixed or dynamic size,...">Vector</a> of scalars containing the quality of the elements identified by <code>ELEM_ID</code> of a <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>. The function is templated on the <a class="el" href="classvcl_1_1Vector.html" title="The Vector class is a generic container of objects of type T, that could have fixed or dynamic size,...">Vector</a> itself.  <br /></td></tr>
<tr class="separator:a8e07fcb626e0c670f8f92e930d0b2c46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04201da836f3c6bc6eb9444319f7b492" id="r_a04201da836f3c6bc6eb9444319f7b492"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classvcl_1_1Matrix.html">typename</a> <a class="el" href="classvcl_1_1Matrix.html">Vect</a> , MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a04201da836f3c6bc6eb9444319f7b492"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">Vect</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a04201da836f3c6bc6eb9444319f7b492">vertexQualityVector</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;mesh)</td></tr>
<tr class="memdesc:a04201da836f3c6bc6eb9444319f7b492"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a #V <a class="el" href="classvcl_1_1Vector.html" title="The Vector class is a generic container of objects of type T, that could have fixed or dynamic size,...">Vector</a> of scalars containing the quality of the vertices of a <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>. The function is templated on the <a class="el" href="classvcl_1_1Vector.html" title="The Vector class is a generic container of objects of type T, that could have fixed or dynamic size,...">Vector</a> itself.  <br /></td></tr>
<tr class="separator:a04201da836f3c6bc6eb9444319f7b492"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7afddefac9fc869e5cb82367856f19e9" id="r_a7afddefac9fc869e5cb82367856f19e9"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classvcl_1_1Matrix.html">typename</a> <a class="el" href="classvcl_1_1Matrix.html">Vect</a> , FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a7afddefac9fc869e5cb82367856f19e9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">Vect</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a7afddefac9fc869e5cb82367856f19e9">faceQualityVector</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;mesh)</td></tr>
<tr class="memdesc:a7afddefac9fc869e5cb82367856f19e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a #F <a class="el" href="classvcl_1_1Vector.html" title="The Vector class is a generic container of objects of type T, that could have fixed or dynamic size,...">Vector</a> of scalars containing the quality of the faces of a <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>. The function is templated on the <a class="el" href="classvcl_1_1Vector.html" title="The Vector class is a generic container of objects of type T, that could have fixed or dynamic size,...">Vector</a> itself.  <br /></td></tr>
<tr class="separator:a7afddefac9fc869e5cb82367856f19e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa433f6d104a81e917270cca3d9ed26ed" id="r_aa433f6d104a81e917270cca3d9ed26ed"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType, MatrixConcept VMatrix, MatrixConcept VNMatrix = Eigen::MatrixX3d&gt; </td></tr>
<tr class="memitem:aa433f6d104a81e917270cca3d9ed26ed"><td class="memTemplItemLeft" align="right" valign="top">MeshType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#aa433f6d104a81e917270cca3d9ed26ed">pointCloudMeshFromMatrices</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="classvcl_1_1Matrix.html">VMatrix</a> &amp;vertices, <a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="classvcl_1_1Matrix.html">VNMatrix</a> &amp;<a class="el" href="classvcl_1_1Matrix.html">vertexNormals</a>=<a class="el" href="classvcl_1_1Matrix.html">VNMatrix</a>())</td></tr>
<tr class="memdesc:aa433f6d104a81e917270cca3d9ed26ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates and returns a new point cloud mesh from the input vertex matrix and the other matrices that are given as arguments.  <br /></td></tr>
<tr class="separator:aa433f6d104a81e917270cca3d9ed26ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae60ae8879b69a995723ada3f73422606" id="r_ae60ae8879b69a995723ada3f73422606"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType, MatrixConcept VMatrix, MatrixConcept FMatrix = Eigen::MatrixX3i, MatrixConcept VNMatrix = Eigen::MatrixX3d, MatrixConcept FNMatrix = Eigen::MatrixX3d&gt; </td></tr>
<tr class="memitem:ae60ae8879b69a995723ada3f73422606"><td class="memTemplItemLeft" align="right" valign="top">MeshType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ae60ae8879b69a995723ada3f73422606">meshFromMatrices</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="classvcl_1_1Matrix.html">VMatrix</a> &amp;vertices, <a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="classvcl_1_1Matrix.html">FMatrix</a> &amp;faces=<a class="el" href="classvcl_1_1Matrix.html">FMatrix</a>(), <a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="classvcl_1_1Matrix.html">VNMatrix</a> &amp;<a class="el" href="classvcl_1_1Matrix.html">vertexNormals</a>=<a class="el" href="classvcl_1_1Matrix.html">VNMatrix</a>(), <a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="classvcl_1_1Matrix.html">FNMatrix</a> &amp;<a class="el" href="classvcl_1_1Matrix.html">faceNormals</a>=<a class="el" href="classvcl_1_1Matrix.html">FNMatrix</a>())</td></tr>
<tr class="memdesc:ae60ae8879b69a995723ada3f73422606"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates and returns a new mesh from the input vertex and face (if any) matrices, and the other matrices that are given as arguments.  <br /></td></tr>
<tr class="separator:ae60ae8879b69a995723ada3f73422606"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af39dbdcb3c98584459fdb4b3e87e3332" id="r_af39dbdcb3c98584459fdb4b3e87e3332"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType, MatrixConcept VMatrix, MatrixConcept FMatrix = Eigen::MatrixX3i, MatrixConcept EMatrix = Eigen::MatrixX2i, MatrixConcept VNMatrix = Eigen::MatrixX3d, MatrixConcept FNMatrix = Eigen::MatrixX3d&gt; </td></tr>
<tr class="memitem:af39dbdcb3c98584459fdb4b3e87e3332"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#af39dbdcb3c98584459fdb4b3e87e3332">importMeshFromMatrices</a> (MeshType &amp;mesh, <a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="classvcl_1_1Matrix.html">VMatrix</a> &amp;vertices, <a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="classvcl_1_1Matrix.html">FMatrix</a> &amp;faces=<a class="el" href="classvcl_1_1Matrix.html">FMatrix</a>(), <a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="classvcl_1_1Matrix.html">EMatrix</a> &amp;edges=<a class="el" href="classvcl_1_1Matrix.html">EMatrix</a>(), <a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="classvcl_1_1Matrix.html">VNMatrix</a> &amp;<a class="el" href="classvcl_1_1Matrix.html">vertexNormals</a>=<a class="el" href="classvcl_1_1Matrix.html">VNMatrix</a>(), <a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="classvcl_1_1Matrix.html">FNMatrix</a> &amp;<a class="el" href="classvcl_1_1Matrix.html">faceNormals</a>=<a class="el" href="classvcl_1_1Matrix.html">FNMatrix</a>())</td></tr>
<tr class="memdesc:af39dbdcb3c98584459fdb4b3e87e3332"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the given input <code>mesh</code> from the input vertex matrix, and the other matrices that are given as arguments.  <br /></td></tr>
<tr class="separator:af39dbdcb3c98584459fdb4b3e87e3332"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02ca8fdd4a9b050d0f0ac4d5e1c13bde" id="r_a02ca8fdd4a9b050d0f0ac4d5e1c13bde"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType, MatrixConcept VMatrix&gt; </td></tr>
<tr class="memitem:a02ca8fdd4a9b050d0f0ac4d5e1c13bde"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a02ca8fdd4a9b050d0f0ac4d5e1c13bde">importVerticesFromMatrix</a> (MeshType &amp;mesh, <a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="classvcl_1_1Matrix.html">VMatrix</a> &amp;vertices, <a class="el" href="classvcl_1_1Matrix.html">bool</a> <a class="el" href="classvcl_1_1Matrix.html">clearBeforeSet</a>=<a class="el" href="classvcl_1_1Matrix.html">true</a>)</td></tr>
<tr class="memdesc:a02ca8fdd4a9b050d0f0ac4d5e1c13bde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the vertices of the given input <code>mesh</code> from the input vertex matrix.  <br /></td></tr>
<tr class="separator:a02ca8fdd4a9b050d0f0ac4d5e1c13bde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41c8a076bfadd5ab22ebd08eab05237d" id="r_a41c8a076bfadd5ab22ebd08eab05237d"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType, MatrixConcept FMatrix&gt; </td></tr>
<tr class="memitem:a41c8a076bfadd5ab22ebd08eab05237d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a41c8a076bfadd5ab22ebd08eab05237d">importFacesFromMatrix</a> (MeshType &amp;mesh, <a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="classvcl_1_1Matrix.html">FMatrix</a> &amp;faces, <a class="el" href="classvcl_1_1Matrix.html">bool</a> <a class="el" href="classvcl_1_1Matrix.html">clearBeforeSet</a>=<a class="el" href="classvcl_1_1Matrix.html">true</a>)</td></tr>
<tr class="separator:a41c8a076bfadd5ab22ebd08eab05237d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd8cc56f370e2fca77dc3da2a248d1f5" id="r_abd8cc56f370e2fca77dc3da2a248d1f5"><td class="memTemplParams" colspan="2">template&lt;EdgeMeshConcept MeshType, MatrixConcept EMatrix&gt; </td></tr>
<tr class="memitem:abd8cc56f370e2fca77dc3da2a248d1f5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#abd8cc56f370e2fca77dc3da2a248d1f5">importEdgesFromMatrix</a> (MeshType &amp;mesh, <a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="classvcl_1_1Matrix.html">EMatrix</a> &amp;edges, <a class="el" href="classvcl_1_1Matrix.html">bool</a> <a class="el" href="classvcl_1_1Matrix.html">clearBeforeSet</a>=<a class="el" href="classvcl_1_1Matrix.html">true</a>)</td></tr>
<tr class="separator:abd8cc56f370e2fca77dc3da2a248d1f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a255e7edcea02d432b2aa8a1c46dae3e5" id="r_a255e7edcea02d432b2aa8a1c46dae3e5"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType, MatrixConcept VNMatrix&gt; </td></tr>
<tr class="memitem:a255e7edcea02d432b2aa8a1c46dae3e5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a255e7edcea02d432b2aa8a1c46dae3e5">importVertexNormalsFromMatrix</a> (MeshType &amp;mesh, <a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="classvcl_1_1Matrix.html">VNMatrix</a> &amp;<a class="el" href="classvcl_1_1Matrix.html">vertexNormals</a>)</td></tr>
<tr class="separator:a255e7edcea02d432b2aa8a1c46dae3e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab91626832747d82bfe051ffc6a9d8619" id="r_ab91626832747d82bfe051ffc6a9d8619"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType, MatrixConcept FNMatrix&gt; </td></tr>
<tr class="memitem:ab91626832747d82bfe051ffc6a9d8619"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ab91626832747d82bfe051ffc6a9d8619">importFaceNormalsFromMatrix</a> (MeshType &amp;mesh, <a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="classvcl_1_1Matrix.html">FNMatrix</a> &amp;<a class="el" href="classvcl_1_1Matrix.html">faceNormals</a>)</td></tr>
<tr class="separator:ab91626832747d82bfe051ffc6a9d8619"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0b73844d3c33491eb38e6e34017eb98" id="r_ac0b73844d3c33491eb38e6e34017eb98"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType, MatrixConcept VCMatrix&gt; </td></tr>
<tr class="memitem:ac0b73844d3c33491eb38e6e34017eb98"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ac0b73844d3c33491eb38e6e34017eb98">importVertexColorsFromMatrix</a> (MeshType &amp;mesh, <a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="classvcl_1_1Matrix.html">VCMatrix</a> &amp;<a class="el" href="classvcl_1_1Matrix.html">vertexColors</a>)</td></tr>
<tr class="separator:ac0b73844d3c33491eb38e6e34017eb98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a909af3aba8fff954b61d9c98f7470eab" id="r_a909af3aba8fff954b61d9c98f7470eab"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType, MatrixConcept FCMatrix&gt; </td></tr>
<tr class="memitem:a909af3aba8fff954b61d9c98f7470eab"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a909af3aba8fff954b61d9c98f7470eab">importFaceColorsFromMatrix</a> (MeshType &amp;mesh, <a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="classvcl_1_1Matrix.html">FCMatrix</a> &amp;<a class="el" href="classvcl_1_1Matrix.html">faceColors</a>)</td></tr>
<tr class="separator:a909af3aba8fff954b61d9c98f7470eab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bdac4366b8757c10172f6e1ad61976d" id="r_a9bdac4366b8757c10172f6e1ad61976d"><td class="memTemplParams" colspan="2">template&lt;EdgeMeshConcept MeshType, MatrixConcept ECMatrix&gt; </td></tr>
<tr class="memitem:a9bdac4366b8757c10172f6e1ad61976d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a9bdac4366b8757c10172f6e1ad61976d">importEdgeColorsFromMatrix</a> (MeshType &amp;mesh, <a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="classvcl_1_1Matrix.html">ECMatrix</a> &amp;<a class="el" href="classvcl_1_1Matrix.html">edgeColors</a>)</td></tr>
<tr class="separator:a9bdac4366b8757c10172f6e1ad61976d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adac28fe9c51f808b6120eb2d9387484b" id="r_adac28fe9c51f808b6120eb2d9387484b"><td class="memTemplParams" colspan="2">template&lt;EdgeMeshConcept EdgeMesh, FaceMeshConcept MeshType, PlaneConcept PlaneType&gt; </td></tr>
<tr class="memitem:adac28fe9c51f808b6120eb2d9387484b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">EdgeMesh</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#adac28fe9c51f808b6120eb2d9387484b">meshPlaneIntersection</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>, <a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="classvcl_1_1Matrix.html">PlaneType</a> &amp;<a class="el" href="classvcl_1_1Matrix.html">pl</a>)</td></tr>
<tr class="memdesc:adac28fe9c51f808b6120eb2d9387484b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes a mesh and a plane as inputs and computes the intersection between the mesh and the plane. It creates a new EdgeMesh to represent the intersection edges.  <br /></td></tr>
<tr class="separator:adac28fe9c51f808b6120eb2d9387484b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e4c155f781f7c3e6fca2b922398fb82" id="r_a1e4c155f781f7c3e6fca2b922398fb82"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType, <a class="el" href="classvcl_1_1Matrix.html">typename</a> <a class="el" href="classvcl_1_1Matrix.html">SScalar</a> &gt; </td></tr>
<tr class="memitem:a1e4c155f781f7c3e6fca2b922398fb82"><td class="memTemplItemLeft" align="right" valign="top">MeshType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a1e4c155f781f7c3e6fca2b922398fb82">meshSphereIntersection</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>, <a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="classvcl_1_1Sphere.html">vcl::Sphere</a>&lt; <a class="el" href="classvcl_1_1Matrix.html">SScalar</a> &gt; &amp;<a class="el" href="classvcl_1_1Matrix.html">sphere</a>, <a class="el" href="classvcl_1_1Matrix.html">double</a> <a class="el" href="classvcl_1_1Matrix.html">tol</a>)</td></tr>
<tr class="memdesc:a1e4c155f781f7c3e6fca2b922398fb82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the intersection between a mesh and a ball.  <br /></td></tr>
<tr class="separator:a1e4c155f781f7c3e6fca2b922398fb82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5da120ef4b6039bf54902d14cb8b7519" id="r_a5da120ef4b6039bf54902d14cb8b7519"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType, <a class="el" href="classvcl_1_1Matrix.html">typename</a> <a class="el" href="classvcl_1_1Matrix.html">SScalar</a> &gt; </td></tr>
<tr class="memitem:a5da120ef4b6039bf54902d14cb8b7519"><td class="memTemplItemLeft" align="right" valign="top">MeshType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a5da120ef4b6039bf54902d14cb8b7519">meshSphereIntersection</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>, <a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="classvcl_1_1Sphere.html">vcl::Sphere</a>&lt; <a class="el" href="classvcl_1_1Matrix.html">SScalar</a> &gt; &amp;<a class="el" href="classvcl_1_1Matrix.html">sphere</a>)</td></tr>
<tr class="memdesc:a5da120ef4b6039bf54902d14cb8b7519"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as meshSphereIntersection(MeshType, Sphere, double);.  <br /></td></tr>
<tr class="separator:a5da120ef4b6039bf54902d14cb8b7519"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6bad1ad4846f6650d8e1cf03053ffaca" id="r_ga6bad1ad4846f6650d8e1cf03053ffaca"><td class="memTemplParams" colspan="2">template&lt;SamplerConcept SamplerType, MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga6bad1ad4846f6650d8e1cf03053ffaca"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">SamplerType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__point__sampling.html#ga6bad1ad4846f6650d8e1cf03053ffaca">allVerticesPointSampling</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>, std::vector&lt; <a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a> &gt; &amp;<a class="el" href="classvcl_1_1Matrix.html">birthVertices</a>, <a class="el" href="classvcl_1_1Matrix.html">bool</a> <a class="el" href="classvcl_1_1Matrix.html">onlySelected</a>=<a class="el" href="classvcl_1_1Matrix.html">false</a>)</td></tr>
<tr class="memdesc:ga6bad1ad4846f6650d8e1cf03053ffaca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a Sampler object that contains all the vertices contained in the given mesh.  <br /></td></tr>
<tr class="separator:ga6bad1ad4846f6650d8e1cf03053ffaca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0574891fa5b4831a4e707432860bebd4" id="r_ga0574891fa5b4831a4e707432860bebd4"><td class="memTemplParams" colspan="2">template&lt;SamplerConcept SamplerType, MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga0574891fa5b4831a4e707432860bebd4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">SamplerType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__point__sampling.html#ga0574891fa5b4831a4e707432860bebd4">allVerticesPointSampling</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>, <a class="el" href="classvcl_1_1Matrix.html">bool</a> <a class="el" href="classvcl_1_1Matrix.html">onlySelected</a>=<a class="el" href="classvcl_1_1Matrix.html">false</a>)</td></tr>
<tr class="memdesc:ga0574891fa5b4831a4e707432860bebd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a Sampler object that contains all the vertices contained in the given mesh.  <br /></td></tr>
<tr class="separator:ga0574891fa5b4831a4e707432860bebd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga14a5fe047802f08870b0d9c8e2c6d6b0" id="r_ga14a5fe047802f08870b0d9c8e2c6d6b0"><td class="memTemplParams" colspan="2">template&lt;SamplerConcept SamplerType, FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga14a5fe047802f08870b0d9c8e2c6d6b0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">SamplerType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__point__sampling.html#ga14a5fe047802f08870b0d9c8e2c6d6b0">allFacesPointSampling</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>, std::vector&lt; <a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a> &gt; &amp;<a class="el" href="classvcl_1_1Matrix.html">birthFaces</a>, <a class="el" href="classvcl_1_1Matrix.html">bool</a> <a class="el" href="classvcl_1_1Matrix.html">onlySelected</a>=<a class="el" href="classvcl_1_1Matrix.html">false</a>)</td></tr>
<tr class="memdesc:ga14a5fe047802f08870b0d9c8e2c6d6b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a SamplerType object that contains all the faces contained in the given mesh.  <br /></td></tr>
<tr class="separator:ga14a5fe047802f08870b0d9c8e2c6d6b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ed68aa0237831920672882dea64fc83" id="r_ga6ed68aa0237831920672882dea64fc83"><td class="memTemplParams" colspan="2">template&lt;SamplerConcept SamplerType, FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga6ed68aa0237831920672882dea64fc83"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">SamplerType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__point__sampling.html#ga6ed68aa0237831920672882dea64fc83">allFacesPointSampling</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>, <a class="el" href="classvcl_1_1Matrix.html">bool</a> <a class="el" href="classvcl_1_1Matrix.html">onlySelected</a>=<a class="el" href="classvcl_1_1Matrix.html">false</a>)</td></tr>
<tr class="memdesc:ga6ed68aa0237831920672882dea64fc83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a SamplerType object that contains all the faces contained in the given mesh.  <br /></td></tr>
<tr class="separator:ga6ed68aa0237831920672882dea64fc83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e63011af761c14b63e738ffc562bfa4" id="r_ga6e63011af761c14b63e738ffc562bfa4"><td class="memTemplParams" colspan="2">template&lt;SamplerConcept SamplerType, MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga6e63011af761c14b63e738ffc562bfa4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">SamplerType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__point__sampling.html#ga6e63011af761c14b63e738ffc562bfa4">vertexUniformPointSampling</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>, <a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a> <a class="el" href="classvcl_1_1Matrix.html">nSamples</a>, std::vector&lt; <a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a> &gt; &amp;<a class="el" href="classvcl_1_1Matrix.html">birthVertices</a>, <a class="el" href="classvcl_1_1Matrix.html">bool</a> <a class="el" href="classvcl_1_1Matrix.html">onlySelected</a>=<a class="el" href="classvcl_1_1Matrix.html">false</a>, <a class="el" href="classvcl_1_1Matrix.html">bool</a> <a class="el" href="classvcl_1_1Matrix.html">deterministic</a>=<a class="el" href="classvcl_1_1Matrix.html">false</a>)</td></tr>
<tr class="memdesc:ga6e63011af761c14b63e738ffc562bfa4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a SamplerType object that contains the given number of samples taken from the vertices of the given mesh. Each vertex has the same probability of being chosen. If onlySelected is true, only the selected vertices are sampled. The indices of the sampled vertices in the mesh are stored in the birthVertices vector.  <br /></td></tr>
<tr class="separator:ga6e63011af761c14b63e738ffc562bfa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5bb3ffc00ab21f608405f5d5cb45837e" id="r_ga5bb3ffc00ab21f608405f5d5cb45837e"><td class="memTemplParams" colspan="2">template&lt;SamplerConcept SamplerType, MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga5bb3ffc00ab21f608405f5d5cb45837e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">SamplerType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__point__sampling.html#ga5bb3ffc00ab21f608405f5d5cb45837e">vertexUniformPointSampling</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>, <a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a> <a class="el" href="classvcl_1_1Matrix.html">nSamples</a>, <a class="el" href="classvcl_1_1Matrix.html">bool</a> <a class="el" href="classvcl_1_1Matrix.html">onlySelected</a>=<a class="el" href="classvcl_1_1Matrix.html">false</a>, <a class="el" href="classvcl_1_1Matrix.html">bool</a> <a class="el" href="classvcl_1_1Matrix.html">deterministic</a>=<a class="el" href="classvcl_1_1Matrix.html">false</a>)</td></tr>
<tr class="memdesc:ga5bb3ffc00ab21f608405f5d5cb45837e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a SamplerType object that contains the given number of samples taken from the vertices of the given mesh. Each vertex has the same probability of being chosen. If onlySelected is true, only the selected vertices are sampled.  <br /></td></tr>
<tr class="separator:ga5bb3ffc00ab21f608405f5d5cb45837e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga94e128e7ea93dd40b0b1084c40f0786f" id="r_ga94e128e7ea93dd40b0b1084c40f0786f"><td class="memTemplParams" colspan="2">template&lt;SamplerConcept SamplerType, FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga94e128e7ea93dd40b0b1084c40f0786f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">SamplerType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__point__sampling.html#ga94e128e7ea93dd40b0b1084c40f0786f">faceUniformPointSampling</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>, <a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a> <a class="el" href="classvcl_1_1Matrix.html">nSamples</a>, std::vector&lt; <a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a> &gt; &amp;<a class="el" href="classvcl_1_1Matrix.html">birthFaces</a>, <a class="el" href="classvcl_1_1Matrix.html">bool</a> <a class="el" href="classvcl_1_1Matrix.html">onlySelected</a>=<a class="el" href="classvcl_1_1Matrix.html">false</a>, <a class="el" href="classvcl_1_1Matrix.html">bool</a> <a class="el" href="classvcl_1_1Matrix.html">deterministic</a>=<a class="el" href="classvcl_1_1Matrix.html">false</a>)</td></tr>
<tr class="memdesc:ga94e128e7ea93dd40b0b1084c40f0786f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a SamplerType object that contains the given number of samples taken from the faces of the given mesh. Each face has the same probability of being chosen. If onlySelected is true, only the selected faces are sampled. The indices of the sampled faces in the mesh are stored in the birthFaces vector.  <br /></td></tr>
<tr class="separator:ga94e128e7ea93dd40b0b1084c40f0786f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9bb8d0edffb2b4d75fa1ac1d8b9fece2" id="r_ga9bb8d0edffb2b4d75fa1ac1d8b9fece2"><td class="memTemplParams" colspan="2">template&lt;SamplerConcept SamplerType, FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga9bb8d0edffb2b4d75fa1ac1d8b9fece2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">SamplerType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__point__sampling.html#ga9bb8d0edffb2b4d75fa1ac1d8b9fece2">faceUniformPointSampling</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>, <a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a> <a class="el" href="classvcl_1_1Matrix.html">nSamples</a>, <a class="el" href="classvcl_1_1Matrix.html">bool</a> <a class="el" href="classvcl_1_1Matrix.html">onlySelected</a>=<a class="el" href="classvcl_1_1Matrix.html">false</a>, <a class="el" href="classvcl_1_1Matrix.html">bool</a> <a class="el" href="classvcl_1_1Matrix.html">deterministic</a>=<a class="el" href="classvcl_1_1Matrix.html">false</a>)</td></tr>
<tr class="memdesc:ga9bb8d0edffb2b4d75fa1ac1d8b9fece2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a SamplerType object that contains the given number of samples taken from the faces of the given mesh. Each face has the same probability of being chosen. If onlySelected is true, only the selected faces are sampled.  <br /></td></tr>
<tr class="separator:ga9bb8d0edffb2b4d75fa1ac1d8b9fece2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5cfe308da197164da340267bc3a3756f" id="r_ga5cfe308da197164da340267bc3a3756f"><td class="memTemplParams" colspan="2">template&lt;SamplerConcept SamplerType, MeshConcept MeshType, <a class="el" href="classvcl_1_1Matrix.html">typename</a> ScalarType &gt; </td></tr>
<tr class="memitem:ga5cfe308da197164da340267bc3a3756f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">SamplerType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__point__sampling.html#ga5cfe308da197164da340267bc3a3756f">vertexWeightedPointSampling</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>, <a class="el" href="classvcl_1_1Matrix.html">const</a> std::vector&lt; ScalarType &gt; &amp;<a class="el" href="classvcl_1_1Matrix.html">weights</a>, <a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a> <a class="el" href="classvcl_1_1Matrix.html">nSamples</a>, std::vector&lt; <a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a> &gt; &amp;<a class="el" href="classvcl_1_1Matrix.html">birthVertices</a>, <a class="el" href="classvcl_1_1Matrix.html">bool</a> <a class="el" href="classvcl_1_1Matrix.html">deterministic</a>=<a class="el" href="classvcl_1_1Matrix.html">false</a>)</td></tr>
<tr class="memdesc:ga5cfe308da197164da340267bc3a3756f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Samples the vertices in a weighted way, using the per vertex weights given as input. Each vertex has a probability of being chosen that is proportional to its weight. If onlySelected is true, only the selected vertices are sampled. The indices of the sampled vertices in the mesh are stored in the birthVertices vector.  <br /></td></tr>
<tr class="separator:ga5cfe308da197164da340267bc3a3756f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c655840001a3b184e1e77f1dd5c1c24" id="r_ga5c655840001a3b184e1e77f1dd5c1c24"><td class="memTemplParams" colspan="2">template&lt;SamplerConcept SamplerType, MeshConcept MeshType, <a class="el" href="classvcl_1_1Matrix.html">typename</a> ScalarType &gt; </td></tr>
<tr class="memitem:ga5c655840001a3b184e1e77f1dd5c1c24"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">SamplerType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__point__sampling.html#ga5c655840001a3b184e1e77f1dd5c1c24">vertexWeightedPointSampling</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>, <a class="el" href="classvcl_1_1Matrix.html">const</a> std::vector&lt; ScalarType &gt; &amp;<a class="el" href="classvcl_1_1Matrix.html">weights</a>, <a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a> <a class="el" href="classvcl_1_1Matrix.html">nSamples</a>, <a class="el" href="classvcl_1_1Matrix.html">bool</a> <a class="el" href="classvcl_1_1Matrix.html">deterministic</a>=<a class="el" href="classvcl_1_1Matrix.html">false</a>)</td></tr>
<tr class="memdesc:ga5c655840001a3b184e1e77f1dd5c1c24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Samples the vertices in a weighted way, using the per vertex weights given as input. Each vertex has a probability of being chosen that is proportional to its weight. If onlySelected is true, only the selected vertices are sampled.  <br /></td></tr>
<tr class="separator:ga5c655840001a3b184e1e77f1dd5c1c24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45797a5529565501b0217b75b996cc8d" id="r_ga45797a5529565501b0217b75b996cc8d"><td class="memTemplParams" colspan="2">template&lt;SamplerConcept SamplerType, FaceMeshConcept MeshType, <a class="el" href="classvcl_1_1Matrix.html">typename</a> ScalarType &gt; </td></tr>
<tr class="memitem:ga45797a5529565501b0217b75b996cc8d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">SamplerType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__point__sampling.html#ga45797a5529565501b0217b75b996cc8d">faceWeightedPointSampling</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>, <a class="el" href="classvcl_1_1Matrix.html">const</a> std::vector&lt; ScalarType &gt; &amp;<a class="el" href="classvcl_1_1Matrix.html">weights</a>, <a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a> <a class="el" href="classvcl_1_1Matrix.html">nSamples</a>, std::vector&lt; <a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a> &gt; &amp;<a class="el" href="classvcl_1_1Matrix.html">birthFaces</a>, <a class="el" href="classvcl_1_1Matrix.html">bool</a> <a class="el" href="classvcl_1_1Matrix.html">deterministic</a>=<a class="el" href="classvcl_1_1Matrix.html">false</a>)</td></tr>
<tr class="memdesc:ga45797a5529565501b0217b75b996cc8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a SamplerType object that contains the given number of samples taken from the faces of the given mesh. Each face has the same probability of being chosen. If onlySelected is true, only the selected faces are sampled. The indices of the sampled faces in the mesh are stored in the birthFaces vector.  <br /></td></tr>
<tr class="separator:ga45797a5529565501b0217b75b996cc8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b80c4e54addd57077b19b3be88e46df" id="r_ga7b80c4e54addd57077b19b3be88e46df"><td class="memTemplParams" colspan="2">template&lt;SamplerConcept SamplerType, FaceMeshConcept MeshType, <a class="el" href="classvcl_1_1Matrix.html">typename</a> ScalarType &gt; </td></tr>
<tr class="memitem:ga7b80c4e54addd57077b19b3be88e46df"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">SamplerType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__point__sampling.html#ga7b80c4e54addd57077b19b3be88e46df">faceWeightedPointSampling</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>, <a class="el" href="classvcl_1_1Matrix.html">const</a> std::vector&lt; ScalarType &gt; &amp;<a class="el" href="classvcl_1_1Matrix.html">weights</a>, <a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a> <a class="el" href="classvcl_1_1Matrix.html">nSamples</a>, <a class="el" href="classvcl_1_1Matrix.html">bool</a> <a class="el" href="classvcl_1_1Matrix.html">deterministic</a>=<a class="el" href="classvcl_1_1Matrix.html">false</a>)</td></tr>
<tr class="memdesc:ga7b80c4e54addd57077b19b3be88e46df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a SamplerType object that contains the given number of samples taken from the faces of the given mesh. Each face has the same probability of being chosen. If onlySelected is true, only the selected faces are sampled.  <br /></td></tr>
<tr class="separator:ga7b80c4e54addd57077b19b3be88e46df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga06a1f194581098995159c29d970f09fa" id="r_ga06a1f194581098995159c29d970f09fa"><td class="memTemplParams" colspan="2">template&lt;SamplerConcept SamplerType, MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga06a1f194581098995159c29d970f09fa"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">SamplerType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__point__sampling.html#ga06a1f194581098995159c29d970f09fa">vertexQualityWeightedPointSampling</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>, <a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a> <a class="el" href="classvcl_1_1Matrix.html">nSamples</a>, <a class="el" href="classvcl_1_1Matrix.html">bool</a> <a class="el" href="classvcl_1_1Matrix.html">deterministic</a>=<a class="el" href="classvcl_1_1Matrix.html">false</a>)</td></tr>
<tr class="memdesc:ga06a1f194581098995159c29d970f09fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Samples the vertices in a weighted way, using the per vertex Quality component. Each vertex has a probability of being chosen that is proportional to its quality value.  <br /></td></tr>
<tr class="separator:ga06a1f194581098995159c29d970f09fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca1e65bf9e52ec03df48208bc727a90b" id="r_gaca1e65bf9e52ec03df48208bc727a90b"><td class="memTemplParams" colspan="2">template&lt;SamplerConcept SamplerType, FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:gaca1e65bf9e52ec03df48208bc727a90b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">SamplerType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__point__sampling.html#gaca1e65bf9e52ec03df48208bc727a90b">faceQualityWeightedPointSampling</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>, <a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a> <a class="el" href="classvcl_1_1Matrix.html">nSamples</a>, <a class="el" href="classvcl_1_1Matrix.html">bool</a> <a class="el" href="classvcl_1_1Matrix.html">deterministic</a>=<a class="el" href="classvcl_1_1Matrix.html">false</a>)</td></tr>
<tr class="memdesc:gaca1e65bf9e52ec03df48208bc727a90b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Samples the faces in a weighted way, using the per face Quality component. Each face has a probability of being chosen that is proportional to its quality value.  <br /></td></tr>
<tr class="separator:gaca1e65bf9e52ec03df48208bc727a90b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga61de0fbca61ca1cf5d4afd01204bae90" id="r_ga61de0fbca61ca1cf5d4afd01204bae90"><td class="memTemplParams" colspan="2">template&lt;SamplerConcept SamplerType, FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga61de0fbca61ca1cf5d4afd01204bae90"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">SamplerType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__point__sampling.html#ga61de0fbca61ca1cf5d4afd01204bae90">vertexAreaWeightedPointSampling</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>, <a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a> <a class="el" href="classvcl_1_1Matrix.html">nSamples</a>, <a class="el" href="classvcl_1_1Matrix.html">bool</a> <a class="el" href="classvcl_1_1Matrix.html">deterministic</a>=<a class="el" href="classvcl_1_1Matrix.html">false</a>)</td></tr>
<tr class="memdesc:ga61de0fbca61ca1cf5d4afd01204bae90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Samples the vertices in a weighted way, using the area. Each vertex has a probability of being chosen that is proportional to the average area of its adjacent faces.  <br /></td></tr>
<tr class="separator:ga61de0fbca61ca1cf5d4afd01204bae90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga865ca2d8750dd3ec5543dc2bfc3d00d3" id="r_ga865ca2d8750dd3ec5543dc2bfc3d00d3"><td class="memTemplParams" colspan="2">template&lt;SamplerConcept SamplerType, FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga865ca2d8750dd3ec5543dc2bfc3d00d3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">SamplerType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__point__sampling.html#ga865ca2d8750dd3ec5543dc2bfc3d00d3">faceAreaWeightedPointSampling</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>, <a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a> <a class="el" href="classvcl_1_1Matrix.html">nSamples</a>, <a class="el" href="classvcl_1_1Matrix.html">bool</a> <a class="el" href="classvcl_1_1Matrix.html">deterministic</a>=<a class="el" href="classvcl_1_1Matrix.html">false</a>)</td></tr>
<tr class="memdesc:ga865ca2d8750dd3ec5543dc2bfc3d00d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Samples the faces in a weighted way, using the per face area. Each face has a probability of being chosen that is proportional to its area.  <br /></td></tr>
<tr class="separator:ga865ca2d8750dd3ec5543dc2bfc3d00d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d709e7d573815c0e5ebd934904de746" id="r_ga3d709e7d573815c0e5ebd934904de746"><td class="memTemplParams" colspan="2">template&lt;SamplerConcept SamplerType, FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga3d709e7d573815c0e5ebd934904de746"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">SamplerType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__point__sampling.html#ga3d709e7d573815c0e5ebd934904de746">montecarloPointSampling</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>, <a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a> <a class="el" href="classvcl_1_1Matrix.html">nSamples</a>, std::vector&lt; <a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a> &gt; &amp;<a class="el" href="classvcl_1_1Matrix.html">birthFaces</a>, <a class="el" href="classvcl_1_1Matrix.html">bool</a> <a class="el" href="classvcl_1_1Matrix.html">deterministic</a>=<a class="el" href="classvcl_1_1Matrix.html">false</a>)</td></tr>
<tr class="memdesc:ga3d709e7d573815c0e5ebd934904de746"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a montecarlo distribution with an exact number of samples. It works by generating a sequence of consecutive segments proportional to the face areas and actually shooting sample over this line. The indices of the sampled faces in the mesh are stored in the birthFaces vector.  <br /></td></tr>
<tr class="separator:ga3d709e7d573815c0e5ebd934904de746"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d65adc0bca9ee054f7491f14f43b0ec" id="r_ga1d65adc0bca9ee054f7491f14f43b0ec"><td class="memTemplParams" colspan="2">template&lt;SamplerConcept SamplerType, FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga1d65adc0bca9ee054f7491f14f43b0ec"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">SamplerType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__point__sampling.html#ga1d65adc0bca9ee054f7491f14f43b0ec">montecarloPointSampling</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>, <a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a> <a class="el" href="classvcl_1_1Matrix.html">nSamples</a>, <a class="el" href="classvcl_1_1Matrix.html">bool</a> <a class="el" href="classvcl_1_1Matrix.html">deterministic</a>=<a class="el" href="classvcl_1_1Matrix.html">false</a>)</td></tr>
<tr class="memdesc:ga1d65adc0bca9ee054f7491f14f43b0ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a montecarlo distribution with an exact number of samples. It works by generating a sequence of consecutive segments proportional to the face areas and actually shooting sample over this line.  <br /></td></tr>
<tr class="separator:ga1d65adc0bca9ee054f7491f14f43b0ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cc79547db9d6b6a15264fc004fec4dc" id="r_a6cc79547db9d6b6a15264fc004fec4dc"><td class="memTemplParams" colspan="2">template&lt;SamplerConcept SamplerType, FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a6cc79547db9d6b6a15264fc004fec4dc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">SamplerType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a6cc79547db9d6b6a15264fc004fec4dc">stratifiedMontecarloPointSampling</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>, <a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a> <a class="el" href="classvcl_1_1Matrix.html">nSamples</a>, <a class="el" href="classvcl_1_1Matrix.html">bool</a> <a class="el" href="classvcl_1_1Matrix.html">deterministic</a>=<a class="el" href="classvcl_1_1Matrix.html">false</a>)</td></tr>
<tr class="separator:a6cc79547db9d6b6a15264fc004fec4dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8dfa9b78c674bc57e4a7400f723590bc" id="r_ga8dfa9b78c674bc57e4a7400f723590bc"><td class="memTemplParams" colspan="2">template&lt;SamplerConcept SamplerType, FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga8dfa9b78c674bc57e4a7400f723590bc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">SamplerType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__point__sampling.html#ga8dfa9b78c674bc57e4a7400f723590bc">montecarloPoissonPointSampling</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>, <a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a> <a class="el" href="classvcl_1_1Matrix.html">nSamples</a>, <a class="el" href="classvcl_1_1Matrix.html">bool</a> <a class="el" href="classvcl_1_1Matrix.html">deterministic</a>=<a class="el" href="classvcl_1_1Matrix.html">false</a>)</td></tr>
<tr class="memdesc:ga8dfa9b78c674bc57e4a7400f723590bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function compute montecarlo distribution with an approximate number of samples exploiting the poisson distribution approximation of the binomial distribution.  <br /></td></tr>
<tr class="separator:ga8dfa9b78c674bc57e4a7400f723590bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29eebb11ad214c9832b49f81417aae34" id="r_a29eebb11ad214c9832b49f81417aae34"><td class="memTemplParams" colspan="2">template&lt;SamplerConcept SamplerType, FaceMeshConcept MeshType, <a class="el" href="classvcl_1_1Matrix.html">typename</a> ScalarType &gt; </td></tr>
<tr class="memitem:a29eebb11ad214c9832b49f81417aae34"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">SamplerType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a29eebb11ad214c9832b49f81417aae34">vertexWeightedMontecarloPointSampling</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>, <a class="el" href="classvcl_1_1Matrix.html">const</a> std::vector&lt; ScalarType &gt; &amp;<a class="el" href="classvcl_1_1Matrix.html">weights</a>, <a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a> <a class="el" href="classvcl_1_1Matrix.html">nSamples</a>, <a class="el" href="classvcl_1_1Matrix.html">double</a> variance, <a class="el" href="classvcl_1_1Matrix.html">bool</a> <a class="el" href="classvcl_1_1Matrix.html">deterministic</a>=<a class="el" href="classvcl_1_1Matrix.html">false</a>)</td></tr>
<tr class="separator:a29eebb11ad214c9832b49f81417aae34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6617580fead9a30c7c8db2e236e2a7a" id="r_ac6617580fead9a30c7c8db2e236e2a7a"><td class="memTemplParams" colspan="2">template&lt;SamplerConcept SamplerType, FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ac6617580fead9a30c7c8db2e236e2a7a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">SamplerType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ac6617580fead9a30c7c8db2e236e2a7a">vertexQualityWeightedMontecarloPointSampling</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>, <a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a> <a class="el" href="classvcl_1_1Matrix.html">nSamples</a>, <a class="el" href="classvcl_1_1Matrix.html">double</a> variance, <a class="el" href="classvcl_1_1Matrix.html">bool</a> <a class="el" href="classvcl_1_1Matrix.html">deterministic</a>=<a class="el" href="classvcl_1_1Matrix.html">false</a>)</td></tr>
<tr class="separator:ac6617580fead9a30c7c8db2e236e2a7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab5bd336ab6b6a6138f89ffbb56ef3b5" id="r_aab5bd336ab6b6a6138f89ffbb56ef3b5"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType, FaceConcept FaceType&gt; </td></tr>
<tr class="memitem:aab5bd336ab6b6a6138f89ffbb56ef3b5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#aab5bd336ab6b6a6138f89ffbb56ef3b5">addTriangleFacesFromPolygon</a> (MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>, FaceType &amp;f, <a class="el" href="classvcl_1_1Matrix.html">const</a> std::vector&lt; <a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a> &gt; &amp;polygon)</td></tr>
<tr class="memdesc:aab5bd336ab6b6a6138f89ffbb56ef3b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a vector of indices of vertices in a mesh representing a polyon, this function adds N triangular faces to the mesh, that are the triangulation of the input polygon. <a class="el" href="classvcl_1_1Triangle.html">Triangle</a> edges that are internal in the polygon are marked as faux.  <br /></td></tr>
<tr class="separator:aab5bd336ab6b6a6138f89ffbb56ef3b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acad48a316f6b47d2ce4fa978be50a97e" id="r_acad48a316f6b47d2ce4fa978be50a97e"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:acad48a316f6b47d2ce4fa978be50a97e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#acad48a316f6b47d2ce4fa978be50a97e">addTriangleFacesFromPolygon</a> (MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>, <a class="el" href="classvcl_1_1Matrix.html">const</a> std::vector&lt; <a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a> &gt; &amp;polygon)</td></tr>
<tr class="memdesc:acad48a316f6b47d2ce4fa978be50a97e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a vector of indices of vertices in a mesh representing a polyon, this function adds N triangular faces to the mesh, that are the triangulation of the input polygon. <a class="el" href="classvcl_1_1Triangle.html">Triangle</a> edges that are internal in the polygon are marked as faux. This function returns the index of the first added triangle.  <br /></td></tr>
<tr class="separator:acad48a316f6b47d2ce4fa978be50a97e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d6bf09841cfbbaaa328de2d552fc090" id="r_a1d6bf09841cfbbaaa328de2d552fc090"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a1d6bf09841cfbbaaa328de2d552fc090"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classvcl_1_1Matrix.html">typename</a> MeshType::VertexType * &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a1d6bf09841cfbbaaa328de2d552fc090">fillAndShuffleVertexPointerVector</a> (MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>, <a class="el" href="classvcl_1_1Matrix.html">bool</a> <a class="el" href="classvcl_1_1Matrix.html">deterministic</a>=<a class="el" href="classvcl_1_1Matrix.html">false</a>)</td></tr>
<tr class="separator:a1d6bf09841cfbbaaa328de2d552fc090"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa78e0576d6ad4f8e4af89367f38dabe5" id="r_aa78e0576d6ad4f8e4af89367f38dabe5"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:aa78e0576d6ad4f8e4af89367f38dabe5"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="classvcl_1_1Matrix.html">typename</a> MeshType::VertexType * &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#aa78e0576d6ad4f8e4af89367f38dabe5">fillAndShuffleVertexPointerVector</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>, <a class="el" href="classvcl_1_1Matrix.html">bool</a> <a class="el" href="classvcl_1_1Matrix.html">deterministic</a>=<a class="el" href="classvcl_1_1Matrix.html">false</a>)</td></tr>
<tr class="separator:aa78e0576d6ad4f8e4af89367f38dabe5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9667638a4f4f3faea6994a61ce7119e" id="r_ac9667638a4f4f3faea6994a61ce7119e"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ac9667638a4f4f3faea6994a61ce7119e"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ac9667638a4f4f3faea6994a61ce7119e">fillAndShuffleVertexIndexVector</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>, <a class="el" href="classvcl_1_1Matrix.html">bool</a> <a class="el" href="classvcl_1_1Matrix.html">deterministic</a>=<a class="el" href="classvcl_1_1Matrix.html">false</a>)</td></tr>
<tr class="separator:ac9667638a4f4f3faea6994a61ce7119e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad656a119fe2eb1573d28a28e6576d41d" id="r_ad656a119fe2eb1573d28a28e6576d41d"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ad656a119fe2eb1573d28a28e6576d41d"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classvcl_1_1Matrix.html">typename</a> MeshType::FaceType * &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ad656a119fe2eb1573d28a28e6576d41d">fillAndShuffleFacePointerVector</a> (MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>, <a class="el" href="classvcl_1_1Matrix.html">bool</a> <a class="el" href="classvcl_1_1Matrix.html">deterministic</a>=<a class="el" href="classvcl_1_1Matrix.html">false</a>)</td></tr>
<tr class="separator:ad656a119fe2eb1573d28a28e6576d41d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9b1a38c4fad92ad74bbc461e64f1c08" id="r_ab9b1a38c4fad92ad74bbc461e64f1c08"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ab9b1a38c4fad92ad74bbc461e64f1c08"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="classvcl_1_1Matrix.html">typename</a> MeshType::FaceType * &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ab9b1a38c4fad92ad74bbc461e64f1c08">fillAndShuffleFacePointerVector</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>, <a class="el" href="classvcl_1_1Matrix.html">bool</a> <a class="el" href="classvcl_1_1Matrix.html">deterministic</a>=<a class="el" href="classvcl_1_1Matrix.html">false</a>)</td></tr>
<tr class="separator:ab9b1a38c4fad92ad74bbc461e64f1c08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae41a0dea61c2ea301966406de57ae461" id="r_ae41a0dea61c2ea301966406de57ae461"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ae41a0dea61c2ea301966406de57ae461"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ae41a0dea61c2ea301966406de57ae461">fillAndShuffleFaceIndexVector</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>, <a class="el" href="classvcl_1_1Matrix.html">bool</a> <a class="el" href="classvcl_1_1Matrix.html">deterministic</a>=<a class="el" href="classvcl_1_1Matrix.html">false</a>)</td></tr>
<tr class="separator:ae41a0dea61c2ea301966406de57ae461"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6effb8d19dc6c62592f8f2cfff8a6854" id="r_a6effb8d19dc6c62592f8f2cfff8a6854"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a6effb8d19dc6c62592f8f2cfff8a6854"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a6effb8d19dc6c62592f8f2cfff8a6854">laplacianSmoothing</a> (MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>, <a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a> <a class="el" href="classvcl_1_1Matrix.html">step</a>, <a class="el" href="classvcl_1_1Matrix.html">bool</a> <a class="el" href="classvcl_1_1Matrix.html">smoothSelected</a>=<a class="el" href="classvcl_1_1Matrix.html">false</a>, <a class="el" href="classvcl_1_1Matrix.html">bool</a> <a class="el" href="classvcl_1_1Matrix.html">cotangentWeight</a>=<a class="el" href="classvcl_1_1Matrix.html">false</a>)</td></tr>
<tr class="memdesc:a6effb8d19dc6c62592f8f2cfff8a6854"><td class="mdescLeft">&#160;</td><td class="mdescRight">vertexCoordLaplacianSmoothing the classical Laplacian smoothing. Each vertex is moved onto the average of the adjacent vertices.  <br /></td></tr>
<tr class="separator:a6effb8d19dc6c62592f8f2cfff8a6854"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d1a7878d6acec093a915b11413984aa" id="r_a7d1a7878d6acec093a915b11413984aa"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a7d1a7878d6acec093a915b11413984aa"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a7d1a7878d6acec093a915b11413984aa">taubinSmoothing</a> (MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>, <a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a> <a class="el" href="classvcl_1_1Matrix.html">step</a>, <a class="el" href="classvcl_1_1Matrix.html">float</a> <a class="el" href="classvcl_1_1Matrix.html">lambda</a>, <a class="el" href="classvcl_1_1Matrix.html">float</a> <a class="el" href="classvcl_1_1Matrix.html">mu</a>, <a class="el" href="classvcl_1_1Matrix.html">bool</a> <a class="el" href="classvcl_1_1Matrix.html">smoothSelected</a>=<a class="el" href="classvcl_1_1Matrix.html">false</a>)</td></tr>
<tr class="separator:a7d1a7878d6acec093a915b11413984aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33f84f8e28d1adf77369c920bb0e46b5" id="r_a33f84f8e28d1adf77369c920bb0e46b5"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType, PointConcept PointType&gt; </td></tr>
<tr class="memitem:a33f84f8e28d1adf77369c920bb0e46b5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a33f84f8e28d1adf77369c920bb0e46b5">smoothPerVertexNormalsPointCloud</a> (MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>, <a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="classvcl_1_1KDTree.html">KDTree</a>&lt; PointType &gt; &amp;<a class="el" href="classvcl_1_1Matrix.html">tree</a>, <a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a> <a class="el" href="classvcl_1_1Matrix.html">neighborNum</a>, <a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a> <a class="el" href="classvcl_1_1Matrix.html">iterNum</a>)</td></tr>
<tr class="memdesc:a33f84f8e28d1adf77369c920bb0e46b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">smoothPerVertexNormalsPointCloud  <br /></td></tr>
<tr class="separator:a33f84f8e28d1adf77369c920bb0e46b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a2005cb82322d607914a2e2dcd63e66" id="r_a9a2005cb82322d607914a2e2dcd63e66"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a9a2005cb82322d607914a2e2dcd63e66"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a9a2005cb82322d607914a2e2dcd63e66">smoothPerVertexNormalsPointCloud</a> (MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>, <a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a> <a class="el" href="classvcl_1_1Matrix.html">neighborNum</a>, <a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a> <a class="el" href="classvcl_1_1Matrix.html">iterNum</a>)</td></tr>
<tr class="memdesc:a9a2005cb82322d607914a2e2dcd63e66"><td class="mdescLeft">&#160;</td><td class="mdescRight">smoothPerVertexNormalsPointCloud  <br /></td></tr>
<tr class="separator:a9a2005cb82322d607914a2e2dcd63e66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ff4adce6cdd2cc82aec090338c4ccfe" id="r_a8ff4adce6cdd2cc82aec090338c4ccfe"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a8ff4adce6cdd2cc82aec090338c4ccfe"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classvcl_1_1MeshEdgeUtil.html">MeshEdgeUtil</a>&lt; MeshType &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a8ff4adce6cdd2cc82aec090338c4ccfe">fillAndSortMeshEdgeUtilVector</a> (MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>, <a class="el" href="classvcl_1_1Matrix.html">bool</a> <a class="el" href="classvcl_1_1Matrix.html">includeFauxEdges</a>=<a class="el" href="classvcl_1_1Matrix.html">true</a>)</td></tr>
<tr class="separator:a8ff4adce6cdd2cc82aec090338c4ccfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66a5b3121ca08d3686ae7637a9e30cf7" id="r_a66a5b3121ca08d3686ae7637a9e30cf7"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a66a5b3121ca08d3686ae7637a9e30cf7"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classvcl_1_1ConstMeshEdgeUtil.html">ConstMeshEdgeUtil</a>&lt; MeshType &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a66a5b3121ca08d3686ae7637a9e30cf7">fillAndSortMeshEdgeUtilVector</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>, <a class="el" href="classvcl_1_1Matrix.html">bool</a> <a class="el" href="classvcl_1_1Matrix.html">includeFauxEdges</a>=<a class="el" href="classvcl_1_1Matrix.html">true</a>)</td></tr>
<tr class="separator:a66a5b3121ca08d3686ae7637a9e30cf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66e2e1e0ec5d91e9def735ecf4f84b0e" id="r_a66e2e1e0ec5d91e9def735ecf4f84b0e"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a66e2e1e0ec5d91e9def735ecf4f84b0e"><td class="memTemplItemLeft" align="right" valign="top">MeshType::VertexType::CoordType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a66e2e1e0ec5d91e9def735ecf4f84b0e">barycenter</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>)</td></tr>
<tr class="memdesc:a66e2e1e0ec5d91e9def735ecf4f84b0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the barycenter of the mesh, that is the simple average of all the vertex coordintes of the mesh.  <br /></td></tr>
<tr class="separator:a66e2e1e0ec5d91e9def735ecf4f84b0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63bff22265d64d974b4fe4267b6dbac0" id="r_a63bff22265d64d974b4fe4267b6dbac0"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a63bff22265d64d974b4fe4267b6dbac0"><td class="memTemplItemLeft" align="right" valign="top">MeshType::VertexType::CoordType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a63bff22265d64d974b4fe4267b6dbac0">scalarWeightedBarycenter</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>)</td></tr>
<tr class="memdesc:a63bff22265d64d974b4fe4267b6dbac0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the barycenter of the mesh weighted on the per vertex quality values.  <br /></td></tr>
<tr class="separator:a63bff22265d64d974b4fe4267b6dbac0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecc52dfd02e09e49a5dd1612183a2cb8" id="r_aecc52dfd02e09e49a5dd1612183a2cb8"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:aecc52dfd02e09e49a5dd1612183a2cb8"><td class="memTemplItemLeft" align="right" valign="top">MeshType::VertexType::CoordType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#aecc52dfd02e09e49a5dd1612183a2cb8">shellBarycenter</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>)</td></tr>
<tr class="memdesc:aecc52dfd02e09e49a5dd1612183a2cb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the barycenter of the surface thin-shell. E.g. it assume a 'empty' model where all the mass is located on the surface and compute the barycenter of that thinshell. Works for any polygonal model (no problem with open, nonmanifold selfintersecting models). Useful for computing the barycenter of 2D planar figures.  <br /></td></tr>
<tr class="separator:aecc52dfd02e09e49a5dd1612183a2cb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2aa52bf969238c1f809e218722e63ccf" id="r_ga2aa52bf969238c1f809e218722e63ccf"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga2aa52bf969238c1f809e218722e63ccf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mesh__stat.html#ga2aa52bf969238c1f809e218722e63ccf">boundingBox</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>)</td></tr>
<tr class="memdesc:ga2aa52bf969238c1f809e218722e63ccf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the bounding box of a mesh.  <br /></td></tr>
<tr class="separator:ga2aa52bf969238c1f809e218722e63ccf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a3eb7aeb0da02be51ca136620616b43" id="r_a9a3eb7aeb0da02be51ca136620616b43"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a9a3eb7aeb0da02be51ca136620616b43"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">double</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a9a3eb7aeb0da02be51ca136620616b43">volume</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>)</td></tr>
<tr class="memdesc:a9a3eb7aeb0da02be51ca136620616b43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the volume of a closed surface <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>. Returned value is meaningful only if the input mesh is watertight.  <br /></td></tr>
<tr class="separator:a9a3eb7aeb0da02be51ca136620616b43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dfa8d4e30b457c12c3e5e21b4fc123a" id="r_a5dfa8d4e30b457c12c3e5e21b4fc123a"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a5dfa8d4e30b457c12c3e5e21b4fc123a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">double</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a5dfa8d4e30b457c12c3e5e21b4fc123a">surfaceArea</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>)</td></tr>
<tr class="memdesc:a5dfa8d4e30b457c12c3e5e21b4fc123a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the surface area of the given <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>, that is the sum of the areas of each face of the mesh.  <br /></td></tr>
<tr class="separator:a5dfa8d4e30b457c12c3e5e21b4fc123a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86c0811cfbc37a3b319d57902e81e949" id="r_a86c0811cfbc37a3b319d57902e81e949"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a86c0811cfbc37a3b319d57902e81e949"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">double</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a86c0811cfbc37a3b319d57902e81e949">borderLength</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>)</td></tr>
<tr class="memdesc:a86c0811cfbc37a3b319d57902e81e949"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the border length of the given <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>, that is the sum of the length of the edges that are on border in the given mesh.  <br /></td></tr>
<tr class="separator:a86c0811cfbc37a3b319d57902e81e949"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46a67e9dd1e0a9805f812c10328caaa2" id="r_a46a67e9dd1e0a9805f812c10328caaa2"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a46a67e9dd1e0a9805f812c10328caaa2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a46a67e9dd1e0a9805f812c10328caaa2">covarianceMatrixOfPointCloud</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>)</td></tr>
<tr class="memdesc:a46a67e9dd1e0a9805f812c10328caaa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the covariance matrix of a <a class="el" href="classvcl_1_1Point.html" title="The Point class represents an N-dimensional point containing N scalar values.">Point</a> Cloud <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>.  <br /></td></tr>
<tr class="separator:a46a67e9dd1e0a9805f812c10328caaa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49e57acf0c1cb51e98f7a176051d99ee" id="r_a49e57acf0c1cb51e98f7a176051d99ee"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a49e57acf0c1cb51e98f7a176051d99ee"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a49e57acf0c1cb51e98f7a176051d99ee">covarianceMatrixOfMesh</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>)</td></tr>
<tr class="memdesc:a49e57acf0c1cb51e98f7a176051d99ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute covariance matrix of a mesh, i.e. the integral int_{m} { (x-b)(x-b)^T }dx where b is the barycenter and x spans over the mesh m.  <br /></td></tr>
<tr class="separator:a49e57acf0c1cb51e98f7a176051d99ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a598979803f34d74d1c4c9d4599d01eb8" id="r_a598979803f34d74d1c4c9d4599d01eb8"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType, <a class="el" href="classvcl_1_1Matrix.html">typename</a> ScalarType &gt; </td></tr>
<tr class="memitem:a598979803f34d74d1c4c9d4599d01eb8"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; ScalarType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a598979803f34d74d1c4c9d4599d01eb8">vertexRadiusFromWeights</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>, <a class="el" href="classvcl_1_1Matrix.html">const</a> std::vector&lt; ScalarType &gt; &amp;<a class="el" href="classvcl_1_1Matrix.html">weights</a>, <a class="el" href="classvcl_1_1Matrix.html">double</a> <a class="el" href="classvcl_1_1Matrix.html">diskRadius</a>, <a class="el" href="classvcl_1_1Matrix.html">double</a> <a class="el" href="classvcl_1_1Matrix.html">radiusVariance</a>, <a class="el" href="classvcl_1_1Matrix.html">bool</a> <a class="el" href="classvcl_1_1Matrix.html">invert</a>=<a class="el" href="classvcl_1_1Matrix.html">false</a>)</td></tr>
<tr class="memdesc:a598979803f34d74d1c4c9d4599d01eb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">When performing an adptive pruning for each sample we expect a varying radius to be removed. The radius is a PerVertex attribute that we compute from the current per vertex weights given as argument. The expected radius of the sample is computed so that it linearly maps the quality between diskradius and diskradius*variance.  <br /></td></tr>
<tr class="separator:a598979803f34d74d1c4c9d4599d01eb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74127bca614f622db4ffc101f3d6c241" id="r_a74127bca614f622db4ffc101f3d6c241"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a74127bca614f622db4ffc101f3d6c241"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; <a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a>, <a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a74127bca614f622db4ffc101f3d6c241">creaseFaceEdges</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>, <a class="el" href="classvcl_1_1Matrix.html">double</a> <a class="el" href="classvcl_1_1Matrix.html">angleRadNeg</a>, <a class="el" href="classvcl_1_1Matrix.html">double</a> <a class="el" href="classvcl_1_1Matrix.html">angleRadPos</a>, <a class="el" href="classvcl_1_1Matrix.html">bool</a> <a class="el" href="classvcl_1_1Matrix.html">alsoBorderEdges</a>=<a class="el" href="classvcl_1_1Matrix.html">false</a>)</td></tr>
<tr class="memdesc:a74127bca614f622db4ffc101f3d6c241"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector of pairs &lt;face index; edge index&gt; of the edges that have a dihedral angle outside the given range.  <br /></td></tr>
<tr class="separator:a74127bca614f622db4ffc101f3d6c241"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2972300f527bd1cce6182dde8b76c41" id="r_ae2972300f527bd1cce6182dde8b76c41"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ae2972300f527bd1cce6182dde8b76c41"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ae2972300f527bd1cce6182dde8b76c41">vertexQualityMinMax</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>)</td></tr>
<tr class="memdesc:ae2972300f527bd1cce6182dde8b76c41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pair containing the min and the maximum vertex quality.  <br /></td></tr>
<tr class="separator:ae2972300f527bd1cce6182dde8b76c41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42145b026908d9eafadd429eba4fa0be" id="r_a42145b026908d9eafadd429eba4fa0be"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a42145b026908d9eafadd429eba4fa0be"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a42145b026908d9eafadd429eba4fa0be">faceQualityMinMax</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>)</td></tr>
<tr class="memdesc:a42145b026908d9eafadd429eba4fa0be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pair containing the min and the maximum face quality.  <br /></td></tr>
<tr class="separator:a42145b026908d9eafadd429eba4fa0be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ed4ecc783b58f5327f0a6b68c071727" id="r_a9ed4ecc783b58f5327f0a6b68c071727"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a9ed4ecc783b58f5327f0a6b68c071727"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a9ed4ecc783b58f5327f0a6b68c071727">vertexQualityAverage</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>)</td></tr>
<tr class="memdesc:a9ed4ecc783b58f5327f0a6b68c071727"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a scalar that is the average of the vertex quality.  <br /></td></tr>
<tr class="separator:a9ed4ecc783b58f5327f0a6b68c071727"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cdee5764b3aa8dbc91ff6a114e9bfc1" id="r_a4cdee5764b3aa8dbc91ff6a114e9bfc1"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a4cdee5764b3aa8dbc91ff6a114e9bfc1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a4cdee5764b3aa8dbc91ff6a114e9bfc1">faceQualityAverage</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>)</td></tr>
<tr class="memdesc:a4cdee5764b3aa8dbc91ff6a114e9bfc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a scalar that is the average of the face quality.  <br /></td></tr>
<tr class="separator:a4cdee5764b3aa8dbc91ff6a114e9bfc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8a8d81401816c73db39eeae352e95bc" id="r_aa8a8d81401816c73db39eeae352e95bc"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:aa8a8d81401816c73db39eeae352e95bc"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classvcl_1_1Matrix.html">typename</a> MeshType::VertexType::QualityType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#aa8a8d81401816c73db39eeae352e95bc">vertexRadiusFromQuality</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>, <a class="el" href="classvcl_1_1Matrix.html">double</a> <a class="el" href="classvcl_1_1Matrix.html">diskRadius</a>, <a class="el" href="classvcl_1_1Matrix.html">double</a> <a class="el" href="classvcl_1_1Matrix.html">radiusVariance</a>, <a class="el" href="classvcl_1_1Matrix.html">bool</a> <a class="el" href="classvcl_1_1Matrix.html">invert</a>=<a class="el" href="classvcl_1_1Matrix.html">false</a>)</td></tr>
<tr class="memdesc:aa8a8d81401816c73db39eeae352e95bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">When performing an adptive pruning for each sample we expect a varying radius to be removed. The radius is a PerVertex attribute that we compute from the current per vertex quality component. The expected radius of the sample is computed so that it linearly maps the quality between diskradius and diskradius*variance.  <br /></td></tr>
<tr class="separator:aa8a8d81401816c73db39eeae352e95bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cbfad9340b842c1bf68c7faf4ff9dc7" id="r_a7cbfad9340b842c1bf68c7faf4ff9dc7"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType, <a class="el" href="classvcl_1_1Matrix.html">typename</a> <a class="el" href="classvcl_1_1Matrix.html">HScalar</a>  = double&gt; </td></tr>
<tr class="memitem:a7cbfad9340b842c1bf68c7faf4ff9dc7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Histogram.html">Histogram</a>&lt; <a class="el" href="classvcl_1_1Matrix.html">HScalar</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a7cbfad9340b842c1bf68c7faf4ff9dc7">vertexQualityHistogram</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>, <a class="el" href="classvcl_1_1Matrix.html">bool</a> <a class="el" href="classvcl_1_1Matrix.html">selectionOnly</a>=<a class="el" href="classvcl_1_1Matrix.html">false</a>, <a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a> <a class="el" href="classvcl_1_1Matrix.html">histSize</a>=10000)</td></tr>
<tr class="separator:a7cbfad9340b842c1bf68c7faf4ff9dc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af44349f8534585f6e0cef128edb98ca0" id="r_af44349f8534585f6e0cef128edb98ca0"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType, <a class="el" href="classvcl_1_1Matrix.html">typename</a> <a class="el" href="classvcl_1_1Matrix.html">HScalar</a>  = double&gt; </td></tr>
<tr class="memitem:af44349f8534585f6e0cef128edb98ca0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Histogram.html">Histogram</a>&lt; <a class="el" href="classvcl_1_1Matrix.html">HScalar</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#af44349f8534585f6e0cef128edb98ca0">faceQualityHistogram</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>, <a class="el" href="classvcl_1_1Matrix.html">bool</a> <a class="el" href="classvcl_1_1Matrix.html">selectionOnly</a>=<a class="el" href="classvcl_1_1Matrix.html">false</a>, <a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a> <a class="el" href="classvcl_1_1Matrix.html">histSize</a>=10000)</td></tr>
<tr class="separator:af44349f8534585f6e0cef128edb98ca0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ebad55b87f91b27b05663d9ce7ad406" id="r_a7ebad55b87f91b27b05663d9ce7ad406"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a7ebad55b87f91b27b05663d9ce7ad406"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a7ebad55b87f91b27b05663d9ce7ad406">vertexSelectionNumber</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>)</td></tr>
<tr class="separator:a7ebad55b87f91b27b05663d9ce7ad406"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5585995167e0f9338ebb153314c0067b" id="r_a5585995167e0f9338ebb153314c0067b"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a5585995167e0f9338ebb153314c0067b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a5585995167e0f9338ebb153314c0067b">faceSelectionNumber</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>)</td></tr>
<tr class="separator:a5585995167e0f9338ebb153314c0067b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c0e3b298085bade007d415e0adff385" id="r_a3c0e3b298085bade007d415e0adff385"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a3c0e3b298085bade007d415e0adff385"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a3c0e3b298085bade007d415e0adff385">faceEdgesSelectionNumber</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>)</td></tr>
<tr class="separator:a3c0e3b298085bade007d415e0adff385"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11baff43762bd72ed51ae9884a8ae4b8" id="r_a11baff43762bd72ed51ae9884a8ae4b8"><td class="memTemplParams" colspan="2">template&lt;EdgeMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a11baff43762bd72ed51ae9884a8ae4b8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a11baff43762bd72ed51ae9884a8ae4b8">edgeSelectionNumber</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>)</td></tr>
<tr class="separator:a11baff43762bd72ed51ae9884a8ae4b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ecd18a495232ac86d4c81913a1ad3f7" id="r_ga8ecd18a495232ac86d4c81913a1ad3f7"><td class="memTemplParams" colspan="2">template&lt;HasBoundingBox MeshType&gt; </td></tr>
<tr class="memitem:ga8ecd18a495232ac86d4c81913a1ad3f7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__update.html#ga8ecd18a495232ac86d4c81913a1ad3f7">updateBoundingBox</a> (MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>)</td></tr>
<tr class="memdesc:ga8ecd18a495232ac86d4c81913a1ad3f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the bounding box of the mesh.  <br /></td></tr>
<tr class="separator:ga8ecd18a495232ac86d4c81913a1ad3f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga38b37b1e8291340239554140dd07bcf2" id="r_ga38b37b1e8291340239554140dd07bcf2"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga38b37b1e8291340239554140dd07bcf2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__update.html#ga38b37b1e8291340239554140dd07bcf2">setPerVertexColor</a> (MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>, <a class="el" href="classvcl_1_1Color.html">vcl::Color</a> c=<a class="el" href="classvcl_1_1Color.html#a002e401382a7608e0c68f42c089057bca933a633d2d20cec2e05a97a403dcd1d4">vcl::Color::White</a>, <a class="el" href="classvcl_1_1Matrix.html">bool</a> <a class="el" href="classvcl_1_1Matrix.html">onlySelected</a>=<a class="el" href="classvcl_1_1Matrix.html">false</a>)</td></tr>
<tr class="memdesc:ga38b37b1e8291340239554140dd07bcf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the color of the vertices. If the <code>onlySelected</code> flag is set to <code>true</code>, only the color of the selected vertices will be set. Otherwise, all the vertices will have the same color.  <br /></td></tr>
<tr class="separator:ga38b37b1e8291340239554140dd07bcf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd40b9510ebcbbc885f2b251eff19c85" id="r_gafd40b9510ebcbbc885f2b251eff19c85"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:gafd40b9510ebcbbc885f2b251eff19c85"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__update.html#gafd40b9510ebcbbc885f2b251eff19c85">setPerFaceColor</a> (MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>, <a class="el" href="classvcl_1_1Color.html">vcl::Color</a> c=<a class="el" href="classvcl_1_1Color.html#a002e401382a7608e0c68f42c089057bca933a633d2d20cec2e05a97a403dcd1d4">vcl::Color::White</a>, <a class="el" href="classvcl_1_1Matrix.html">bool</a> <a class="el" href="classvcl_1_1Matrix.html">onlySelected</a>=<a class="el" href="classvcl_1_1Matrix.html">false</a>)</td></tr>
<tr class="memdesc:gafd40b9510ebcbbc885f2b251eff19c85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the color of the faces. If the <code>onlySelected</code> flag is set to <code>true</code>, only the color of the selected faces will be set. Otherwise, all the faces will have the same color.  <br /></td></tr>
<tr class="separator:gafd40b9510ebcbbc885f2b251eff19c85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0219bcd298aa7039dc3b772d5bf2422d" id="r_ga0219bcd298aa7039dc3b772d5bf2422d"><td class="memTemplParams" colspan="2">template&lt;EdgeMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga0219bcd298aa7039dc3b772d5bf2422d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__update.html#ga0219bcd298aa7039dc3b772d5bf2422d">setPerEdgeColor</a> (MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>, <a class="el" href="classvcl_1_1Color.html">vcl::Color</a> c=<a class="el" href="classvcl_1_1Color.html#a002e401382a7608e0c68f42c089057bca933a633d2d20cec2e05a97a403dcd1d4">vcl::Color::White</a>, <a class="el" href="classvcl_1_1Matrix.html">bool</a> <a class="el" href="classvcl_1_1Matrix.html">onlySelected</a>=<a class="el" href="classvcl_1_1Matrix.html">false</a>)</td></tr>
<tr class="memdesc:ga0219bcd298aa7039dc3b772d5bf2422d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the color of the edges. If the <code>onlySelected</code> flag is set to <code>true</code>, only the color of the selected edges will be set. Otherwise, all the edges will have the same color.  <br /></td></tr>
<tr class="separator:ga0219bcd298aa7039dc3b772d5bf2422d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa7a7bdb880ed18451dbad7b220ad708" id="r_gafa7a7bdb880ed18451dbad7b220ad708"><td class="memTemplParams" colspan="2">template&lt;HasColor MeshType&gt; </td></tr>
<tr class="memitem:gafa7a7bdb880ed18451dbad7b220ad708"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__update.html#gafa7a7bdb880ed18451dbad7b220ad708">setMeshColor</a> (MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>, <a class="el" href="classvcl_1_1Color.html">vcl::Color</a> c=<a class="el" href="classvcl_1_1Color.html#a002e401382a7608e0c68f42c089057bca933a633d2d20cec2e05a97a403dcd1d4">vcl::Color::White</a>)</td></tr>
<tr class="memdesc:gafa7a7bdb880ed18451dbad7b220ad708"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the color component of a mesh.  <br /></td></tr>
<tr class="separator:gafa7a7bdb880ed18451dbad7b220ad708"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga003227edc01710ea2a42c6e326b34698" id="r_ga003227edc01710ea2a42c6e326b34698"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga003227edc01710ea2a42c6e326b34698"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__update.html#ga003227edc01710ea2a42c6e326b34698">setPerVertexColorFromFaceColor</a> (MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>)</td></tr>
<tr class="memdesc:ga003227edc01710ea2a42c6e326b34698"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the vertex colors from its incident face colors, computing a plain average of the face colors.  <br /></td></tr>
<tr class="separator:ga003227edc01710ea2a42c6e326b34698"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga698e981e0c5fd646f3401579735e7825" id="r_ga698e981e0c5fd646f3401579735e7825"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga698e981e0c5fd646f3401579735e7825"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__update.html#ga698e981e0c5fd646f3401579735e7825">setPerFaceColorFromVertexColor</a> (MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>)</td></tr>
<tr class="memdesc:ga698e981e0c5fd646f3401579735e7825"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the face colors from its incident vertex colors, computing a plain average of the vertex colors.  <br /></td></tr>
<tr class="separator:ga698e981e0c5fd646f3401579735e7825"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga74663732e6ecc892378c9a9f4d485b54" id="r_ga74663732e6ecc892378c9a9f4d485b54"><td class="memTemplParams" colspan="2">template&lt;EdgeMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga74663732e6ecc892378c9a9f4d485b54"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__update.html#ga74663732e6ecc892378c9a9f4d485b54">setPerEdgeColorFromVertexColor</a> (MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>)</td></tr>
<tr class="memdesc:ga74663732e6ecc892378c9a9f4d485b54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the edge colors from its incident vertex colors, computing a plain average of the vertex colors.  <br /></td></tr>
<tr class="separator:ga74663732e6ecc892378c9a9f4d485b54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga213cbe42a2c49bda6686e5dee548941f" id="r_ga213cbe42a2c49bda6686e5dee548941f"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga213cbe42a2c49bda6686e5dee548941f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__update.html#ga213cbe42a2c49bda6686e5dee548941f">setPerVertexColorFromQuality</a> (MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>, <a class="el" href="classvcl_1_1Color.html#a32ace7bd7fccf742b39f6cd83042a10f">vcl::Color::ColorMap</a> <a class="el" href="classvcl_1_1Matrix.html">colorMap</a>=<a class="el" href="classvcl_1_1Color.html#a32ace7bd7fccf742b39f6cd83042a10fab41395ae78ccecdb7c2a311a4bb25130">vcl::Color::RedBlue</a>, <a class="el" href="classvcl_1_1Matrix.html">typename</a> MeshType::VertexType::QualityType <a class="el" href="classvcl_1_1Matrix.html">minQuality</a>=0, <a class="el" href="classvcl_1_1Matrix.html">typename</a> MeshType::VertexType::QualityType <a class="el" href="classvcl_1_1Matrix.html">maxQuality</a>=0)</td></tr>
<tr class="memdesc:ga213cbe42a2c49bda6686e5dee548941f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the vertex colors from the quality values by computing a shading in the given color map (default is Red to Blue color map), in the given interval [minQuality, maxQuality].  <br /></td></tr>
<tr class="separator:ga213cbe42a2c49bda6686e5dee548941f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad1237f614680030ae7d2bdc13b2877b6" id="r_gad1237f614680030ae7d2bdc13b2877b6"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:gad1237f614680030ae7d2bdc13b2877b6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__update.html#gad1237f614680030ae7d2bdc13b2877b6">setPerFaceColorFromQuality</a> (MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>, <a class="el" href="classvcl_1_1Color.html#a32ace7bd7fccf742b39f6cd83042a10f">vcl::Color::ColorMap</a> <a class="el" href="classvcl_1_1Matrix.html">colorMap</a>=<a class="el" href="classvcl_1_1Color.html#a32ace7bd7fccf742b39f6cd83042a10fab41395ae78ccecdb7c2a311a4bb25130">vcl::Color::RedBlue</a>, <a class="el" href="classvcl_1_1Matrix.html">typename</a> MeshType::FaceType::QualityType <a class="el" href="classvcl_1_1Matrix.html">minQuality</a>=0, <a class="el" href="classvcl_1_1Matrix.html">typename</a> MeshType::FaceType::QualityType <a class="el" href="classvcl_1_1Matrix.html">maxQuality</a>=0)</td></tr>
<tr class="memdesc:gad1237f614680030ae7d2bdc13b2877b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the face colors from the quality values by computing a shading in the given color map (default is Red to Blue color map), in the given interval [minQuality, maxQuality].  <br /></td></tr>
<tr class="separator:gad1237f614680030ae7d2bdc13b2877b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb208445ca45b8758d9522c420694f38" id="r_gadb208445ca45b8758d9522c420694f38"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:gadb208445ca45b8758d9522c420694f38"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__update.html#gadb208445ca45b8758d9522c420694f38">setPerVertexColorFromFaceBorderFlag</a> (MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>, <a class="el" href="classvcl_1_1Color.html">Color</a> <a class="el" href="classvcl_1_1Matrix.html">borderColor</a>=<a class="el" href="classvcl_1_1Color.html#a002e401382a7608e0c68f42c089057bcaf54d29d341201c1ef87b86671a29b28e">vcl::Color::Blue</a>, <a class="el" href="classvcl_1_1Color.html">Color</a> <a class="el" href="classvcl_1_1Matrix.html">internalColor</a>=<a class="el" href="classvcl_1_1Color.html#a002e401382a7608e0c68f42c089057bca933a633d2d20cec2e05a97a403dcd1d4">vcl::Color::White</a>, <a class="el" href="classvcl_1_1Color.html">Color</a> <a class="el" href="classvcl_1_1Matrix.html">mixColor</a>=<a class="el" href="classvcl_1_1Color.html#a002e401382a7608e0c68f42c089057bcaa70f19981682325e9f47020f45097ab3">vcl::Color::Cyan</a>)</td></tr>
<tr class="memdesc:gadb208445ca45b8758d9522c420694f38"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classvcl_1_1Color.html" title="The Color class represents a 32 bit color.">Color</a> the vertices of the mesh that are on border, using the border flags of the faces.  <br /></td></tr>
<tr class="separator:gadb208445ca45b8758d9522c420694f38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaefda81ff00c7e8d3b5ff19c9e90c03bf" id="r_gaefda81ff00c7e8d3b5ff19c9e90c03bf"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:gaefda81ff00c7e8d3b5ff19c9e90c03bf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__update.html#gaefda81ff00c7e8d3b5ff19c9e90c03bf">setPerFaceColorFromConnectedComponents</a> (MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>, <a class="el" href="classvcl_1_1Matrix.html">const</a> std::vector&lt; std::set&lt; <a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a> &gt; &gt; &amp;<a class="el" href="group__clean.html#ga774f9a47e9cef107d59b97d0434177f7">connectedComponents</a>)</td></tr>
<tr class="memdesc:gaefda81ff00c7e8d3b5ff19c9e90c03bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an already computed vector of sets of connected components (see vcl::connectedComponents(m) in <code>vclib/algorithms/clean.h</code>), sets face colors according from connected components of the mesh. Each connected component will have a different per face color.  <br /></td></tr>
<tr class="separator:gaefda81ff00c7e8d3b5ff19c9e90c03bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga39a8c9027a5e7c936518969bda799f71" id="r_ga39a8c9027a5e7c936518969bda799f71"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga39a8c9027a5e7c936518969bda799f71"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__update.html#ga39a8c9027a5e7c936518969bda799f71">setPerFaceColorFromConnectedComponents</a> (MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>)</td></tr>
<tr class="memdesc:ga39a8c9027a5e7c936518969bda799f71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets face colors according from connected components of the mesh. Each connected component will have a different per face color. Since this function will need to compute connected components of the mesh, also per <a class="el" href="classvcl_1_1Face.html" title="The Face class represents an Face element of the vcl::Mesh class.">Face</a> AdjacentFaces component is required.  <br /></td></tr>
<tr class="separator:ga39a8c9027a5e7c936518969bda799f71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga318a121ea66deb73b4d95ca0ec311290" id="r_ga318a121ea66deb73b4d95ca0ec311290"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga318a121ea66deb73b4d95ca0ec311290"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__update.html#ga318a121ea66deb73b4d95ca0ec311290">setPerFaceColorScattering</a> (MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>, <a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a> <a class="el" href="classvcl_1_1Matrix.html">nColors</a>=50, <a class="el" href="classvcl_1_1Matrix.html">bool</a> <a class="el" href="classvcl_1_1Matrix.html">checkFauxEdges</a>=<a class="el" href="classvcl_1_1Matrix.html">true</a>)</td></tr>
<tr class="memdesc:ga318a121ea66deb73b4d95ca0ec311290"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function colors each face of the mesh using a given number of scattering colors (default number is 50). By default, colors uniformely adjacent faces having faux edges in common. This check is made only if the option <code>checkFauxEdges</code> is set to true, and if the per <a class="el" href="classvcl_1_1Face.html" title="The Face class represents an Face element of the vcl::Mesh class.">Face</a> AdjacentFaces component is available in the mesh.  <br /></td></tr>
<tr class="separator:ga318a121ea66deb73b4d95ca0ec311290"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga37b2b7fbbfce106c039cb86ad7994335" id="r_ga37b2b7fbbfce106c039cb86ad7994335"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType, PointConcept PointType&gt; </td></tr>
<tr class="memitem:ga37b2b7fbbfce106c039cb86ad7994335"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__update.html#ga37b2b7fbbfce106c039cb86ad7994335">setPerVertexColorPerlinNoise</a> (MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>, PointType <a class="el" href="classvcl_1_1Matrix.html">period</a>, PointType offset=PointType(0, 0, 0), <a class="el" href="classvcl_1_1Matrix.html">bool</a> <a class="el" href="classvcl_1_1Matrix.html">onSelected</a>=<a class="el" href="classvcl_1_1Matrix.html">false</a>)</td></tr>
<tr class="memdesc:ga37b2b7fbbfce106c039cb86ad7994335"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the vertex color according to a perlin noise computed on the vertex coordinates.  <br /></td></tr>
<tr class="separator:ga37b2b7fbbfce106c039cb86ad7994335"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga48d79f5a79d36e16d20272ccdb3f56e5" id="r_ga48d79f5a79d36e16d20272ccdb3f56e5"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType, PointConcept PointType&gt; </td></tr>
<tr class="memitem:ga48d79f5a79d36e16d20272ccdb3f56e5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__update.html#ga48d79f5a79d36e16d20272ccdb3f56e5">setPerVertexPerlinColor</a> (MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>, <a class="el" href="classvcl_1_1Matrix.html">double</a> <a class="el" href="classvcl_1_1Matrix.html">period</a>, PointType offset=PointType(0, 0, 0), <a class="el" href="classvcl_1_1Color.html">Color</a> <a class="el" href="classvcl_1_1Matrix.html">color1</a>=<a class="el" href="classvcl_1_1Color.html#a002e401382a7608e0c68f42c089057bca5777c5f96e2970090b99598c215292f7">Color::Black</a>, <a class="el" href="classvcl_1_1Color.html">Color</a> <a class="el" href="classvcl_1_1Matrix.html">color2</a>=<a class="el" href="classvcl_1_1Color.html#a002e401382a7608e0c68f42c089057bca933a633d2d20cec2e05a97a403dcd1d4">Color::White</a>, <a class="el" href="classvcl_1_1Matrix.html">bool</a> <a class="el" href="classvcl_1_1Matrix.html">onSelected</a>=<a class="el" href="classvcl_1_1Matrix.html">false</a>)</td></tr>
<tr class="memdesc:ga48d79f5a79d36e16d20272ccdb3f56e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple Perlin color mixing. <code>color1</code> and <code>color2</code> are mixed according the perlin noise function, with <code>period</code> and <code>offset</code>.  <br /></td></tr>
<tr class="separator:ga48d79f5a79d36e16d20272ccdb3f56e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0953cccb4f94dded63edb630530e2197" id="r_a0953cccb4f94dded63edb630530e2197"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType, LoggerConcept LogType = NullLogger&gt; </td></tr>
<tr class="memitem:a0953cccb4f94dded63edb630530e2197"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a0953cccb4f94dded63edb630530e2197">updatePrincipalCurvatureTaubin95</a> (MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>, <a class="el" href="classvcl_1_1Matrix.html">LogType</a> &amp;log)</td></tr>
<tr class="separator:a0953cccb4f94dded63edb630530e2197"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac053ed0caa29edc306e54201f0bf6123" id="r_ac053ed0caa29edc306e54201f0bf6123"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType, LoggerConcept LogType = NullLogger&gt; </td></tr>
<tr class="memitem:ac053ed0caa29edc306e54201f0bf6123"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ac053ed0caa29edc306e54201f0bf6123">updatePrincipalCurvaturePCA</a> (MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>, <a class="el" href="classvcl_1_1Matrix.html">typename</a> MeshType::VertexType::CoordType::ScalarType radius, <a class="el" href="classvcl_1_1Matrix.html">bool</a> <a class="el" href="classvcl_1_1Matrix.html">montecarloSampling</a>=<a class="el" href="classvcl_1_1Matrix.html">true</a>, <a class="el" href="classvcl_1_1Matrix.html">LogType</a> &amp;log=<a class="el" href="group__miscellaneous.html#ga3377e3c875ec245e90ac5a395105ce99">nullLogger</a>)</td></tr>
<tr class="memdesc:ac053ed0caa29edc306e54201f0bf6123"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the Principal Curvature meseaure as described in the paper: Robust principal curvatures on Multiple Scales, Yong-Liang Yang, Yu-Kun Lai, Shi-Min Hu Helmut Pottmann SGP 2004. If montecarloSampling==true the covariance is computed by montecarlo sampling on the mesh (faster); If montecarloSampling==false the covariance is computed by (analytic)integration over the surface (slower).  <br /></td></tr>
<tr class="separator:ac053ed0caa29edc306e54201f0bf6123"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c1237fab955f1bf4329842c6d3ed51a" id="r_a3c1237fab955f1bf4329842c6d3ed51a"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType, LoggerConcept LogType = NullLogger&gt; </td></tr>
<tr class="memitem:a3c1237fab955f1bf4329842c6d3ed51a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a3c1237fab955f1bf4329842c6d3ed51a">updatePrincipalCurvature</a> (MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>, <a class="el" href="classvcl_1_1Matrix.html">LogType</a> &amp;log=<a class="el" href="group__miscellaneous.html#ga3377e3c875ec245e90ac5a395105ce99">nullLogger</a>)</td></tr>
<tr class="separator:a3c1237fab955f1bf4329842c6d3ed51a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b3ad75679b446aabe75e8f1701bce67" id="r_a8b3ad75679b446aabe75e8f1701bce67"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType, LoggerConcept LogType = NullLogger&gt; </td></tr>
<tr class="memitem:a8b3ad75679b446aabe75e8f1701bce67"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a8b3ad75679b446aabe75e8f1701bce67">updatePrincipalCurvature</a> (MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>, <a class="el" href="namespacevcl.html#aaca879a6bfd47ff8429d6b2f6cfa9440">VCLibPrincipalCurvatureAlgorithm</a> <a class="el" href="classvcl_1_1Matrix.html">alg</a>=<a class="el" href="namespacevcl.html#aaca879a6bfd47ff8429d6b2f6cfa9440a16e818963316b0b43fcbdec6d75f25ed">VCL_PRINCIPAL_CURVATURE_TAUBIN95</a>, <a class="el" href="classvcl_1_1Matrix.html">LogType</a> &amp;log=<a class="el" href="group__miscellaneous.html#ga3377e3c875ec245e90ac5a395105ce99">nullLogger</a>)</td></tr>
<tr class="separator:a8b3ad75679b446aabe75e8f1701bce67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a359b253b8af6d1ae3ac24625e8ac7a56" id="r_a359b253b8af6d1ae3ac24625e8ac7a56"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a359b253b8af6d1ae3ac24625e8ac7a56"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a359b253b8af6d1ae3ac24625e8ac7a56">updateBorder</a> (MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>)</td></tr>
<tr class="memdesc:a359b253b8af6d1ae3ac24625e8ac7a56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes per-face border flags without requiring any kind of topology info.  <br /></td></tr>
<tr class="separator:a359b253b8af6d1ae3ac24625e8ac7a56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c9ac6a7be92ef3620293918623eac14" id="r_a5c9ac6a7be92ef3620293918623eac14"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a> ELEM_ID, LoggerConcept LogType = NullLogger&gt; </td></tr>
<tr class="memitem:a5c9ac6a7be92ef3620293918623eac14"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a5c9ac6a7be92ef3620293918623eac14">clearPerElementNormals</a> (MeshConcept <a class="el" href="classvcl_1_1Matrix.html">auto</a> &amp;mesh, <a class="el" href="classvcl_1_1Matrix.html">LogType</a> &amp;log=<a class="el" href="group__miscellaneous.html#ga3377e3c875ec245e90ac5a395105ce99">nullLogger</a>)</td></tr>
<tr class="memdesc:a5c9ac6a7be92ef3620293918623eac14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets to zero the normals of all the <code>ELEM_ID</code> elements of the mesh, including the unreferenced ones.  <br /></td></tr>
<tr class="separator:a5c9ac6a7be92ef3620293918623eac14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a033ff1897830e289bcecfd482bfe9074" id="r_a033ff1897830e289bcecfd482bfe9074"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a> ELEM_ID, LoggerConcept LogType = NullLogger&gt; </td></tr>
<tr class="memitem:a033ff1897830e289bcecfd482bfe9074"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a033ff1897830e289bcecfd482bfe9074">normalizePerElementNormals</a> (MeshConcept <a class="el" href="classvcl_1_1Matrix.html">auto</a> &amp;mesh, <a class="el" href="classvcl_1_1Matrix.html">LogType</a> &amp;log=<a class="el" href="group__miscellaneous.html#ga3377e3c875ec245e90ac5a395105ce99">nullLogger</a>)</td></tr>
<tr class="memdesc:a033ff1897830e289bcecfd482bfe9074"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalizes the length of the normals of all the <code>ELEM_ID</code> elements.  <br /></td></tr>
<tr class="separator:a033ff1897830e289bcecfd482bfe9074"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd84dece22955e70f1ae77fc5c8d6b24" id="r_abd84dece22955e70f1ae77fc5c8d6b24"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a> ELEM_ID, <a class="el" href="classvcl_1_1Matrix.html">typename</a> <a class="el" href="classvcl_1_1Matrix.html">MScalar</a> , LoggerConcept LogType = NullLogger&gt; </td></tr>
<tr class="memitem:abd84dece22955e70f1ae77fc5c8d6b24"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#abd84dece22955e70f1ae77fc5c8d6b24">multiplyPerElementNormalsByMatrix</a> (MeshConcept <a class="el" href="classvcl_1_1Matrix.html">auto</a> &amp;mesh, <a class="el" href="namespacevcl.html#a2b8b0e2e4450f76fb433f95326f85e6d">Matrix33</a>&lt; <a class="el" href="classvcl_1_1Matrix.html">MScalar</a> &gt; <a class="el" href="classvcl_1_1Matrix.html">mat</a>, <a class="el" href="classvcl_1_1Matrix.html">bool</a> <a class="el" href="classvcl_1_1Matrix.html">removeScalingFromMatrix</a>=<a class="el" href="classvcl_1_1Matrix.html">true</a>, <a class="el" href="classvcl_1_1Matrix.html">LogType</a> &amp;log=<a class="el" href="group__miscellaneous.html#ga3377e3c875ec245e90ac5a395105ce99">nullLogger</a>)</td></tr>
<tr class="memdesc:abd84dece22955e70f1ae77fc5c8d6b24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies the normals of all the <code>ELEM_ID</code> elements by the given 3x3 <a class="el" href="classvcl_1_1Matrix.html">Matrix</a>.  <br /></td></tr>
<tr class="separator:abd84dece22955e70f1ae77fc5c8d6b24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a304004401342d3afd55a2dd3a521d807" id="r_a304004401342d3afd55a2dd3a521d807"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a> ELEM_ID, <a class="el" href="classvcl_1_1Matrix.html">typename</a> <a class="el" href="classvcl_1_1Matrix.html">MScalar</a> , LoggerConcept LogType = NullLogger&gt; </td></tr>
<tr class="memitem:a304004401342d3afd55a2dd3a521d807"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a304004401342d3afd55a2dd3a521d807">multiplyPerElementNormalsByMatrix</a> (MeshConcept <a class="el" href="classvcl_1_1Matrix.html">auto</a> &amp;mesh, <a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="namespacevcl.html#a1ebaf363f3eba42f665854a59613068c">Matrix44</a>&lt; <a class="el" href="classvcl_1_1Matrix.html">MScalar</a> &gt; &amp;<a class="el" href="classvcl_1_1Matrix.html">mat</a>, <a class="el" href="classvcl_1_1Matrix.html">bool</a> <a class="el" href="classvcl_1_1Matrix.html">removeScalingFromMatrix</a>=<a class="el" href="classvcl_1_1Matrix.html">true</a>, <a class="el" href="classvcl_1_1Matrix.html">LogType</a> &amp;log=<a class="el" href="group__miscellaneous.html#ga3377e3c875ec245e90ac5a395105ce99">nullLogger</a>)</td></tr>
<tr class="memdesc:a304004401342d3afd55a2dd3a521d807"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies the normals of all the <code>ELEM_ID</code> elements by the given TRS 4x4 <a class="el" href="classvcl_1_1Matrix.html">Matrix</a>.  <br /></td></tr>
<tr class="separator:a304004401342d3afd55a2dd3a521d807"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96aac67d3963514cab5023c1749f8cd7" id="r_a96aac67d3963514cab5023c1749f8cd7"><td class="memTemplParams" colspan="2">template&lt;LoggerConcept LogType = NullLogger&gt; </td></tr>
<tr class="memitem:a96aac67d3963514cab5023c1749f8cd7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a96aac67d3963514cab5023c1749f8cd7">clearPerVertexNormals</a> (MeshConcept <a class="el" href="classvcl_1_1Matrix.html">auto</a> &amp;mesh, <a class="el" href="classvcl_1_1Matrix.html">LogType</a> &amp;log=<a class="el" href="group__miscellaneous.html#ga3377e3c875ec245e90ac5a395105ce99">nullLogger</a>)</td></tr>
<tr class="memdesc:a96aac67d3963514cab5023c1749f8cd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as clearPerElementNormals, but for the vertex normals.  <br /></td></tr>
<tr class="separator:a96aac67d3963514cab5023c1749f8cd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a385c6f0e9e2d7ad9df7f19e967163331" id="r_a385c6f0e9e2d7ad9df7f19e967163331"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType, LoggerConcept LogType = NullLogger&gt; </td></tr>
<tr class="memitem:a385c6f0e9e2d7ad9df7f19e967163331"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a385c6f0e9e2d7ad9df7f19e967163331">clearPerReferencedVertexNormals</a> (MeshType &amp;mesh, <a class="el" href="classvcl_1_1Matrix.html">LogType</a> &amp;log=<a class="el" href="group__miscellaneous.html#ga3377e3c875ec245e90ac5a395105ce99">nullLogger</a>)</td></tr>
<tr class="memdesc:a385c6f0e9e2d7ad9df7f19e967163331"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets to zero all the normals of vertices that are referenced by at least one element, leaving unchanged all the normals of the unreferenced vertices that may be still useful.  <br /></td></tr>
<tr class="separator:a385c6f0e9e2d7ad9df7f19e967163331"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad02648e687324278cf2df5230af63c22" id="r_ad02648e687324278cf2df5230af63c22"><td class="memTemplParams" colspan="2">template&lt;LoggerConcept LogType = NullLogger&gt; </td></tr>
<tr class="memitem:ad02648e687324278cf2df5230af63c22"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ad02648e687324278cf2df5230af63c22">clearPerFaceNormals</a> (FaceMeshConcept <a class="el" href="classvcl_1_1Matrix.html">auto</a> &amp;mesh, <a class="el" href="classvcl_1_1Matrix.html">LogType</a> &amp;log=<a class="el" href="group__miscellaneous.html#ga3377e3c875ec245e90ac5a395105ce99">nullLogger</a>)</td></tr>
<tr class="memdesc:ad02648e687324278cf2df5230af63c22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as clearPerElementNormals, but for the face normals.  <br /></td></tr>
<tr class="separator:ad02648e687324278cf2df5230af63c22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacf4094f5263defa68fd1e925f5e967d" id="r_aacf4094f5263defa68fd1e925f5e967d"><td class="memTemplParams" colspan="2">template&lt;LoggerConcept LogType = NullLogger&gt; </td></tr>
<tr class="memitem:aacf4094f5263defa68fd1e925f5e967d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#aacf4094f5263defa68fd1e925f5e967d">normalizePerVertexNormals</a> (MeshConcept <a class="el" href="classvcl_1_1Matrix.html">auto</a> &amp;mesh, <a class="el" href="classvcl_1_1Matrix.html">LogType</a> &amp;log=<a class="el" href="group__miscellaneous.html#ga3377e3c875ec245e90ac5a395105ce99">nullLogger</a>)</td></tr>
<tr class="memdesc:aacf4094f5263defa68fd1e925f5e967d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as normalizePerElementNormals, but for the vertex normals.  <br /></td></tr>
<tr class="separator:aacf4094f5263defa68fd1e925f5e967d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb813f7e8bd797fe133e12b9c356ffa4" id="r_acb813f7e8bd797fe133e12b9c356ffa4"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType, LoggerConcept LogType = NullLogger&gt; </td></tr>
<tr class="memitem:acb813f7e8bd797fe133e12b9c356ffa4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#acb813f7e8bd797fe133e12b9c356ffa4">normalizePerReferencedVertexNormals</a> (MeshType &amp;mesh, <a class="el" href="classvcl_1_1Matrix.html">LogType</a> &amp;log=<a class="el" href="group__miscellaneous.html#ga3377e3c875ec245e90ac5a395105ce99">nullLogger</a>)</td></tr>
<tr class="memdesc:acb813f7e8bd797fe133e12b9c356ffa4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalizes the length of normals the referenced vertices.  <br /></td></tr>
<tr class="separator:acb813f7e8bd797fe133e12b9c356ffa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9d81a913adbce049dfe4ebb667b833c" id="r_af9d81a913adbce049dfe4ebb667b833c"><td class="memTemplParams" colspan="2">template&lt;LoggerConcept LogType = NullLogger&gt; </td></tr>
<tr class="memitem:af9d81a913adbce049dfe4ebb667b833c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#af9d81a913adbce049dfe4ebb667b833c">normalizePerFaceNormals</a> (FaceMeshConcept <a class="el" href="classvcl_1_1Matrix.html">auto</a> &amp;mesh, <a class="el" href="classvcl_1_1Matrix.html">LogType</a> &amp;log=<a class="el" href="group__miscellaneous.html#ga3377e3c875ec245e90ac5a395105ce99">nullLogger</a>)</td></tr>
<tr class="memdesc:af9d81a913adbce049dfe4ebb667b833c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as normalizePerElementNormals, but for the face normals.  <br /></td></tr>
<tr class="separator:af9d81a913adbce049dfe4ebb667b833c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a884a9e1e47cbc016ed1dc5ce1fa6e37a" id="r_a884a9e1e47cbc016ed1dc5ce1fa6e37a"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classvcl_1_1Matrix.html">typename</a> <a class="el" href="classvcl_1_1Matrix.html">Matrix</a> , LoggerConcept LogType = NullLogger&gt; </td></tr>
<tr class="memitem:a884a9e1e47cbc016ed1dc5ce1fa6e37a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a884a9e1e47cbc016ed1dc5ce1fa6e37a">multiplyPerVertexNormalsByMatrix</a> (MeshConcept <a class="el" href="classvcl_1_1Matrix.html">auto</a> &amp;mesh, <a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="classvcl_1_1Matrix.html">Matrix</a> &amp;<a class="el" href="classvcl_1_1Matrix.html">mat</a>, <a class="el" href="classvcl_1_1Matrix.html">bool</a> <a class="el" href="classvcl_1_1Matrix.html">removeScalingFromMatrix</a>=<a class="el" href="classvcl_1_1Matrix.html">true</a>, <a class="el" href="classvcl_1_1Matrix.html">LogType</a> &amp;log=<a class="el" href="group__miscellaneous.html#ga3377e3c875ec245e90ac5a395105ce99">nullLogger</a>)</td></tr>
<tr class="memdesc:a884a9e1e47cbc016ed1dc5ce1fa6e37a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as multiplyPerElementNormalsByMatrix, but for the vertex normals.  <br /></td></tr>
<tr class="separator:a884a9e1e47cbc016ed1dc5ce1fa6e37a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad958cfae923a7b224814e64c78f6a9bb" id="r_ad958cfae923a7b224814e64c78f6a9bb"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classvcl_1_1Matrix.html">typename</a> <a class="el" href="classvcl_1_1Matrix.html">Matrix</a> , LoggerConcept LogType = NullLogger&gt; </td></tr>
<tr class="memitem:ad958cfae923a7b224814e64c78f6a9bb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ad958cfae923a7b224814e64c78f6a9bb">multiplyPerFaceNormalsByMatrix</a> (FaceMeshConcept <a class="el" href="classvcl_1_1Matrix.html">auto</a> &amp;mesh, <a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="classvcl_1_1Matrix.html">Matrix</a> &amp;<a class="el" href="classvcl_1_1Matrix.html">mat</a>, <a class="el" href="classvcl_1_1Matrix.html">bool</a> <a class="el" href="classvcl_1_1Matrix.html">removeScalingFromMatrix</a>=<a class="el" href="classvcl_1_1Matrix.html">true</a>, <a class="el" href="classvcl_1_1Matrix.html">LogType</a> &amp;log=<a class="el" href="group__miscellaneous.html#ga3377e3c875ec245e90ac5a395105ce99">nullLogger</a>)</td></tr>
<tr class="memdesc:ad958cfae923a7b224814e64c78f6a9bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as multiplyPerElementNormalsByMatrix, but for the face normals.  <br /></td></tr>
<tr class="separator:ad958cfae923a7b224814e64c78f6a9bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30ed1f8a6c4deb5ed255be33dec7ae1a" id="r_a30ed1f8a6c4deb5ed255be33dec7ae1a"><td class="memTemplParams" colspan="2">template&lt;LoggerConcept LogType = NullLogger&gt; </td></tr>
<tr class="memitem:a30ed1f8a6c4deb5ed255be33dec7ae1a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a30ed1f8a6c4deb5ed255be33dec7ae1a">updatePerFaceNormals</a> (FaceMeshConcept <a class="el" href="classvcl_1_1Matrix.html">auto</a> &amp;mesh, <a class="el" href="classvcl_1_1Matrix.html">bool</a> <a class="el" href="classvcl_1_1Matrix.html">normalize</a>=<a class="el" href="classvcl_1_1Matrix.html">true</a>, <a class="el" href="classvcl_1_1Matrix.html">LogType</a> &amp;log=<a class="el" href="group__miscellaneous.html#ga3377e3c875ec245e90ac5a395105ce99">nullLogger</a>)</td></tr>
<tr class="memdesc:a30ed1f8a6c4deb5ed255be33dec7ae1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes and sets the face normal.  <br /></td></tr>
<tr class="separator:a30ed1f8a6c4deb5ed255be33dec7ae1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab34ff241ba6e9a67648a4c86abc55624" id="r_ab34ff241ba6e9a67648a4c86abc55624"><td class="memTemplParams" colspan="2">template&lt;LoggerConcept LogType = NullLogger&gt; </td></tr>
<tr class="memitem:ab34ff241ba6e9a67648a4c86abc55624"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ab34ff241ba6e9a67648a4c86abc55624">updatePerVertexNormals</a> (FaceMeshConcept <a class="el" href="classvcl_1_1Matrix.html">auto</a> &amp;mesh, <a class="el" href="classvcl_1_1Matrix.html">bool</a> <a class="el" href="classvcl_1_1Matrix.html">normalize</a>=<a class="el" href="classvcl_1_1Matrix.html">true</a>, <a class="el" href="classvcl_1_1Matrix.html">LogType</a> &amp;log=<a class="el" href="group__miscellaneous.html#ga3377e3c875ec245e90ac5a395105ce99">nullLogger</a>)</td></tr>
<tr class="memdesc:ab34ff241ba6e9a67648a4c86abc55624"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the vertex normal as the classic area weighted average.  <br /></td></tr>
<tr class="separator:ab34ff241ba6e9a67648a4c86abc55624"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3c5aa91fdd7c8d4e5123493184f511d" id="r_ae3c5aa91fdd7c8d4e5123493184f511d"><td class="memTemplParams" colspan="2">template&lt;LoggerConcept LogType = NullLogger&gt; </td></tr>
<tr class="memitem:ae3c5aa91fdd7c8d4e5123493184f511d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ae3c5aa91fdd7c8d4e5123493184f511d">updatePerVertexNormalsFromFaceNormals</a> (FaceMeshConcept <a class="el" href="classvcl_1_1Matrix.html">auto</a> &amp;mesh, <a class="el" href="classvcl_1_1Matrix.html">bool</a> <a class="el" href="classvcl_1_1Matrix.html">normalize</a>=<a class="el" href="classvcl_1_1Matrix.html">true</a>, <a class="el" href="classvcl_1_1Matrix.html">LogType</a> &amp;log=<a class="el" href="group__miscellaneous.html#ga3377e3c875ec245e90ac5a395105ce99">nullLogger</a>)</td></tr>
<tr class="memdesc:ae3c5aa91fdd7c8d4e5123493184f511d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the vertex normal as the sum of the adjacent faces normals.  <br /></td></tr>
<tr class="separator:ae3c5aa91fdd7c8d4e5123493184f511d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a063ce05a627948b7fc5fbaa80bd8330d" id="r_a063ce05a627948b7fc5fbaa80bd8330d"><td class="memTemplParams" colspan="2">template&lt;LoggerConcept LogType = NullLogger&gt; </td></tr>
<tr class="memitem:a063ce05a627948b7fc5fbaa80bd8330d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a063ce05a627948b7fc5fbaa80bd8330d">updatePerVertexAndFaceNormals</a> (FaceMeshConcept <a class="el" href="classvcl_1_1Matrix.html">auto</a> &amp;mesh, <a class="el" href="classvcl_1_1Matrix.html">bool</a> <a class="el" href="classvcl_1_1Matrix.html">normalize</a>=<a class="el" href="classvcl_1_1Matrix.html">true</a>, <a class="el" href="classvcl_1_1Matrix.html">LogType</a> &amp;log=<a class="el" href="group__miscellaneous.html#ga3377e3c875ec245e90ac5a395105ce99">nullLogger</a>)</td></tr>
<tr class="memdesc:a063ce05a627948b7fc5fbaa80bd8330d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the face normals and then vertex normal as the angle weighted average.  <br /></td></tr>
<tr class="separator:a063ce05a627948b7fc5fbaa80bd8330d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad76bd2acfb577ac0946b35ee8b9acdb7" id="r_ad76bd2acfb577ac0946b35ee8b9acdb7"><td class="memTemplParams" colspan="2">template&lt;LoggerConcept LogType = NullLogger&gt; </td></tr>
<tr class="memitem:ad76bd2acfb577ac0946b35ee8b9acdb7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ad76bd2acfb577ac0946b35ee8b9acdb7">updatePerVertexNormalsAngleWeighted</a> (FaceMeshConcept <a class="el" href="classvcl_1_1Matrix.html">auto</a> &amp;mesh, <a class="el" href="classvcl_1_1Matrix.html">bool</a> <a class="el" href="classvcl_1_1Matrix.html">normalize</a>=<a class="el" href="classvcl_1_1Matrix.html">true</a>, <a class="el" href="classvcl_1_1Matrix.html">LogType</a> &amp;log=<a class="el" href="group__miscellaneous.html#ga3377e3c875ec245e90ac5a395105ce99">nullLogger</a>)</td></tr>
<tr class="memdesc:ad76bd2acfb577ac0946b35ee8b9acdb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the vertex normal as an angle weighted average.  <br /></td></tr>
<tr class="separator:ad76bd2acfb577ac0946b35ee8b9acdb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a764d9748bb6e05ba976be88ee7abe459" id="r_a764d9748bb6e05ba976be88ee7abe459"><td class="memTemplParams" colspan="2">template&lt;LoggerConcept LogType = NullLogger&gt; </td></tr>
<tr class="memitem:a764d9748bb6e05ba976be88ee7abe459"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a764d9748bb6e05ba976be88ee7abe459">updatePerVertexNormalsNelsonMaxWeighted</a> (FaceMeshConcept <a class="el" href="classvcl_1_1Matrix.html">auto</a> &amp;mesh, <a class="el" href="classvcl_1_1Matrix.html">bool</a> <a class="el" href="classvcl_1_1Matrix.html">normalize</a>=<a class="el" href="classvcl_1_1Matrix.html">true</a>, <a class="el" href="classvcl_1_1Matrix.html">LogType</a> &amp;log=<a class="el" href="group__miscellaneous.html#ga3377e3c875ec245e90ac5a395105ce99">nullLogger</a>)</td></tr>
<tr class="memdesc:a764d9748bb6e05ba976be88ee7abe459"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the vertex normal using the Max et al. weighting scheme.  <br /></td></tr>
<tr class="separator:a764d9748bb6e05ba976be88ee7abe459"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a745a7eed34f93850095b2c81f127d9f6" id="r_a745a7eed34f93850095b2c81f127d9f6"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a745a7eed34f93850095b2c81f127d9f6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a745a7eed34f93850095b2c81f127d9f6">setPerVertexQuality</a> (MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>, <a class="el" href="classvcl_1_1Matrix.html">typename</a> MeshType::VertexType::QualityType s)</td></tr>
<tr class="memdesc:a745a7eed34f93850095b2c81f127d9f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a constant value to all the vertex quality of the mesh.  <br /></td></tr>
<tr class="separator:a745a7eed34f93850095b2c81f127d9f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa949e95f7bfb9d8dedc0f7e15e5d3ab9" id="r_aa949e95f7bfb9d8dedc0f7e15e5d3ab9"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:aa949e95f7bfb9d8dedc0f7e15e5d3ab9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#aa949e95f7bfb9d8dedc0f7e15e5d3ab9">setPerFaceQuality</a> (MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>, <a class="el" href="classvcl_1_1Matrix.html">typename</a> MeshType::FaceType::QualityType s)</td></tr>
<tr class="memdesc:aa949e95f7bfb9d8dedc0f7e15e5d3ab9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a constant value to all the face quality of the mesh.  <br /></td></tr>
<tr class="separator:aa949e95f7bfb9d8dedc0f7e15e5d3ab9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a696dc0c7e7d1e45751850aaa7a51f247" id="r_a696dc0c7e7d1e45751850aaa7a51f247"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a696dc0c7e7d1e45751850aaa7a51f247"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a696dc0c7e7d1e45751850aaa7a51f247">clampPerVertexQuality</a> (MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>, <a class="el" href="classvcl_1_1Matrix.html">typename</a> MeshType::VertexType::QualityType <a class="el" href="classvcl_1_1Matrix.html">minS</a>, <a class="el" href="classvcl_1_1Matrix.html">typename</a> MeshType::VertexType::QualityType <a class="el" href="classvcl_1_1Matrix.html">maxS</a>)</td></tr>
<tr class="memdesc:a696dc0c7e7d1e45751850aaa7a51f247"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clamps the vertex quality of a mesh in a given interval.  <br /></td></tr>
<tr class="separator:a696dc0c7e7d1e45751850aaa7a51f247"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a748cd8beb49f3c7a18dbd1efdcd8bf21" id="r_a748cd8beb49f3c7a18dbd1efdcd8bf21"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a748cd8beb49f3c7a18dbd1efdcd8bf21"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a748cd8beb49f3c7a18dbd1efdcd8bf21">clampPerFaceQuality</a> (MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>, <a class="el" href="classvcl_1_1Matrix.html">typename</a> MeshType::FaceType::QualityType <a class="el" href="classvcl_1_1Matrix.html">minS</a>, <a class="el" href="classvcl_1_1Matrix.html">typename</a> MeshType::FaceType::QualityType <a class="el" href="classvcl_1_1Matrix.html">maxS</a>)</td></tr>
<tr class="memdesc:a748cd8beb49f3c7a18dbd1efdcd8bf21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clamps the face quality of a mesh in a given interval.  <br /></td></tr>
<tr class="separator:a748cd8beb49f3c7a18dbd1efdcd8bf21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1a6ca42d06d208218a4aa820f220696" id="r_ad1a6ca42d06d208218a4aa820f220696"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ad1a6ca42d06d208218a4aa820f220696"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ad1a6ca42d06d208218a4aa820f220696">normalizePerVertexQuality</a> (MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>, <a class="el" href="classvcl_1_1Matrix.html">typename</a> MeshType::VertexType::QualityType <a class="el" href="classvcl_1_1Matrix.html">minS</a>=0, <a class="el" href="classvcl_1_1Matrix.html">typename</a> MeshType::VertexType::QualityType <a class="el" href="classvcl_1_1Matrix.html">maxS</a>=1)</td></tr>
<tr class="memdesc:ad1a6ca42d06d208218a4aa820f220696"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalizes the vertex quality of a mesh in a given interval (default [0, 1]).  <br /></td></tr>
<tr class="separator:ad1a6ca42d06d208218a4aa820f220696"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a607cbcdaf24e6dd7cec3e23a28fb450f" id="r_a607cbcdaf24e6dd7cec3e23a28fb450f"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a607cbcdaf24e6dd7cec3e23a28fb450f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a607cbcdaf24e6dd7cec3e23a28fb450f">normalizePerFaceQuality</a> (MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>, <a class="el" href="classvcl_1_1Matrix.html">typename</a> MeshType::FaceType::QualityType <a class="el" href="classvcl_1_1Matrix.html">minS</a>=0, <a class="el" href="classvcl_1_1Matrix.html">typename</a> MeshType::FaceType::QualityType <a class="el" href="classvcl_1_1Matrix.html">maxS</a>=1)</td></tr>
<tr class="memdesc:a607cbcdaf24e6dd7cec3e23a28fb450f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalizes the face quality of a mesh in a given interval (default [0, 1]).  <br /></td></tr>
<tr class="separator:a607cbcdaf24e6dd7cec3e23a28fb450f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8b71c44c2c2e9adcc6bad8e278e7010" id="r_af8b71c44c2c2e9adcc6bad8e278e7010"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:af8b71c44c2c2e9adcc6bad8e278e7010"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#af8b71c44c2c2e9adcc6bad8e278e7010">setPerVertexQualityFromVertexValence</a> (MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>)</td></tr>
<tr class="memdesc:af8b71c44c2c2e9adcc6bad8e278e7010"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign to the vertex quality of the mesh the valence of each vertex, that is the number of adjacent faces of the vertex.  <br /></td></tr>
<tr class="separator:af8b71c44c2c2e9adcc6bad8e278e7010"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9e9aa9515cb4086de430109e361cfde" id="r_ab9e9aa9515cb4086de430109e361cfde"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ab9e9aa9515cb4086de430109e361cfde"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ab9e9aa9515cb4086de430109e361cfde">setPerFaceQualityFromFaceArea</a> (MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>)</td></tr>
<tr class="memdesc:ab9e9aa9515cb4086de430109e361cfde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign to the face quality of the mesh the area of each face.  <br /></td></tr>
<tr class="separator:ab9e9aa9515cb4086de430109e361cfde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b31235ba7d846238e202713eaaa0495" id="r_a2b31235ba7d846238e202713eaaa0495"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a2b31235ba7d846238e202713eaaa0495"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a2b31235ba7d846238e202713eaaa0495">setPerVertexQualityFromPrincipalCurvatureGaussian</a> (MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>)</td></tr>
<tr class="separator:a2b31235ba7d846238e202713eaaa0495"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88a3a13cc9462bac2a7e1e578cddf540" id="r_a88a3a13cc9462bac2a7e1e578cddf540"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a88a3a13cc9462bac2a7e1e578cddf540"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a88a3a13cc9462bac2a7e1e578cddf540">setPerVertexQualityFromPrincipalCurvatureMean</a> (MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>)</td></tr>
<tr class="separator:a88a3a13cc9462bac2a7e1e578cddf540"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88daff53e6272feb2b26432246c0f848" id="r_a88daff53e6272feb2b26432246c0f848"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a88daff53e6272feb2b26432246c0f848"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a88daff53e6272feb2b26432246c0f848">setPerVertexQualityFromPrincipalCurvatureMinValue</a> (MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>)</td></tr>
<tr class="separator:a88daff53e6272feb2b26432246c0f848"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b1d34773ec1878660fe407a4768b67b" id="r_a7b1d34773ec1878660fe407a4768b67b"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a7b1d34773ec1878660fe407a4768b67b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a7b1d34773ec1878660fe407a4768b67b">setPerVertexQualityFromPrincipalCurvatureMaxValue</a> (MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>)</td></tr>
<tr class="separator:a7b1d34773ec1878660fe407a4768b67b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fa908d1710912a11715aedca11ecb76" id="r_a2fa908d1710912a11715aedca11ecb76"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a2fa908d1710912a11715aedca11ecb76"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a2fa908d1710912a11715aedca11ecb76">setPerVertexQualityFromPrincipalCurvatureShapeIndex</a> (MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>)</td></tr>
<tr class="memdesc:a2fa908d1710912a11715aedca11ecb76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the Shape Index S from the Principal Curvature, as defined by [Koenderink 1992] and stores it in the per-vertex quality.  <br /></td></tr>
<tr class="separator:a2fa908d1710912a11715aedca11ecb76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4120bcf201dd0de7e75bbd2e39a658df" id="r_a4120bcf201dd0de7e75bbd2e39a658df"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a4120bcf201dd0de7e75bbd2e39a658df"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a4120bcf201dd0de7e75bbd2e39a658df">setPerVertexQualityFromPrincipalCurvatureCurvedness</a> (MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>)</td></tr>
<tr class="memdesc:a4120bcf201dd0de7e75bbd2e39a658df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the Curvedness C from the Principal Curvature, as defined by [Koenderink 1992] and stores it in the per-vertex quality.  <br /></td></tr>
<tr class="separator:a4120bcf201dd0de7e75bbd2e39a658df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b0bc5dbd8005d39d14ccf664ffca33c" id="r_a7b0bc5dbd8005d39d14ccf664ffca33c"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a7b0bc5dbd8005d39d14ccf664ffca33c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a7b0bc5dbd8005d39d14ccf664ffca33c">clearVertexSelection</a> (MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>)</td></tr>
<tr class="separator:a7b0bc5dbd8005d39d14ccf664ffca33c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb5edd39f9dd2fc2220d8b08be523e29" id="r_abb5edd39f9dd2fc2220d8b08be523e29"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:abb5edd39f9dd2fc2220d8b08be523e29"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#abb5edd39f9dd2fc2220d8b08be523e29">clearFaceSelection</a> (MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>)</td></tr>
<tr class="separator:abb5edd39f9dd2fc2220d8b08be523e29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abae51c1f51e5b5ca5f12018bb6ae1a40" id="r_abae51c1f51e5b5ca5f12018bb6ae1a40"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:abae51c1f51e5b5ca5f12018bb6ae1a40"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#abae51c1f51e5b5ca5f12018bb6ae1a40">clearFaceEdgesSelection</a> (MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>)</td></tr>
<tr class="separator:abae51c1f51e5b5ca5f12018bb6ae1a40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0416a0056c7bbd35f81e72bb9b536db0" id="r_a0416a0056c7bbd35f81e72bb9b536db0"><td class="memTemplParams" colspan="2">template&lt;EdgeMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a0416a0056c7bbd35f81e72bb9b536db0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a0416a0056c7bbd35f81e72bb9b536db0">clearEdgeSelection</a> (MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>)</td></tr>
<tr class="separator:a0416a0056c7bbd35f81e72bb9b536db0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaec6c356404a0bf3eb24a29e867004df" id="r_aaec6c356404a0bf3eb24a29e867004df"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:aaec6c356404a0bf3eb24a29e867004df"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#aaec6c356404a0bf3eb24a29e867004df">selectNonManifoldVertices</a> (MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>, <a class="el" href="classvcl_1_1Matrix.html">bool</a> <a class="el" href="classvcl_1_1Matrix.html">clearSelectionFirst</a>)</td></tr>
<tr class="separator:aaec6c356404a0bf3eb24a29e867004df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad22242be96fcd8ea8fd0f4ab4bd9c8fa" id="r_ad22242be96fcd8ea8fd0f4ab4bd9c8fa"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ad22242be96fcd8ea8fd0f4ab4bd9c8fa"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ad22242be96fcd8ea8fd0f4ab4bd9c8fa">selectCreaseFaceEdges</a> (MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>, <a class="el" href="classvcl_1_1Matrix.html">double</a> <a class="el" href="classvcl_1_1Matrix.html">angleRadNeg</a>, <a class="el" href="classvcl_1_1Matrix.html">double</a> <a class="el" href="classvcl_1_1Matrix.html">angleRadPos</a>, <a class="el" href="classvcl_1_1Matrix.html">bool</a> <a class="el" href="classvcl_1_1Matrix.html">alsoBorderEdges</a>=<a class="el" href="classvcl_1_1Matrix.html">false</a>)</td></tr>
<tr class="separator:ad22242be96fcd8ea8fd0f4ab4bd9c8fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54e8371c2ddda188c9540ea7e7bddf78" id="r_a54e8371c2ddda188c9540ea7e7bddf78"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a54e8371c2ddda188c9540ea7e7bddf78"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a54e8371c2ddda188c9540ea7e7bddf78">clearPerVertexAdjacentFaces</a> (MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>)</td></tr>
<tr class="memdesc:a54e8371c2ddda188c9540ea7e7bddf78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the adjacent faces of each vertex of the mesh.  <br /></td></tr>
<tr class="separator:a54e8371c2ddda188c9540ea7e7bddf78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3ecae45cc9e58f948dc04178fd6669b" id="r_af3ecae45cc9e58f948dc04178fd6669b"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:af3ecae45cc9e58f948dc04178fd6669b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#af3ecae45cc9e58f948dc04178fd6669b">updatePerVertexAdjacentFaces</a> (MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>)</td></tr>
<tr class="memdesc:af3ecae45cc9e58f948dc04178fd6669b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the adjacent faces of each vertex of the mesh.  <br /></td></tr>
<tr class="separator:af3ecae45cc9e58f948dc04178fd6669b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a312c8ca27b3e94994a1f03bc1a3d826d" id="r_a312c8ca27b3e94994a1f03bc1a3d826d"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a312c8ca27b3e94994a1f03bc1a3d826d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a312c8ca27b3e94994a1f03bc1a3d826d">clearPerVertexAdjacentVertices</a> (MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>)</td></tr>
<tr class="memdesc:a312c8ca27b3e94994a1f03bc1a3d826d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the adjacent vertices of each vertex of the mesh.  <br /></td></tr>
<tr class="separator:a312c8ca27b3e94994a1f03bc1a3d826d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b6e8d46b2b867729d95c72ab1925df2" id="r_a6b6e8d46b2b867729d95c72ab1925df2"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a6b6e8d46b2b867729d95c72ab1925df2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a6b6e8d46b2b867729d95c72ab1925df2">updatePerVertexAdjacentVertices</a> (MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>)</td></tr>
<tr class="memdesc:a6b6e8d46b2b867729d95c72ab1925df2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the adjacent vertices of each vertex of the mesh.  <br /></td></tr>
<tr class="separator:a6b6e8d46b2b867729d95c72ab1925df2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec301aa1e068ae4ceeeef43761b9ee04" id="r_aec301aa1e068ae4ceeeef43761b9ee04"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:aec301aa1e068ae4ceeeef43761b9ee04"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#aec301aa1e068ae4ceeeef43761b9ee04">clearPerFaceAdjacentFaces</a> (MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>)</td></tr>
<tr class="memdesc:aec301aa1e068ae4ceeeef43761b9ee04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the adjacent faces of each face of the mesh.  <br /></td></tr>
<tr class="separator:aec301aa1e068ae4ceeeef43761b9ee04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3db69fc234fc8072747aabf1724f9b92" id="r_a3db69fc234fc8072747aabf1724f9b92"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a3db69fc234fc8072747aabf1724f9b92"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a3db69fc234fc8072747aabf1724f9b92">updatePerFaceAdjacentFaces</a> (MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>)</td></tr>
<tr class="memdesc:a3db69fc234fc8072747aabf1724f9b92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the per face adjacent face component.  <br /></td></tr>
<tr class="separator:a3db69fc234fc8072747aabf1724f9b92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90d821ff0dab1c3c45fdfe82ce48448f" id="r_a90d821ff0dab1c3c45fdfe82ce48448f"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType, <a class="el" href="classvcl_1_1Matrix.html">typename</a> <a class="el" href="classvcl_1_1Matrix.html">ScalarM</a> &gt; </td></tr>
<tr class="memitem:a90d821ff0dab1c3c45fdfe82ce48448f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a90d821ff0dab1c3c45fdfe82ce48448f">applyTransformMatrix</a> (MeshType &amp;mesh, <a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="namespacevcl.html#a1ebaf363f3eba42f665854a59613068c">Matrix44</a>&lt; <a class="el" href="classvcl_1_1Matrix.html">ScalarM</a> &gt; &amp;<a class="el" href="classvcl_1_1Matrix.html">matrix</a>, <a class="el" href="classvcl_1_1Matrix.html">bool</a> <a class="el" href="classvcl_1_1Matrix.html">updateNormals</a>=<a class="el" href="classvcl_1_1Matrix.html">true</a>)</td></tr>
<tr class="separator:a90d821ff0dab1c3c45fdfe82ce48448f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c4a60eeed3ddead3611508975cb6045" id="r_a7c4a60eeed3ddead3611508975cb6045"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType, PointConcept PointType&gt; </td></tr>
<tr class="memitem:a7c4a60eeed3ddead3611508975cb6045"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a7c4a60eeed3ddead3611508975cb6045">translate</a> (MeshType &amp;mesh, <a class="el" href="classvcl_1_1Matrix.html">const</a> PointType &amp;<a class="el" href="classvcl_1_1Matrix.html">t</a>)</td></tr>
<tr class="separator:a7c4a60eeed3ddead3611508975cb6045"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5217f309d49911db6e36a4f6d31acdaa" id="r_a5217f309d49911db6e36a4f6d31acdaa"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType, PointConcept PointType&gt; </td></tr>
<tr class="memitem:a5217f309d49911db6e36a4f6d31acdaa"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a5217f309d49911db6e36a4f6d31acdaa">scale</a> (MeshType &amp;mesh, <a class="el" href="classvcl_1_1Matrix.html">const</a> PointType &amp;s)</td></tr>
<tr class="separator:a5217f309d49911db6e36a4f6d31acdaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7f4da00ff716cc6e58e2e9ade275d6a" id="r_ad7f4da00ff716cc6e58e2e9ade275d6a"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType, <a class="el" href="classvcl_1_1Matrix.html">typename</a> Scalar  = double&gt; </td></tr>
<tr class="memitem:ad7f4da00ff716cc6e58e2e9ade275d6a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ad7f4da00ff716cc6e58e2e9ade275d6a">scale</a> (MeshType &amp;mesh, <a class="el" href="classvcl_1_1Matrix.html">const</a> Scalar &amp;s)</td></tr>
<tr class="separator:ad7f4da00ff716cc6e58e2e9ade275d6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6bb8ad7dfb2216bcaee9bdd3e4d8e12" id="r_ac6bb8ad7dfb2216bcaee9bdd3e4d8e12"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType, <a class="el" href="classvcl_1_1Matrix.html">typename</a> Scalar &gt; </td></tr>
<tr class="memitem:ac6bb8ad7dfb2216bcaee9bdd3e4d8e12"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ac6bb8ad7dfb2216bcaee9bdd3e4d8e12">rotate</a> (MeshType &amp;mesh, <a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="namespacevcl.html#a2b8b0e2e4450f76fb433f95326f85e6d">Matrix33</a>&lt; Scalar &gt; &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>, <a class="el" href="classvcl_1_1Matrix.html">bool</a> <a class="el" href="classvcl_1_1Matrix.html">updateNormals</a>=<a class="el" href="classvcl_1_1Matrix.html">true</a>)</td></tr>
<tr class="separator:ac6bb8ad7dfb2216bcaee9bdd3e4d8e12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebd717b5286241cd152d92711bb16bbf" id="r_aebd717b5286241cd152d92711bb16bbf"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType, PointConcept PointType, <a class="el" href="classvcl_1_1Matrix.html">typename</a> Scalar  = double&gt; </td></tr>
<tr class="memitem:aebd717b5286241cd152d92711bb16bbf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#aebd717b5286241cd152d92711bb16bbf">rotate</a> (MeshType &amp;mesh, <a class="el" href="classvcl_1_1Matrix.html">const</a> PointType &amp;<a class="el" href="classvcl_1_1Matrix.html">axis</a>, <a class="el" href="classvcl_1_1Matrix.html">const</a> Scalar &amp;<a class="el" href="classvcl_1_1Matrix.html">angleRad</a>, <a class="el" href="classvcl_1_1Matrix.html">bool</a> <a class="el" href="classvcl_1_1Matrix.html">updateNormals</a>=<a class="el" href="classvcl_1_1Matrix.html">true</a>)</td></tr>
<tr class="separator:aebd717b5286241cd152d92711bb16bbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5adf25d966528e8fee208143f6e894b4" id="r_a5adf25d966528e8fee208143f6e894b4"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType, PointConcept PointType, <a class="el" href="classvcl_1_1Matrix.html">typename</a> Scalar  = double&gt; </td></tr>
<tr class="memitem:a5adf25d966528e8fee208143f6e894b4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a5adf25d966528e8fee208143f6e894b4">rotateDeg</a> (MeshType &amp;mesh, <a class="el" href="classvcl_1_1Matrix.html">const</a> PointType &amp;<a class="el" href="classvcl_1_1Matrix.html">axis</a>, <a class="el" href="classvcl_1_1Matrix.html">const</a> Scalar &amp;<a class="el" href="classvcl_1_1Matrix.html">angleDeg</a>, <a class="el" href="classvcl_1_1Matrix.html">bool</a> <a class="el" href="classvcl_1_1Matrix.html">updateNormals</a>=<a class="el" href="classvcl_1_1Matrix.html">true</a>)</td></tr>
<tr class="separator:a5adf25d966528e8fee208143f6e894b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c3f56025fbf5454a944171424439fca" id="r_a8c3f56025fbf5454a944171424439fca"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classvcl_1_1Matrix.html">unsigned</a> <a class="el" href="classvcl_1_1Matrix.html">char</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a8c3f56025fbf5454a944171424439fca">loadImageData</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> std::string &amp;<a class="el" href="classvcl_1_1Matrix.html">filename</a>, <a class="el" href="classvcl_1_1Matrix.html">int</a> &amp;w, <a class="el" href="classvcl_1_1Matrix.html">int</a> &amp;<a class="el" href="classvcl_1_1Matrix.html">h</a>)</td></tr>
<tr class="separator:a8c3f56025fbf5454a944171424439fca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7970b2e595a2606a0a6d38a792cd3ad" id="r_ab7970b2e595a2606a0a6d38a792cd3ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ab7970b2e595a2606a0a6d38a792cd3ad">saveImageData</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> std::string &amp;<a class="el" href="classvcl_1_1Matrix.html">filename</a>, <a class="el" href="classvcl_1_1Matrix.html">int</a> w, <a class="el" href="classvcl_1_1Matrix.html">int</a> <a class="el" href="classvcl_1_1Matrix.html">h</a>, <a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="classvcl_1_1Matrix.html">unsigned</a> <a class="el" href="classvcl_1_1Matrix.html">char</a> *data, <a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a> quality=90)</td></tr>
<tr class="separator:ab7970b2e595a2606a0a6d38a792cd3ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a214c7dfb93183997081c69d2008b7904" id="r_a214c7dfb93183997081c69d2008b7904"><td class="memItemLeft" align="right" valign="top">std::ifstream&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a214c7dfb93183997081c69d2008b7904">openInputFileStream</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> std::string &amp;<a class="el" href="classvcl_1_1Matrix.html">filename</a>, <a class="el" href="classvcl_1_1Matrix.html">const</a> std::string &amp;<a class="el" href="classvcl_1_1Matrix.html">ext</a>=&quot;&quot;)</td></tr>
<tr class="memdesc:a214c7dfb93183997081c69d2008b7904"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open an input stream from a file.  <br /></td></tr>
<tr class="separator:a214c7dfb93183997081c69d2008b7904"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30dae01a527b0defe0f238b3b0b510b8" id="r_a30dae01a527b0defe0f238b3b0b510b8"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a30dae01a527b0defe0f238b3b0b510b8">readNextNonEmptyLine</a> (std::istream &amp;<a class="el" href="classvcl_1_1Matrix.html">file</a>)</td></tr>
<tr class="memdesc:a30dae01a527b0defe0f238b3b0b510b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads and returns the next non-empty line from a txt stream.  <br /></td></tr>
<tr class="separator:a30dae01a527b0defe0f238b3b0b510b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3982745418fd935c79298714bdf9f75" id="r_aa3982745418fd935c79298714bdf9f75"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#aa3982745418fd935c79298714bdf9f75">readNextNonEmptyLineNoThrow</a> (std::istream &amp;<a class="el" href="classvcl_1_1Matrix.html">file</a>)</td></tr>
<tr class="memdesc:aa3982745418fd935c79298714bdf9f75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads and returns the next non-empty line from a txt stream.  <br /></td></tr>
<tr class="separator:aa3982745418fd935c79298714bdf9f75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b5e5d8a685a997ee41edc94bc5136c1" id="r_a8b5e5d8a685a997ee41edc94bc5136c1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Tokenizer.html">vcl::Tokenizer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a8b5e5d8a685a997ee41edc94bc5136c1">readAndTokenizeNextNonEmptyLine</a> (std::istream &amp;<a class="el" href="classvcl_1_1Matrix.html">file</a>, <a class="el" href="classvcl_1_1Matrix.html">char</a> <a class="el" href="classvcl_1_1Matrix.html">separator</a>=' ')</td></tr>
<tr class="memdesc:a8b5e5d8a685a997ee41edc94bc5136c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads and returns the next non-empty line from a txt stream, tokenized with the given separator.  <br /></td></tr>
<tr class="separator:a8b5e5d8a685a997ee41edc94bc5136c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb72715db26888853fcf3ee0e3fe18e8" id="r_adb72715db26888853fcf3ee0e3fe18e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Tokenizer.html">vcl::Tokenizer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#adb72715db26888853fcf3ee0e3fe18e8">readAndTokenizeNextNonEmptyLineNoThrow</a> (std::istream &amp;<a class="el" href="classvcl_1_1Matrix.html">file</a>, <a class="el" href="classvcl_1_1Matrix.html">char</a> <a class="el" href="classvcl_1_1Matrix.html">separator</a>=' ')</td></tr>
<tr class="memdesc:adb72715db26888853fcf3ee0e3fe18e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads and returns the next non-empty line from a txt stream, tokenized with the given separator.  <br /></td></tr>
<tr class="separator:adb72715db26888853fcf3ee0e3fe18e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18e098749891a7daa5a62a0f768bac62" id="r_a18e098749891a7daa5a62a0f768bac62"><td class="memTemplParams" colspan="2">template&lt;IsNotClass T&gt; </td></tr>
<tr class="memitem:a18e098749891a7daa5a62a0f768bac62"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a18e098749891a7daa5a62a0f768bac62">deserialize</a> (std::istream &amp;is, T &amp;data, std::endian endian)</td></tr>
<tr class="memdesc:a18e098749891a7daa5a62a0f768bac62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deserialize data from an input stream, using the specified endian format.  <br /></td></tr>
<tr class="separator:a18e098749891a7daa5a62a0f768bac62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adba0ad72ed6db7296eac1c91786ca106" id="r_adba0ad72ed6db7296eac1c91786ca106"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classvcl_1_1Matrix.html">typename</a> T &gt; </td></tr>
<tr class="memitem:adba0ad72ed6db7296eac1c91786ca106"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#adba0ad72ed6db7296eac1c91786ca106">deserializeN</a> (std::istream &amp;is, T *data, std::size_t size, std::endian endian=std::endian::little)</td></tr>
<tr class="memdesc:adba0ad72ed6db7296eac1c91786ca106"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deserialize an array of contiguous data from an input stream, using the specified format.  <br /></td></tr>
<tr class="separator:adba0ad72ed6db7296eac1c91786ca106"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a801af2c87c0523fd06c3adafecc9b2fb" id="r_a801af2c87c0523fd06c3adafecc9b2fb"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classvcl_1_1Matrix.html">typename</a> T , typename... Others&gt; </td></tr>
<tr class="memitem:a801af2c87c0523fd06c3adafecc9b2fb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a801af2c87c0523fd06c3adafecc9b2fb">deserialize</a> (std::istream &amp;is, T &amp;data, <a class="el" href="classvcl_1_1Matrix.html">Others</a> &amp;... <a class="el" href="classvcl_1_1Matrix.html">others</a>)</td></tr>
<tr class="separator:a801af2c87c0523fd06c3adafecc9b2fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17051e34bedc366cb41d655f7365a071" id="r_a17051e34bedc366cb41d655f7365a071"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classvcl_1_1Matrix.html">typename</a> T , std::size_t N&gt; </td></tr>
<tr class="memitem:a17051e34bedc366cb41d655f7365a071"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a17051e34bedc366cb41d655f7365a071">deserialize</a> (std::istream &amp;is, std::array&lt; T, <a class="el" href="classvcl_1_1Matrix.html">N</a> &gt; &amp;<a class="el" href="classvcl_1_1Matrix.html">a</a>)</td></tr>
<tr class="memdesc:a17051e34bedc366cb41d655f7365a071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deserialize specializations ///.  <br /></td></tr>
<tr class="separator:a17051e34bedc366cb41d655f7365a071"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2b134ebe097914129ec9e8c8ecaf10a" id="r_af2b134ebe097914129ec9e8c8ecaf10a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#af2b134ebe097914129ec9e8c8ecaf10a">deserialize</a> (std::istream &amp;is, std::string &amp;s)</td></tr>
<tr class="separator:af2b134ebe097914129ec9e8c8ecaf10a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9fed85edca355a0134d16d95c47419a" id="r_af9fed85edca355a0134d16d95c47419a"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classvcl_1_1Matrix.html">typename</a> T &gt; </td></tr>
<tr class="memitem:af9fed85edca355a0134d16d95c47419a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#af9fed85edca355a0134d16d95c47419a">deserialize</a> (std::istream &amp;is, std::vector&lt; T &gt; &amp;v)</td></tr>
<tr class="separator:af9fed85edca355a0134d16d95c47419a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0f9865a748e4167c16d86a685220bc5" id="r_ae0f9865a748e4167c16d86a685220bc5"><td class="memTemplParams" colspan="2">template&lt;IsNotClass T&gt; </td></tr>
<tr class="memitem:ae0f9865a748e4167c16d86a685220bc5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ae0f9865a748e4167c16d86a685220bc5">serialize</a> (std::ostream &amp;<a class="el" href="classvcl_1_1Matrix.html">os</a>, <a class="el" href="classvcl_1_1Matrix.html">const</a> T &amp;data, std::endian endian)</td></tr>
<tr class="memdesc:ae0f9865a748e4167c16d86a685220bc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialize data to an output stream, using the specified endian format.  <br /></td></tr>
<tr class="separator:ae0f9865a748e4167c16d86a685220bc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80c041438e1f1466941101be64525eda" id="r_a80c041438e1f1466941101be64525eda"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classvcl_1_1Matrix.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a80c041438e1f1466941101be64525eda"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a80c041438e1f1466941101be64525eda">serializeN</a> (std::ostream &amp;<a class="el" href="classvcl_1_1Matrix.html">os</a>, <a class="el" href="classvcl_1_1Matrix.html">const</a> T *data, std::size_t size, std::endian endian=std::endian::little)</td></tr>
<tr class="memdesc:a80c041438e1f1466941101be64525eda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialize an array of contiguous data to an output stream, using the specified format.  <br /></td></tr>
<tr class="separator:a80c041438e1f1466941101be64525eda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ed54da403c1a9f64bc3a0d01b47b4d0" id="r_a8ed54da403c1a9f64bc3a0d01b47b4d0"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classvcl_1_1Matrix.html">typename</a> T , typename... Others&gt; </td></tr>
<tr class="memitem:a8ed54da403c1a9f64bc3a0d01b47b4d0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a8ed54da403c1a9f64bc3a0d01b47b4d0">serialize</a> (std::ostream &amp;<a class="el" href="classvcl_1_1Matrix.html">os</a>, <a class="el" href="classvcl_1_1Matrix.html">const</a> T &amp;data, <a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="classvcl_1_1Matrix.html">Others</a> &amp;... <a class="el" href="classvcl_1_1Matrix.html">others</a>)</td></tr>
<tr class="separator:a8ed54da403c1a9f64bc3a0d01b47b4d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1752045db61b3ba5688131a9795199b1" id="r_a1752045db61b3ba5688131a9795199b1"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classvcl_1_1Matrix.html">typename</a> T , std::size_t N&gt; </td></tr>
<tr class="memitem:a1752045db61b3ba5688131a9795199b1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a1752045db61b3ba5688131a9795199b1">serialize</a> (std::ostream &amp;<a class="el" href="classvcl_1_1Matrix.html">os</a>, <a class="el" href="classvcl_1_1Matrix.html">const</a> std::array&lt; T, <a class="el" href="classvcl_1_1Matrix.html">N</a> &gt; &amp;<a class="el" href="classvcl_1_1Matrix.html">a</a>)</td></tr>
<tr class="memdesc:a1752045db61b3ba5688131a9795199b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialize specializations ///.  <br /></td></tr>
<tr class="separator:a1752045db61b3ba5688131a9795199b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4b850dbc2d9419d8f8bce37ea4a6e68" id="r_ac4b850dbc2d9419d8f8bce37ea4a6e68"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ac4b850dbc2d9419d8f8bce37ea4a6e68">serialize</a> (std::ostream &amp;<a class="el" href="classvcl_1_1Matrix.html">os</a>, <a class="el" href="classvcl_1_1Matrix.html">const</a> std::string &amp;s)</td></tr>
<tr class="separator:ac4b850dbc2d9419d8f8bce37ea4a6e68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab54d08593ddeb3bded76b3c06ae69ba5" id="r_ab54d08593ddeb3bded76b3c06ae69ba5"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classvcl_1_1Matrix.html">typename</a> T &gt; </td></tr>
<tr class="memitem:ab54d08593ddeb3bded76b3c06ae69ba5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ab54d08593ddeb3bded76b3c06ae69ba5">serialize</a> (std::ostream &amp;<a class="el" href="classvcl_1_1Matrix.html">os</a>, <a class="el" href="classvcl_1_1Matrix.html">const</a> std::vector&lt; T &gt; &amp;v)</td></tr>
<tr class="separator:ab54d08593ddeb3bded76b3c06ae69ba5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea5f889621e9a85c0c893d082b34b474" id="r_aea5f889621e9a85c0c893d082b34b474"><td class="memItemLeft" align="right" valign="top">std::ofstream&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#aea5f889621e9a85c0c893d082b34b474">openOutputFileStream</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> std::string &amp;<a class="el" href="classvcl_1_1Matrix.html">filename</a>, <a class="el" href="classvcl_1_1Matrix.html">const</a> std::string &amp;<a class="el" href="classvcl_1_1Matrix.html">ext</a>=&quot;&quot;)</td></tr>
<tr class="separator:aea5f889621e9a85c0c893d082b34b474"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac557c4a143d0e7c137c1e92099d9f105" id="r_ac557c4a143d0e7c137c1e92099d9f105"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1MeshInfo.html">MeshInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ac557c4a143d0e7c137c1e92099d9f105">formatCapability</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> std::string &amp;format)</td></tr>
<tr class="separator:ac557c4a143d0e7c137c1e92099d9f105"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3db844790e39aca57d8c05410eb25eee" id="r_ga3db844790e39aca57d8c05410eb25eee"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType, LoggerConcept LogType = NullLogger&gt; </td></tr>
<tr class="memitem:ga3db844790e39aca57d8c05410eb25eee"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__load.html#ga3db844790e39aca57d8c05410eb25eee">load</a> (MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>, <a class="el" href="classvcl_1_1Matrix.html">const</a> std::string &amp;<a class="el" href="classvcl_1_1Matrix.html">filename</a>, <a class="el" href="classvcl_1_1MeshInfo.html">MeshInfo</a> &amp;<a class="el" href="classvcl_1_1Matrix.html">loadedInfo</a>, <a class="el" href="classvcl_1_1Matrix.html">LogType</a> &amp;log=<a class="el" href="group__miscellaneous.html#ga3377e3c875ec245e90ac5a395105ce99">nullLogger</a>, <a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="structvcl_1_1LoadSettings.html">LoadSettings</a> &amp;<a class="el" href="classvcl_1_1Matrix.html">settings</a>=<a class="el" href="structvcl_1_1LoadSettings.html">LoadSettings</a>())</td></tr>
<tr class="memdesc:ga3db844790e39aca57d8c05410eb25eee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads a mesh from a file with the given filename and stores it in the given mesh object. Checks automatically the file format to load from the given filename.  <br /></td></tr>
<tr class="separator:ga3db844790e39aca57d8c05410eb25eee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f909ea2ad3fcd89af0e9b28103c7ea2" id="r_ga2f909ea2ad3fcd89af0e9b28103c7ea2"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType, LoggerConcept LogType = NullLogger&gt; </td></tr>
<tr class="memitem:ga2f909ea2ad3fcd89af0e9b28103c7ea2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__load.html#ga2f909ea2ad3fcd89af0e9b28103c7ea2">load</a> (MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>, <a class="el" href="classvcl_1_1Matrix.html">const</a> std::string &amp;<a class="el" href="classvcl_1_1Matrix.html">filename</a>, <a class="el" href="classvcl_1_1Matrix.html">LogType</a> &amp;log=<a class="el" href="group__miscellaneous.html#ga3377e3c875ec245e90ac5a395105ce99">nullLogger</a>, <a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="structvcl_1_1LoadSettings.html">LoadSettings</a> &amp;<a class="el" href="classvcl_1_1Matrix.html">settings</a>=<a class="el" href="structvcl_1_1LoadSettings.html">LoadSettings</a>())</td></tr>
<tr class="memdesc:ga2f909ea2ad3fcd89af0e9b28103c7ea2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads a mesh from a file with the given filename and stores it in the given mesh object. Checks automatically the file format to load from the given filename.  <br /></td></tr>
<tr class="separator:ga2f909ea2ad3fcd89af0e9b28103c7ea2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab87677c7c4cfcf616df35ae1cb0347c2" id="r_gab87677c7c4cfcf616df35ae1cb0347c2"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType, LoggerConcept LogType = NullLogger&gt; </td></tr>
<tr class="memitem:gab87677c7c4cfcf616df35ae1cb0347c2"><td class="memTemplItemLeft" align="right" valign="top">MeshType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__load.html#gab87677c7c4cfcf616df35ae1cb0347c2">load</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> std::string &amp;<a class="el" href="classvcl_1_1Matrix.html">filename</a>, <a class="el" href="classvcl_1_1MeshInfo.html">MeshInfo</a> &amp;<a class="el" href="classvcl_1_1Matrix.html">loadedInfo</a>, <a class="el" href="classvcl_1_1Matrix.html">LogType</a> &amp;log=<a class="el" href="group__miscellaneous.html#ga3377e3c875ec245e90ac5a395105ce99">nullLogger</a>, <a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="structvcl_1_1LoadSettings.html">LoadSettings</a> &amp;<a class="el" href="classvcl_1_1Matrix.html">settings</a>=<a class="el" href="structvcl_1_1LoadSettings.html">LoadSettings</a>())</td></tr>
<tr class="memdesc:gab87677c7c4cfcf616df35ae1cb0347c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads a mesh from a file with the given filename and stores it in the returned mesh object. Checks automatically the file format to load from the given filename.  <br /></td></tr>
<tr class="separator:gab87677c7c4cfcf616df35ae1cb0347c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga269e46f3e70647a909d8d07d3875fc0a" id="r_ga269e46f3e70647a909d8d07d3875fc0a"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType, LoggerConcept LogType = NullLogger&gt; </td></tr>
<tr class="memitem:ga269e46f3e70647a909d8d07d3875fc0a"><td class="memTemplItemLeft" align="right" valign="top">MeshType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__load.html#ga269e46f3e70647a909d8d07d3875fc0a">load</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> std::string &amp;<a class="el" href="classvcl_1_1Matrix.html">filename</a>, <a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="structvcl_1_1LoadSettings.html">LoadSettings</a> &amp;<a class="el" href="classvcl_1_1Matrix.html">settings</a>, <a class="el" href="classvcl_1_1Matrix.html">LogType</a> &amp;log=<a class="el" href="group__miscellaneous.html#ga3377e3c875ec245e90ac5a395105ce99">nullLogger</a>)</td></tr>
<tr class="memdesc:ga269e46f3e70647a909d8d07d3875fc0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads a mesh from a file with the given filename and stores it in the returned mesh object. Checks automatically the file format to load from the given filename.  <br /></td></tr>
<tr class="separator:ga269e46f3e70647a909d8d07d3875fc0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac416e5f3f89e8f6eda94faaa0f6c34ba" id="r_gac416e5f3f89e8f6eda94faaa0f6c34ba"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType, LoggerConcept LogType = NullLogger&gt; </td></tr>
<tr class="memitem:gac416e5f3f89e8f6eda94faaa0f6c34ba"><td class="memTemplItemLeft" align="right" valign="top">MeshType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__load.html#gac416e5f3f89e8f6eda94faaa0f6c34ba">load</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> std::string &amp;<a class="el" href="classvcl_1_1Matrix.html">filename</a>, <a class="el" href="classvcl_1_1Matrix.html">LogType</a> &amp;log=<a class="el" href="group__miscellaneous.html#ga3377e3c875ec245e90ac5a395105ce99">nullLogger</a>, <a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="structvcl_1_1LoadSettings.html">LoadSettings</a> &amp;<a class="el" href="classvcl_1_1Matrix.html">settings</a>=<a class="el" href="structvcl_1_1LoadSettings.html">LoadSettings</a>())</td></tr>
<tr class="memdesc:gac416e5f3f89e8f6eda94faaa0f6c34ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads a mesh from a file with the given filename and stores it in the returned mesh object. Checks automatically the file format to load from the given filename.  <br /></td></tr>
<tr class="separator:gac416e5f3f89e8f6eda94faaa0f6c34ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89b928a94b582f3a2b6922c429342a6a" id="r_a89b928a94b582f3a2b6922c429342a6a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1MeshInfo.html">MeshInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a89b928a94b582f3a2b6922c429342a6a">objFormatCapability</a> ()</td></tr>
<tr class="separator:a89b928a94b582f3a2b6922c429342a6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga93f9e6608c986d36d98110314b96dc7d" id="r_ga93f9e6608c986d36d98110314b96dc7d"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType, LoggerConcept LogType = NullLogger&gt; </td></tr>
<tr class="memitem:ga93f9e6608c986d36d98110314b96dc7d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__load.html#ga93f9e6608c986d36d98110314b96dc7d">loadObj</a> (MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>, std::istream &amp;<a class="el" href="classvcl_1_1Matrix.html">inputObjStream</a>, <a class="el" href="classvcl_1_1Matrix.html">const</a> std::vector&lt; std::istream * &gt; &amp;<a class="el" href="classvcl_1_1Matrix.html">inputMtlStreams</a>, <a class="el" href="classvcl_1_1MeshInfo.html">MeshInfo</a> &amp;<a class="el" href="classvcl_1_1Matrix.html">loadedInfo</a>, <a class="el" href="classvcl_1_1Matrix.html">LogType</a> &amp;log=<a class="el" href="group__miscellaneous.html#ga3377e3c875ec245e90ac5a395105ce99">nullLogger</a>, <a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="structvcl_1_1LoadSettings.html">LoadSettings</a> &amp;<a class="el" href="classvcl_1_1Matrix.html">settings</a>=<a class="el" href="structvcl_1_1LoadSettings.html">LoadSettings</a>())</td></tr>
<tr class="memdesc:ga93f9e6608c986d36d98110314b96dc7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads from the given input obj stream and puts the content into the mesh m.  <br /></td></tr>
<tr class="separator:ga93f9e6608c986d36d98110314b96dc7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6756f30390090912a52ca7897deb948e" id="r_ga6756f30390090912a52ca7897deb948e"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType, LoggerConcept LogType = NullLogger&gt; </td></tr>
<tr class="memitem:ga6756f30390090912a52ca7897deb948e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__load.html#ga6756f30390090912a52ca7897deb948e">loadObj</a> (MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>, std::istream &amp;<a class="el" href="classvcl_1_1Matrix.html">inputObjStream</a>, <a class="el" href="classvcl_1_1Matrix.html">const</a> std::vector&lt; std::istream * &gt; &amp;<a class="el" href="classvcl_1_1Matrix.html">inputMtlStreams</a>, <a class="el" href="classvcl_1_1Matrix.html">LogType</a> &amp;log=<a class="el" href="group__miscellaneous.html#ga3377e3c875ec245e90ac5a395105ce99">nullLogger</a>, <a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="structvcl_1_1LoadSettings.html">LoadSettings</a> &amp;<a class="el" href="classvcl_1_1Matrix.html">settings</a>=<a class="el" href="structvcl_1_1LoadSettings.html">LoadSettings</a>())</td></tr>
<tr class="memdesc:ga6756f30390090912a52ca7897deb948e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads from the given input obj stream and puts the content into the mesh m.  <br /></td></tr>
<tr class="separator:ga6756f30390090912a52ca7897deb948e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b11e1b88b28e79e7df4a2826d8752e8" id="r_ga2b11e1b88b28e79e7df4a2826d8752e8"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType, LoggerConcept LogType = NullLogger&gt; </td></tr>
<tr class="memitem:ga2b11e1b88b28e79e7df4a2826d8752e8"><td class="memTemplItemLeft" align="right" valign="top">MeshType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__load.html#ga2b11e1b88b28e79e7df4a2826d8752e8">loadObj</a> (std::istream &amp;<a class="el" href="classvcl_1_1Matrix.html">inputObjStream</a>, <a class="el" href="classvcl_1_1Matrix.html">const</a> std::vector&lt; std::istream * &gt; &amp;<a class="el" href="classvcl_1_1Matrix.html">inputMtlStreams</a>, <a class="el" href="classvcl_1_1MeshInfo.html">MeshInfo</a> &amp;<a class="el" href="classvcl_1_1Matrix.html">loadedInfo</a>, <a class="el" href="classvcl_1_1Matrix.html">LogType</a> &amp;log=<a class="el" href="group__miscellaneous.html#ga3377e3c875ec245e90ac5a395105ce99">nullLogger</a>, <a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="structvcl_1_1LoadSettings.html">LoadSettings</a> &amp;<a class="el" href="classvcl_1_1Matrix.html">settings</a>=<a class="el" href="structvcl_1_1LoadSettings.html">LoadSettings</a>())</td></tr>
<tr class="memdesc:ga2b11e1b88b28e79e7df4a2826d8752e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads from the given input obj stream and puts the content into the returned mesh m.  <br /></td></tr>
<tr class="separator:ga2b11e1b88b28e79e7df4a2826d8752e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7745599144780bce5c909d32ddaf2bb7" id="r_ga7745599144780bce5c909d32ddaf2bb7"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType, LoggerConcept LogType = NullLogger&gt; </td></tr>
<tr class="memitem:ga7745599144780bce5c909d32ddaf2bb7"><td class="memTemplItemLeft" align="right" valign="top">MeshType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__load.html#ga7745599144780bce5c909d32ddaf2bb7">loadObj</a> (std::istream &amp;<a class="el" href="classvcl_1_1Matrix.html">inputObjStream</a>, <a class="el" href="classvcl_1_1Matrix.html">const</a> std::vector&lt; std::istream * &gt; &amp;<a class="el" href="classvcl_1_1Matrix.html">inputMtlStreams</a>, <a class="el" href="classvcl_1_1Matrix.html">LogType</a> &amp;log=<a class="el" href="group__miscellaneous.html#ga3377e3c875ec245e90ac5a395105ce99">nullLogger</a>, <a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="structvcl_1_1LoadSettings.html">LoadSettings</a> &amp;<a class="el" href="classvcl_1_1Matrix.html">settings</a>=<a class="el" href="structvcl_1_1LoadSettings.html">LoadSettings</a>())</td></tr>
<tr class="memdesc:ga7745599144780bce5c909d32ddaf2bb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads from the given input obj stream and puts the content into the returned mesh m.  <br /></td></tr>
<tr class="separator:ga7745599144780bce5c909d32ddaf2bb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c44236f7c414805acd268e83c69737c" id="r_ga4c44236f7c414805acd268e83c69737c"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType, LoggerConcept LogType = NullLogger&gt; </td></tr>
<tr class="memitem:ga4c44236f7c414805acd268e83c69737c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__load.html#ga4c44236f7c414805acd268e83c69737c">loadObj</a> (MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>, <a class="el" href="classvcl_1_1Matrix.html">const</a> std::string &amp;<a class="el" href="classvcl_1_1Matrix.html">filename</a>, <a class="el" href="classvcl_1_1MeshInfo.html">MeshInfo</a> &amp;<a class="el" href="classvcl_1_1Matrix.html">loadedInfo</a>, <a class="el" href="classvcl_1_1Matrix.html">LogType</a> &amp;log=<a class="el" href="group__miscellaneous.html#ga3377e3c875ec245e90ac5a395105ce99">nullLogger</a>, <a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="structvcl_1_1LoadSettings.html">LoadSettings</a> &amp;<a class="el" href="classvcl_1_1Matrix.html">settings</a>=<a class="el" href="structvcl_1_1LoadSettings.html">LoadSettings</a>())</td></tr>
<tr class="memdesc:ga4c44236f7c414805acd268e83c69737c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads from the given input obj file and puts the content into the mesh m.  <br /></td></tr>
<tr class="separator:ga4c44236f7c414805acd268e83c69737c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3231ea187eb7f23106f9f2e7b4b52ebd" id="r_ga3231ea187eb7f23106f9f2e7b4b52ebd"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType, LoggerConcept LogType = NullLogger&gt; </td></tr>
<tr class="memitem:ga3231ea187eb7f23106f9f2e7b4b52ebd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__load.html#ga3231ea187eb7f23106f9f2e7b4b52ebd">loadObj</a> (MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>, <a class="el" href="classvcl_1_1Matrix.html">const</a> std::string &amp;<a class="el" href="classvcl_1_1Matrix.html">filename</a>, <a class="el" href="classvcl_1_1Matrix.html">LogType</a> &amp;log=<a class="el" href="group__miscellaneous.html#ga3377e3c875ec245e90ac5a395105ce99">nullLogger</a>, <a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="structvcl_1_1LoadSettings.html">LoadSettings</a> &amp;<a class="el" href="classvcl_1_1Matrix.html">settings</a>=<a class="el" href="structvcl_1_1LoadSettings.html">LoadSettings</a>())</td></tr>
<tr class="memdesc:ga3231ea187eb7f23106f9f2e7b4b52ebd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads from the given input obj file and puts the content into the mesh m.  <br /></td></tr>
<tr class="separator:ga3231ea187eb7f23106f9f2e7b4b52ebd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga174d43782481ac94397d4dee33e7c2bd" id="r_ga174d43782481ac94397d4dee33e7c2bd"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType, LoggerConcept LogType = NullLogger&gt; </td></tr>
<tr class="memitem:ga174d43782481ac94397d4dee33e7c2bd"><td class="memTemplItemLeft" align="right" valign="top">MeshType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__load.html#ga174d43782481ac94397d4dee33e7c2bd">loadObj</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> std::string &amp;<a class="el" href="classvcl_1_1Matrix.html">filename</a>, <a class="el" href="classvcl_1_1MeshInfo.html">MeshInfo</a> &amp;<a class="el" href="classvcl_1_1Matrix.html">loadedInfo</a>, <a class="el" href="classvcl_1_1Matrix.html">LogType</a> &amp;log=<a class="el" href="group__miscellaneous.html#ga3377e3c875ec245e90ac5a395105ce99">nullLogger</a>, <a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="structvcl_1_1LoadSettings.html">LoadSettings</a> &amp;<a class="el" href="classvcl_1_1Matrix.html">settings</a>=<a class="el" href="structvcl_1_1LoadSettings.html">LoadSettings</a>())</td></tr>
<tr class="memdesc:ga174d43782481ac94397d4dee33e7c2bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads from the given input obj file and puts the content into the returned mesh m.  <br /></td></tr>
<tr class="separator:ga174d43782481ac94397d4dee33e7c2bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga239f3a0cb6812c2a673826d403e97313" id="r_ga239f3a0cb6812c2a673826d403e97313"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType, LoggerConcept LogType = NullLogger&gt; </td></tr>
<tr class="memitem:ga239f3a0cb6812c2a673826d403e97313"><td class="memTemplItemLeft" align="right" valign="top">MeshType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__load.html#ga239f3a0cb6812c2a673826d403e97313">loadObj</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> std::string &amp;<a class="el" href="classvcl_1_1Matrix.html">filename</a>, <a class="el" href="classvcl_1_1Matrix.html">LogType</a> &amp;log=<a class="el" href="group__miscellaneous.html#ga3377e3c875ec245e90ac5a395105ce99">nullLogger</a>, <a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="structvcl_1_1LoadSettings.html">LoadSettings</a> &amp;<a class="el" href="classvcl_1_1Matrix.html">settings</a>=<a class="el" href="structvcl_1_1LoadSettings.html">LoadSettings</a>())</td></tr>
<tr class="memdesc:ga239f3a0cb6812c2a673826d403e97313"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads from the given input obj file and puts the content into the returned mesh m.  <br /></td></tr>
<tr class="separator:ga239f3a0cb6812c2a673826d403e97313"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b3bf569c152577b42fd7457844810da" id="r_a5b3bf569c152577b42fd7457844810da"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType, LoggerConcept LogType = NullLogger&gt; </td></tr>
<tr class="memitem:a5b3bf569c152577b42fd7457844810da"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a5b3bf569c152577b42fd7457844810da">saveObj</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>, std::ostream &amp;<a class="el" href="classvcl_1_1Matrix.html">fp</a>, std::ostream &amp;<a class="el" href="classvcl_1_1Matrix.html">mtlfp</a>, <a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="structvcl_1_1SaveSettings.html">SaveSettings</a> &amp;<a class="el" href="classvcl_1_1Matrix.html">settings</a>, <a class="el" href="classvcl_1_1Matrix.html">LogType</a> &amp;log=<a class="el" href="group__miscellaneous.html#ga3377e3c875ec245e90ac5a395105ce99">nullLogger</a>)</td></tr>
<tr class="separator:a5b3bf569c152577b42fd7457844810da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c4772dc391aa32c2a0b6b3b88f375a5" id="r_a0c4772dc391aa32c2a0b6b3b88f375a5"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType, LoggerConcept LogType = NullLogger&gt; </td></tr>
<tr class="memitem:a0c4772dc391aa32c2a0b6b3b88f375a5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a0c4772dc391aa32c2a0b6b3b88f375a5">saveObj</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>, std::ostream &amp;<a class="el" href="classvcl_1_1Matrix.html">fp</a>, std::ostream &amp;<a class="el" href="classvcl_1_1Matrix.html">mtlfp</a>, <a class="el" href="classvcl_1_1Matrix.html">LogType</a> &amp;log=<a class="el" href="group__miscellaneous.html#ga3377e3c875ec245e90ac5a395105ce99">nullLogger</a>, <a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="structvcl_1_1SaveSettings.html">SaveSettings</a> &amp;<a class="el" href="classvcl_1_1Matrix.html">settings</a>=<a class="el" href="structvcl_1_1SaveSettings.html">SaveSettings</a>())</td></tr>
<tr class="separator:a0c4772dc391aa32c2a0b6b3b88f375a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7e5770fccdeac13be7dc8d0061f9659" id="r_ac7e5770fccdeac13be7dc8d0061f9659"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType, LoggerConcept LogType = NullLogger&gt; </td></tr>
<tr class="memitem:ac7e5770fccdeac13be7dc8d0061f9659"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ac7e5770fccdeac13be7dc8d0061f9659">saveObj</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>, std::ostream &amp;<a class="el" href="classvcl_1_1Matrix.html">fp</a>, <a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="structvcl_1_1SaveSettings.html">SaveSettings</a> &amp;<a class="el" href="classvcl_1_1Matrix.html">settings</a>, <a class="el" href="classvcl_1_1Matrix.html">LogType</a> &amp;log=<a class="el" href="group__miscellaneous.html#ga3377e3c875ec245e90ac5a395105ce99">nullLogger</a>)</td></tr>
<tr class="separator:ac7e5770fccdeac13be7dc8d0061f9659"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac380fcb4c9c863de61d8849d980afa2e" id="r_ac380fcb4c9c863de61d8849d980afa2e"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType, LoggerConcept LogType = NullLogger&gt; </td></tr>
<tr class="memitem:ac380fcb4c9c863de61d8849d980afa2e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ac380fcb4c9c863de61d8849d980afa2e">saveObj</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>, std::ostream &amp;<a class="el" href="classvcl_1_1Matrix.html">fp</a>, <a class="el" href="classvcl_1_1Matrix.html">LogType</a> &amp;log=<a class="el" href="group__miscellaneous.html#ga3377e3c875ec245e90ac5a395105ce99">nullLogger</a>, <a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="structvcl_1_1SaveSettings.html">SaveSettings</a> &amp;<a class="el" href="classvcl_1_1Matrix.html">settings</a>=<a class="el" href="structvcl_1_1SaveSettings.html">SaveSettings</a>())</td></tr>
<tr class="separator:ac380fcb4c9c863de61d8849d980afa2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba2732159a83341a0a30e462023d2984" id="r_aba2732159a83341a0a30e462023d2984"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType, LoggerConcept LogType = NullLogger&gt; </td></tr>
<tr class="memitem:aba2732159a83341a0a30e462023d2984"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#aba2732159a83341a0a30e462023d2984">saveObj</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>, <a class="el" href="classvcl_1_1Matrix.html">const</a> std::string &amp;<a class="el" href="classvcl_1_1Matrix.html">filename</a>, <a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="structvcl_1_1SaveSettings.html">SaveSettings</a> &amp;<a class="el" href="classvcl_1_1Matrix.html">settings</a>, <a class="el" href="classvcl_1_1Matrix.html">LogType</a> &amp;log=<a class="el" href="group__miscellaneous.html#ga3377e3c875ec245e90ac5a395105ce99">nullLogger</a>)</td></tr>
<tr class="separator:aba2732159a83341a0a30e462023d2984"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab88bf72e736841da046b3989aaef757f" id="r_ab88bf72e736841da046b3989aaef757f"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType, LoggerConcept LogType = NullLogger&gt; </td></tr>
<tr class="memitem:ab88bf72e736841da046b3989aaef757f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ab88bf72e736841da046b3989aaef757f">saveObj</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>, <a class="el" href="classvcl_1_1Matrix.html">const</a> std::string &amp;<a class="el" href="classvcl_1_1Matrix.html">filename</a>, <a class="el" href="classvcl_1_1Matrix.html">LogType</a> &amp;log=<a class="el" href="group__miscellaneous.html#ga3377e3c875ec245e90ac5a395105ce99">nullLogger</a>, <a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="structvcl_1_1SaveSettings.html">SaveSettings</a> &amp;<a class="el" href="classvcl_1_1Matrix.html">settings</a>=<a class="el" href="structvcl_1_1SaveSettings.html">SaveSettings</a>())</td></tr>
<tr class="separator:ab88bf72e736841da046b3989aaef757f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5fcaf6c89c8030d5989da2c50af169a" id="r_af5fcaf6c89c8030d5989da2c50af169a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1MeshInfo.html">MeshInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#af5fcaf6c89c8030d5989da2c50af169a">offFormatCapability</a> ()</td></tr>
<tr class="separator:af5fcaf6c89c8030d5989da2c50af169a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga13f201b5e3356b3aff18b482348bcb0e" id="r_ga13f201b5e3356b3aff18b482348bcb0e"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType, LoggerConcept LogType = NullLogger&gt; </td></tr>
<tr class="memitem:ga13f201b5e3356b3aff18b482348bcb0e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__load.html#ga13f201b5e3356b3aff18b482348bcb0e">loadOff</a> (MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>, std::istream &amp;<a class="el" href="classvcl_1_1Matrix.html">inputOffStream</a>, <a class="el" href="classvcl_1_1MeshInfo.html">MeshInfo</a> &amp;<a class="el" href="classvcl_1_1Matrix.html">loadedInfo</a>, <a class="el" href="classvcl_1_1Matrix.html">LogType</a> &amp;log=<a class="el" href="group__miscellaneous.html#ga3377e3c875ec245e90ac5a395105ce99">nullLogger</a>, <a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="structvcl_1_1LoadSettings.html">LoadSettings</a> &amp;<a class="el" href="classvcl_1_1Matrix.html">settings</a>=<a class="el" href="structvcl_1_1LoadSettings.html">LoadSettings</a>())</td></tr>
<tr class="memdesc:ga13f201b5e3356b3aff18b482348bcb0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads from the given input off stream and puts the content into the mesh m.  <br /></td></tr>
<tr class="separator:ga13f201b5e3356b3aff18b482348bcb0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga59bb302205dcae2446b6273f403b2d45" id="r_ga59bb302205dcae2446b6273f403b2d45"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType, LoggerConcept LogType = NullLogger&gt; </td></tr>
<tr class="memitem:ga59bb302205dcae2446b6273f403b2d45"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__load.html#ga59bb302205dcae2446b6273f403b2d45">loadOff</a> (MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>, std::istream &amp;<a class="el" href="classvcl_1_1Matrix.html">inputOffStream</a>, <a class="el" href="classvcl_1_1Matrix.html">LogType</a> &amp;log=<a class="el" href="group__miscellaneous.html#ga3377e3c875ec245e90ac5a395105ce99">nullLogger</a>, <a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="structvcl_1_1LoadSettings.html">LoadSettings</a> &amp;<a class="el" href="classvcl_1_1Matrix.html">settings</a>=<a class="el" href="structvcl_1_1LoadSettings.html">LoadSettings</a>())</td></tr>
<tr class="memdesc:ga59bb302205dcae2446b6273f403b2d45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads from the given input off stream and puts the content into the mesh m.  <br /></td></tr>
<tr class="separator:ga59bb302205dcae2446b6273f403b2d45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga797b24bb115f37d8915c8e9759a9867f" id="r_ga797b24bb115f37d8915c8e9759a9867f"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType, LoggerConcept LogType = NullLogger&gt; </td></tr>
<tr class="memitem:ga797b24bb115f37d8915c8e9759a9867f"><td class="memTemplItemLeft" align="right" valign="top">MeshType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__load.html#ga797b24bb115f37d8915c8e9759a9867f">loadOff</a> (std::istream &amp;<a class="el" href="classvcl_1_1Matrix.html">inputOffStream</a>, <a class="el" href="classvcl_1_1MeshInfo.html">MeshInfo</a> &amp;<a class="el" href="classvcl_1_1Matrix.html">loadedInfo</a>, <a class="el" href="classvcl_1_1Matrix.html">LogType</a> &amp;log=<a class="el" href="group__miscellaneous.html#ga3377e3c875ec245e90ac5a395105ce99">nullLogger</a>, <a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="structvcl_1_1LoadSettings.html">LoadSettings</a> &amp;<a class="el" href="classvcl_1_1Matrix.html">settings</a>=<a class="el" href="structvcl_1_1LoadSettings.html">LoadSettings</a>())</td></tr>
<tr class="memdesc:ga797b24bb115f37d8915c8e9759a9867f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads from the given input off stream and puts the content into the returned mesh m.  <br /></td></tr>
<tr class="separator:ga797b24bb115f37d8915c8e9759a9867f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac92070d29575f067c0808a26bb87e230" id="r_gac92070d29575f067c0808a26bb87e230"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType, LoggerConcept LogType = NullLogger&gt; </td></tr>
<tr class="memitem:gac92070d29575f067c0808a26bb87e230"><td class="memTemplItemLeft" align="right" valign="top">MeshType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__load.html#gac92070d29575f067c0808a26bb87e230">loadOff</a> (std::istream &amp;<a class="el" href="classvcl_1_1Matrix.html">inputOffStream</a>, <a class="el" href="classvcl_1_1Matrix.html">LogType</a> &amp;log=<a class="el" href="group__miscellaneous.html#ga3377e3c875ec245e90ac5a395105ce99">nullLogger</a>, <a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="structvcl_1_1LoadSettings.html">LoadSettings</a> &amp;<a class="el" href="classvcl_1_1Matrix.html">settings</a>=<a class="el" href="structvcl_1_1LoadSettings.html">LoadSettings</a>())</td></tr>
<tr class="memdesc:gac92070d29575f067c0808a26bb87e230"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads from the given input off stream and puts the content into the returned mesh m.  <br /></td></tr>
<tr class="separator:gac92070d29575f067c0808a26bb87e230"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ff7328152705f9b8a4b71cabecd6c6a" id="r_ga5ff7328152705f9b8a4b71cabecd6c6a"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType, LoggerConcept LogType = NullLogger&gt; </td></tr>
<tr class="memitem:ga5ff7328152705f9b8a4b71cabecd6c6a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__load.html#ga5ff7328152705f9b8a4b71cabecd6c6a">loadOff</a> (MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>, <a class="el" href="classvcl_1_1Matrix.html">const</a> std::string &amp;<a class="el" href="classvcl_1_1Matrix.html">filename</a>, <a class="el" href="classvcl_1_1MeshInfo.html">MeshInfo</a> &amp;<a class="el" href="classvcl_1_1Matrix.html">loadedInfo</a>, <a class="el" href="classvcl_1_1Matrix.html">LogType</a> &amp;log=<a class="el" href="group__miscellaneous.html#ga3377e3c875ec245e90ac5a395105ce99">nullLogger</a>, <a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="structvcl_1_1LoadSettings.html">LoadSettings</a> &amp;<a class="el" href="classvcl_1_1Matrix.html">settings</a>=<a class="el" href="structvcl_1_1LoadSettings.html">LoadSettings</a>())</td></tr>
<tr class="memdesc:ga5ff7328152705f9b8a4b71cabecd6c6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads from the given input off file and puts the content into the mesh m.  <br /></td></tr>
<tr class="separator:ga5ff7328152705f9b8a4b71cabecd6c6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8f1775d391d393c7eae48450c760a948" id="r_ga8f1775d391d393c7eae48450c760a948"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType, LoggerConcept LogType = NullLogger&gt; </td></tr>
<tr class="memitem:ga8f1775d391d393c7eae48450c760a948"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__load.html#ga8f1775d391d393c7eae48450c760a948">loadOff</a> (MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>, <a class="el" href="classvcl_1_1Matrix.html">const</a> std::string &amp;<a class="el" href="classvcl_1_1Matrix.html">filename</a>, <a class="el" href="classvcl_1_1Matrix.html">LogType</a> &amp;log=<a class="el" href="group__miscellaneous.html#ga3377e3c875ec245e90ac5a395105ce99">nullLogger</a>, <a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="structvcl_1_1LoadSettings.html">LoadSettings</a> &amp;<a class="el" href="classvcl_1_1Matrix.html">settings</a>=<a class="el" href="structvcl_1_1LoadSettings.html">LoadSettings</a>())</td></tr>
<tr class="memdesc:ga8f1775d391d393c7eae48450c760a948"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads from the given input off file and puts the content into the mesh m.  <br /></td></tr>
<tr class="separator:ga8f1775d391d393c7eae48450c760a948"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga10f54aaa8d392663627c3b713e643cbf" id="r_ga10f54aaa8d392663627c3b713e643cbf"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType, LoggerConcept LogType = NullLogger&gt; </td></tr>
<tr class="memitem:ga10f54aaa8d392663627c3b713e643cbf"><td class="memTemplItemLeft" align="right" valign="top">MeshType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__load.html#ga10f54aaa8d392663627c3b713e643cbf">loadOff</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> std::string &amp;<a class="el" href="classvcl_1_1Matrix.html">filename</a>, <a class="el" href="classvcl_1_1MeshInfo.html">MeshInfo</a> &amp;<a class="el" href="classvcl_1_1Matrix.html">loadedInfo</a>, <a class="el" href="classvcl_1_1Matrix.html">LogType</a> &amp;log=<a class="el" href="group__miscellaneous.html#ga3377e3c875ec245e90ac5a395105ce99">nullLogger</a>, <a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="structvcl_1_1LoadSettings.html">LoadSettings</a> &amp;<a class="el" href="classvcl_1_1Matrix.html">settings</a>=<a class="el" href="structvcl_1_1LoadSettings.html">LoadSettings</a>())</td></tr>
<tr class="memdesc:ga10f54aaa8d392663627c3b713e643cbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads from the given input off file and puts the content into the returned mesh m.  <br /></td></tr>
<tr class="separator:ga10f54aaa8d392663627c3b713e643cbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga27cf869b83e640cdc1c5f565464cd243" id="r_ga27cf869b83e640cdc1c5f565464cd243"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType, LoggerConcept LogType = NullLogger&gt; </td></tr>
<tr class="memitem:ga27cf869b83e640cdc1c5f565464cd243"><td class="memTemplItemLeft" align="right" valign="top">MeshType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__load.html#ga27cf869b83e640cdc1c5f565464cd243">loadOff</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> std::string &amp;<a class="el" href="classvcl_1_1Matrix.html">filename</a>, <a class="el" href="classvcl_1_1Matrix.html">LogType</a> &amp;log=<a class="el" href="group__miscellaneous.html#ga3377e3c875ec245e90ac5a395105ce99">nullLogger</a>, <a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="structvcl_1_1LoadSettings.html">LoadSettings</a> &amp;<a class="el" href="classvcl_1_1Matrix.html">settings</a>=<a class="el" href="structvcl_1_1LoadSettings.html">LoadSettings</a>())</td></tr>
<tr class="memdesc:ga27cf869b83e640cdc1c5f565464cd243"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads from the given input off file and puts the content into the returned mesh m.  <br /></td></tr>
<tr class="separator:ga27cf869b83e640cdc1c5f565464cd243"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af30239e4decbd70237fd851685ca91af" id="r_af30239e4decbd70237fd851685ca91af"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType, LoggerConcept LogType = NullLogger&gt; </td></tr>
<tr class="memitem:af30239e4decbd70237fd851685ca91af"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#af30239e4decbd70237fd851685ca91af">saveOff</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>, std::ostream &amp;<a class="el" href="classvcl_1_1Matrix.html">fp</a>, <a class="el" href="classvcl_1_1Matrix.html">LogType</a> &amp;log=<a class="el" href="group__miscellaneous.html#ga3377e3c875ec245e90ac5a395105ce99">nullLogger</a>, <a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="structvcl_1_1SaveSettings.html">SaveSettings</a> &amp;<a class="el" href="classvcl_1_1Matrix.html">settings</a>=<a class="el" href="structvcl_1_1SaveSettings.html">SaveSettings</a>())</td></tr>
<tr class="separator:af30239e4decbd70237fd851685ca91af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55a3e435c00920652599f2e25aff5668" id="r_a55a3e435c00920652599f2e25aff5668"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType, LoggerConcept LogType = NullLogger&gt; </td></tr>
<tr class="memitem:a55a3e435c00920652599f2e25aff5668"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a55a3e435c00920652599f2e25aff5668">saveOff</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>, std::ostream &amp;<a class="el" href="classvcl_1_1Matrix.html">fp</a>, <a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="structvcl_1_1SaveSettings.html">SaveSettings</a> &amp;<a class="el" href="classvcl_1_1Matrix.html">settings</a>, <a class="el" href="classvcl_1_1Matrix.html">LogType</a> &amp;log=<a class="el" href="group__miscellaneous.html#ga3377e3c875ec245e90ac5a395105ce99">nullLogger</a>)</td></tr>
<tr class="separator:a55a3e435c00920652599f2e25aff5668"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab19ae9a0cb55d721a21e0d74dbbc4be9" id="r_ab19ae9a0cb55d721a21e0d74dbbc4be9"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType, LoggerConcept LogType = NullLogger&gt; </td></tr>
<tr class="memitem:ab19ae9a0cb55d721a21e0d74dbbc4be9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ab19ae9a0cb55d721a21e0d74dbbc4be9">saveOff</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>, <a class="el" href="classvcl_1_1Matrix.html">const</a> std::string &amp;<a class="el" href="classvcl_1_1Matrix.html">filename</a>, <a class="el" href="classvcl_1_1Matrix.html">LogType</a> &amp;log=<a class="el" href="group__miscellaneous.html#ga3377e3c875ec245e90ac5a395105ce99">nullLogger</a>, <a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="structvcl_1_1SaveSettings.html">SaveSettings</a> &amp;<a class="el" href="classvcl_1_1Matrix.html">settings</a>=<a class="el" href="structvcl_1_1SaveSettings.html">SaveSettings</a>())</td></tr>
<tr class="separator:ab19ae9a0cb55d721a21e0d74dbbc4be9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac36029862245b69a249d5a407990436b" id="r_ac36029862245b69a249d5a407990436b"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType, LoggerConcept LogType = NullLogger&gt; </td></tr>
<tr class="memitem:ac36029862245b69a249d5a407990436b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ac36029862245b69a249d5a407990436b">saveOff</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>, <a class="el" href="classvcl_1_1Matrix.html">const</a> std::string &amp;<a class="el" href="classvcl_1_1Matrix.html">filename</a>, <a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="structvcl_1_1SaveSettings.html">SaveSettings</a> &amp;<a class="el" href="classvcl_1_1Matrix.html">settings</a>, <a class="el" href="classvcl_1_1Matrix.html">LogType</a> &amp;log=<a class="el" href="group__miscellaneous.html#ga3377e3c875ec245e90ac5a395105ce99">nullLogger</a>)</td></tr>
<tr class="separator:ac36029862245b69a249d5a407990436b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a088781f7755d7dc3343571923f25d4cb" id="r_a088781f7755d7dc3343571923f25d4cb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1MeshInfo.html">MeshInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a088781f7755d7dc3343571923f25d4cb">plyFormatCapability</a> ()</td></tr>
<tr class="separator:a088781f7755d7dc3343571923f25d4cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafcf7d196e8a97818051f0eb8cdeaf098" id="r_gafcf7d196e8a97818051f0eb8cdeaf098"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType, LoggerConcept LogType = NullLogger&gt; </td></tr>
<tr class="memitem:gafcf7d196e8a97818051f0eb8cdeaf098"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__load.html#gafcf7d196e8a97818051f0eb8cdeaf098">loadPly</a> (MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>, std::istream &amp;<a class="el" href="classvcl_1_1Matrix.html">inputPlyStream</a>, <a class="el" href="classvcl_1_1MeshInfo.html">MeshInfo</a> &amp;<a class="el" href="classvcl_1_1Matrix.html">loadedInfo</a>, <a class="el" href="classvcl_1_1Matrix.html">LogType</a> &amp;log=<a class="el" href="group__miscellaneous.html#ga3377e3c875ec245e90ac5a395105ce99">nullLogger</a>, <a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="structvcl_1_1LoadSettings.html">LoadSettings</a> &amp;<a class="el" href="classvcl_1_1Matrix.html">settings</a>=<a class="el" href="structvcl_1_1LoadSettings.html">LoadSettings</a>())</td></tr>
<tr class="memdesc:gafcf7d196e8a97818051f0eb8cdeaf098"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads from the given input ply stream and puts the content into the mesh m.  <br /></td></tr>
<tr class="separator:gafcf7d196e8a97818051f0eb8cdeaf098"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e9501df39c4acb17c0e3a6d3f001fc0" id="r_ga8e9501df39c4acb17c0e3a6d3f001fc0"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType, LoggerConcept LogType = NullLogger&gt; </td></tr>
<tr class="memitem:ga8e9501df39c4acb17c0e3a6d3f001fc0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__load.html#ga8e9501df39c4acb17c0e3a6d3f001fc0">loadPly</a> (MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>, std::istream &amp;<a class="el" href="classvcl_1_1Matrix.html">inputPlyStream</a>, <a class="el" href="classvcl_1_1Matrix.html">LogType</a> &amp;log=<a class="el" href="group__miscellaneous.html#ga3377e3c875ec245e90ac5a395105ce99">nullLogger</a>, <a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="structvcl_1_1LoadSettings.html">LoadSettings</a> &amp;<a class="el" href="classvcl_1_1Matrix.html">settings</a>=<a class="el" href="structvcl_1_1LoadSettings.html">LoadSettings</a>())</td></tr>
<tr class="memdesc:ga8e9501df39c4acb17c0e3a6d3f001fc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads from the given input ply stream and puts the content into the mesh m.  <br /></td></tr>
<tr class="separator:ga8e9501df39c4acb17c0e3a6d3f001fc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga58dc2767f492a91a226894a46eb117d7" id="r_ga58dc2767f492a91a226894a46eb117d7"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType, LoggerConcept LogType = NullLogger&gt; </td></tr>
<tr class="memitem:ga58dc2767f492a91a226894a46eb117d7"><td class="memTemplItemLeft" align="right" valign="top">MeshType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__load.html#ga58dc2767f492a91a226894a46eb117d7">loadPly</a> (std::istream &amp;<a class="el" href="classvcl_1_1Matrix.html">inputPlyStream</a>, <a class="el" href="classvcl_1_1MeshInfo.html">MeshInfo</a> &amp;<a class="el" href="classvcl_1_1Matrix.html">loadedInfo</a>, <a class="el" href="classvcl_1_1Matrix.html">LogType</a> &amp;log=<a class="el" href="group__miscellaneous.html#ga3377e3c875ec245e90ac5a395105ce99">nullLogger</a>, <a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="structvcl_1_1LoadSettings.html">LoadSettings</a> &amp;<a class="el" href="classvcl_1_1Matrix.html">settings</a>=<a class="el" href="structvcl_1_1LoadSettings.html">LoadSettings</a>())</td></tr>
<tr class="memdesc:ga58dc2767f492a91a226894a46eb117d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads from the given input ply stream and puts the content into the returned mesh m.  <br /></td></tr>
<tr class="separator:ga58dc2767f492a91a226894a46eb117d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga660940c7f5f7e57e44b7d46388dace12" id="r_ga660940c7f5f7e57e44b7d46388dace12"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType, LoggerConcept LogType = NullLogger&gt; </td></tr>
<tr class="memitem:ga660940c7f5f7e57e44b7d46388dace12"><td class="memTemplItemLeft" align="right" valign="top">MeshType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__load.html#ga660940c7f5f7e57e44b7d46388dace12">loadPly</a> (std::istream &amp;<a class="el" href="classvcl_1_1Matrix.html">inputPlyStream</a>, <a class="el" href="classvcl_1_1Matrix.html">LogType</a> &amp;log=<a class="el" href="group__miscellaneous.html#ga3377e3c875ec245e90ac5a395105ce99">nullLogger</a>, <a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="structvcl_1_1LoadSettings.html">LoadSettings</a> &amp;<a class="el" href="classvcl_1_1Matrix.html">settings</a>=<a class="el" href="structvcl_1_1LoadSettings.html">LoadSettings</a>())</td></tr>
<tr class="memdesc:ga660940c7f5f7e57e44b7d46388dace12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads from the given input ply stream and puts the content into the returned mesh m.  <br /></td></tr>
<tr class="separator:ga660940c7f5f7e57e44b7d46388dace12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c94c10ecbb5aa9c0ea66729a2403114" id="r_ga1c94c10ecbb5aa9c0ea66729a2403114"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType, LoggerConcept LogType = NullLogger&gt; </td></tr>
<tr class="memitem:ga1c94c10ecbb5aa9c0ea66729a2403114"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__load.html#ga1c94c10ecbb5aa9c0ea66729a2403114">loadPly</a> (MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>, <a class="el" href="classvcl_1_1Matrix.html">const</a> std::string &amp;<a class="el" href="classvcl_1_1Matrix.html">filename</a>, <a class="el" href="classvcl_1_1MeshInfo.html">MeshInfo</a> &amp;<a class="el" href="classvcl_1_1Matrix.html">loadedInfo</a>, <a class="el" href="classvcl_1_1Matrix.html">LogType</a> &amp;log=<a class="el" href="group__miscellaneous.html#ga3377e3c875ec245e90ac5a395105ce99">nullLogger</a>, <a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="structvcl_1_1LoadSettings.html">LoadSettings</a> &amp;<a class="el" href="classvcl_1_1Matrix.html">settings</a>=<a class="el" href="structvcl_1_1LoadSettings.html">LoadSettings</a>())</td></tr>
<tr class="memdesc:ga1c94c10ecbb5aa9c0ea66729a2403114"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads the given ply file and puts the content into the mesh m.  <br /></td></tr>
<tr class="separator:ga1c94c10ecbb5aa9c0ea66729a2403114"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3642b81ee6f165d6c6f6d251c544aa9c" id="r_ga3642b81ee6f165d6c6f6d251c544aa9c"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType, LoggerConcept LogType = NullLogger&gt; </td></tr>
<tr class="memitem:ga3642b81ee6f165d6c6f6d251c544aa9c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__load.html#ga3642b81ee6f165d6c6f6d251c544aa9c">loadPly</a> (MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>, <a class="el" href="classvcl_1_1Matrix.html">const</a> std::string &amp;<a class="el" href="classvcl_1_1Matrix.html">filename</a>, <a class="el" href="classvcl_1_1Matrix.html">LogType</a> &amp;log=<a class="el" href="group__miscellaneous.html#ga3377e3c875ec245e90ac5a395105ce99">nullLogger</a>, <a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="structvcl_1_1LoadSettings.html">LoadSettings</a> &amp;<a class="el" href="classvcl_1_1Matrix.html">settings</a>=<a class="el" href="structvcl_1_1LoadSettings.html">LoadSettings</a>())</td></tr>
<tr class="memdesc:ga3642b81ee6f165d6c6f6d251c544aa9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads the given ply file and puts the content into the mesh m.  <br /></td></tr>
<tr class="separator:ga3642b81ee6f165d6c6f6d251c544aa9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga87b6a1dbb16c2d384b3c1748ae6d63a5" id="r_ga87b6a1dbb16c2d384b3c1748ae6d63a5"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType, LoggerConcept LogType = NullLogger&gt; </td></tr>
<tr class="memitem:ga87b6a1dbb16c2d384b3c1748ae6d63a5"><td class="memTemplItemLeft" align="right" valign="top">MeshType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__load.html#ga87b6a1dbb16c2d384b3c1748ae6d63a5">loadPly</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> std::string &amp;<a class="el" href="classvcl_1_1Matrix.html">filename</a>, <a class="el" href="classvcl_1_1MeshInfo.html">MeshInfo</a> &amp;<a class="el" href="classvcl_1_1Matrix.html">loadedInfo</a>, <a class="el" href="classvcl_1_1Matrix.html">LogType</a> &amp;log=<a class="el" href="group__miscellaneous.html#ga3377e3c875ec245e90ac5a395105ce99">nullLogger</a>, <a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="structvcl_1_1LoadSettings.html">LoadSettings</a> &amp;<a class="el" href="classvcl_1_1Matrix.html">settings</a>=<a class="el" href="structvcl_1_1LoadSettings.html">LoadSettings</a>())</td></tr>
<tr class="memdesc:ga87b6a1dbb16c2d384b3c1748ae6d63a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads the given ply file and puts the content into the returned mesh m.  <br /></td></tr>
<tr class="separator:ga87b6a1dbb16c2d384b3c1748ae6d63a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac415bd661fb5065ccb5bb91e1989d7e6" id="r_gac415bd661fb5065ccb5bb91e1989d7e6"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType, LoggerConcept LogType = NullLogger&gt; </td></tr>
<tr class="memitem:gac415bd661fb5065ccb5bb91e1989d7e6"><td class="memTemplItemLeft" align="right" valign="top">MeshType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__load.html#gac415bd661fb5065ccb5bb91e1989d7e6">loadPly</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> std::string &amp;<a class="el" href="classvcl_1_1Matrix.html">filename</a>, <a class="el" href="classvcl_1_1Matrix.html">LogType</a> &amp;log=<a class="el" href="group__miscellaneous.html#ga3377e3c875ec245e90ac5a395105ce99">nullLogger</a>, <a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="structvcl_1_1LoadSettings.html">LoadSettings</a> &amp;<a class="el" href="classvcl_1_1Matrix.html">settings</a>=<a class="el" href="structvcl_1_1LoadSettings.html">LoadSettings</a>())</td></tr>
<tr class="memdesc:gac415bd661fb5065ccb5bb91e1989d7e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads the given ply file and puts the content into the returned mesh m.  <br /></td></tr>
<tr class="separator:gac415bd661fb5065ccb5bb91e1989d7e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7f540d003359dcb537a9a9bd371ecc3" id="r_ae7f540d003359dcb537a9a9bd371ecc3"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType, LoggerConcept LogType = NullLogger&gt; </td></tr>
<tr class="memitem:ae7f540d003359dcb537a9a9bd371ecc3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ae7f540d003359dcb537a9a9bd371ecc3">savePly</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>, std::ostream &amp;<a class="el" href="classvcl_1_1Matrix.html">fp</a>, <a class="el" href="classvcl_1_1Matrix.html">LogType</a> &amp;log=<a class="el" href="group__miscellaneous.html#ga3377e3c875ec245e90ac5a395105ce99">nullLogger</a>, <a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="structvcl_1_1SaveSettings.html">SaveSettings</a> &amp;<a class="el" href="classvcl_1_1Matrix.html">settings</a>=<a class="el" href="structvcl_1_1SaveSettings.html">SaveSettings</a>())</td></tr>
<tr class="separator:ae7f540d003359dcb537a9a9bd371ecc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2d567e8169973c8b6948d7ba9ae2f5b" id="r_ad2d567e8169973c8b6948d7ba9ae2f5b"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType, LoggerConcept LogType = NullLogger&gt; </td></tr>
<tr class="memitem:ad2d567e8169973c8b6948d7ba9ae2f5b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ad2d567e8169973c8b6948d7ba9ae2f5b">savePly</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>, std::ostream &amp;<a class="el" href="classvcl_1_1Matrix.html">fp</a>, <a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="structvcl_1_1SaveSettings.html">SaveSettings</a> &amp;<a class="el" href="classvcl_1_1Matrix.html">settings</a>, <a class="el" href="classvcl_1_1Matrix.html">LogType</a> &amp;log=<a class="el" href="group__miscellaneous.html#ga3377e3c875ec245e90ac5a395105ce99">nullLogger</a>)</td></tr>
<tr class="separator:ad2d567e8169973c8b6948d7ba9ae2f5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb4c76b10afab737e57b2bc224a60bba" id="r_abb4c76b10afab737e57b2bc224a60bba"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType, LoggerConcept LogType = NullLogger&gt; </td></tr>
<tr class="memitem:abb4c76b10afab737e57b2bc224a60bba"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#abb4c76b10afab737e57b2bc224a60bba">savePly</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>, <a class="el" href="classvcl_1_1Matrix.html">const</a> std::string &amp;<a class="el" href="classvcl_1_1Matrix.html">filename</a>, <a class="el" href="classvcl_1_1Matrix.html">LogType</a> &amp;log=<a class="el" href="group__miscellaneous.html#ga3377e3c875ec245e90ac5a395105ce99">nullLogger</a>, <a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="structvcl_1_1SaveSettings.html">SaveSettings</a> &amp;<a class="el" href="classvcl_1_1Matrix.html">settings</a>=<a class="el" href="structvcl_1_1SaveSettings.html">SaveSettings</a>())</td></tr>
<tr class="separator:abb4c76b10afab737e57b2bc224a60bba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d5216e450e5401b0a2140547a181cc4" id="r_a0d5216e450e5401b0a2140547a181cc4"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType, LoggerConcept LogType = NullLogger&gt; </td></tr>
<tr class="memitem:a0d5216e450e5401b0a2140547a181cc4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a0d5216e450e5401b0a2140547a181cc4">savePly</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>, <a class="el" href="classvcl_1_1Matrix.html">const</a> std::string &amp;<a class="el" href="classvcl_1_1Matrix.html">filename</a>, <a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="structvcl_1_1SaveSettings.html">SaveSettings</a> &amp;<a class="el" href="classvcl_1_1Matrix.html">settings</a>, <a class="el" href="classvcl_1_1Matrix.html">LogType</a> &amp;log=<a class="el" href="group__miscellaneous.html#ga3377e3c875ec245e90ac5a395105ce99">nullLogger</a>)</td></tr>
<tr class="separator:a0d5216e450e5401b0a2140547a181cc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad0c212c27b66b9c0440ac847e557da55" id="r_gad0c212c27b66b9c0440ac847e557da55"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType, LoggerConcept LogType = NullLogger&gt; </td></tr>
<tr class="memitem:gad0c212c27b66b9c0440ac847e557da55"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__save.html#gad0c212c27b66b9c0440ac847e557da55">save</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>, <a class="el" href="classvcl_1_1Matrix.html">const</a> std::string &amp;<a class="el" href="classvcl_1_1Matrix.html">filename</a>, <a class="el" href="classvcl_1_1Matrix.html">LogType</a> &amp;log=<a class="el" href="group__miscellaneous.html#ga3377e3c875ec245e90ac5a395105ce99">nullLogger</a>, <a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="structvcl_1_1SaveSettings.html">SaveSettings</a> &amp;<a class="el" href="classvcl_1_1Matrix.html">settings</a>=<a class="el" href="structvcl_1_1SaveSettings.html">SaveSettings</a>())</td></tr>
<tr class="memdesc:gad0c212c27b66b9c0440ac847e557da55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saves a mesh to a file with the given filename. Checks automatically the file format to save from the given filename.  <br /></td></tr>
<tr class="separator:gad0c212c27b66b9c0440ac847e557da55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9deecac6d9fa88da2ace760ed105ed9d" id="r_a9deecac6d9fa88da2ace760ed105ed9d"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType, LoggerConcept LogType = NullLogger&gt; </td></tr>
<tr class="memitem:a9deecac6d9fa88da2ace760ed105ed9d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a9deecac6d9fa88da2ace760ed105ed9d">save</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>, <a class="el" href="classvcl_1_1Matrix.html">const</a> std::string &amp;<a class="el" href="classvcl_1_1Matrix.html">filename</a>, <a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="structvcl_1_1SaveSettings.html">SaveSettings</a> &amp;<a class="el" href="classvcl_1_1Matrix.html">settings</a>, <a class="el" href="classvcl_1_1Matrix.html">LogType</a> &amp;log=<a class="el" href="group__miscellaneous.html#ga3377e3c875ec245e90ac5a395105ce99">nullLogger</a>)</td></tr>
<tr class="memdesc:a9deecac6d9fa88da2ace760ed105ed9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saves a mesh to a file with the given filename. Checks automatically the file format to save from the given filename.  <br /></td></tr>
<tr class="separator:a9deecac6d9fa88da2ace760ed105ed9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa57501f92552253dc35fc6cf5797540" id="r_aaa57501f92552253dc35fc6cf5797540"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1MeshInfo.html">MeshInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#aaa57501f92552253dc35fc6cf5797540">stlFormatCapability</a> ()</td></tr>
<tr class="separator:aaa57501f92552253dc35fc6cf5797540"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ae70c434de2964991dd3564d8816a6f" id="r_ga2ae70c434de2964991dd3564d8816a6f"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType, LoggerConcept LogType = NullLogger&gt; </td></tr>
<tr class="memitem:ga2ae70c434de2964991dd3564d8816a6f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__load.html#ga2ae70c434de2964991dd3564d8816a6f">loadStl</a> (MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>, std::istream &amp;<a class="el" href="classvcl_1_1Matrix.html">inputStlStream</a>, <a class="el" href="classvcl_1_1MeshInfo.html">MeshInfo</a> &amp;<a class="el" href="classvcl_1_1Matrix.html">loadedInfo</a>, <a class="el" href="classvcl_1_1Matrix.html">bool</a> isBinary=<a class="el" href="classvcl_1_1Matrix.html">false</a>, <a class="el" href="classvcl_1_1Matrix.html">LogType</a> &amp;log=<a class="el" href="group__miscellaneous.html#ga3377e3c875ec245e90ac5a395105ce99">nullLogger</a>, <a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="structvcl_1_1LoadSettings.html">LoadSettings</a> &amp;<a class="el" href="classvcl_1_1Matrix.html">settings</a>=<a class="el" href="structvcl_1_1LoadSettings.html">LoadSettings</a>())</td></tr>
<tr class="memdesc:ga2ae70c434de2964991dd3564d8816a6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads from the given input stl stream and puts the content into the mesh m.  <br /></td></tr>
<tr class="separator:ga2ae70c434de2964991dd3564d8816a6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga087a3cfa26bf365002e0ce87f298a6a5" id="r_ga087a3cfa26bf365002e0ce87f298a6a5"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType, LoggerConcept LogType = NullLogger&gt; </td></tr>
<tr class="memitem:ga087a3cfa26bf365002e0ce87f298a6a5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__load.html#ga087a3cfa26bf365002e0ce87f298a6a5">loadStl</a> (MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>, std::istream &amp;<a class="el" href="classvcl_1_1Matrix.html">inputStlStream</a>, <a class="el" href="classvcl_1_1Matrix.html">bool</a> isBinary=<a class="el" href="classvcl_1_1Matrix.html">false</a>, <a class="el" href="classvcl_1_1Matrix.html">LogType</a> &amp;log=<a class="el" href="group__miscellaneous.html#ga3377e3c875ec245e90ac5a395105ce99">nullLogger</a>, <a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="structvcl_1_1LoadSettings.html">LoadSettings</a> &amp;<a class="el" href="classvcl_1_1Matrix.html">settings</a>=<a class="el" href="structvcl_1_1LoadSettings.html">LoadSettings</a>())</td></tr>
<tr class="memdesc:ga087a3cfa26bf365002e0ce87f298a6a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads from the given input stl stream and puts the content into the mesh m.  <br /></td></tr>
<tr class="separator:ga087a3cfa26bf365002e0ce87f298a6a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga126bd4d6eaf85383f09f9f0762764d3f" id="r_ga126bd4d6eaf85383f09f9f0762764d3f"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType, LoggerConcept LogType = NullLogger&gt; </td></tr>
<tr class="memitem:ga126bd4d6eaf85383f09f9f0762764d3f"><td class="memTemplItemLeft" align="right" valign="top">MeshType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__load.html#ga126bd4d6eaf85383f09f9f0762764d3f">loadStl</a> (std::istream &amp;<a class="el" href="classvcl_1_1Matrix.html">inputStlStream</a>, <a class="el" href="classvcl_1_1MeshInfo.html">MeshInfo</a> &amp;<a class="el" href="classvcl_1_1Matrix.html">loadedInfo</a>, <a class="el" href="classvcl_1_1Matrix.html">bool</a> isBinary=<a class="el" href="classvcl_1_1Matrix.html">false</a>, <a class="el" href="classvcl_1_1Matrix.html">LogType</a> &amp;log=<a class="el" href="group__miscellaneous.html#ga3377e3c875ec245e90ac5a395105ce99">nullLogger</a>, <a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="structvcl_1_1LoadSettings.html">LoadSettings</a> &amp;<a class="el" href="classvcl_1_1Matrix.html">settings</a>=<a class="el" href="structvcl_1_1LoadSettings.html">LoadSettings</a>())</td></tr>
<tr class="memdesc:ga126bd4d6eaf85383f09f9f0762764d3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads from the given input stl stream and puts the content into the returned mesh m.  <br /></td></tr>
<tr class="separator:ga126bd4d6eaf85383f09f9f0762764d3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga678f4f0a63009a7ec8fb50b18c0b311b" id="r_ga678f4f0a63009a7ec8fb50b18c0b311b"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType, LoggerConcept LogType = NullLogger&gt; </td></tr>
<tr class="memitem:ga678f4f0a63009a7ec8fb50b18c0b311b"><td class="memTemplItemLeft" align="right" valign="top">MeshType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__load.html#ga678f4f0a63009a7ec8fb50b18c0b311b">loadStl</a> (std::istream &amp;<a class="el" href="classvcl_1_1Matrix.html">inputStlStream</a>, <a class="el" href="classvcl_1_1Matrix.html">bool</a> isBinary=<a class="el" href="classvcl_1_1Matrix.html">false</a>, <a class="el" href="classvcl_1_1Matrix.html">LogType</a> &amp;log=<a class="el" href="group__miscellaneous.html#ga3377e3c875ec245e90ac5a395105ce99">nullLogger</a>, <a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="structvcl_1_1LoadSettings.html">LoadSettings</a> &amp;<a class="el" href="classvcl_1_1Matrix.html">settings</a>=<a class="el" href="structvcl_1_1LoadSettings.html">LoadSettings</a>())</td></tr>
<tr class="memdesc:ga678f4f0a63009a7ec8fb50b18c0b311b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads from the given input stl stream and puts the content into the returned mesh m.  <br /></td></tr>
<tr class="separator:ga678f4f0a63009a7ec8fb50b18c0b311b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga90e0a3849ab428f5d6b73690228cf6ef" id="r_ga90e0a3849ab428f5d6b73690228cf6ef"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType, LoggerConcept LogType = NullLogger&gt; </td></tr>
<tr class="memitem:ga90e0a3849ab428f5d6b73690228cf6ef"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__load.html#ga90e0a3849ab428f5d6b73690228cf6ef">loadStl</a> (MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>, <a class="el" href="classvcl_1_1Matrix.html">const</a> std::string &amp;<a class="el" href="classvcl_1_1Matrix.html">filename</a>, <a class="el" href="classvcl_1_1MeshInfo.html">MeshInfo</a> &amp;<a class="el" href="classvcl_1_1Matrix.html">loadedInfo</a>, <a class="el" href="classvcl_1_1Matrix.html">LogType</a> &amp;log=<a class="el" href="group__miscellaneous.html#ga3377e3c875ec245e90ac5a395105ce99">nullLogger</a>, <a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="structvcl_1_1LoadSettings.html">LoadSettings</a> &amp;<a class="el" href="classvcl_1_1Matrix.html">settings</a>=<a class="el" href="structvcl_1_1LoadSettings.html">LoadSettings</a>())</td></tr>
<tr class="memdesc:ga90e0a3849ab428f5d6b73690228cf6ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads from the given input stl file and puts the content into the mesh m.  <br /></td></tr>
<tr class="separator:ga90e0a3849ab428f5d6b73690228cf6ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab2627bb400a9b21f382ad309fc679349" id="r_gab2627bb400a9b21f382ad309fc679349"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType, LoggerConcept LogType = NullLogger&gt; </td></tr>
<tr class="memitem:gab2627bb400a9b21f382ad309fc679349"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__load.html#gab2627bb400a9b21f382ad309fc679349">loadStl</a> (MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>, <a class="el" href="classvcl_1_1Matrix.html">const</a> std::string &amp;<a class="el" href="classvcl_1_1Matrix.html">filename</a>, <a class="el" href="classvcl_1_1Matrix.html">LogType</a> &amp;log=<a class="el" href="group__miscellaneous.html#ga3377e3c875ec245e90ac5a395105ce99">nullLogger</a>, <a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="structvcl_1_1LoadSettings.html">LoadSettings</a> &amp;<a class="el" href="classvcl_1_1Matrix.html">settings</a>=<a class="el" href="structvcl_1_1LoadSettings.html">LoadSettings</a>())</td></tr>
<tr class="memdesc:gab2627bb400a9b21f382ad309fc679349"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads from the given input stl file and puts the content into the mesh m.  <br /></td></tr>
<tr class="separator:gab2627bb400a9b21f382ad309fc679349"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga700de91e6f09b7f5131af770af3e0a03" id="r_ga700de91e6f09b7f5131af770af3e0a03"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType, LoggerConcept LogType = NullLogger&gt; </td></tr>
<tr class="memitem:ga700de91e6f09b7f5131af770af3e0a03"><td class="memTemplItemLeft" align="right" valign="top">MeshType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__load.html#ga700de91e6f09b7f5131af770af3e0a03">loadStl</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> std::string &amp;<a class="el" href="classvcl_1_1Matrix.html">filename</a>, <a class="el" href="classvcl_1_1MeshInfo.html">MeshInfo</a> &amp;<a class="el" href="classvcl_1_1Matrix.html">loadedInfo</a>, <a class="el" href="classvcl_1_1Matrix.html">LogType</a> &amp;log=<a class="el" href="group__miscellaneous.html#ga3377e3c875ec245e90ac5a395105ce99">nullLogger</a>, <a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="structvcl_1_1LoadSettings.html">LoadSettings</a> &amp;<a class="el" href="classvcl_1_1Matrix.html">settings</a>=<a class="el" href="structvcl_1_1LoadSettings.html">LoadSettings</a>())</td></tr>
<tr class="memdesc:ga700de91e6f09b7f5131af770af3e0a03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads from the given input stl file and puts the content into the returned mesh m.  <br /></td></tr>
<tr class="separator:ga700de91e6f09b7f5131af770af3e0a03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a5f657d3caf544987ffcb50f072442e" id="r_ga7a5f657d3caf544987ffcb50f072442e"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType, LoggerConcept LogType = NullLogger&gt; </td></tr>
<tr class="memitem:ga7a5f657d3caf544987ffcb50f072442e"><td class="memTemplItemLeft" align="right" valign="top">MeshType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__load.html#ga7a5f657d3caf544987ffcb50f072442e">loadStl</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> std::string &amp;<a class="el" href="classvcl_1_1Matrix.html">filename</a>, <a class="el" href="classvcl_1_1Matrix.html">LogType</a> &amp;log=<a class="el" href="group__miscellaneous.html#ga3377e3c875ec245e90ac5a395105ce99">nullLogger</a>, <a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="structvcl_1_1LoadSettings.html">LoadSettings</a> &amp;<a class="el" href="classvcl_1_1Matrix.html">settings</a>=<a class="el" href="structvcl_1_1LoadSettings.html">LoadSettings</a>())</td></tr>
<tr class="memdesc:ga7a5f657d3caf544987ffcb50f072442e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads from the given input stl file and puts the content into the returned mesh m.  <br /></td></tr>
<tr class="separator:ga7a5f657d3caf544987ffcb50f072442e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a466fdb28942beb260111ef9ce39130d3" id="r_a466fdb28942beb260111ef9ce39130d3"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType, LoggerConcept LogType = NullLogger&gt; </td></tr>
<tr class="memitem:a466fdb28942beb260111ef9ce39130d3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a466fdb28942beb260111ef9ce39130d3">saveStl</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>, std::ostream &amp;<a class="el" href="classvcl_1_1Matrix.html">fp</a>, <a class="el" href="classvcl_1_1Matrix.html">LogType</a> &amp;log=<a class="el" href="group__miscellaneous.html#ga3377e3c875ec245e90ac5a395105ce99">nullLogger</a>, <a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="structvcl_1_1SaveSettings.html">SaveSettings</a> &amp;<a class="el" href="classvcl_1_1Matrix.html">settings</a>=<a class="el" href="structvcl_1_1SaveSettings.html">SaveSettings</a>())</td></tr>
<tr class="separator:a466fdb28942beb260111ef9ce39130d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abafec546bb33b770cc260e75643ac101" id="r_abafec546bb33b770cc260e75643ac101"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType, LoggerConcept LogType = NullLogger&gt; </td></tr>
<tr class="memitem:abafec546bb33b770cc260e75643ac101"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#abafec546bb33b770cc260e75643ac101">saveStl</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>, std::ostream &amp;<a class="el" href="classvcl_1_1Matrix.html">fp</a>, <a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="structvcl_1_1SaveSettings.html">SaveSettings</a> &amp;<a class="el" href="classvcl_1_1Matrix.html">settings</a>, <a class="el" href="classvcl_1_1Matrix.html">LogType</a> &amp;log=<a class="el" href="group__miscellaneous.html#ga3377e3c875ec245e90ac5a395105ce99">nullLogger</a>)</td></tr>
<tr class="separator:abafec546bb33b770cc260e75643ac101"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a979472e4bb92ef4df1a5001732090736" id="r_a979472e4bb92ef4df1a5001732090736"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType, LoggerConcept LogType = NullLogger&gt; </td></tr>
<tr class="memitem:a979472e4bb92ef4df1a5001732090736"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a979472e4bb92ef4df1a5001732090736">saveStl</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>, <a class="el" href="classvcl_1_1Matrix.html">const</a> std::string &amp;<a class="el" href="classvcl_1_1Matrix.html">filename</a>, <a class="el" href="classvcl_1_1Matrix.html">LogType</a> &amp;log=<a class="el" href="group__miscellaneous.html#ga3377e3c875ec245e90ac5a395105ce99">nullLogger</a>, <a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="structvcl_1_1SaveSettings.html">SaveSettings</a> &amp;<a class="el" href="classvcl_1_1Matrix.html">settings</a>=<a class="el" href="structvcl_1_1SaveSettings.html">SaveSettings</a>())</td></tr>
<tr class="separator:a979472e4bb92ef4df1a5001732090736"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9236f9a9fb72ab815a010ad4f16bd024" id="r_a9236f9a9fb72ab815a010ad4f16bd024"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType, LoggerConcept LogType = NullLogger&gt; </td></tr>
<tr class="memitem:a9236f9a9fb72ab815a010ad4f16bd024"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a9236f9a9fb72ab815a010ad4f16bd024">saveStl</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>, <a class="el" href="classvcl_1_1Matrix.html">const</a> std::string &amp;<a class="el" href="classvcl_1_1Matrix.html">filename</a>, <a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="structvcl_1_1SaveSettings.html">SaveSettings</a> &amp;<a class="el" href="classvcl_1_1Matrix.html">settings</a>, <a class="el" href="classvcl_1_1Matrix.html">LogType</a> &amp;log=<a class="el" href="group__miscellaneous.html#ga3377e3c875ec245e90ac5a395105ce99">nullLogger</a>)</td></tr>
<tr class="separator:a9236f9a9fb72ab815a010ad4f16bd024"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33948b0cb8e44bec17d4b0dfef8bd254" id="r_a33948b0cb8e44bec17d4b0dfef8bd254"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classvcl_1_1Matrix.html">typename</a> Scalar &gt; </td></tr>
<tr class="memitem:a33948b0cb8e44bec17d4b0dfef8bd254"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a33948b0cb8e44bec17d4b0dfef8bd254">isDegenerate</a> (Scalar <a class="el" href="classvcl_1_1Matrix.html">t</a>)</td></tr>
<tr class="separator:a33948b0cb8e44bec17d4b0dfef8bd254"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a834f1e7b99e2c76775d28618ed24d281" id="r_a834f1e7b99e2c76775d28618ed24d281"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classvcl_1_1Matrix.html">typename</a> Scalar &gt; </td></tr>
<tr class="memitem:a834f1e7b99e2c76775d28618ed24d281"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a834f1e7b99e2c76775d28618ed24d281">epsilonEquals</a> (Scalar p1, Scalar <a class="el" href="classvcl_1_1Matrix.html">p2</a>, Scalar <a class="el" href="classvcl_1_1Matrix.html">epsilon</a>=std::numeric_limits&lt; Scalar &gt;::epsilon())</td></tr>
<tr class="separator:a834f1e7b99e2c76775d28618ed24d281"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53f705e848cce98dd23542a2d109e55b" id="r_a53f705e848cce98dd23542a2d109e55b"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classvcl_1_1Matrix.html">typename</a> Scalar &gt; </td></tr>
<tr class="memitem:a53f705e848cce98dd23542a2d109e55b"><td class="memTemplItemLeft" align="right" valign="top">Scalar&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a53f705e848cce98dd23542a2d109e55b">toRad</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> Scalar &amp;<a class="el" href="classvcl_1_1Matrix.html">a</a>)</td></tr>
<tr class="separator:a53f705e848cce98dd23542a2d109e55b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1578b48cbfdb04c6675ac5a3b535bb83" id="r_a1578b48cbfdb04c6675ac5a3b535bb83"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classvcl_1_1Matrix.html">typename</a> Scalar &gt; </td></tr>
<tr class="memitem:a1578b48cbfdb04c6675ac5a3b535bb83"><td class="memTemplItemLeft" align="right" valign="top">Scalar&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a1578b48cbfdb04c6675ac5a3b535bb83">toDeg</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> Scalar &amp;<a class="el" href="classvcl_1_1Matrix.html">a</a>)</td></tr>
<tr class="separator:a1578b48cbfdb04c6675ac5a3b535bb83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6613e39304926dee856b8b9770b3be5" id="r_aa6613e39304926dee856b8b9770b3be5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#aa6613e39304926dee856b8b9770b3be5">lnOfFactorial</a> (<a class="el" href="classvcl_1_1Matrix.html">int</a> <a class="el" href="classvcl_1_1Matrix.html">n</a>)</td></tr>
<tr class="memdesc:aa6613e39304926dee856b8b9770b3be5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes and caches the result of the natural logarithm of n!  <br /></td></tr>
<tr class="separator:aa6613e39304926dee856b8b9770b3be5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a438da980623645640c78105766bde287" id="r_a438da980623645640c78105766bde287"><td class="memTemplParams" colspan="2">template&lt;Point3Concept PointType&gt; </td></tr>
<tr class="memitem:a438da980623645640c78105766bde287"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; PointType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a438da980623645640c78105766bde287">sphericalFibonacciPointSet</a> (<a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a> <a class="el" href="classvcl_1_1Matrix.html">n</a>)</td></tr>
<tr class="memdesc:a438da980623645640c78105766bde287"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector of <code>n</code> points distributed in a unit sphere.  <br /></td></tr>
<tr class="separator:a438da980623645640c78105766bde287"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3edcb561672a6be17e9453bd1ea446d5" id="r_a3edcb561672a6be17e9453bd1ea446d5"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classvcl_1_1Matrix.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a3edcb561672a6be17e9453bd1ea446d5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">constexpr</a> <a class="el" href="classvcl_1_1Matrix.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a3edcb561672a6be17e9453bd1ea446d5">min</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> T &amp;<a class="el" href="classvcl_1_1Matrix.html">el1</a>, <a class="el" href="classvcl_1_1Matrix.html">const</a> T &amp;<a class="el" href="classvcl_1_1Matrix.html">el2</a>)</td></tr>
<tr class="separator:a3edcb561672a6be17e9453bd1ea446d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c1835cef3addd7dbae2b21a43523f3a" id="r_a9c1835cef3addd7dbae2b21a43523f3a"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classvcl_1_1Matrix.html">typename</a> <a class="el" href="classvcl_1_1Matrix.html">Head</a> , typename... Tail&gt; <br />
requires (sizeof...(<a class="el" href="classvcl_1_1Matrix.html">tail</a>) &gt; 0)</td></tr>
<tr class="memitem:a9c1835cef3addd7dbae2b21a43523f3a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">constexpr</a> <a class="el" href="classvcl_1_1Matrix.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a9c1835cef3addd7dbae2b21a43523f3a">min</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="classvcl_1_1Matrix.html">Head</a> &amp;<a class="el" href="classvcl_1_1Matrix.html">head0</a>, <a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="classvcl_1_1Matrix.html">Head</a> &amp;<a class="el" href="classvcl_1_1Matrix.html">head1</a>, <a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="classvcl_1_1Matrix.html">Tail</a> &amp;... <a class="el" href="classvcl_1_1Matrix.html">tail</a>)</td></tr>
<tr class="separator:a9c1835cef3addd7dbae2b21a43523f3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69cc63a5ad2974d082145ed1dee7846b" id="r_a69cc63a5ad2974d082145ed1dee7846b"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classvcl_1_1Matrix.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a69cc63a5ad2974d082145ed1dee7846b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">constexpr</a> <a class="el" href="classvcl_1_1Matrix.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a69cc63a5ad2974d082145ed1dee7846b">max</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> T &amp;<a class="el" href="classvcl_1_1Matrix.html">el1</a>, <a class="el" href="classvcl_1_1Matrix.html">const</a> T &amp;<a class="el" href="classvcl_1_1Matrix.html">el2</a>)</td></tr>
<tr class="separator:a69cc63a5ad2974d082145ed1dee7846b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a212fbf643d263ad106507f7aa462cf46" id="r_a212fbf643d263ad106507f7aa462cf46"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classvcl_1_1Matrix.html">typename</a> <a class="el" href="classvcl_1_1Matrix.html">Head</a> , typename... Tail&gt; <br />
requires (sizeof...(<a class="el" href="classvcl_1_1Matrix.html">tail</a>) &gt; 0)</td></tr>
<tr class="memitem:a212fbf643d263ad106507f7aa462cf46"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">constexpr</a> <a class="el" href="classvcl_1_1Matrix.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a212fbf643d263ad106507f7aa462cf46">max</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="classvcl_1_1Matrix.html">Head</a> &amp;<a class="el" href="classvcl_1_1Matrix.html">head0</a>, <a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="classvcl_1_1Matrix.html">Head</a> &amp;<a class="el" href="classvcl_1_1Matrix.html">head1</a>, <a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="classvcl_1_1Matrix.html">Tail</a> &amp;... <a class="el" href="classvcl_1_1Matrix.html">tail</a>)</td></tr>
<tr class="separator:a212fbf643d263ad106507f7aa462cf46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac11460526cb6d79733a8dfe0e15614f4" id="r_ac11460526cb6d79733a8dfe0e15614f4"><td class="memTemplParams" colspan="2">template&lt;PointConcept PointType&gt; </td></tr>
<tr class="memitem:ac11460526cb6d79733a8dfe0e15614f4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">constexpr</a> <a class="el" href="classvcl_1_1Matrix.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ac11460526cb6d79733a8dfe0e15614f4">min</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> PointType &amp;p1, <a class="el" href="classvcl_1_1Matrix.html">const</a> PointType &amp;<a class="el" href="classvcl_1_1Matrix.html">p2</a>)</td></tr>
<tr class="separator:ac11460526cb6d79733a8dfe0e15614f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49a9bdba85989ec5842081c5c84d4fc7" id="r_a49a9bdba85989ec5842081c5c84d4fc7"><td class="memTemplParams" colspan="2">template&lt;PointConcept PointType&gt; </td></tr>
<tr class="memitem:a49a9bdba85989ec5842081c5c84d4fc7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">constexpr</a> <a class="el" href="classvcl_1_1Matrix.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a49a9bdba85989ec5842081c5c84d4fc7">max</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> PointType &amp;p1, <a class="el" href="classvcl_1_1Matrix.html">const</a> PointType &amp;<a class="el" href="classvcl_1_1Matrix.html">p2</a>)</td></tr>
<tr class="separator:a49a9bdba85989ec5842081c5c84d4fc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc2f93864498c3b143e13c1b0009bdc4" id="r_afc2f93864498c3b143e13c1b0009bdc4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#afc2f93864498c3b143e13c1b0009bdc4">perlinNoise</a> (<a class="el" href="classvcl_1_1Matrix.html">double</a> x, <a class="el" href="classvcl_1_1Matrix.html">double</a> y, <a class="el" href="classvcl_1_1Matrix.html">double</a> z)</td></tr>
<tr class="memdesc:afc2f93864498c3b143e13c1b0009bdc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">3D Perlin noise, returns a value in the [-1,1] range with period 255  <br /></td></tr>
<tr class="separator:afc2f93864498c3b143e13c1b0009bdc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cc1884dbb897a34716178c7b06e7bb2" id="r_a2cc1884dbb897a34716178c7b06e7bb2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a2cc1884dbb897a34716178c7b06e7bb2">poissonRatioOfUniformsInteger</a> (<a class="el" href="classvcl_1_1Matrix.html">double</a> <a class="el" href="classvcl_1_1Matrix.html">L</a>, std::mt19937 &amp;<a class="el" href="classvcl_1_1Matrix.html">gen</a>)</td></tr>
<tr class="memdesc:a2cc1884dbb897a34716178c7b06e7bb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This subfunction generates a integer with the poisson distribution using the ratio-of-uniforms rejection method (PRUAt). This approach is STABLE even for large L (e.g. it does not suffer from the overflow limit of the classical Knuth implementation) Execution time does not depend on L, except that it matters whether is within the range where ln(n!) is tabulated.  <br /></td></tr>
<tr class="separator:a2cc1884dbb897a34716178c7b06e7bb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef13acb79205bb8fe990f66e1fa203f3" id="r_aef13acb79205bb8fe990f66e1fa203f3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#aef13acb79205bb8fe990f66e1fa203f3">poissonRatioOfUniformsInteger</a> (<a class="el" href="classvcl_1_1Matrix.html">double</a> <a class="el" href="classvcl_1_1Matrix.html">L</a>)</td></tr>
<tr class="separator:aef13acb79205bb8fe990f66e1fa203f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a212c052ae1efd3426a5ea49051f8011c" id="r_a212c052ae1efd3426a5ea49051f8011c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a212c052ae1efd3426a5ea49051f8011c">poissonRandomNumber</a> (<a class="el" href="classvcl_1_1Matrix.html">double</a> <a class="el" href="classvcl_1_1Matrix.html">lambda</a>, std::mt19937 &amp;<a class="el" href="classvcl_1_1Matrix.html">gen</a>)</td></tr>
<tr class="memdesc:a212c052ae1efd3426a5ea49051f8011c"><td class="mdescLeft">&#160;</td><td class="mdescRight">algorithm poisson random number (Knuth): init: Let L ← e^−λ, k ← 0 and p ← 1. do: k ← k + 1. Generate uniform random number u in [0,1] and let p ← p × u. while p &gt; L. return k − 1.  <br /></td></tr>
<tr class="separator:a212c052ae1efd3426a5ea49051f8011c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee130ece16518760ce1f2c1a9da3a6e1" id="r_aee130ece16518760ce1f2c1a9da3a6e1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#aee130ece16518760ce1f2c1a9da3a6e1">poissonRandomNumber</a> (<a class="el" href="classvcl_1_1Matrix.html">double</a> <a class="el" href="classvcl_1_1Matrix.html">lambda</a>)</td></tr>
<tr class="separator:aee130ece16518760ce1f2c1a9da3a6e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1928216d4ca321551feca3fc03054e03" id="r_a1928216d4ca321551feca3fc03054e03"><td class="memTemplParams" colspan="2">template&lt;Point3Concept PointType&gt; </td></tr>
<tr class="memitem:a1928216d4ca321551feca3fc03054e03"><td class="memTemplItemLeft" align="right" valign="top">PointType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a1928216d4ca321551feca3fc03054e03">randomTriangleBarycentricCoordinate</a> (std::mt19937 &amp;<a class="el" href="classvcl_1_1Matrix.html">gen</a>)</td></tr>
<tr class="memdesc:a1928216d4ca321551feca3fc03054e03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate the barycentric coords of a random point over a triangle, with a uniform distribution over the triangle. It uses the parallelogram folding trick.  <br /></td></tr>
<tr class="separator:a1928216d4ca321551feca3fc03054e03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7496693362c10758d4bc28814e02d5c6" id="r_a7496693362c10758d4bc28814e02d5c6"><td class="memTemplParams" colspan="2">template&lt;Point3Concept PointType&gt; </td></tr>
<tr class="memitem:a7496693362c10758d4bc28814e02d5c6"><td class="memTemplItemLeft" align="right" valign="top">PointType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a7496693362c10758d4bc28814e02d5c6">randomTriangleBarycentricCoordinate</a> ()</td></tr>
<tr class="separator:a7496693362c10758d4bc28814e02d5c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c7c00f108bb07302bfb7643c66f3ef4" id="r_a7c7c00f108bb07302bfb7643c66f3ef4"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classvcl_1_1Matrix.html">typename</a> ScalarType &gt; </td></tr>
<tr class="memitem:a7c7c00f108bb07302bfb7643c66f3ef4"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; ScalarType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a7c7c00f108bb07302bfb7643c66f3ef4">randomPolygonBarycentricCoordinate</a> (<a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a> <a class="el" href="classvcl_1_1Matrix.html">polySize</a>, std::mt19937 &amp;<a class="el" href="classvcl_1_1Matrix.html">gen</a>)</td></tr>
<tr class="separator:a7c7c00f108bb07302bfb7643c66f3ef4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d0305c02567d29d5bc48a0cdbaacda3" id="r_a3d0305c02567d29d5bc48a0cdbaacda3"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classvcl_1_1Matrix.html">typename</a> ScalarType &gt; </td></tr>
<tr class="memitem:a3d0305c02567d29d5bc48a0cdbaacda3"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; ScalarType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a3d0305c02567d29d5bc48a0cdbaacda3">randomPolygonBarycentricCoordinate</a> (<a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a> <a class="el" href="classvcl_1_1Matrix.html">polySize</a>)</td></tr>
<tr class="separator:a3d0305c02567d29d5bc48a0cdbaacda3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24901186f1a77f31a23d64f30f0b0dc3" id="r_a24901186f1a77f31a23d64f30f0b0dc3"><td class="memTemplParams" colspan="2">template&lt;MatrixConcept MatrixType, Point3Concept PointType, <a class="el" href="classvcl_1_1Matrix.html">typename</a> ScalarType &gt; </td></tr>
<tr class="memitem:a24901186f1a77f31a23d64f30f0b0dc3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a24901186f1a77f31a23d64f30f0b0dc3">setTransformMatrixRotation</a> (<a class="el" href="classvcl_1_1Matrix.html">MatrixType</a> &amp;<a class="el" href="classvcl_1_1Matrix.html">matrix</a>, PointType <a class="el" href="classvcl_1_1Matrix.html">axis</a>, <a class="el" href="classvcl_1_1Matrix.html">const</a> ScalarType &amp;<a class="el" href="classvcl_1_1Matrix.html">angleRad</a>)</td></tr>
<tr class="memdesc:a24901186f1a77f31a23d64f30f0b0dc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an 3D axis and an angle expressed in randiants, fills the given matrix with a transform matrix that represents the rotation matrix of the given axis/angle.  <br /></td></tr>
<tr class="separator:a24901186f1a77f31a23d64f30f0b0dc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd5d95d87600e42a0da835735e35ea99" id="r_abd5d95d87600e42a0da835735e35ea99"><td class="memTemplParams" colspan="2">template&lt;MatrixConcept MatrixType, Point3Concept PointType, <a class="el" href="classvcl_1_1Matrix.html">typename</a> ScalarType &gt; </td></tr>
<tr class="memitem:abd5d95d87600e42a0da835735e35ea99"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#abd5d95d87600e42a0da835735e35ea99">setTransformMatrixRotationDeg</a> (<a class="el" href="classvcl_1_1Matrix.html">MatrixType</a> &amp;<a class="el" href="classvcl_1_1Matrix.html">matrix</a>, PointType <a class="el" href="classvcl_1_1Matrix.html">axis</a>, <a class="el" href="classvcl_1_1Matrix.html">const</a> ScalarType &amp;<a class="el" href="classvcl_1_1Matrix.html">angleDeg</a>)</td></tr>
<tr class="memdesc:abd5d95d87600e42a0da835735e35ea99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an 3D axis and an angle expressed in degrees, fills the given matrix with a transform matrix that represents the rotation matrix of the given axis/angle.  <br /></td></tr>
<tr class="separator:abd5d95d87600e42a0da835735e35ea99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeae3bed7ce8fef5657452d857cf87bed" id="r_aeae3bed7ce8fef5657452d857cf87bed"><td class="memTemplParams" colspan="2">template&lt;MatrixConcept MatrixType, Point3Concept PointType&gt; </td></tr>
<tr class="memitem:aeae3bed7ce8fef5657452d857cf87bed"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#aeae3bed7ce8fef5657452d857cf87bed">setTransformMatrixRotation</a> (<a class="el" href="classvcl_1_1Matrix.html">MatrixType</a> &amp;<a class="el" href="classvcl_1_1Matrix.html">matrix</a>, <a class="el" href="classvcl_1_1Matrix.html">const</a> PointType &amp;<a class="el" href="classvcl_1_1Matrix.html">fromVector</a>, <a class="el" href="classvcl_1_1Matrix.html">const</a> PointType &amp;<a class="el" href="classvcl_1_1Matrix.html">toVector</a>)</td></tr>
<tr class="memdesc:aeae3bed7ce8fef5657452d857cf87bed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given two 3D vectors, fills the given matrix with a transform matrix that represents the rotation matrix from the first vector to the second vector.  <br /></td></tr>
<tr class="separator:aeae3bed7ce8fef5657452d857cf87bed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a097be0ad25e27900059458ab8dc0b041" id="r_a097be0ad25e27900059458ab8dc0b041"><td class="memTemplParams" colspan="2">template&lt;MatrixConcept MatrixType, Point3Concept PointType&gt; </td></tr>
<tr class="memitem:a097be0ad25e27900059458ab8dc0b041"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a097be0ad25e27900059458ab8dc0b041">setTransformMatrixTranslation</a> (<a class="el" href="classvcl_1_1Matrix.html">MatrixType</a> &amp;<a class="el" href="classvcl_1_1Matrix.html">matrix</a>, <a class="el" href="classvcl_1_1Matrix.html">const</a> PointType &amp;<a class="el" href="classvcl_1_1Matrix.html">translation</a>)</td></tr>
<tr class="separator:a097be0ad25e27900059458ab8dc0b041"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a060ef5e5d4c2fcf544a6102154e0eed8" id="r_a060ef5e5d4c2fcf544a6102154e0eed8"><td class="memTemplParams" colspan="2">template&lt;MatrixConcept MatrixType, <a class="el" href="classvcl_1_1Matrix.html">typename</a> ScalarType &gt; </td></tr>
<tr class="memitem:a060ef5e5d4c2fcf544a6102154e0eed8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a060ef5e5d4c2fcf544a6102154e0eed8">setTransformMatrixScale</a> (<a class="el" href="classvcl_1_1Matrix.html">MatrixType</a> &amp;<a class="el" href="classvcl_1_1Matrix.html">matrix</a>, <a class="el" href="classvcl_1_1Matrix.html">const</a> ScalarType &amp;<a class="el" href="namespacevcl.html#a5217f309d49911db6e36a4f6d31acdaa">scale</a>)</td></tr>
<tr class="separator:a060ef5e5d4c2fcf544a6102154e0eed8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bc1039bda53b44dfcefd9be1cdf1d9a" id="r_a2bc1039bda53b44dfcefd9be1cdf1d9a"><td class="memTemplParams" colspan="2">template&lt;MatrixConcept MatrixType, Point3Concept PointType&gt; </td></tr>
<tr class="memitem:a2bc1039bda53b44dfcefd9be1cdf1d9a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a2bc1039bda53b44dfcefd9be1cdf1d9a">setTransformMatrixScale</a> (<a class="el" href="classvcl_1_1Matrix.html">MatrixType</a> &amp;<a class="el" href="classvcl_1_1Matrix.html">matrix</a>, <a class="el" href="classvcl_1_1Matrix.html">const</a> PointType &amp;<a class="el" href="namespacevcl.html#a5217f309d49911db6e36a4f6d31acdaa">scale</a>)</td></tr>
<tr class="separator:a2bc1039bda53b44dfcefd9be1cdf1d9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefa0051d67bdf4a551140929a2cc0b2f" id="r_aefa0051d67bdf4a551140929a2cc0b2f"><td class="memTemplParams" colspan="2">template&lt;MatrixConcept MatrixType, Point3Concept PointType, <a class="el" href="classvcl_1_1Matrix.html">typename</a> ScalarType &gt; </td></tr>
<tr class="memitem:aefa0051d67bdf4a551140929a2cc0b2f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">MatrixType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#aefa0051d67bdf4a551140929a2cc0b2f">rotationMatrix</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> PointType &amp;<a class="el" href="classvcl_1_1Matrix.html">axis</a>, <a class="el" href="classvcl_1_1Matrix.html">const</a> ScalarType &amp;<a class="el" href="classvcl_1_1Matrix.html">angleRad</a>)</td></tr>
<tr class="memdesc:aefa0051d67bdf4a551140929a2cc0b2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an 3D axis and an angle expressed in randiants, returns a transform matrix that represents the rotation matrix of the given axis/angle.  <br /></td></tr>
<tr class="separator:aefa0051d67bdf4a551140929a2cc0b2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f6b127154a5e14946cb66492d214de8" id="r_a7f6b127154a5e14946cb66492d214de8"><td class="memTemplParams" colspan="2">template&lt;MatrixConcept MatrixType, Point3Concept PointType, <a class="el" href="classvcl_1_1Matrix.html">typename</a> ScalarType &gt; </td></tr>
<tr class="memitem:a7f6b127154a5e14946cb66492d214de8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">MatrixType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a7f6b127154a5e14946cb66492d214de8">rotationMatrixDeg</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> PointType &amp;<a class="el" href="classvcl_1_1Matrix.html">axis</a>, <a class="el" href="classvcl_1_1Matrix.html">const</a> ScalarType &amp;<a class="el" href="classvcl_1_1Matrix.html">angleDeg</a>)</td></tr>
<tr class="memdesc:a7f6b127154a5e14946cb66492d214de8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an 3D axis and an angle expressed in degrees, fills the given matrix with a transform matrix that represents the rotation matrix of the given axis/angle.  <br /></td></tr>
<tr class="separator:a7f6b127154a5e14946cb66492d214de8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4870ee93dae22bb750da059cefa6d9f2" id="r_a4870ee93dae22bb750da059cefa6d9f2"><td class="memTemplParams" colspan="2">template&lt;MatrixConcept MatrixType, Point3Concept PointType&gt; </td></tr>
<tr class="memitem:a4870ee93dae22bb750da059cefa6d9f2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">MatrixType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a4870ee93dae22bb750da059cefa6d9f2">rotationMatrix</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> PointType &amp;<a class="el" href="classvcl_1_1Matrix.html">fromVector</a>, <a class="el" href="classvcl_1_1Matrix.html">const</a> PointType &amp;<a class="el" href="classvcl_1_1Matrix.html">toVector</a>)</td></tr>
<tr class="memdesc:a4870ee93dae22bb750da059cefa6d9f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given two 3D vectors, returns a transform matrix that represents the rotation matrix from the first vector to the second vector.  <br /></td></tr>
<tr class="separator:a4870ee93dae22bb750da059cefa6d9f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83e4e98dc107ee9f2b22550bcbb25ea7" id="r_ga83e4e98dc107ee9f2b22550bcbb25ea7"><td class="memTemplParams" colspan="2">template&lt;EdgeMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga83e4e98dc107ee9f2b22550bcbb25ea7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__edge__requirements.html#ga83e4e98dc107ee9f2b22550bcbb25ea7">isEdgeContainerCompact</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>)</td></tr>
<tr class="memdesc:ga83e4e98dc107ee9f2b22550bcbb25ea7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if the given mesh has its EdgeContainer compact.  <br /></td></tr>
<tr class="separator:ga83e4e98dc107ee9f2b22550bcbb25ea7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c3b76563f3710059dd10a87a98967cb" id="r_ga5c3b76563f3710059dd10a87a98967cb"><td class="memTemplParams" colspan="2">template&lt;EdgeMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga5c3b76563f3710059dd10a87a98967cb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__edge__requirements.html#ga5c3b76563f3710059dd10a87a98967cb">isPerEdgeAdjacentEdgesAvailable</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>)</td></tr>
<tr class="memdesc:ga5c3b76563f3710059dd10a87a98967cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the AdjacentEdges component is available (enabled) in the <a class="el" href="classvcl_1_1Edge.html" title="The Edge class represents an Edge element of the vcl::Mesh class.">Edge</a> element of the input mesh m.  <br /></td></tr>
<tr class="separator:ga5c3b76563f3710059dd10a87a98967cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga55a6207dd62fdf1e146a42119f65ee7d" id="r_ga55a6207dd62fdf1e146a42119f65ee7d"><td class="memTemplParams" colspan="2">template&lt;EdgeMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga55a6207dd62fdf1e146a42119f65ee7d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__edge__requirements.html#ga55a6207dd62fdf1e146a42119f65ee7d">enableIfPerEdgeAdjacentEdgesOptional</a> (MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>)</td></tr>
<tr class="memdesc:ga55a6207dd62fdf1e146a42119f65ee7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the input mesh has a EdgeContainer, and the <a class="el" href="classvcl_1_1Edge.html" title="The Edge class represents an Edge element of the vcl::Mesh class.">Edge</a> <a class="el" href="classvcl_1_1Element.html" title="The Element class.">Element</a> has a AdjacentEdges Component, this function enables the Component in the <a class="el" href="classvcl_1_1Element.html" title="The Element class.">Element</a> if the component needs to be enabled (meaning that it is optional). Returns <code>true</code> if, after the call of this function, the AdjacentEdges component will be available in the <a class="el" href="classvcl_1_1Edge.html" title="The Edge class represents an Edge element of the vcl::Mesh class.">Edge</a> <a class="el" href="classvcl_1_1Element.html" title="The Element class.">Element</a> of the mesh.  <br /></td></tr>
<tr class="separator:ga55a6207dd62fdf1e146a42119f65ee7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6cde5476921f6aa1530542e40c3626d6" id="r_ga6cde5476921f6aa1530542e40c3626d6"><td class="memTemplParams" colspan="2">template&lt;EdgeMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga6cde5476921f6aa1530542e40c3626d6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__edge__requirements.html#ga6cde5476921f6aa1530542e40c3626d6">isPerEdgeAdjacentFacesAvailable</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>)</td></tr>
<tr class="memdesc:ga6cde5476921f6aa1530542e40c3626d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the AdjacentFaces component is available (enabled) in the <a class="el" href="classvcl_1_1Edge.html" title="The Edge class represents an Edge element of the vcl::Mesh class.">Edge</a> element of the input mesh m.  <br /></td></tr>
<tr class="separator:ga6cde5476921f6aa1530542e40c3626d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab587d17dd049174b67e95fd1bdce9fc5" id="r_gab587d17dd049174b67e95fd1bdce9fc5"><td class="memTemplParams" colspan="2">template&lt;EdgeMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:gab587d17dd049174b67e95fd1bdce9fc5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__edge__requirements.html#gab587d17dd049174b67e95fd1bdce9fc5">enableIfPerEdgeAdjacentFacesOptional</a> (MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>)</td></tr>
<tr class="memdesc:gab587d17dd049174b67e95fd1bdce9fc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the input mesh has a EdgeContainer, and the <a class="el" href="classvcl_1_1Edge.html" title="The Edge class represents an Edge element of the vcl::Mesh class.">Edge</a> <a class="el" href="classvcl_1_1Element.html" title="The Element class.">Element</a> has a AdjacentFaces Component, this function enables the Component in the <a class="el" href="classvcl_1_1Element.html" title="The Element class.">Element</a> if the component needs to be enabled (meaning that it is optional). Returns <code>true</code> if, after the call of this function, the AdjacentFaces component will be available in the <a class="el" href="classvcl_1_1Edge.html" title="The Edge class represents an Edge element of the vcl::Mesh class.">Edge</a> <a class="el" href="classvcl_1_1Element.html" title="The Element class.">Element</a> of the mesh.  <br /></td></tr>
<tr class="separator:gab587d17dd049174b67e95fd1bdce9fc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24af8033d5db434a5935b5646ee829be" id="r_ga24af8033d5db434a5935b5646ee829be"><td class="memTemplParams" colspan="2">template&lt;EdgeMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga24af8033d5db434a5935b5646ee829be"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__edge__requirements.html#ga24af8033d5db434a5935b5646ee829be">isPerEdgeColorAvailable</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>)</td></tr>
<tr class="memdesc:ga24af8033d5db434a5935b5646ee829be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the <a class="el" href="classvcl_1_1Color.html" title="The Color class represents a 32 bit color.">Color</a> component is available (enabled) in the <a class="el" href="classvcl_1_1Edge.html" title="The Edge class represents an Edge element of the vcl::Mesh class.">Edge</a> element of the input mesh m.  <br /></td></tr>
<tr class="separator:ga24af8033d5db434a5935b5646ee829be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b5846c10685de9e77115bcc0695dee4" id="r_ga7b5846c10685de9e77115bcc0695dee4"><td class="memTemplParams" colspan="2">template&lt;EdgeMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga7b5846c10685de9e77115bcc0695dee4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__edge__requirements.html#ga7b5846c10685de9e77115bcc0695dee4">enableIfPerEdgeColorOptional</a> (MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>)</td></tr>
<tr class="memdesc:ga7b5846c10685de9e77115bcc0695dee4"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the input mesh has a EdgeContainer, and the <a class="el" href="classvcl_1_1Edge.html" title="The Edge class represents an Edge element of the vcl::Mesh class.">Edge</a> <a class="el" href="classvcl_1_1Element.html" title="The Element class.">Element</a> has a <a class="el" href="classvcl_1_1Color.html" title="The Color class represents a 32 bit color.">Color</a> Component, this function enables the Component in the <a class="el" href="classvcl_1_1Element.html" title="The Element class.">Element</a> if the component needs to be enabled (meaning that it is optional). Returns <code>true</code> if, after the call of this function, the <a class="el" href="classvcl_1_1Color.html" title="The Color class represents a 32 bit color.">Color</a> component will be available in the <a class="el" href="classvcl_1_1Edge.html" title="The Edge class represents an Edge element of the vcl::Mesh class.">Edge</a> <a class="el" href="classvcl_1_1Element.html" title="The Element class.">Element</a> of the mesh.  <br /></td></tr>
<tr class="separator:ga7b5846c10685de9e77115bcc0695dee4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6844bace61ed05e1603075ca9b98b3ae" id="r_ga6844bace61ed05e1603075ca9b98b3ae"><td class="memTemplParams" colspan="2">template&lt;EdgeMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga6844bace61ed05e1603075ca9b98b3ae"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__edge__requirements.html#ga6844bace61ed05e1603075ca9b98b3ae">isPerEdgeMarkAvailable</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>)</td></tr>
<tr class="memdesc:ga6844bace61ed05e1603075ca9b98b3ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the Mark component is available (enabled) in the <a class="el" href="classvcl_1_1Edge.html" title="The Edge class represents an Edge element of the vcl::Mesh class.">Edge</a> element of the input mesh m.  <br /></td></tr>
<tr class="separator:ga6844bace61ed05e1603075ca9b98b3ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga06074783595077e51f9d4baf34b96e58" id="r_ga06074783595077e51f9d4baf34b96e58"><td class="memTemplParams" colspan="2">template&lt;EdgeMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga06074783595077e51f9d4baf34b96e58"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__edge__requirements.html#ga06074783595077e51f9d4baf34b96e58">enableIfPerEdgeMarkOptional</a> (MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>)</td></tr>
<tr class="memdesc:ga06074783595077e51f9d4baf34b96e58"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the input mesh has a EdgeContainer, and the <a class="el" href="classvcl_1_1Edge.html" title="The Edge class represents an Edge element of the vcl::Mesh class.">Edge</a> <a class="el" href="classvcl_1_1Element.html" title="The Element class.">Element</a> has a Mark Component, this function enables the Component in the <a class="el" href="classvcl_1_1Element.html" title="The Element class.">Element</a> if the component needs to be enabled (meaning that it is optional). Returns <code>true</code> if, after the call of this function, the Mark component will be available in the <a class="el" href="classvcl_1_1Edge.html" title="The Edge class represents an Edge element of the vcl::Mesh class.">Edge</a> <a class="el" href="classvcl_1_1Element.html" title="The Element class.">Element</a> of the mesh.  <br /></td></tr>
<tr class="separator:ga06074783595077e51f9d4baf34b96e58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6144c482a8b16b2ca1a4547efe1758b3" id="r_ga6144c482a8b16b2ca1a4547efe1758b3"><td class="memTemplParams" colspan="2">template&lt;EdgeMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga6144c482a8b16b2ca1a4547efe1758b3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__edge__requirements.html#ga6144c482a8b16b2ca1a4547efe1758b3">isPerEdgeNormalAvailable</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>)</td></tr>
<tr class="memdesc:ga6144c482a8b16b2ca1a4547efe1758b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the Normal component is available (enabled) in the <a class="el" href="classvcl_1_1Edge.html" title="The Edge class represents an Edge element of the vcl::Mesh class.">Edge</a> element of the input mesh m.  <br /></td></tr>
<tr class="separator:ga6144c482a8b16b2ca1a4547efe1758b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab610dcba60432af8c792b49e4a0d2107" id="r_gab610dcba60432af8c792b49e4a0d2107"><td class="memTemplParams" colspan="2">template&lt;EdgeMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:gab610dcba60432af8c792b49e4a0d2107"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__edge__requirements.html#gab610dcba60432af8c792b49e4a0d2107">enableIfPerEdgeNormalOptional</a> (MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>)</td></tr>
<tr class="memdesc:gab610dcba60432af8c792b49e4a0d2107"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the input mesh has a EdgeContainer, and the <a class="el" href="classvcl_1_1Edge.html" title="The Edge class represents an Edge element of the vcl::Mesh class.">Edge</a> <a class="el" href="classvcl_1_1Element.html" title="The Element class.">Element</a> has a Normal Component, this function enables the Component in the <a class="el" href="classvcl_1_1Element.html" title="The Element class.">Element</a> if the component needs to be enabled (meaning that it is optional). Returns <code>true</code> if, after the call of this function, the Normal component will be available in the <a class="el" href="classvcl_1_1Edge.html" title="The Edge class represents an Edge element of the vcl::Mesh class.">Edge</a> <a class="el" href="classvcl_1_1Element.html" title="The Element class.">Element</a> of the mesh.  <br /></td></tr>
<tr class="separator:gab610dcba60432af8c792b49e4a0d2107"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa6c60f70395d97b9c9b4ecae76f5c947" id="r_gaa6c60f70395d97b9c9b4ecae76f5c947"><td class="memTemplParams" colspan="2">template&lt;EdgeMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:gaa6c60f70395d97b9c9b4ecae76f5c947"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__edge__requirements.html#gaa6c60f70395d97b9c9b4ecae76f5c947">isPerEdgeQualityAvailable</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>)</td></tr>
<tr class="memdesc:gaa6c60f70395d97b9c9b4ecae76f5c947"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the Quality component is available (enabled) in the <a class="el" href="classvcl_1_1Edge.html" title="The Edge class represents an Edge element of the vcl::Mesh class.">Edge</a> element of the input mesh m.  <br /></td></tr>
<tr class="separator:gaa6c60f70395d97b9c9b4ecae76f5c947"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae7a4783178e3aa1db82a5965e9186581" id="r_gae7a4783178e3aa1db82a5965e9186581"><td class="memTemplParams" colspan="2">template&lt;EdgeMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:gae7a4783178e3aa1db82a5965e9186581"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__edge__requirements.html#gae7a4783178e3aa1db82a5965e9186581">enableIfPerEdgeQualityOptional</a> (MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>)</td></tr>
<tr class="memdesc:gae7a4783178e3aa1db82a5965e9186581"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the input mesh has a EdgeContainer, and the <a class="el" href="classvcl_1_1Edge.html" title="The Edge class represents an Edge element of the vcl::Mesh class.">Edge</a> <a class="el" href="classvcl_1_1Element.html" title="The Element class.">Element</a> has a Quality Component, this function enables the Component in the <a class="el" href="classvcl_1_1Element.html" title="The Element class.">Element</a> if the component needs to be enabled (meaning that it is optional). Returns <code>true</code> if, after the call of this function, the Quality component will be available in the <a class="el" href="classvcl_1_1Edge.html" title="The Edge class represents an Edge element of the vcl::Mesh class.">Edge</a> <a class="el" href="classvcl_1_1Element.html" title="The Element class.">Element</a> of the mesh.  <br /></td></tr>
<tr class="separator:gae7a4783178e3aa1db82a5965e9186581"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d66bb2b817db1d107bb1c2dcfb0679e" id="r_ga4d66bb2b817db1d107bb1c2dcfb0679e"><td class="memTemplParams" colspan="2">template&lt;EdgeMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga4d66bb2b817db1d107bb1c2dcfb0679e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__edge__requirements.html#ga4d66bb2b817db1d107bb1c2dcfb0679e">requireEdgeContainerCompactness</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>)</td></tr>
<tr class="memdesc:ga4d66bb2b817db1d107bb1c2dcfb0679e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function asserts that a <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a> has the EdgeContainer compact (no elements flagged as deleted).  <br /></td></tr>
<tr class="separator:ga4d66bb2b817db1d107bb1c2dcfb0679e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed78bac32311fa312f1eb9bcb2aab5eb" id="r_gaed78bac32311fa312f1eb9bcb2aab5eb"><td class="memTemplParams" colspan="2">template&lt;EdgeMeshConcept MeshType&gt; <br />
requires HasPerEdgeAdjacentEdges&lt;MeshType&gt;</td></tr>
<tr class="memitem:gaed78bac32311fa312f1eb9bcb2aab5eb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__edge__requirements.html#gaed78bac32311fa312f1eb9bcb2aab5eb">requirePerEdgeAdjacentEdges</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>)</td></tr>
<tr class="memdesc:gaed78bac32311fa312f1eb9bcb2aab5eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function asserts that a <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a> has a EdgeContainer, the <a class="el" href="classvcl_1_1Edge.html" title="The Edge class represents an Edge element of the vcl::Mesh class.">Edge</a> has a AdjacentEdges Component, and that the AdjacentEdges Component is enabled and available at runtime.  <br /></td></tr>
<tr class="separator:gaed78bac32311fa312f1eb9bcb2aab5eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga82b37755a2e68c0b04c81a79fa82ad46" id="r_ga82b37755a2e68c0b04c81a79fa82ad46"><td class="memTemplParams" colspan="2">template&lt;EdgeMeshConcept MeshType&gt; <br />
requires HasPerEdgeAdjacentFaces&lt;MeshType&gt;</td></tr>
<tr class="memitem:ga82b37755a2e68c0b04c81a79fa82ad46"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__edge__requirements.html#ga82b37755a2e68c0b04c81a79fa82ad46">requirePerEdgeAdjacentFaces</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>)</td></tr>
<tr class="memdesc:ga82b37755a2e68c0b04c81a79fa82ad46"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function asserts that a <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a> has a EdgeContainer, the <a class="el" href="classvcl_1_1Edge.html" title="The Edge class represents an Edge element of the vcl::Mesh class.">Edge</a> has a AdjacentFaces Component, and that the AdjacentFaces Component is enabled and available at runtime.  <br /></td></tr>
<tr class="separator:ga82b37755a2e68c0b04c81a79fa82ad46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad1cac17f541eeabac2a6d8396a818f53" id="r_gad1cac17f541eeabac2a6d8396a818f53"><td class="memTemplParams" colspan="2">template&lt;EdgeMeshConcept MeshType&gt; <br />
requires HasPerEdgeColor&lt;MeshType&gt;</td></tr>
<tr class="memitem:gad1cac17f541eeabac2a6d8396a818f53"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__edge__requirements.html#gad1cac17f541eeabac2a6d8396a818f53">requirePerEdgeColor</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>)</td></tr>
<tr class="memdesc:gad1cac17f541eeabac2a6d8396a818f53"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function asserts that a <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a> has a EdgeContainer, the <a class="el" href="classvcl_1_1Edge.html" title="The Edge class represents an Edge element of the vcl::Mesh class.">Edge</a> has a <a class="el" href="classvcl_1_1Color.html" title="The Color class represents a 32 bit color.">Color</a> Component, and that the <a class="el" href="classvcl_1_1Color.html" title="The Color class represents a 32 bit color.">Color</a> Component is enabled and available at runtime.  <br /></td></tr>
<tr class="separator:gad1cac17f541eeabac2a6d8396a818f53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4033fc59330b356991232c063afb6bc1" id="r_ga4033fc59330b356991232c063afb6bc1"><td class="memTemplParams" colspan="2">template&lt;EdgeMeshConcept MeshType&gt; <br />
requires HasPerEdgeMark&lt;MeshType&gt;</td></tr>
<tr class="memitem:ga4033fc59330b356991232c063afb6bc1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__edge__requirements.html#ga4033fc59330b356991232c063afb6bc1">requirePerEdgeMark</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>)</td></tr>
<tr class="memdesc:ga4033fc59330b356991232c063afb6bc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function asserts that a <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a> has a EdgeContainer, the <a class="el" href="classvcl_1_1Edge.html" title="The Edge class represents an Edge element of the vcl::Mesh class.">Edge</a> has a Mark Component, and that the Mark Component is enabled and available at runtime.  <br /></td></tr>
<tr class="separator:ga4033fc59330b356991232c063afb6bc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga99f673acd51fd28272fc286b054ac3f2" id="r_ga99f673acd51fd28272fc286b054ac3f2"><td class="memTemplParams" colspan="2">template&lt;EdgeMeshConcept MeshType&gt; <br />
requires HasPerEdgeNormal&lt;MeshType&gt;</td></tr>
<tr class="memitem:ga99f673acd51fd28272fc286b054ac3f2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__edge__requirements.html#ga99f673acd51fd28272fc286b054ac3f2">requirePerEdgeNormal</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>)</td></tr>
<tr class="memdesc:ga99f673acd51fd28272fc286b054ac3f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function asserts that a <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a> has a EdgeContainer, the <a class="el" href="classvcl_1_1Edge.html" title="The Edge class represents an Edge element of the vcl::Mesh class.">Edge</a> has a Normal Component, and that the Normal Component is enabled and available at runtime.  <br /></td></tr>
<tr class="separator:ga99f673acd51fd28272fc286b054ac3f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae9df0edfc2990c2971514d87e866c31e" id="r_gae9df0edfc2990c2971514d87e866c31e"><td class="memTemplParams" colspan="2">template&lt;EdgeMeshConcept MeshType&gt; <br />
requires HasPerEdgeQuality&lt;MeshType&gt;</td></tr>
<tr class="memitem:gae9df0edfc2990c2971514d87e866c31e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__edge__requirements.html#gae9df0edfc2990c2971514d87e866c31e">requirePerEdgeQuality</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>)</td></tr>
<tr class="memdesc:gae9df0edfc2990c2971514d87e866c31e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function asserts that a <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a> has a EdgeContainer, the <a class="el" href="classvcl_1_1Edge.html" title="The Edge class represents an Edge element of the vcl::Mesh class.">Edge</a> has a Quality Component, and that the Quality Component is enabled and available at runtime.  <br /></td></tr>
<tr class="separator:gae9df0edfc2990c2971514d87e866c31e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f4ab723ca992b97ebeba82f85fac787" id="r_ga3f4ab723ca992b97ebeba82f85fac787"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a> ELEM_ID, MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga3f4ab723ca992b97ebeba82f85fac787"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mesh__requirements.html#ga3f4ab723ca992b97ebeba82f85fac787">isElementContainerCompact</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>)</td></tr>
<tr class="memdesc:ga3f4ab723ca992b97ebeba82f85fac787"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if the given mesh has its Container of the given <a class="el" href="classvcl_1_1Element.html" title="The Element class.">Element</a> compact.  <br /></td></tr>
<tr class="separator:ga3f4ab723ca992b97ebeba82f85fac787"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0cb1dd17c45e56caf4a313f557e677c3" id="r_ga0cb1dd17c45e56caf4a313f557e677c3"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a> ELEM_ID, <a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a> COMP_ID, MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga0cb1dd17c45e56caf4a313f557e677c3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mesh__requirements.html#ga0cb1dd17c45e56caf4a313f557e677c3">isPerElementComponentAvailable</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>)</td></tr>
<tr class="memdesc:ga0cb1dd17c45e56caf4a313f557e677c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the given component is available in the given element of the input mesh m.  <br /></td></tr>
<tr class="separator:ga0cb1dd17c45e56caf4a313f557e677c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6ccafe282dfd418a16426fb85c5c416" id="r_gac6ccafe282dfd418a16426fb85c5c416"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a> ELEM_ID, <a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a> COMP_ID, MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:gac6ccafe282dfd418a16426fb85c5c416"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mesh__requirements.html#gac6ccafe282dfd418a16426fb85c5c416">enableIfPerElementComponentOptional</a> (MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>)</td></tr>
<tr class="memdesc:gac6ccafe282dfd418a16426fb85c5c416"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes available the given Component in the given <a class="el" href="classvcl_1_1Element.html" title="The Element class.">Element</a> of the input mesh m, and returns <code>true</code> if it succeeds.  <br /></td></tr>
<tr class="separator:gac6ccafe282dfd418a16426fb85c5c416"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b9a2c1e26cd387e348ef4e137ec912c" id="r_ga6b9a2c1e26cd387e348ef4e137ec912c"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a> ELEM_ID, MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga6b9a2c1e26cd387e348ef4e137ec912c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mesh__requirements.html#ga6b9a2c1e26cd387e348ef4e137ec912c">requireElementContainerCompactness</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>)</td></tr>
<tr class="memdesc:ga6b9a2c1e26cd387e348ef4e137ec912c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function asserts that a <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a> has the Container of the given <a class="el" href="classvcl_1_1Element.html" title="The Element class.">Element</a> ID compact (no elements flagged as deleted).  <br /></td></tr>
<tr class="separator:ga6b9a2c1e26cd387e348ef4e137ec912c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga64d5aafc5d7a737a9654c763ee5a8132" id="r_ga64d5aafc5d7a737a9654c763ee5a8132"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a> ELEM_ID, <a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a> COMP_ID, MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga64d5aafc5d7a737a9654c763ee5a8132"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mesh__requirements.html#ga64d5aafc5d7a737a9654c763ee5a8132">requirePerElementComponent</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>)</td></tr>
<tr class="memdesc:ga64d5aafc5d7a737a9654c763ee5a8132"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function asserts that a <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a> has the Container of the given <a class="el" href="classvcl_1_1Element.html" title="The Element class.">Element</a> ID, the <a class="el" href="classvcl_1_1Element.html" title="The Element class.">Element</a> has a Component of the given Component ID, and that Component is available at runtime.  <br /></td></tr>
<tr class="separator:ga64d5aafc5d7a737a9654c763ee5a8132"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca827384c3a3069cf55d77dc48e3f4fa" id="r_gaca827384c3a3069cf55d77dc48e3f4fa"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:gaca827384c3a3069cf55d77dc48e3f4fa"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__face__requirements.html#gaca827384c3a3069cf55d77dc48e3f4fa">isFaceContainerCompact</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>)</td></tr>
<tr class="memdesc:gaca827384c3a3069cf55d77dc48e3f4fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if the given mesh has its FaceContainer compact.  <br /></td></tr>
<tr class="separator:gaca827384c3a3069cf55d77dc48e3f4fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33f24a91d99671c5977a6cd3f90c2993" id="r_ga33f24a91d99671c5977a6cd3f90c2993"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga33f24a91d99671c5977a6cd3f90c2993"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__face__requirements.html#ga33f24a91d99671c5977a6cd3f90c2993">isPerFaceAdjacentEdgesAvailable</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>)</td></tr>
<tr class="memdesc:ga33f24a91d99671c5977a6cd3f90c2993"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the AdjacentEdges component is available (enabled) in the <a class="el" href="classvcl_1_1Face.html" title="The Face class represents an Face element of the vcl::Mesh class.">Face</a> element of the input mesh m.  <br /></td></tr>
<tr class="separator:ga33f24a91d99671c5977a6cd3f90c2993"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab711bf0021a9256445957b3ccc2e0502" id="r_gab711bf0021a9256445957b3ccc2e0502"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:gab711bf0021a9256445957b3ccc2e0502"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__face__requirements.html#gab711bf0021a9256445957b3ccc2e0502">enableIfPerFaceAdjacentEdgesOptional</a> (MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>)</td></tr>
<tr class="memdesc:gab711bf0021a9256445957b3ccc2e0502"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the input mesh has a FaceContainer, and the <a class="el" href="classvcl_1_1Face.html" title="The Face class represents an Face element of the vcl::Mesh class.">Face</a> <a class="el" href="classvcl_1_1Element.html" title="The Element class.">Element</a> has a AdjacentEdges Component, this function enables the Component in the <a class="el" href="classvcl_1_1Element.html" title="The Element class.">Element</a> if the component needs to be enabled (meaning that it is optional). Returns <code>true</code> if, after the call of this function, the AdjacentEdges component will be available in the <a class="el" href="classvcl_1_1Face.html" title="The Face class represents an Face element of the vcl::Mesh class.">Face</a> <a class="el" href="classvcl_1_1Element.html" title="The Element class.">Element</a> of the mesh.  <br /></td></tr>
<tr class="separator:gab711bf0021a9256445957b3ccc2e0502"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a2e0c28c27a21d47d332154fbce554b" id="r_ga3a2e0c28c27a21d47d332154fbce554b"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga3a2e0c28c27a21d47d332154fbce554b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__face__requirements.html#ga3a2e0c28c27a21d47d332154fbce554b">isPerFaceAdjacentFacesAvailable</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>)</td></tr>
<tr class="memdesc:ga3a2e0c28c27a21d47d332154fbce554b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the AdjacentFaces component is available (enabled) in the <a class="el" href="classvcl_1_1Face.html" title="The Face class represents an Face element of the vcl::Mesh class.">Face</a> element of the input mesh m.  <br /></td></tr>
<tr class="separator:ga3a2e0c28c27a21d47d332154fbce554b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb30f645e6cc1b2c1d8655f445bf1843" id="r_gacb30f645e6cc1b2c1d8655f445bf1843"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:gacb30f645e6cc1b2c1d8655f445bf1843"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__face__requirements.html#gacb30f645e6cc1b2c1d8655f445bf1843">enableIfPerFaceAdjacentFacesOptional</a> (MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>)</td></tr>
<tr class="memdesc:gacb30f645e6cc1b2c1d8655f445bf1843"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the input mesh has a FaceContainer, and the <a class="el" href="classvcl_1_1Face.html" title="The Face class represents an Face element of the vcl::Mesh class.">Face</a> <a class="el" href="classvcl_1_1Element.html" title="The Element class.">Element</a> has a AdjacentFaces Component, this function enables the Component in the <a class="el" href="classvcl_1_1Element.html" title="The Element class.">Element</a> if the component needs to be enabled (meaning that it is optional). Returns <code>true</code> if, after the call of this function, the AdjacentFaces component will be available in the <a class="el" href="classvcl_1_1Face.html" title="The Face class represents an Face element of the vcl::Mesh class.">Face</a> <a class="el" href="classvcl_1_1Element.html" title="The Element class.">Element</a> of the mesh.  <br /></td></tr>
<tr class="separator:gacb30f645e6cc1b2c1d8655f445bf1843"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac0944e94fb8c662edf2cca5f55b721c7" id="r_gac0944e94fb8c662edf2cca5f55b721c7"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:gac0944e94fb8c662edf2cca5f55b721c7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__face__requirements.html#gac0944e94fb8c662edf2cca5f55b721c7">isPerFaceColorAvailable</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>)</td></tr>
<tr class="memdesc:gac0944e94fb8c662edf2cca5f55b721c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the <a class="el" href="classvcl_1_1Color.html" title="The Color class represents a 32 bit color.">Color</a> component is available (enabled) in the <a class="el" href="classvcl_1_1Face.html" title="The Face class represents an Face element of the vcl::Mesh class.">Face</a> element of the input mesh m.  <br /></td></tr>
<tr class="separator:gac0944e94fb8c662edf2cca5f55b721c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf3262073d55561ee24b5cfcc22250ee1" id="r_gaf3262073d55561ee24b5cfcc22250ee1"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:gaf3262073d55561ee24b5cfcc22250ee1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__face__requirements.html#gaf3262073d55561ee24b5cfcc22250ee1">enableIfPerFaceColorOptional</a> (MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>)</td></tr>
<tr class="memdesc:gaf3262073d55561ee24b5cfcc22250ee1"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the input mesh has a FaceContainer, and the <a class="el" href="classvcl_1_1Face.html" title="The Face class represents an Face element of the vcl::Mesh class.">Face</a> <a class="el" href="classvcl_1_1Element.html" title="The Element class.">Element</a> has a <a class="el" href="classvcl_1_1Color.html" title="The Color class represents a 32 bit color.">Color</a> Component, this function enables the Component in the <a class="el" href="classvcl_1_1Element.html" title="The Element class.">Element</a> if the component needs to be enabled (meaning that it is optional). Returns <code>true</code> if, after the call of this function, the <a class="el" href="classvcl_1_1Color.html" title="The Color class represents a 32 bit color.">Color</a> component will be available in the <a class="el" href="classvcl_1_1Face.html" title="The Face class represents an Face element of the vcl::Mesh class.">Face</a> <a class="el" href="classvcl_1_1Element.html" title="The Element class.">Element</a> of the mesh.  <br /></td></tr>
<tr class="separator:gaf3262073d55561ee24b5cfcc22250ee1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a5688d9713cddb144509b29dfd9f8ab" id="r_ga8a5688d9713cddb144509b29dfd9f8ab"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga8a5688d9713cddb144509b29dfd9f8ab"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__face__requirements.html#ga8a5688d9713cddb144509b29dfd9f8ab">isPerFaceMarkAvailable</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>)</td></tr>
<tr class="memdesc:ga8a5688d9713cddb144509b29dfd9f8ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the Mark component is available (enabled) in the <a class="el" href="classvcl_1_1Face.html" title="The Face class represents an Face element of the vcl::Mesh class.">Face</a> element of the input mesh m.  <br /></td></tr>
<tr class="separator:ga8a5688d9713cddb144509b29dfd9f8ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0efcb1c23b82c5c20f26149672806012" id="r_ga0efcb1c23b82c5c20f26149672806012"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga0efcb1c23b82c5c20f26149672806012"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__face__requirements.html#ga0efcb1c23b82c5c20f26149672806012">enableIfPerFaceMarkOptional</a> (MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>)</td></tr>
<tr class="memdesc:ga0efcb1c23b82c5c20f26149672806012"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the input mesh has a FaceContainer, and the <a class="el" href="classvcl_1_1Face.html" title="The Face class represents an Face element of the vcl::Mesh class.">Face</a> <a class="el" href="classvcl_1_1Element.html" title="The Element class.">Element</a> has a Mark Component, this function enables the Component in the <a class="el" href="classvcl_1_1Element.html" title="The Element class.">Element</a> if the component needs to be enabled (meaning that it is optional). Returns <code>true</code> if, after the call of this function, the Mark component will be available in the <a class="el" href="classvcl_1_1Face.html" title="The Face class represents an Face element of the vcl::Mesh class.">Face</a> <a class="el" href="classvcl_1_1Element.html" title="The Element class.">Element</a> of the mesh.  <br /></td></tr>
<tr class="separator:ga0efcb1c23b82c5c20f26149672806012"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ab2973732b455aedeb6f6dfe424346f" id="r_ga6ab2973732b455aedeb6f6dfe424346f"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga6ab2973732b455aedeb6f6dfe424346f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__face__requirements.html#ga6ab2973732b455aedeb6f6dfe424346f">isPerFaceNormalAvailable</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>)</td></tr>
<tr class="memdesc:ga6ab2973732b455aedeb6f6dfe424346f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the Normal component is available (enabled) in the <a class="el" href="classvcl_1_1Face.html" title="The Face class represents an Face element of the vcl::Mesh class.">Face</a> element of the input mesh m.  <br /></td></tr>
<tr class="separator:ga6ab2973732b455aedeb6f6dfe424346f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf07e8fad913b41d5db61c140e24d35c4" id="r_gaf07e8fad913b41d5db61c140e24d35c4"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:gaf07e8fad913b41d5db61c140e24d35c4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__face__requirements.html#gaf07e8fad913b41d5db61c140e24d35c4">enableIfPerFaceNormalOptional</a> (MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>)</td></tr>
<tr class="memdesc:gaf07e8fad913b41d5db61c140e24d35c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the input mesh has a FaceContainer, and the <a class="el" href="classvcl_1_1Face.html" title="The Face class represents an Face element of the vcl::Mesh class.">Face</a> <a class="el" href="classvcl_1_1Element.html" title="The Element class.">Element</a> has a Normal Component, this function enables the Component in the <a class="el" href="classvcl_1_1Element.html" title="The Element class.">Element</a> if the component needs to be enabled (meaning that it is optional). Returns <code>true</code> if, after the call of this function, the Normal component will be available in the <a class="el" href="classvcl_1_1Face.html" title="The Face class represents an Face element of the vcl::Mesh class.">Face</a> <a class="el" href="classvcl_1_1Element.html" title="The Element class.">Element</a> of the mesh.  <br /></td></tr>
<tr class="separator:gaf07e8fad913b41d5db61c140e24d35c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf6682edccdffa17b232dd83c08718cd5" id="r_gaf6682edccdffa17b232dd83c08718cd5"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:gaf6682edccdffa17b232dd83c08718cd5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__face__requirements.html#gaf6682edccdffa17b232dd83c08718cd5">isPerFacePrincipalCurvatureAvailable</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>)</td></tr>
<tr class="memdesc:gaf6682edccdffa17b232dd83c08718cd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the <a class="el" href="classvcl_1_1PrincipalCurvature.html" title="The PrincipalCurvature class stores the principal curvature directions and values at a point on a sur...">PrincipalCurvature</a> component is available (enabled) in the <a class="el" href="classvcl_1_1Face.html" title="The Face class represents an Face element of the vcl::Mesh class.">Face</a> element of the input mesh m.  <br /></td></tr>
<tr class="separator:gaf6682edccdffa17b232dd83c08718cd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e4d93cc27448070bbb26df5cf3c200a" id="r_ga7e4d93cc27448070bbb26df5cf3c200a"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga7e4d93cc27448070bbb26df5cf3c200a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__face__requirements.html#ga7e4d93cc27448070bbb26df5cf3c200a">enableIfPerFacePrincipalCurvatureOptional</a> (MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>)</td></tr>
<tr class="memdesc:ga7e4d93cc27448070bbb26df5cf3c200a"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the input mesh has a FaceContainer, and the <a class="el" href="classvcl_1_1Face.html" title="The Face class represents an Face element of the vcl::Mesh class.">Face</a> <a class="el" href="classvcl_1_1Element.html" title="The Element class.">Element</a> has a <a class="el" href="classvcl_1_1PrincipalCurvature.html" title="The PrincipalCurvature class stores the principal curvature directions and values at a point on a sur...">PrincipalCurvature</a> Component, this function enables the Component in the <a class="el" href="classvcl_1_1Element.html" title="The Element class.">Element</a> if the component needs to be enabled (meaning that it is optional). Returns <code>true</code> if, after the call of this function, the <a class="el" href="classvcl_1_1PrincipalCurvature.html" title="The PrincipalCurvature class stores the principal curvature directions and values at a point on a sur...">PrincipalCurvature</a> component will be available in the <a class="el" href="classvcl_1_1Face.html" title="The Face class represents an Face element of the vcl::Mesh class.">Face</a> <a class="el" href="classvcl_1_1Element.html" title="The Element class.">Element</a> of the mesh.  <br /></td></tr>
<tr class="separator:ga7e4d93cc27448070bbb26df5cf3c200a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga75a72c0a2cccc6981c1ac702ab4f5a5c" id="r_ga75a72c0a2cccc6981c1ac702ab4f5a5c"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga75a72c0a2cccc6981c1ac702ab4f5a5c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__face__requirements.html#ga75a72c0a2cccc6981c1ac702ab4f5a5c">isPerFaceQualityAvailable</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>)</td></tr>
<tr class="memdesc:ga75a72c0a2cccc6981c1ac702ab4f5a5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the Quality component is available (enabled) in the <a class="el" href="classvcl_1_1Face.html" title="The Face class represents an Face element of the vcl::Mesh class.">Face</a> element of the input mesh m.  <br /></td></tr>
<tr class="separator:ga75a72c0a2cccc6981c1ac702ab4f5a5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga074866b13c60aa020dd3285eb206ee7e" id="r_ga074866b13c60aa020dd3285eb206ee7e"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga074866b13c60aa020dd3285eb206ee7e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__face__requirements.html#ga074866b13c60aa020dd3285eb206ee7e">enableIfPerFaceQualityOptional</a> (MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>)</td></tr>
<tr class="memdesc:ga074866b13c60aa020dd3285eb206ee7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the input mesh has a FaceContainer, and the <a class="el" href="classvcl_1_1Face.html" title="The Face class represents an Face element of the vcl::Mesh class.">Face</a> <a class="el" href="classvcl_1_1Element.html" title="The Element class.">Element</a> has a Quality Component, this function enables the Component in the <a class="el" href="classvcl_1_1Element.html" title="The Element class.">Element</a> if the component needs to be enabled (meaning that it is optional). Returns <code>true</code> if, after the call of this function, the Quality component will be available in the <a class="el" href="classvcl_1_1Face.html" title="The Face class represents an Face element of the vcl::Mesh class.">Face</a> <a class="el" href="classvcl_1_1Element.html" title="The Element class.">Element</a> of the mesh.  <br /></td></tr>
<tr class="separator:ga074866b13c60aa020dd3285eb206ee7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga817a6cd5920e1bb0e8850c183367e112" id="r_ga817a6cd5920e1bb0e8850c183367e112"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga817a6cd5920e1bb0e8850c183367e112"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__face__requirements.html#ga817a6cd5920e1bb0e8850c183367e112">isPerFaceWedgeColorsAvailable</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>)</td></tr>
<tr class="memdesc:ga817a6cd5920e1bb0e8850c183367e112"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the WedgeColors component is available (enabled) in the <a class="el" href="classvcl_1_1Face.html" title="The Face class represents an Face element of the vcl::Mesh class.">Face</a> element of the input mesh m.  <br /></td></tr>
<tr class="separator:ga817a6cd5920e1bb0e8850c183367e112"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf2bc7d8c340f922fda76e1d01588433c" id="r_gaf2bc7d8c340f922fda76e1d01588433c"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:gaf2bc7d8c340f922fda76e1d01588433c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__face__requirements.html#gaf2bc7d8c340f922fda76e1d01588433c">enableIfPerFaceWedgeColorsOptional</a> (MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>)</td></tr>
<tr class="memdesc:gaf2bc7d8c340f922fda76e1d01588433c"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the input mesh has a FaceContainer, and the <a class="el" href="classvcl_1_1Face.html" title="The Face class represents an Face element of the vcl::Mesh class.">Face</a> <a class="el" href="classvcl_1_1Element.html" title="The Element class.">Element</a> has a WedgeColors Component, this function enables the Component in the <a class="el" href="classvcl_1_1Element.html" title="The Element class.">Element</a> if the component needs to be enabled (meaning that it is optional). Returns <code>true</code> if, after the call of this function, the WedgeColors component will be available in the <a class="el" href="classvcl_1_1Face.html" title="The Face class represents an Face element of the vcl::Mesh class.">Face</a> <a class="el" href="classvcl_1_1Element.html" title="The Element class.">Element</a> of the mesh.  <br /></td></tr>
<tr class="separator:gaf2bc7d8c340f922fda76e1d01588433c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5fbed843fdb42d0018a5f343523b0719" id="r_ga5fbed843fdb42d0018a5f343523b0719"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga5fbed843fdb42d0018a5f343523b0719"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__face__requirements.html#ga5fbed843fdb42d0018a5f343523b0719">isPerFaceWedgeTexCoordsAvailable</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>)</td></tr>
<tr class="memdesc:ga5fbed843fdb42d0018a5f343523b0719"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the WedgeTexCoords component is available (enabled) in the <a class="el" href="classvcl_1_1Face.html" title="The Face class represents an Face element of the vcl::Mesh class.">Face</a> element of the input mesh m.  <br /></td></tr>
<tr class="separator:ga5fbed843fdb42d0018a5f343523b0719"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5cfd1a61b06b32978aa70024f8b8e8f3" id="r_ga5cfd1a61b06b32978aa70024f8b8e8f3"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga5cfd1a61b06b32978aa70024f8b8e8f3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__face__requirements.html#ga5cfd1a61b06b32978aa70024f8b8e8f3">enableIfPerFaceWedgeTexCoordsOptional</a> (MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>)</td></tr>
<tr class="memdesc:ga5cfd1a61b06b32978aa70024f8b8e8f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the input mesh has a FaceContainer, and the <a class="el" href="classvcl_1_1Face.html" title="The Face class represents an Face element of the vcl::Mesh class.">Face</a> <a class="el" href="classvcl_1_1Element.html" title="The Element class.">Element</a> has a WedgeTexCoords Component, this function enables the Component in the <a class="el" href="classvcl_1_1Element.html" title="The Element class.">Element</a> if the component needs to be enabled (meaning that it is optional). Returns <code>true</code> if, after the call of this function, the WedgeTexCoords component will be available in the <a class="el" href="classvcl_1_1Face.html" title="The Face class represents an Face element of the vcl::Mesh class.">Face</a> <a class="el" href="classvcl_1_1Element.html" title="The Element class.">Element</a> of the mesh.  <br /></td></tr>
<tr class="separator:ga5cfd1a61b06b32978aa70024f8b8e8f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa5e8d79003b3a928d430219d244a4855" id="r_gaa5e8d79003b3a928d430219d244a4855"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:gaa5e8d79003b3a928d430219d244a4855"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__face__requirements.html#gaa5e8d79003b3a928d430219d244a4855">requireFaceContainerCompactness</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>)</td></tr>
<tr class="memdesc:gaa5e8d79003b3a928d430219d244a4855"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function asserts that a <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a> has the FaceContainer compact (no elements flagged as deleted).  <br /></td></tr>
<tr class="separator:gaa5e8d79003b3a928d430219d244a4855"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga806ec8c0b627a10d684745c6eee1ce20" id="r_ga806ec8c0b627a10d684745c6eee1ce20"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; <br />
requires HasPerFaceAdjacentEdges&lt;MeshType&gt;</td></tr>
<tr class="memitem:ga806ec8c0b627a10d684745c6eee1ce20"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__face__requirements.html#ga806ec8c0b627a10d684745c6eee1ce20">requirePerFaceAdjacentEdges</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>)</td></tr>
<tr class="memdesc:ga806ec8c0b627a10d684745c6eee1ce20"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function asserts that a <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a> has a FaceContainer, the <a class="el" href="classvcl_1_1Face.html" title="The Face class represents an Face element of the vcl::Mesh class.">Face</a> has a AdjacentEdges Component, and that the AdjacentEdges Component is enabled and available at runtime.  <br /></td></tr>
<tr class="separator:ga806ec8c0b627a10d684745c6eee1ce20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff3602e750a1d1c93374f642be47a6b0" id="r_gaff3602e750a1d1c93374f642be47a6b0"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; <br />
requires HasPerFaceAdjacentFaces&lt;MeshType&gt;</td></tr>
<tr class="memitem:gaff3602e750a1d1c93374f642be47a6b0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__face__requirements.html#gaff3602e750a1d1c93374f642be47a6b0">requirePerFaceAdjacentFaces</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>)</td></tr>
<tr class="memdesc:gaff3602e750a1d1c93374f642be47a6b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function asserts that a <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a> has a FaceContainer, the <a class="el" href="classvcl_1_1Face.html" title="The Face class represents an Face element of the vcl::Mesh class.">Face</a> has a AdjacentFaces Component, and that the AdjacentFaces Component is enabled and available at runtime.  <br /></td></tr>
<tr class="separator:gaff3602e750a1d1c93374f642be47a6b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae6372afb65d4cb206aed162aff2d71c3" id="r_gae6372afb65d4cb206aed162aff2d71c3"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; <br />
requires HasPerFaceColor&lt;MeshType&gt;</td></tr>
<tr class="memitem:gae6372afb65d4cb206aed162aff2d71c3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__face__requirements.html#gae6372afb65d4cb206aed162aff2d71c3">requirePerFaceColor</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>)</td></tr>
<tr class="memdesc:gae6372afb65d4cb206aed162aff2d71c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function asserts that a <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a> has a FaceContainer, the <a class="el" href="classvcl_1_1Face.html" title="The Face class represents an Face element of the vcl::Mesh class.">Face</a> has a <a class="el" href="classvcl_1_1Color.html" title="The Color class represents a 32 bit color.">Color</a> Component, and that the <a class="el" href="classvcl_1_1Color.html" title="The Color class represents a 32 bit color.">Color</a> Component is enabled and available at runtime.  <br /></td></tr>
<tr class="separator:gae6372afb65d4cb206aed162aff2d71c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac96a0a92c22ced9c629b174dade3dd70" id="r_gac96a0a92c22ced9c629b174dade3dd70"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; <br />
requires HasPerFaceMark&lt;MeshType&gt;</td></tr>
<tr class="memitem:gac96a0a92c22ced9c629b174dade3dd70"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__face__requirements.html#gac96a0a92c22ced9c629b174dade3dd70">requirePerFaceMark</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>)</td></tr>
<tr class="memdesc:gac96a0a92c22ced9c629b174dade3dd70"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function asserts that a <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a> has a FaceContainer, the <a class="el" href="classvcl_1_1Face.html" title="The Face class represents an Face element of the vcl::Mesh class.">Face</a> has a Mark Component, and that the Mark Component is enabled and available at runtime.  <br /></td></tr>
<tr class="separator:gac96a0a92c22ced9c629b174dade3dd70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac641c6af53b47b21fe2b1b85f1b1c8c4" id="r_gac641c6af53b47b21fe2b1b85f1b1c8c4"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; <br />
requires HasPerFaceNormal&lt;MeshType&gt;</td></tr>
<tr class="memitem:gac641c6af53b47b21fe2b1b85f1b1c8c4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__face__requirements.html#gac641c6af53b47b21fe2b1b85f1b1c8c4">requirePerFaceNormal</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>)</td></tr>
<tr class="memdesc:gac641c6af53b47b21fe2b1b85f1b1c8c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function asserts that a <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a> has a FaceContainer, the <a class="el" href="classvcl_1_1Face.html" title="The Face class represents an Face element of the vcl::Mesh class.">Face</a> has a Normal Component, and that the Normal Component is enabled and available at runtime.  <br /></td></tr>
<tr class="separator:gac641c6af53b47b21fe2b1b85f1b1c8c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga880bfabf90d17524361cc4115587db56" id="r_ga880bfabf90d17524361cc4115587db56"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; <br />
requires HasPerFacePrincipalCurvature&lt;MeshType&gt;</td></tr>
<tr class="memitem:ga880bfabf90d17524361cc4115587db56"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__face__requirements.html#ga880bfabf90d17524361cc4115587db56">requirePerFacePrincipalCurvature</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>)</td></tr>
<tr class="memdesc:ga880bfabf90d17524361cc4115587db56"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function asserts that a <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a> has a FaceContainer, the <a class="el" href="classvcl_1_1Face.html" title="The Face class represents an Face element of the vcl::Mesh class.">Face</a> has a <a class="el" href="classvcl_1_1PrincipalCurvature.html" title="The PrincipalCurvature class stores the principal curvature directions and values at a point on a sur...">PrincipalCurvature</a> Component, and that the <a class="el" href="classvcl_1_1PrincipalCurvature.html" title="The PrincipalCurvature class stores the principal curvature directions and values at a point on a sur...">PrincipalCurvature</a> Component is enabled and available at runtime.  <br /></td></tr>
<tr class="separator:ga880bfabf90d17524361cc4115587db56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c3e051c842750da953304d22258d704" id="r_ga7c3e051c842750da953304d22258d704"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; <br />
requires HasPerFaceQuality&lt;MeshType&gt;</td></tr>
<tr class="memitem:ga7c3e051c842750da953304d22258d704"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__face__requirements.html#ga7c3e051c842750da953304d22258d704">requirePerFaceQuality</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>)</td></tr>
<tr class="memdesc:ga7c3e051c842750da953304d22258d704"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function asserts that a <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a> has a FaceContainer, the <a class="el" href="classvcl_1_1Face.html" title="The Face class represents an Face element of the vcl::Mesh class.">Face</a> has a Quality Component, and that the Quality Component is enabled and available at runtime.  <br /></td></tr>
<tr class="separator:ga7c3e051c842750da953304d22258d704"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef39ab9380581074304975fc0cb49570" id="r_gaef39ab9380581074304975fc0cb49570"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; <br />
requires HasPerFaceWedgeColors&lt;MeshType&gt;</td></tr>
<tr class="memitem:gaef39ab9380581074304975fc0cb49570"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__face__requirements.html#gaef39ab9380581074304975fc0cb49570">requirePerFaceWedgeColors</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>)</td></tr>
<tr class="memdesc:gaef39ab9380581074304975fc0cb49570"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function asserts that a <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a> has a FaceContainer, the <a class="el" href="classvcl_1_1Face.html" title="The Face class represents an Face element of the vcl::Mesh class.">Face</a> has a WedgeColors Component, and that the WedgeColors Component is enabled and available at runtime.  <br /></td></tr>
<tr class="separator:gaef39ab9380581074304975fc0cb49570"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f262a65d84b84b17a5d41b13fa98329" id="r_ga7f262a65d84b84b17a5d41b13fa98329"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; <br />
requires HasPerFaceWedgeTexCoords&lt;MeshType&gt;</td></tr>
<tr class="memitem:ga7f262a65d84b84b17a5d41b13fa98329"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__face__requirements.html#ga7f262a65d84b84b17a5d41b13fa98329">requirePerFaceWedgeTexCoords</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>)</td></tr>
<tr class="memdesc:ga7f262a65d84b84b17a5d41b13fa98329"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function asserts that a <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a> has a FaceContainer, the <a class="el" href="classvcl_1_1Face.html" title="The Face class represents an Face element of the vcl::Mesh class.">Face</a> has a WedgeTexCoords Component, and that the WedgeTexCoords Component is enabled and available at runtime.  <br /></td></tr>
<tr class="separator:ga7f262a65d84b84b17a5d41b13fa98329"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f44643cdd6a934b9ab5f60315e6f01a" id="r_ga2f44643cdd6a934b9ab5f60315e6f01a"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga2f44643cdd6a934b9ab5f60315e6f01a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mesh__requirements.html#ga2f44643cdd6a934b9ab5f60315e6f01a">isTriangleMesh</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>)</td></tr>
<tr class="memdesc:ga2f44643cdd6a934b9ab5f60315e6f01a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks <em>at run time</em> if the mesh m is composed of triangles.  <br /></td></tr>
<tr class="separator:ga2f44643cdd6a934b9ab5f60315e6f01a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1878ac13ce283e3535efd93d254d1843" id="r_ga1878ac13ce283e3535efd93d254d1843"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga1878ac13ce283e3535efd93d254d1843"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mesh__requirements.html#ga1878ac13ce283e3535efd93d254d1843">isQuadMesh</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>)</td></tr>
<tr class="memdesc:ga1878ac13ce283e3535efd93d254d1843"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks <em>at run time</em> if the mesh is composed of quads.  <br /></td></tr>
<tr class="separator:ga1878ac13ce283e3535efd93d254d1843"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb9fbe7647f2b656ab871e2bb20b8c33" id="r_gacb9fbe7647f2b656ab871e2bb20b8c33"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:gacb9fbe7647f2b656ab871e2bb20b8c33"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mesh__requirements.html#gacb9fbe7647f2b656ab871e2bb20b8c33">isCompact</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>)</td></tr>
<tr class="memdesc:gacb9fbe7647f2b656ab871e2bb20b8c33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a> is compact, that is if it does not contains deleted elements.  <br /></td></tr>
<tr class="separator:gacb9fbe7647f2b656ab871e2bb20b8c33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f347e31d2e1fd9471cc98f46668c64c" id="r_ga3f347e31d2e1fd9471cc98f46668c64c"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga3f347e31d2e1fd9471cc98f46668c64c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mesh__requirements.html#ga3f347e31d2e1fd9471cc98f46668c64c">requireTriangleMesh</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>)</td></tr>
<tr class="memdesc:ga3f347e31d2e1fd9471cc98f46668c64c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the mesh is composed of triangles, and if not, throws an exception.  <br /></td></tr>
<tr class="separator:ga3f347e31d2e1fd9471cc98f46668c64c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa713300521a68b8fe8bf5154fdae27b8" id="r_gaa713300521a68b8fe8bf5154fdae27b8"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:gaa713300521a68b8fe8bf5154fdae27b8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mesh__requirements.html#gaa713300521a68b8fe8bf5154fdae27b8">requireQuadMesh</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>)</td></tr>
<tr class="memdesc:gaa713300521a68b8fe8bf5154fdae27b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the mesh is composed of quads, and if not, throws an exception.  <br /></td></tr>
<tr class="separator:gaa713300521a68b8fe8bf5154fdae27b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga84e84c881525f5d76599d6ef8d4a0933" id="r_ga84e84c881525f5d76599d6ef8d4a0933"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga84e84c881525f5d76599d6ef8d4a0933"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mesh__requirements.html#ga84e84c881525f5d76599d6ef8d4a0933">requireCompactness</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>)</td></tr>
<tr class="memdesc:ga84e84c881525f5d76599d6ef8d4a0933"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a> is compact, that is if it does not contains deleted elements, and if not, throws an exception.  <br /></td></tr>
<tr class="separator:ga84e84c881525f5d76599d6ef8d4a0933"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf71077b0dd03e109c80a05dc1bcafdf5" id="r_gaf71077b0dd03e109c80a05dc1bcafdf5"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:gaf71077b0dd03e109c80a05dc1bcafdf5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__vertex__requirements.html#gaf71077b0dd03e109c80a05dc1bcafdf5">isVertexContainerCompact</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>)</td></tr>
<tr class="memdesc:gaf71077b0dd03e109c80a05dc1bcafdf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if the given mesh has its <a class="el" href="classvcl_1_1Vertex.html" title="The Vertex class represents an Vertex element of the vcl::Mesh class.">Vertex</a> Container compact.  <br /></td></tr>
<tr class="separator:gaf71077b0dd03e109c80a05dc1bcafdf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e568fca42924a53fde391597ff4e560" id="r_a3e568fca42924a53fde391597ff4e560"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a3e568fca42924a53fde391597ff4e560"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a3e568fca42924a53fde391597ff4e560">isPerVertexAdjacentFacesAvailable</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>)</td></tr>
<tr class="separator:a3e568fca42924a53fde391597ff4e560"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a617cf756eac51fcf6b566ce5d4c09393" id="r_a617cf756eac51fcf6b566ce5d4c09393"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a617cf756eac51fcf6b566ce5d4c09393"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a617cf756eac51fcf6b566ce5d4c09393">enableIfPerVertexAdjacentFacesOptional</a> (MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>)</td></tr>
<tr class="separator:a617cf756eac51fcf6b566ce5d4c09393"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84a2badab79a21f537f854257457ae8e" id="r_a84a2badab79a21f537f854257457ae8e"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a84a2badab79a21f537f854257457ae8e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a84a2badab79a21f537f854257457ae8e">isPerVertexAdjacentVerticesAvailable</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>)</td></tr>
<tr class="separator:a84a2badab79a21f537f854257457ae8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e15c93274d1207f45bb0673fce3ba8a" id="r_a6e15c93274d1207f45bb0673fce3ba8a"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a6e15c93274d1207f45bb0673fce3ba8a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a6e15c93274d1207f45bb0673fce3ba8a">enableIfPerVertexAdjacentVerticesOptional</a> (MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>)</td></tr>
<tr class="separator:a6e15c93274d1207f45bb0673fce3ba8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac805cc3d735ee5883647218cdd1ee7e0" id="r_ac805cc3d735ee5883647218cdd1ee7e0"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ac805cc3d735ee5883647218cdd1ee7e0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ac805cc3d735ee5883647218cdd1ee7e0">isPerVertexColorAvailable</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>)</td></tr>
<tr class="separator:ac805cc3d735ee5883647218cdd1ee7e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a802d56a620a24d04972ba5d483a2730a" id="r_a802d56a620a24d04972ba5d483a2730a"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a802d56a620a24d04972ba5d483a2730a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a802d56a620a24d04972ba5d483a2730a">enableIfPerVertexColorOptional</a> (MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>)</td></tr>
<tr class="separator:a802d56a620a24d04972ba5d483a2730a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dc8c6d96d74cceffb34a1a480864563" id="r_a7dc8c6d96d74cceffb34a1a480864563"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a7dc8c6d96d74cceffb34a1a480864563"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a7dc8c6d96d74cceffb34a1a480864563">isPerVertexMarkAvailable</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>)</td></tr>
<tr class="separator:a7dc8c6d96d74cceffb34a1a480864563"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64bde18cc07f8804c0c96e5def984f26" id="r_a64bde18cc07f8804c0c96e5def984f26"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a64bde18cc07f8804c0c96e5def984f26"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a64bde18cc07f8804c0c96e5def984f26">enableIfPerVertexMarkOptional</a> (MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>)</td></tr>
<tr class="separator:a64bde18cc07f8804c0c96e5def984f26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af37173d6ec6aa5b11580217057aa6e24" id="r_af37173d6ec6aa5b11580217057aa6e24"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:af37173d6ec6aa5b11580217057aa6e24"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#af37173d6ec6aa5b11580217057aa6e24">isPerVertexNormalAvailable</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>)</td></tr>
<tr class="separator:af37173d6ec6aa5b11580217057aa6e24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4a7a739d6f30a2e4768b7b12c663418" id="r_af4a7a739d6f30a2e4768b7b12c663418"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:af4a7a739d6f30a2e4768b7b12c663418"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#af4a7a739d6f30a2e4768b7b12c663418">enableIfPerVertexNormalOptional</a> (MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>)</td></tr>
<tr class="separator:af4a7a739d6f30a2e4768b7b12c663418"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeba9629e5f1c2363b2b35bc865f9d11e" id="r_aeba9629e5f1c2363b2b35bc865f9d11e"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:aeba9629e5f1c2363b2b35bc865f9d11e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#aeba9629e5f1c2363b2b35bc865f9d11e">isPerVertexPrincipalCurvatureAvailable</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>)</td></tr>
<tr class="separator:aeba9629e5f1c2363b2b35bc865f9d11e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a579b161f8a4132e5106608bebc70e363" id="r_a579b161f8a4132e5106608bebc70e363"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a579b161f8a4132e5106608bebc70e363"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a579b161f8a4132e5106608bebc70e363">enableIfPerVertexPrincipalCurvatureOptional</a> (MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>)</td></tr>
<tr class="separator:a579b161f8a4132e5106608bebc70e363"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09449154647e40fd0a3c1e965a91bf49" id="r_a09449154647e40fd0a3c1e965a91bf49"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a09449154647e40fd0a3c1e965a91bf49"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a09449154647e40fd0a3c1e965a91bf49">isPerVertexQualityAvailable</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>)</td></tr>
<tr class="separator:a09449154647e40fd0a3c1e965a91bf49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9eb68875b4658e81e104725173df6fd" id="r_aa9eb68875b4658e81e104725173df6fd"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:aa9eb68875b4658e81e104725173df6fd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#aa9eb68875b4658e81e104725173df6fd">enableIfPerVertexQualityOptional</a> (MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>)</td></tr>
<tr class="separator:aa9eb68875b4658e81e104725173df6fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91da20c5938a63be8d206b547892a205" id="r_a91da20c5938a63be8d206b547892a205"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a91da20c5938a63be8d206b547892a205"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a91da20c5938a63be8d206b547892a205">isPerVertexTexCoordAvailable</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>)</td></tr>
<tr class="separator:a91da20c5938a63be8d206b547892a205"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a369d2067cce035b7b4a710c5b364a28c" id="r_a369d2067cce035b7b4a710c5b364a28c"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a369d2067cce035b7b4a710c5b364a28c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a369d2067cce035b7b4a710c5b364a28c">enableIfPerVertexTexCoordOptional</a> (MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>)</td></tr>
<tr class="separator:a369d2067cce035b7b4a710c5b364a28c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5e94dd9b89e9bc4fb21701af6e788ca" id="r_ae5e94dd9b89e9bc4fb21701af6e788ca"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ae5e94dd9b89e9bc4fb21701af6e788ca"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ae5e94dd9b89e9bc4fb21701af6e788ca">requireVertexContainerCompactness</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>)</td></tr>
<tr class="separator:ae5e94dd9b89e9bc4fb21701af6e788ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f6666a7b9cd7293ab07aaf6cbc1dc4c" id="r_a1f6666a7b9cd7293ab07aaf6cbc1dc4c"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classvcl_1_1Matrix.html">typename</a> MeshType &gt; <br />
requires HasPerVertexAdjacentFaces&lt;MeshType&gt;</td></tr>
<tr class="memitem:a1f6666a7b9cd7293ab07aaf6cbc1dc4c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a1f6666a7b9cd7293ab07aaf6cbc1dc4c">requirePerVertexAdjacentFaces</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>)</td></tr>
<tr class="separator:a1f6666a7b9cd7293ab07aaf6cbc1dc4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a224534742afebeedf036df597231c700" id="r_a224534742afebeedf036df597231c700"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classvcl_1_1Matrix.html">typename</a> MeshType &gt; <br />
requires HasPerVertexAdjacentVertices&lt;MeshType&gt;</td></tr>
<tr class="memitem:a224534742afebeedf036df597231c700"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a224534742afebeedf036df597231c700">requirePerVertexAdjacentVertices</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>)</td></tr>
<tr class="separator:a224534742afebeedf036df597231c700"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fc65a005474dd6f983d5f9b235b5387" id="r_a3fc65a005474dd6f983d5f9b235b5387"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classvcl_1_1Matrix.html">typename</a> MeshType &gt; <br />
requires HasPerVertexColor&lt;MeshType&gt;</td></tr>
<tr class="memitem:a3fc65a005474dd6f983d5f9b235b5387"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a3fc65a005474dd6f983d5f9b235b5387">requirePerVertexColor</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>)</td></tr>
<tr class="separator:a3fc65a005474dd6f983d5f9b235b5387"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1b0cb92a48a555d7084bb6fb94ef359" id="r_ad1b0cb92a48a555d7084bb6fb94ef359"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classvcl_1_1Matrix.html">typename</a> MeshType &gt; <br />
requires HasPerVertexMark&lt;MeshType&gt;</td></tr>
<tr class="memitem:ad1b0cb92a48a555d7084bb6fb94ef359"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ad1b0cb92a48a555d7084bb6fb94ef359">requirePerVertexMark</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>)</td></tr>
<tr class="separator:ad1b0cb92a48a555d7084bb6fb94ef359"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab43f884f6ca679c8f57255e11ddaa768" id="r_ab43f884f6ca679c8f57255e11ddaa768"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classvcl_1_1Matrix.html">typename</a> MeshType &gt; <br />
requires HasPerVertexNormal&lt;MeshType&gt;</td></tr>
<tr class="memitem:ab43f884f6ca679c8f57255e11ddaa768"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ab43f884f6ca679c8f57255e11ddaa768">requirePerVertexNormal</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>)</td></tr>
<tr class="separator:ab43f884f6ca679c8f57255e11ddaa768"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af330a765b2c7772ff85378f617ade27b" id="r_af330a765b2c7772ff85378f617ade27b"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classvcl_1_1Matrix.html">typename</a> MeshType &gt; <br />
requires HasPerVertexPrincipalCurvature&lt;MeshType&gt;</td></tr>
<tr class="memitem:af330a765b2c7772ff85378f617ade27b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#af330a765b2c7772ff85378f617ade27b">requirePerVertexPrincipalCurvature</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>)</td></tr>
<tr class="separator:af330a765b2c7772ff85378f617ade27b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49287ff6e3778f10a280b1166006dff9" id="r_a49287ff6e3778f10a280b1166006dff9"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classvcl_1_1Matrix.html">typename</a> MeshType &gt; <br />
requires HasPerVertexQuality&lt;MeshType&gt;</td></tr>
<tr class="memitem:a49287ff6e3778f10a280b1166006dff9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a49287ff6e3778f10a280b1166006dff9">requirePerVertexQuality</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>)</td></tr>
<tr class="separator:a49287ff6e3778f10a280b1166006dff9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f20fd534d1bb822fe5b13f2515025ee" id="r_a5f20fd534d1bb822fe5b13f2515025ee"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classvcl_1_1Matrix.html">typename</a> MeshType &gt; <br />
requires HasPerVertexTexCoord&lt;MeshType&gt;</td></tr>
<tr class="memitem:a5f20fd534d1bb822fe5b13f2515025ee"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a5f20fd534d1bb822fe5b13f2515025ee">requirePerVertexTexCoord</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>)</td></tr>
<tr class="separator:a5f20fd534d1bb822fe5b13f2515025ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca4e61e9eb02bae8617f346aaf830452" id="r_aca4e61e9eb02bae8617f346aaf830452"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classvcl_1_1Matrix.html">typename</a> T , typename... Args&gt; </td></tr>
<tr class="memitem:aca4e61e9eb02bae8617f346aaf830452"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#aca4e61e9eb02bae8617f346aaf830452">compactVector</a> (std::vector&lt; T, Args... &gt; &amp;<a class="el" href="classvcl_1_1Matrix.html">vec</a>, <a class="el" href="classvcl_1_1Matrix.html">const</a> std::vector&lt; <a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a> &gt; &amp;<a class="el" href="classvcl_1_1Matrix.html">newIndices</a>)</td></tr>
<tr class="memdesc:aca4e61e9eb02bae8617f346aaf830452"><td class="mdescLeft">&#160;</td><td class="mdescRight">It will take care of compacting the vector vec, depending on the content of the vector newIndices.  <br /></td></tr>
<tr class="separator:aca4e61e9eb02bae8617f346aaf830452"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb189433c1c9d7bf52a96ff359f364ec" id="r_aeb189433c1c9d7bf52a96ff359f364ec"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classvcl_1_1Matrix.html">typename</a> T , typename... Rest&gt; </td></tr>
<tr class="memitem:aeb189433c1c9d7bf52a96ff359f364ec"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#aeb189433c1c9d7bf52a96ff359f364ec">hashCombine</a> (std::size_t &amp;<a class="el" href="classvcl_1_1Matrix.html">seed</a>, <a class="el" href="classvcl_1_1Matrix.html">const</a> T &amp;v, <a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="classvcl_1_1Matrix.html">Rest</a> &amp;... <a class="el" href="classvcl_1_1Matrix.html">rest</a>)</td></tr>
<tr class="memdesc:aeb189433c1c9d7bf52a96ff359f364ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starting from a seed, computes the hash of a series of objects.  <br /></td></tr>
<tr class="separator:aeb189433c1c9d7bf52a96ff359f364ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abde6b767fa0b116a5fd8b2a5fa0af488" id="r_abde6b767fa0b116a5fd8b2a5fa0af488"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classvcl_1_1Matrix.html">typename</a> Iterator , <a class="el" href="classvcl_1_1Matrix.html">typename</a> <a class="el" href="classvcl_1_1Matrix.html">Lambda</a> &gt; </td></tr>
<tr class="memitem:abde6b767fa0b116a5fd8b2a5fa0af488"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#abde6b767fa0b116a5fd8b2a5fa0af488">parallelFor</a> (Iterator &amp;&amp;begin, Iterator &amp;&amp;end, <a class="el" href="classvcl_1_1Matrix.html">Lambda</a> &amp;&amp;<a class="el" href="classvcl_1_1Matrix.html">F</a>)</td></tr>
<tr class="memdesc:abde6b767fa0b116a5fd8b2a5fa0af488"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function executes a parallel for over the elements iterated between <code>begin</code> and <code>end</code> iterators, if parallel requirements have been found in the system.  <br /></td></tr>
<tr class="separator:abde6b767fa0b116a5fd8b2a5fa0af488"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac74faed2021a2b157f5b80757ee694d8" id="r_ac74faed2021a2b157f5b80757ee694d8"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classvcl_1_1Matrix.html">typename</a> Iterator , <a class="el" href="classvcl_1_1Matrix.html">typename</a> <a class="el" href="classvcl_1_1Matrix.html">Lambda</a> &gt; </td></tr>
<tr class="memitem:ac74faed2021a2b157f5b80757ee694d8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ac74faed2021a2b157f5b80757ee694d8">parallelFor</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> Iterator &amp;begin, <a class="el" href="classvcl_1_1Matrix.html">const</a> Iterator &amp;end, <a class="el" href="classvcl_1_1Matrix.html">Lambda</a> &amp;&amp;<a class="el" href="classvcl_1_1Matrix.html">F</a>)</td></tr>
<tr class="memdesc:ac74faed2021a2b157f5b80757ee694d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function executes a parallel for over the elements iterated between <code>begin</code> and <code>end</code> iterators, if parallel requirements have been found in the system.  <br /></td></tr>
<tr class="separator:ac74faed2021a2b157f5b80757ee694d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bbb25a5a74276bc05a251ab860a286d" id="r_a0bbb25a5a74276bc05a251ab860a286d"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="conceptvcl_1_1Range.html">vcl::Range</a> Rng, <a class="el" href="classvcl_1_1Matrix.html">typename</a> <a class="el" href="classvcl_1_1Matrix.html">Lambda</a> &gt; </td></tr>
<tr class="memitem:a0bbb25a5a74276bc05a251ab860a286d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a0bbb25a5a74276bc05a251ab860a286d">parallelFor</a> (<a class="el" href="classvcl_1_1Matrix.html">Rng</a> &amp;&amp;<a class="el" href="classvcl_1_1Matrix.html">r</a>, <a class="el" href="classvcl_1_1Matrix.html">Lambda</a> &amp;&amp;<a class="el" href="classvcl_1_1Matrix.html">F</a>)</td></tr>
<tr class="memdesc:a0bbb25a5a74276bc05a251ab860a286d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function executes a parallel for over a range if parallel requirements have been found in the system.  <br /></td></tr>
<tr class="separator:a0bbb25a5a74276bc05a251ab860a286d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad43b0e6c5acf9f903daf25853361a24c" id="r_ad43b0e6c5acf9f903daf25853361a24c"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="conceptvcl_1_1Range.html">vcl::Range</a> Rng, <a class="el" href="classvcl_1_1Matrix.html">typename</a> <a class="el" href="classvcl_1_1Matrix.html">Lambda</a> &gt; </td></tr>
<tr class="memitem:ad43b0e6c5acf9f903daf25853361a24c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ad43b0e6c5acf9f903daf25853361a24c">parallelFor</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="classvcl_1_1Matrix.html">Rng</a> &amp;<a class="el" href="classvcl_1_1Matrix.html">r</a>, <a class="el" href="classvcl_1_1Matrix.html">Lambda</a> &amp;&amp;<a class="el" href="classvcl_1_1Matrix.html">F</a>)</td></tr>
<tr class="memdesc:ad43b0e6c5acf9f903daf25853361a24c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function executes a parallel for over a range if parallel requirements have been found in the system.  <br /></td></tr>
<tr class="separator:ad43b0e6c5acf9f903daf25853361a24c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45834fe7b55127feba8ce3050653ca96" id="r_a45834fe7b55127feba8ce3050653ca96"><td class="memItemLeft" align="right" valign="top">std::string::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a45834fe7b55127feba8ce3050653ca96">findCaseInsensitive</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> std::string &amp;<a class="el" href="classvcl_1_1Matrix.html">input</a>, <a class="el" href="classvcl_1_1Matrix.html">const</a> std::string &amp;<a class="el" href="classvcl_1_1Matrix.html">substr</a>)</td></tr>
<tr class="memdesc:a45834fe7b55127feba8ce3050653ca96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Looks into <code>input</code> if there is a substring equal to <code>substr</code>, without taking into account case sensitiveness. Returns an iterator pointing to the beginning position in <code>input</code> of the substring, return an iterator <code>end()</code> if the substring was not found.  <br /></td></tr>
<tr class="separator:a45834fe7b55127feba8ce3050653ca96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9231ca38abac20eb8ced8246ab485899" id="r_a9231ca38abac20eb8ced8246ab485899"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classvcl_1_1Matrix.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a9231ca38abac20eb8ced8246ab485899"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a9231ca38abac20eb8ced8246ab485899">toString</a> (T <a class="el" href="classvcl_1_1Matrix.html">val</a>)</td></tr>
<tr class="memdesc:a9231ca38abac20eb8ced8246ab485899"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a value of type <code>T</code> to a string.  <br /></td></tr>
<tr class="separator:a9231ca38abac20eb8ced8246ab485899"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9101a04223deed528addeb4dbf722bf" id="r_af9101a04223deed528addeb4dbf722bf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#af9101a04223deed528addeb4dbf722bf">containsCaseInsensitive</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> std::string &amp;<a class="el" href="classvcl_1_1Matrix.html">input</a>, <a class="el" href="classvcl_1_1Matrix.html">const</a> std::string &amp;<a class="el" href="classvcl_1_1Matrix.html">substr</a>)</td></tr>
<tr class="memdesc:af9101a04223deed528addeb4dbf722bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if the <code>input</code> string contains <code>substr</code> as a substring, without taking into account case sensitiveness.  <br /></td></tr>
<tr class="separator:af9101a04223deed528addeb4dbf722bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bb7f6b147a8bc291fee7ef462f8a1bd" id="r_a9bb7f6b147a8bc291fee7ef462f8a1bd"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a9bb7f6b147a8bc291fee7ef462f8a1bd">toLower</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> std::string &amp;s)</td></tr>
<tr class="separator:a9bb7f6b147a8bc291fee7ef462f8a1bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac83671737ba679edb3511815c82494d1" id="r_ac83671737ba679edb3511815c82494d1"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ac83671737ba679edb3511815c82494d1">toUpper</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> std::string &amp;s)</td></tr>
<tr class="separator:ac83671737ba679edb3511815c82494d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbeefcb5ecbc42c311e46711ee48ecd2" id="r_afbeefcb5ecbc42c311e46711ee48ecd2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#afbeefcb5ecbc42c311e46711ee48ecd2">removeCarriageReturn</a> (std::string &amp;s)</td></tr>
<tr class="memdesc:afbeefcb5ecbc42c311e46711ee48ecd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the carriage return character (<code>\r</code>) from the end of the string.  <br /></td></tr>
<tr class="separator:afbeefcb5ecbc42c311e46711ee48ecd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08ddfb40632cb38ec4750610e0e2ebaa" id="r_a08ddfb40632cb38ec4750610e0e2ebaa"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classvcl_1_1Matrix.html">typename</a> T , <a class="el" href="classvcl_1_1Matrix.html">typename</a> <a class="el" href="classvcl_1_1Matrix.html">U</a> , typename... Us&gt; </td></tr>
<tr class="memitem:a08ddfb40632cb38ec4750610e0e2ebaa"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">constexpr</a> <a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a08ddfb40632cb38ec4750610e0e2ebaa">tupleIndexByType</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> std::tuple&lt; <a class="el" href="classvcl_1_1Matrix.html">U</a>, Us... &gt; &amp;)</td></tr>
<tr class="memdesc:a08ddfb40632cb38ec4750610e0e2ebaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of a type T in a std::tuple&lt;U, Us...&gt; passed as parameter; Returns UINT_NULL if the type T is not found in the tuple.  <br /></td></tr>
<tr class="separator:a08ddfb40632cb38ec4750610e0e2ebaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1420d0b9ba83dea9e692db635533f46c" id="r_a1420d0b9ba83dea9e692db635533f46c"><td class="memTemplParams" colspan="2">template&lt;PointConcept PointType, <a class="el" href="classvcl_1_1Matrix.html">typename</a> <a class="el" href="classvcl_1_1Matrix.html">D</a> &gt; </td></tr>
<tr class="memitem:a1420d0b9ba83dea9e692db635533f46c"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a1420d0b9ba83dea9e692db635533f46c">RegularGrid</a> (PointType, PointType, <a class="el" href="classvcl_1_1Matrix.html">D</a>) -&gt; <a class="el" href="classvcl_1_1RegularGrid.html">RegularGrid</a>&lt; <a class="el" href="classvcl_1_1Matrix.html">typename</a> PointType::ScalarType, PointType::DIM &gt;</td></tr>
<tr class="separator:a1420d0b9ba83dea9e692db635533f46c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f45446c5f7bcad8bd9dd9c515bf1e55" id="r_a6f45446c5f7bcad8bd9dd9c515bf1e55"><td class="memTemplParams" colspan="2">template&lt;PointConcept PointType&gt; </td></tr>
<tr class="memitem:a6f45446c5f7bcad8bd9dd9c515bf1e55"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Point.html">Point</a>&lt; <a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a>, PointType::DIM &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a6f45446c5f7bcad8bd9dd9c515bf1e55">bestGridSize</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> PointType &amp;lengths, <a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a> <a class="el" href="classvcl_1_1Matrix.html">nElements</a>)</td></tr>
<tr class="memdesc:a6f45446c5f7bcad8bd9dd9c515bf1e55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the best sizes (number of cells per dimension) of a Grid, starting from the lengths of the grid and the number of elements to place in the grid.  <br /></td></tr>
<tr class="separator:a6f45446c5f7bcad8bd9dd9c515bf1e55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1f5ecc820f6ab64fb437ba12296601c" id="r_ab1f5ecc820f6ab64fb437ba12296601c"><td class="memTemplParams" colspan="2">template&lt;PointIteratorConcept It&gt; </td></tr>
<tr class="memitem:ab1f5ecc820f6ab64fb437ba12296601c"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ab1f5ecc820f6ab64fb437ba12296601c">StaticGrid</a> (<a class="el" href="classvcl_1_1Matrix.html">It</a>, <a class="el" href="classvcl_1_1Matrix.html">It</a>) -&gt; <a class="el" href="classvcl_1_1StaticGrid.html">StaticGrid</a>&lt; <a class="el" href="classvcl_1_1RegularGrid.html">RegularGrid</a>&lt; <a class="el" href="classvcl_1_1Matrix.html">typename</a> It::value_type, It::value_type::DIM &gt;, <a class="el" href="classvcl_1_1Matrix.html">typename</a> It::value_type::ScalarType &gt;</td></tr>
<tr class="separator:ab1f5ecc820f6ab64fb437ba12296601c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7586ced2cedb8cd2aa668c8136b24603" id="r_a7586ced2cedb8cd2aa668c8136b24603"><td class="memTemplParams" colspan="2">template&lt;PointIteratorConcept It, <a class="el" href="classvcl_1_1Matrix.html">typename</a> <a class="el" href="classvcl_1_1Matrix.html">F</a> &gt; </td></tr>
<tr class="memitem:a7586ced2cedb8cd2aa668c8136b24603"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a7586ced2cedb8cd2aa668c8136b24603">StaticGrid</a> (<a class="el" href="classvcl_1_1Matrix.html">It</a>, <a class="el" href="classvcl_1_1Matrix.html">It</a>, <a class="el" href="classvcl_1_1Matrix.html">F</a>) -&gt; <a class="el" href="classvcl_1_1StaticGrid.html">StaticGrid</a>&lt; <a class="el" href="classvcl_1_1RegularGrid.html">RegularGrid</a>&lt; <a class="el" href="classvcl_1_1Matrix.html">typename</a> It::value_type, It::value_type::DIM &gt;, <a class="el" href="classvcl_1_1Matrix.html">typename</a> It::value_type::ScalarType &gt;</td></tr>
<tr class="separator:a7586ced2cedb8cd2aa668c8136b24603"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6d4557abc45cc5daf2fe2e389b91ce9" id="r_ae6d4557abc45cc5daf2fe2e389b91ce9"><td class="memTemplParams" colspan="2">template&lt;VertexPointerRangeConcept Rng&gt; </td></tr>
<tr class="memitem:ae6d4557abc45cc5daf2fe2e389b91ce9"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ae6d4557abc45cc5daf2fe2e389b91ce9">StaticGrid</a> (<a class="el" href="classvcl_1_1Matrix.html">Rng</a>) -&gt; <a class="el" href="classvcl_1_1StaticGrid.html">StaticGrid</a>&lt; <a class="el" href="classvcl_1_1RegularGrid.html">RegularGrid</a>&lt; <a class="el" href="classvcl_1_1Matrix.html">typename</a> std::remove_pointer_t&lt; <a class="el" href="classvcl_1_1Matrix.html">typename</a> std::ranges::iterator_t&lt; <a class="el" href="classvcl_1_1Matrix.html">Rng</a> &gt;::value_type &gt;::CoordType::ScalarType, 3 &gt;, <a class="el" href="classvcl_1_1Matrix.html">typename</a> std::ranges::iterator_t&lt; <a class="el" href="classvcl_1_1Matrix.html">Rng</a> &gt;::value_type &gt;</td></tr>
<tr class="separator:ae6d4557abc45cc5daf2fe2e389b91ce9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7606be147f292f38e1e22a709708a19" id="r_ab7606be147f292f38e1e22a709708a19"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ab7606be147f292f38e1e22a709708a19"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ab7606be147f292f38e1e22a709708a19">KDTree</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>) -&gt; <a class="el" href="classvcl_1_1KDTree.html">KDTree</a>&lt; <a class="el" href="classvcl_1_1Matrix.html">typename</a> MeshType::VertexType::CoordType &gt;</td></tr>
<tr class="separator:ab7606be147f292f38e1e22a709708a19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1ec171b583b3872ae8b1b5e6a513b49" id="r_ab1ec171b583b3872ae8b1b5e6a513b49"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ab1ec171b583b3872ae8b1b5e6a513b49"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ab1ec171b583b3872ae8b1b5e6a513b49">KDTree</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>, <a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a> <a class="el" href="classvcl_1_1Matrix.html">pointsPerCell</a>) -&gt; <a class="el" href="classvcl_1_1KDTree.html">KDTree</a>&lt; <a class="el" href="classvcl_1_1Matrix.html">typename</a> MeshType::VertexType::CoordType &gt;</td></tr>
<tr class="separator:ab1ec171b583b3872ae8b1b5e6a513b49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5c4a6423ece2f30e5d81a3f5b0026b9" id="r_ae5c4a6423ece2f30e5d81a3f5b0026b9"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ae5c4a6423ece2f30e5d81a3f5b0026b9"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ae5c4a6423ece2f30e5d81a3f5b0026b9">KDTree</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>, <a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a> <a class="el" href="classvcl_1_1Matrix.html">pointsPerCell</a>, <a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a> <a class="el" href="classvcl_1_1Matrix.html">maxDepth</a>) -&gt; <a class="el" href="classvcl_1_1KDTree.html">KDTree</a>&lt; <a class="el" href="classvcl_1_1Matrix.html">typename</a> MeshType::VertexType::CoordType &gt;</td></tr>
<tr class="separator:ae5c4a6423ece2f30e5d81a3f5b0026b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9e8e92d81c40489de3567c10b3db44c" id="r_ae9e8e92d81c40489de3567c10b3db44c"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ae9e8e92d81c40489de3567c10b3db44c"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ae9e8e92d81c40489de3567c10b3db44c">KDTree</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>, <a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a> <a class="el" href="classvcl_1_1Matrix.html">pointsPerCell</a>, <a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a> <a class="el" href="classvcl_1_1Matrix.html">maxDepth</a>, <a class="el" href="classvcl_1_1Matrix.html">bool</a> <a class="el" href="classvcl_1_1Matrix.html">balanced</a>) -&gt; <a class="el" href="classvcl_1_1KDTree.html">KDTree</a>&lt; <a class="el" href="classvcl_1_1Matrix.html">typename</a> MeshType::VertexType::CoordType &gt;</td></tr>
<tr class="separator:ae9e8e92d81c40489de3567c10b3db44c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4e08b69bd34fcb7b7b8648ea27ee31e" id="r_af4e08b69bd34fcb7b7b8648ea27ee31e"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a> ELEM_ID, MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:af4e08b69bd34fcb7b7b8648ea27ee31e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#af4e08b69bd34fcb7b7b8648ea27ee31e">addPerElementCustomComponent</a> (MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>, <a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="structvcl_1_1MeshInfo_1_1CustomComponent.html">MeshInfo::CustomComponent</a> &amp;<a class="el" href="classvcl_1_1Matrix.html">cc</a>)</td></tr>
<tr class="separator:af4e08b69bd34fcb7b7b8648ea27ee31e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af68e89e67c2fd8636c9dba90319b94a8" id="r_af68e89e67c2fd8636c9dba90319b94a8"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:af68e89e67c2fd8636c9dba90319b94a8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#af68e89e67c2fd8636c9dba90319b94a8">addPerVertexCustomComponent</a> (MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>, <a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="structvcl_1_1MeshInfo_1_1CustomComponent.html">MeshInfo::CustomComponent</a> &amp;<a class="el" href="classvcl_1_1Matrix.html">cc</a>)</td></tr>
<tr class="separator:af68e89e67c2fd8636c9dba90319b94a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7feb8594f6727f2475dbc1d337b32fc" id="r_ae7feb8594f6727f2475dbc1d337b32fc"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ae7feb8594f6727f2475dbc1d337b32fc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ae7feb8594f6727f2475dbc1d337b32fc">addPerFaceCustomComponent</a> (MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>, <a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="structvcl_1_1MeshInfo_1_1CustomComponent.html">MeshInfo::CustomComponent</a> &amp;<a class="el" href="classvcl_1_1Matrix.html">cc</a>)</td></tr>
<tr class="separator:ae7feb8594f6727f2475dbc1d337b32fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c29a82cbd4cf6f0d20392b1d1eb885c" id="r_a0c29a82cbd4cf6f0d20392b1d1eb885c"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a0c29a82cbd4cf6f0d20392b1d1eb885c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a0c29a82cbd4cf6f0d20392b1d1eb885c">enableOptionalComponentsFromInfo</a> (<a class="el" href="classvcl_1_1MeshInfo.html">MeshInfo</a> &amp;info, MeshType &amp;<a class="el" href="classvcl_1_1Matrix.html">m</a>)</td></tr>
<tr class="memdesc:a0c29a82cbd4cf6f0d20392b1d1eb885c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables all the components that are in the file mesh info and that may be enabled in the mesh. If these components are not available in the mesh, the info file will be modified in order to tell that a particular component cannot be saved into the mesh.  <br /></td></tr>
<tr class="separator:a0c29a82cbd4cf6f0d20392b1d1eb885c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10783cb155a40826adff62ef42123efe" id="r_a10783cb155a40826adff62ef42123efe"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classvcl_1_1Matrix.html">typename</a> Scalar &gt; </td></tr>
<tr class="memitem:a10783cb155a40826adff62ef42123efe"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a10783cb155a40826adff62ef42123efe">operator&lt;&lt;</a> (std::ostream &amp;<a class="el" href="classvcl_1_1Matrix.html">out</a>, <a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="classvcl_1_1Array.html">Array</a>&lt; Scalar, 2 &gt; &amp;<a class="el" href="classvcl_1_1Matrix.html">a</a>)</td></tr>
<tr class="separator:a10783cb155a40826adff62ef42123efe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb087e661b9a756b25bc45f9b9fbf367" id="r_acb087e661b9a756b25bc45f9b9fbf367"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classvcl_1_1Matrix.html">typename</a> T &gt; </td></tr>
<tr class="memitem:acb087e661b9a756b25bc45f9b9fbf367"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#acb087e661b9a756b25bc45f9b9fbf367">operator&lt;&lt;</a> (std::ostream &amp;<a class="el" href="classvcl_1_1Matrix.html">os</a>, <a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="classvcl_1_1BitSet.html">BitSet</a>&lt; T &gt; &amp;<a class="el" href="classvcl_1_1Matrix.html">bs</a>)</td></tr>
<tr class="memdesc:acb087e661b9a756b25bc45f9b9fbf367"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output stream operator for <a class="el" href="classvcl_1_1BitSet.html" title="The BitSet class allows to treat an integral type as an array of booleans of a guaranteed size.">BitSet</a>.  <br /></td></tr>
<tr class="separator:acb087e661b9a756b25bc45f9b9fbf367"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05dd102880d029a4ce6a952207559088" id="r_a05dd102880d029a4ce6a952207559088"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a05dd102880d029a4ce6a952207559088">operator&lt;&lt;</a> (std::ostream &amp;<a class="el" href="classvcl_1_1Matrix.html">out</a>, <a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="classvcl_1_1Color.html">Color</a> &amp;c)</td></tr>
<tr class="memdesc:a05dd102880d029a4ce6a952207559088"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload of stream operator to allow a pretty print of a <a class="el" href="classvcl_1_1Color.html" title="The Color class represents a 32 bit color.">vcl::Color</a>.  <br /></td></tr>
<tr class="separator:a05dd102880d029a4ce6a952207559088"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dcc49648719fc830554b892110ff8f2" id="r_a9dcc49648719fc830554b892110ff8f2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Color.html">Color</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a9dcc49648719fc830554b892110ff8f2">colorLerp</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="classvcl_1_1Color.html">Color</a> &amp;<a class="el" href="classvcl_1_1Matrix.html">c0</a>, <a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="classvcl_1_1Color.html">Color</a> &amp;<a class="el" href="classvcl_1_1Matrix.html">c1</a>, <a class="el" href="classvcl_1_1Matrix.html">float</a> value)</td></tr>
<tr class="memdesc:a9dcc49648719fc830554b892110ff8f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an interval of colors (from <code>c0</code> to <code>c1</code>) and a value in the interval [0, 1], returns the linear interpolation color between <code>c0</code> and <code>c1</code> based on <code>value</code> in the [0, 1] interval. If <code>value</code> is out of range, it will be set to the nearest extreme of the interval.  <br /></td></tr>
<tr class="separator:a9dcc49648719fc830554b892110ff8f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c348d7127fb95f134332b8c275846f7" id="r_a6c348d7127fb95f134332b8c275846f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Color.html">Color</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a6c348d7127fb95f134332b8c275846f7">colorFromIntervalRedBlue</a> (<a class="el" href="classvcl_1_1Matrix.html">float</a> value)</td></tr>
<tr class="memdesc:a6c348d7127fb95f134332b8c275846f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a color in the interval from Red to Blue depending on the position of the given value in the interval [0, 1].  <br /></td></tr>
<tr class="separator:a6c348d7127fb95f134332b8c275846f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa361024b35e8aef9609826b177ac1cb" id="r_afa361024b35e8aef9609826b177ac1cb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Color.html">Color</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#afa361024b35e8aef9609826b177ac1cb">colorFromIntervalRedBlue</a> (<a class="el" href="classvcl_1_1Matrix.html">float</a> <a class="el" href="namespacevcl.html#a3edcb561672a6be17e9453bd1ea446d5">min</a>, <a class="el" href="classvcl_1_1Matrix.html">float</a> <a class="el" href="namespacevcl.html#a69cc63a5ad2974d082145ed1dee7846b">max</a>, <a class="el" href="classvcl_1_1Matrix.html">float</a> value)</td></tr>
<tr class="memdesc:afa361024b35e8aef9609826b177ac1cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a color in the interval from Red to Blue depending on the position of the given value in the given interval [min, max].  <br /></td></tr>
<tr class="separator:afa361024b35e8aef9609826b177ac1cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7728ec836fa169f447a90a4d2eee3df5" id="r_a7728ec836fa169f447a90a4d2eee3df5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Color.html">Color</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a7728ec836fa169f447a90a4d2eee3df5">colorFromIntervalParula</a> (<a class="el" href="classvcl_1_1Matrix.html">float</a> value)</td></tr>
<tr class="memdesc:a7728ec836fa169f447a90a4d2eee3df5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a color in the Paraula colormap depending on the position of the given value in the interval [0, 1].  <br /></td></tr>
<tr class="separator:a7728ec836fa169f447a90a4d2eee3df5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9725bc9a2f5b27ce885e76be92185a20" id="r_a9725bc9a2f5b27ce885e76be92185a20"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Color.html">Color</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a9725bc9a2f5b27ce885e76be92185a20">colorFromIntervalParula</a> (<a class="el" href="classvcl_1_1Matrix.html">float</a> <a class="el" href="namespacevcl.html#a3edcb561672a6be17e9453bd1ea446d5">min</a>, <a class="el" href="classvcl_1_1Matrix.html">float</a> <a class="el" href="namespacevcl.html#a69cc63a5ad2974d082145ed1dee7846b">max</a>, <a class="el" href="classvcl_1_1Matrix.html">float</a> value)</td></tr>
<tr class="memdesc:a9725bc9a2f5b27ce885e76be92185a20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a color in the Paraula colormap depending on the position of the given value in the given interval [min, max].  <br /></td></tr>
<tr class="separator:a9725bc9a2f5b27ce885e76be92185a20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8232d4e3c3aca4125e84cb8f124ebc29" id="r_a8232d4e3c3aca4125e84cb8f124ebc29"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Color.html">Color</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a8232d4e3c3aca4125e84cb8f124ebc29">colorFromIntervalGreyShade</a> (<a class="el" href="classvcl_1_1Matrix.html">float</a> value)</td></tr>
<tr class="memdesc:a8232d4e3c3aca4125e84cb8f124ebc29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a color in the grey shade colormap depending on the position of the given value in the interval [0, 1].  <br /></td></tr>
<tr class="separator:a8232d4e3c3aca4125e84cb8f124ebc29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99b591f2eba1ded24ebf6f4b0ee4353f" id="r_a99b591f2eba1ded24ebf6f4b0ee4353f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Color.html">Color</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a99b591f2eba1ded24ebf6f4b0ee4353f">colorFromIntervalGreyShade</a> (<a class="el" href="classvcl_1_1Matrix.html">float</a> <a class="el" href="namespacevcl.html#a3edcb561672a6be17e9453bd1ea446d5">min</a>, <a class="el" href="classvcl_1_1Matrix.html">float</a> <a class="el" href="namespacevcl.html#a69cc63a5ad2974d082145ed1dee7846b">max</a>, <a class="el" href="classvcl_1_1Matrix.html">float</a> value)</td></tr>
<tr class="memdesc:a99b591f2eba1ded24ebf6f4b0ee4353f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a color in the grey shade colormap depending on the position of the given value in the given interval [min, max].  <br /></td></tr>
<tr class="separator:a99b591f2eba1ded24ebf6f4b0ee4353f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5851edce0478bfc7f4084e3529ae6962" id="r_a5851edce0478bfc7f4084e3529ae6962"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Color.html">Color</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a5851edce0478bfc7f4084e3529ae6962">colorFromInterval</a> (<a class="el" href="classvcl_1_1Matrix.html">float</a> value, <a class="el" href="classvcl_1_1Color.html#a32ace7bd7fccf742b39f6cd83042a10f">Color::ColorMap</a> <a class="el" href="classvcl_1_1Matrix.html">cm</a>)</td></tr>
<tr class="memdesc:a5851edce0478bfc7f4084e3529ae6962"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a <code>value</code> in the interval [0, 1], it returns the color in the position in the given ColorMap <code>cm</code> corresponding to the position of <code>value</code> in the interval [0, 1].  <br /></td></tr>
<tr class="separator:a5851edce0478bfc7f4084e3529ae6962"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5a54ddc3c9d67e0c7ed179e78c2ca06" id="r_ab5a54ddc3c9d67e0c7ed179e78c2ca06"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Color.html">Color</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ab5a54ddc3c9d67e0c7ed179e78c2ca06">colorFromInterval</a> (<a class="el" href="classvcl_1_1Matrix.html">float</a> <a class="el" href="namespacevcl.html#a3edcb561672a6be17e9453bd1ea446d5">min</a>, <a class="el" href="classvcl_1_1Matrix.html">float</a> <a class="el" href="namespacevcl.html#a69cc63a5ad2974d082145ed1dee7846b">max</a>, <a class="el" href="classvcl_1_1Matrix.html">float</a> value, <a class="el" href="classvcl_1_1Color.html#a32ace7bd7fccf742b39f6cd83042a10f">Color::ColorMap</a> <a class="el" href="classvcl_1_1Matrix.html">cm</a>)</td></tr>
<tr class="memdesc:ab5a54ddc3c9d67e0c7ed179e78c2ca06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a color in the interval from the minimum color to the maximum color of the given colormap <code>cm</code>, depending on the position of the given value in the given interval [min, max].  <br /></td></tr>
<tr class="separator:ab5a54ddc3c9d67e0c7ed179e78c2ca06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e24134fa80806f677e3d5d72cd9c9e9" id="r_a7e24134fa80806f677e3d5d72cd9c9e9"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classvcl_1_1Color.html">Color</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a7e24134fa80806f677e3d5d72cd9c9e9">colorScattering</a> (<a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a> <a class="el" href="classvcl_1_1Matrix.html">n</a>, <a class="el" href="classvcl_1_1Matrix.html">float</a> <a class="el" href="classvcl_1_1Matrix.html">sat</a>=0.3, <a class="el" href="classvcl_1_1Matrix.html">float</a> <a class="el" href="classvcl_1_1Matrix.html">val</a>=0.9)</td></tr>
<tr class="memdesc:a7e24134fa80806f677e3d5d72cd9c9e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a number <code>n</code>, returns a vector of <code>n</code> colors so that each color differs as much as possible from the previous one of the vector.  <br /></td></tr>
<tr class="separator:a7e24134fa80806f677e3d5d72cd9c9e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38f2bc5486a49a170ae57d8fb6b9b8df" id="r_a38f2bc5486a49a170ae57d8fb6b9b8df"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classvcl_1_1Matrix.html">typename</a> Scalar , <a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a> N&gt; </td></tr>
<tr class="memitem:a38f2bc5486a49a170ae57d8fb6b9b8df"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a38f2bc5486a49a170ae57d8fb6b9b8df">epsilonEquals</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="classvcl_1_1Point.html">Point</a>&lt; Scalar, <a class="el" href="classvcl_1_1Matrix.html">N</a> &gt; &amp;p1, <a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="classvcl_1_1Point.html">Point</a>&lt; Scalar, <a class="el" href="classvcl_1_1Matrix.html">N</a> &gt; &amp;<a class="el" href="classvcl_1_1Matrix.html">p2</a>, <a class="el" href="classvcl_1_1Matrix.html">const</a> Scalar &amp;<a class="el" href="classvcl_1_1Matrix.html">epsilon</a>=std::numeric_limits&lt; Scalar &gt;::epsilon())</td></tr>
<tr class="memdesc:a38f2bc5486a49a170ae57d8fb6b9b8df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two points for equality.  <br /></td></tr>
<tr class="separator:a38f2bc5486a49a170ae57d8fb6b9b8df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf860b9816e4dc7fc87d0bf27aaa0670" id="r_aaf860b9816e4dc7fc87d0bf27aaa0670"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classvcl_1_1Matrix.html">typename</a> <a class="el" href="classvcl_1_1Matrix.html">S</a> , typename... Scalars&gt; </td></tr>
<tr class="memitem:aaf860b9816e4dc7fc87d0bf27aaa0670"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#aaf860b9816e4dc7fc87d0bf27aaa0670">Point</a> (<a class="el" href="classvcl_1_1Matrix.html">S</a>, Scalars... <a class="el" href="classvcl_1_1Matrix.html">scalars</a>) -&gt; <a class="el" href="classvcl_1_1Point.html">Point</a>&lt; <a class="el" href="classvcl_1_1Matrix.html">S</a>, sizeof...(<a class="el" href="classvcl_1_1Matrix.html">Scalars</a>)+1 &gt;</td></tr>
<tr class="separator:aaf860b9816e4dc7fc87d0bf27aaa0670"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a1a624c7abe7c703618b7f512c33039" id="r_a0a1a624c7abe7c703618b7f512c33039"><td class="memTemplParams" colspan="2">template&lt;Point3Concept P, <a class="el" href="classvcl_1_1Matrix.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a0a1a624c7abe7c703618b7f512c33039"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a0a1a624c7abe7c703618b7f512c33039">Sphere</a> (<a class="el" href="classvcl_1_1Matrix.html">P</a>, T) -&gt; <a class="el" href="classvcl_1_1Sphere.html">Sphere</a>&lt; <a class="el" href="classvcl_1_1Matrix.html">typename</a> P::ScalarType &gt;</td></tr>
<tr class="separator:a0a1a624c7abe7c703618b7f512c33039"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ca8accd2e2b6881a3b2359e56396e77" id="r_ga9ca8accd2e2b6881a3b2359e56396e77"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classvcl_1_1Matrix.html">typename</a> T &gt; </td></tr>
<tr class="memitem:ga9ca8accd2e2b6881a3b2359e56396e77"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">constexpr</a> T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__types.html#ga9ca8accd2e2b6881a3b2359e56396e77">asConst</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> T &amp;value) <a class="el" href="classvcl_1_1Matrix.html">noexcept</a></td></tr>
<tr class="memdesc:ga9ca8accd2e2b6881a3b2359e56396e77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function that converts a const pointer/reference to a non-const pointer/reference.  <br /></td></tr>
<tr class="separator:ga9ca8accd2e2b6881a3b2359e56396e77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a943a3fda661e6e71d8fd7106f41dd878" id="r_a943a3fda661e6e71d8fd7106f41dd878"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classvcl_1_1Matrix.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a943a3fda661e6e71d8fd7106f41dd878"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">constexpr</a> T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a943a3fda661e6e71d8fd7106f41dd878">asConst</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> T *value) <a class="el" href="classvcl_1_1Matrix.html">noexcept</a></td></tr>
<tr class="memdesc:a943a3fda661e6e71d8fd7106f41dd878"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function that converts a const pointer/reference to a non-const pointer/reference.    <br /></td></tr>
<tr class="separator:a943a3fda661e6e71d8fd7106f41dd878"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe5c457181ae725f99627c541993a3a8" id="r_abe5c457181ae725f99627c541993a3a8"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classvcl_1_1Matrix.html">typename</a> T &gt; </td></tr>
<tr class="memitem:abe5c457181ae725f99627c541993a3a8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">constexpr</a> T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#abe5c457181ae725f99627c541993a3a8">asConst</a> (T *value) <a class="el" href="classvcl_1_1Matrix.html">noexcept</a></td></tr>
<tr class="memdesc:abe5c457181ae725f99627c541993a3a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function that converts a const pointer/reference to a non-const pointer/reference.    <br /></td></tr>
<tr class="separator:abe5c457181ae725f99627c541993a3a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58e916cd5d73eca35e6f8ae1be248637" id="r_a58e916cd5d73eca35e6f8ae1be248637"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classvcl_1_1Matrix.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a58e916cd5d73eca35e6f8ae1be248637"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a58e916cd5d73eca35e6f8ae1be248637">asConst</a> (<a class="el" href="classvcl_1_1Matrix.html">const</a> T &amp;&amp;)=<a class="el" href="classvcl_1_1Matrix.html">delete</a></td></tr>
<tr class="separator:a58e916cd5d73eca35e6f8ae1be248637"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga86d50e779d2b4fd59e31de5a48e6d112" id="r_ga86d50e779d2b4fd59e31de5a48e6d112"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a> COMP_ID&gt; </td></tr>
<tr class="memitem:ga86d50e779d2b4fd59e31de5a48e6d112"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">constexpr</a> <a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="classvcl_1_1Matrix.html">char</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__types.html#ga86d50e779d2b4fd59e31de5a48e6d112">componentEnumString</a> ()</td></tr>
<tr class="memdesc:ga86d50e779d2b4fd59e31de5a48e6d112"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the string associated to the COMP_ID value.  <br /></td></tr>
<tr class="separator:ga86d50e779d2b4fd59e31de5a48e6d112"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0068c984cb7a600004242ea341b506eb" id="r_ga0068c984cb7a600004242ea341b506eb"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a> ELEM_ID&gt; </td></tr>
<tr class="memitem:ga0068c984cb7a600004242ea341b506eb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">constexpr</a> <a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="classvcl_1_1Matrix.html">char</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__types.html#ga0068c984cb7a600004242ea341b506eb">elementEnumCString</a> ()</td></tr>
<tr class="memdesc:ga0068c984cb7a600004242ea341b506eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the string associated to the ELEM_ID value.  <br /></td></tr>
<tr class="separator:ga0068c984cb7a600004242ea341b506eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab2bbb176efb4243ea25469bbbd1c53af" id="r_gab2bbb176efb4243ea25469bbbd1c53af"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a> ELEM_ID&gt; </td></tr>
<tr class="memitem:gab2bbb176efb4243ea25469bbbd1c53af"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">const</a> std::string &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__types.html#gab2bbb176efb4243ea25469bbbd1c53af">elementEnumString</a> ()</td></tr>
<tr class="memdesc:gab2bbb176efb4243ea25469bbbd1c53af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the string associated to the ELEM_ID value.  <br /></td></tr>
<tr class="separator:gab2bbb176efb4243ea25469bbbd1c53af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaada6c7f7d741d8f7885af287bcc6f746" id="r_gaada6c7f7d741d8f7885af287bcc6f746"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classvcl_1_1Matrix.html">typename</a> T &gt; </td></tr>
<tr class="memitem:gaada6c7f7d741d8f7885af287bcc6f746"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__types.html#gaada6c7f7d741d8f7885af287bcc6f746">dereferencePtr</a> (T &amp;&amp;<a class="el" href="classvcl_1_1Matrix.html">obj</a>)</td></tr>
<tr class="memdesc:gaada6c7f7d741d8f7885af287bcc6f746"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function that applies the unary operator '*' to the argument only if the object is a pointer.  <br /></td></tr>
<tr class="separator:gaada6c7f7d741d8f7885af287bcc6f746"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae32401c3c5edbdeead1769b4d6160f87" id="r_gae32401c3c5edbdeead1769b4d6160f87"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classvcl_1_1Matrix.html">typename</a> T &gt; </td></tr>
<tr class="memitem:gae32401c3c5edbdeead1769b4d6160f87"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__types.html#gae32401c3c5edbdeead1769b4d6160f87">addressOfObj</a> (T &amp;<a class="el" href="classvcl_1_1Matrix.html">obj</a>)</td></tr>
<tr class="memdesc:gae32401c3c5edbdeead1769b4d6160f87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function that applies the unary operator '&amp;' to the argument only if it is not a pointer.  <br /></td></tr>
<tr class="separator:gae32401c3c5edbdeead1769b4d6160f87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae01694fdca8b252384be3296f82fa946" id="r_gae01694fdca8b252384be3296f82fa946"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classvcl_1_1Matrix.html">typename</a> T , <a class="el" href="classvcl_1_1Matrix.html">typename</a> <a class="el" href="classvcl_1_1Matrix.html">U</a> , typename... Us&gt; </td></tr>
<tr class="memitem:gae01694fdca8b252384be3296f82fa946"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">constexpr</a> <a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__types.html#gae01694fdca8b252384be3296f82fa946">indexInTypePack</a> ()</td></tr>
<tr class="memdesc:gae01694fdca8b252384be3296f82fa946"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that returns the index of a Type T in a pack of types (variadic templates). The pack is composed of U and Us...  <br /></td></tr>
<tr class="separator:gae01694fdca8b252384be3296f82fa946"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac398b3cd16575f92ffc3e6cfd6ba1669" id="r_gac398b3cd16575f92ffc3e6cfd6ba1669"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classvcl_1_1Matrix.html">typename</a> <a class="el" href="classvcl_1_1Matrix.html">U</a> , typename... Us&gt; </td></tr>
<tr class="memitem:gac398b3cd16575f92ffc3e6cfd6ba1669"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__types.html#gac398b3cd16575f92ffc3e6cfd6ba1669">indexInTypePack</a> (std::type_index <a class="el" href="classvcl_1_1Matrix.html">ti</a>)</td></tr>
<tr class="memdesc:gac398b3cd16575f92ffc3e6cfd6ba1669"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that returns the index of the type having the given type_index in a pack of types (variadic templates). The pack is composed of U and Us...  <br /></td></tr>
<tr class="separator:gac398b3cd16575f92ffc3e6cfd6ba1669"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6ce6ce1ca6a9813f3437aa0aeee2d94" id="r_ad6ce6ce1ca6a9813f3437aa0aeee2d94"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:ad6ce6ce1ca6a9813f3437aa0aeee2d94"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ad6ce6ce1ca6a9813f3437aa0aeee2d94">indexInTypePack</a> (std::type_index <a class="el" href="classvcl_1_1Matrix.html">ti</a>, <a class="el" href="structvcl_1_1TypeWrapper.html">TypeWrapper</a>&lt; Args... &gt;)</td></tr>
<tr class="separator:ad6ce6ce1ca6a9813f3437aa0aeee2d94"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga3377e3c875ec245e90ac5a395105ce99" id="r_ga3377e3c875ec245e90ac5a395105ce99"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1NullLogger.html">NullLogger</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__miscellaneous.html#ga3377e3c875ec245e90ac5a395105ce99">nullLogger</a></td></tr>
<tr class="memdesc:ga3377e3c875ec245e90ac5a395105ce99"><td class="mdescLeft">&#160;</td><td class="mdescRight">The nullLogger object is an object of type <a class="el" href="classvcl_1_1NullLogger.html" title="The NullLogger class is used as default type in all the library functions that take as input a logger...">NullLogger</a> that is used as default argument in the functions that can take as input a logger.  <br /></td></tr>
<tr class="separator:ga3377e3c875ec245e90ac5a395105ce99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ad8104cd9ccfa9352d33bc7e6ba47e6" id="r_ga9ad8104cd9ccfa9352d33bc7e6ba47e6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">constexpr</a> <a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__types.html#ga9ad8104cd9ccfa9352d33bc7e6ba47e6">UINT_NULL</a> = std::numeric_limits&lt;<a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a>&gt;<a class="el" href="namespacevcl.html#a69cc63a5ad2974d082145ed1dee7846b">::max</a>()</td></tr>
<tr class="memdesc:ga9ad8104cd9ccfa9352d33bc7e6ba47e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The UINT_NULL value represent a null value of uint that is the maximum value that can be represented with unsigned int.  <br /></td></tr>
<tr class="separator:ga9ad8104cd9ccfa9352d33bc7e6ba47e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d7a7538a2f5867a00048a1b3f32eaa6" id="r_ga4d7a7538a2f5867a00048a1b3f32eaa6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">constexpr</a> <a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="classvcl_1_1Matrix.html">char</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__types.html#ga4d7a7538a2f5867a00048a1b3f32eaa6">COMPONENT_ENUM_STRINGS</a> [<a class="el" href="structvcl_1_1CompId.html#a49eaa4bf71f2e6fe44b614a91b94735aaaa49d4a948063ce1fea116fa9af30010">CompId::COMPONENTS_NUMBER</a>]</td></tr>
<tr class="memdesc:ga4d7a7538a2f5867a00048a1b3f32eaa6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The COMPONENT_ENUM_STRINGS array contains the string representation of the <a class="el" href="structvcl_1_1CompId.html#a49eaa4bf71f2e6fe44b614a91b94735a">CompId::Enum</a> values.  <br /></td></tr>
<tr class="separator:ga4d7a7538a2f5867a00048a1b3f32eaa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaead83eb7c9cee68431c31c3890cbb10f" id="r_gaead83eb7c9cee68431c31c3890cbb10f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">constexpr</a> <a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="classvcl_1_1Matrix.html">char</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__types.html#gaead83eb7c9cee68431c31c3890cbb10f">ELEMENT_ENUM_STRINGS</a> [<a class="el" href="structvcl_1_1ElemId.html#a1c18d2f7814686d14cc0dacc8f33a09fa5383a8d3ce75f1f431f09f343aa14fff">ElemId::ELEMENTS_NUMBER</a>]</td></tr>
<tr class="memdesc:gaead83eb7c9cee68431c31c3890cbb10f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The ELEMENT_ENUM_STRINGS array contains the string representation of the elements that can compose a mesh.  <br /></td></tr>
<tr class="separator:gaead83eb7c9cee68431c31c3890cbb10f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ada2232ee49c1d1e75935719367a0c808" name="ada2232ee49c1d1e75935719367a0c808"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada2232ee49c1d1e75935719367a0c808">&#9670;&#160;</a></span>Affine3</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classvcl_1_1Matrix.html">typename</a> Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">using</a> <a class="el" href="namespacevcl.html#ada2232ee49c1d1e75935719367a0c808">vcl::Affine3</a> = <a class="el" href="classvcl_1_1Matrix.html">typedef</a> Eigen::Transform&lt;Scalar, 3, Eigen::Affine&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac8b4caa657856dfd9fe6e9fc93a12afd" name="ac8b4caa657856dfd9fe6e9fc93a12afd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8b4caa657856dfd9fe6e9fc93a12afd">&#9670;&#160;</a></span>Affine3d</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">using</a> <a class="el" href="namespacevcl.html#ac8b4caa657856dfd9fe6e9fc93a12afd">vcl::Affine3d</a> = <a class="el" href="classvcl_1_1Matrix.html">typedef</a> <a class="el" href="namespacevcl.html#ada2232ee49c1d1e75935719367a0c808">Affine3</a>&lt;<a class="el" href="classvcl_1_1Matrix.html">double</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae91948353bf6e59ce4fd22962d6aca50" name="ae91948353bf6e59ce4fd22962d6aca50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae91948353bf6e59ce4fd22962d6aca50">&#9670;&#160;</a></span>Affine3f</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">using</a> <a class="el" href="namespacevcl.html#ae91948353bf6e59ce4fd22962d6aca50">vcl::Affine3f</a> = <a class="el" href="classvcl_1_1Matrix.html">typedef</a> <a class="el" href="namespacevcl.html#ada2232ee49c1d1e75935719367a0c808">Affine3</a>&lt;<a class="el" href="classvcl_1_1Matrix.html">float</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abe93ad031cdf070985559c710c0cccfe" name="abe93ad031cdf070985559c710c0cccfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe93ad031cdf070985559c710c0cccfe">&#9670;&#160;</a></span>Affine3i</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">using</a> <a class="el" href="namespacevcl.html#abe93ad031cdf070985559c710c0cccfe">vcl::Affine3i</a> = <a class="el" href="classvcl_1_1Matrix.html">typedef</a> <a class="el" href="namespacevcl.html#ada2232ee49c1d1e75935719367a0c808">Affine3</a>&lt;<a class="el" href="classvcl_1_1Matrix.html">int</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad892770b57d7187fe007fc5c7b8e28c6" name="ad892770b57d7187fe007fc5c7b8e28c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad892770b57d7187fe007fc5c7b8e28c6">&#9670;&#160;</a></span>Box2</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classvcl_1_1Matrix.html">typename</a> <a class="el" href="classvcl_1_1Matrix.html">S</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">using</a> <a class="el" href="namespacevcl.html#ad892770b57d7187fe007fc5c7b8e28c6">vcl::Box2</a> = <a class="el" href="classvcl_1_1Matrix.html">typedef</a> <a class="el" href="classvcl_1_1Box.html">Box</a>&lt;<a class="el" href="group__space__core.html#ga6d15a5d1bc87330938ae9b8a55373334">Point2</a>&lt;<a class="el" href="classvcl_1_1Matrix.html">S</a>&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a77d7b12e8258d508469b505f056917f1" name="a77d7b12e8258d508469b505f056917f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77d7b12e8258d508469b505f056917f1">&#9670;&#160;</a></span>Box2d</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">using</a> <a class="el" href="namespacevcl.html#a77d7b12e8258d508469b505f056917f1">vcl::Box2d</a> = <a class="el" href="classvcl_1_1Matrix.html">typedef</a> <a class="el" href="classvcl_1_1Box.html">Box</a>&lt;<a class="el" href="group__space__core.html#ga4b02e85ff4d51fe7d689f8dd0e87ecd5">Point2d</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae6dc1589c361fc5f1b6444b74aae377d" name="ae6dc1589c361fc5f1b6444b74aae377d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6dc1589c361fc5f1b6444b74aae377d">&#9670;&#160;</a></span>Box2f</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">using</a> <a class="el" href="namespacevcl.html#ae6dc1589c361fc5f1b6444b74aae377d">vcl::Box2f</a> = <a class="el" href="classvcl_1_1Matrix.html">typedef</a> <a class="el" href="classvcl_1_1Box.html">Box</a>&lt;<a class="el" href="group__space__core.html#gac9560ad588438ce539ec3fdc5658746a">Point2f</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a43d66b66fa1219da110325fc3c9020f9" name="a43d66b66fa1219da110325fc3c9020f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43d66b66fa1219da110325fc3c9020f9">&#9670;&#160;</a></span>Box2i</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">using</a> <a class="el" href="namespacevcl.html#a43d66b66fa1219da110325fc3c9020f9">vcl::Box2i</a> = <a class="el" href="classvcl_1_1Matrix.html">typedef</a> <a class="el" href="classvcl_1_1Box.html">Box</a>&lt;<a class="el" href="group__space__core.html#ga94bdb300286f9b4bf31987102e011f8d">Point2i</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6539e58b4183d50e78e631047cd7ad12" name="a6539e58b4183d50e78e631047cd7ad12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6539e58b4183d50e78e631047cd7ad12">&#9670;&#160;</a></span>Box3</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classvcl_1_1Matrix.html">typename</a> <a class="el" href="classvcl_1_1Matrix.html">S</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">using</a> <a class="el" href="namespacevcl.html#a6539e58b4183d50e78e631047cd7ad12">vcl::Box3</a> = <a class="el" href="classvcl_1_1Matrix.html">typedef</a> <a class="el" href="classvcl_1_1Box.html">Box</a>&lt;<a class="el" href="group__space__core.html#ga13f2718b0763def563b8bd9f65982833">Point3</a>&lt;<a class="el" href="classvcl_1_1Matrix.html">S</a>&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4d5a81b5a74bca25157b2bf0de2c3f6d" name="a4d5a81b5a74bca25157b2bf0de2c3f6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d5a81b5a74bca25157b2bf0de2c3f6d">&#9670;&#160;</a></span>Box3d</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">using</a> <a class="el" href="namespacevcl.html#a4d5a81b5a74bca25157b2bf0de2c3f6d">vcl::Box3d</a> = <a class="el" href="classvcl_1_1Matrix.html">typedef</a> <a class="el" href="classvcl_1_1Box.html">Box</a>&lt;<a class="el" href="group__space__core.html#gabb47c1364fb2fe1464a54417684f011e">Point3d</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad03a804ee48eb9b3cd5aaf47f7641b3f" name="ad03a804ee48eb9b3cd5aaf47f7641b3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad03a804ee48eb9b3cd5aaf47f7641b3f">&#9670;&#160;</a></span>Box3f</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">using</a> <a class="el" href="namespacevcl.html#ad03a804ee48eb9b3cd5aaf47f7641b3f">vcl::Box3f</a> = <a class="el" href="classvcl_1_1Matrix.html">typedef</a> <a class="el" href="classvcl_1_1Box.html">Box</a>&lt;<a class="el" href="group__space__core.html#gae19b0e9639a4f90c91e46910ee66f54c">Point3f</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a84825556201de0537b996b08d1f8aeca" name="a84825556201de0537b996b08d1f8aeca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84825556201de0537b996b08d1f8aeca">&#9670;&#160;</a></span>Box3i</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">using</a> <a class="el" href="namespacevcl.html#a84825556201de0537b996b08d1f8aeca">vcl::Box3i</a> = <a class="el" href="classvcl_1_1Matrix.html">typedef</a> <a class="el" href="classvcl_1_1Box.html">Box</a>&lt;<a class="el" href="group__space__core.html#ga54b0dffe79fabd0458fc78332c91e73a">Point3i</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae166b0242a891e25bde6507bf6776730" name="ae166b0242a891e25bde6507bf6776730"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae166b0242a891e25bde6507bf6776730">&#9670;&#160;</a></span>ConstCustomComponentVectorHandle</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classvcl_1_1Matrix.html">typename</a> T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">using</a> <a class="el" href="namespacevcl.html#ae166b0242a891e25bde6507bf6776730">vcl::ConstCustomComponentVectorHandle</a> = <a class="el" href="classvcl_1_1Matrix.html">typedef</a> <a class="el" href="classvcl_1_1CustomComponentVectorHandle.html">CustomComponentVectorHandle</a>&lt;<a class="el" href="classvcl_1_1Matrix.html">const</a> T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a70592efcf2670361a337c528b34e4dfb" name="a70592efcf2670361a337c528b34e4dfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70592efcf2670361a337c528b34e4dfb">&#9670;&#160;</a></span>ConstEdgeAdjFaceIterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classvcl_1_1Matrix.html">typename</a> FaceType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">using</a> <a class="el" href="namespacevcl.html#a70592efcf2670361a337c528b34e4dfb">vcl::ConstEdgeAdjFaceIterator</a> = <a class="el" href="classvcl_1_1Matrix.html">typedef</a> <a class="el" href="classvcl_1_1EdgeAdjFaceIterator.html">EdgeAdjFaceIterator</a>&lt;FaceType, <a class="el" href="classvcl_1_1Matrix.html">true</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa909fb65065f7aa1f08e7ae17265653d" name="aa909fb65065f7aa1f08e7ae17265653d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa909fb65065f7aa1f08e7ae17265653d">&#9670;&#160;</a></span>ConstElementContainerIterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classvcl_1_1Matrix.html">template</a>&lt; <a class="el" href="classvcl_1_1Matrix.html">typename</a>, typename... &gt; <a class="el" href="classvcl_1_1Matrix.html">typename</a> Container, <a class="el" href="classvcl_1_1Matrix.html">typename</a> T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">using</a> <a class="el" href="namespacevcl.html#aa909fb65065f7aa1f08e7ae17265653d">vcl::ConstElementContainerIterator</a> = <a class="el" href="classvcl_1_1Matrix.html">typedef</a> <a class="el" href="classvcl_1_1ElementContainerIterator.html">ElementContainerIterator</a>&lt;Container, T, <a class="el" href="classvcl_1_1Matrix.html">true</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6e6e68e7341953400d9440b6fc569452" name="a6e6e68e7341953400d9440b6fc569452"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e6e68e7341953400d9440b6fc569452">&#9670;&#160;</a></span>ConstPointerFromIndexIterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classvcl_1_1Matrix.html">typename</a> Iterator , <a class="el" href="classvcl_1_1Matrix.html">typename</a> ElementType , <a class="el" href="classvcl_1_1Matrix.html">typename</a> <a class="el" href="classvcl_1_1Matrix.html">ParentElement</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">using</a> <a class="el" href="namespacevcl.html#a6e6e68e7341953400d9440b6fc569452">vcl::ConstPointerFromIndexIterator</a> = <a class="el" href="classvcl_1_1Matrix.html">typedef</a> <a class="el" href="classvcl_1_1PointerFromIndexIterator.html">PointerFromIndexIterator</a>&lt;Iterator, ElementType, <a class="el" href="classvcl_1_1Matrix.html">ParentElement</a>, <a class="el" href="classvcl_1_1Matrix.html">true</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6c937acb41381e0ce8bb27471da48d24" name="a6c937acb41381e0ce8bb27471da48d24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c937acb41381e0ce8bb27471da48d24">&#9670;&#160;</a></span>ConstVertexSampler</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;VertexConcept VertexType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">using</a> <a class="el" href="namespacevcl.html#a6c937acb41381e0ce8bb27471da48d24">vcl::ConstVertexSampler</a> = <a class="el" href="classvcl_1_1Matrix.html">typedef</a> detail::VertexSampler&lt;VertexType, <a class="el" href="classvcl_1_1Matrix.html">true</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a85b2f3d72f837560dc3dac7b128dd286" name="a85b2f3d72f837560dc3dac7b128dd286"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85b2f3d72f837560dc3dac7b128dd286">&#9670;&#160;</a></span>HashTableGrid2</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classvcl_1_1Matrix.html">typename</a> ValueType , <a class="el" href="classvcl_1_1Matrix.html">typename</a> ScalarType  = double, <a class="el" href="classvcl_1_1Matrix.html">bool</a> AllowDuplicates = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">using</a> <a class="el" href="namespacevcl.html#a85b2f3d72f837560dc3dac7b128dd286">vcl::HashTableGrid2</a> = <a class="el" href="classvcl_1_1Matrix.html">typedef</a> <a class="el" href="classvcl_1_1HashTableGrid.html">HashTableGrid</a>&lt;<a class="el" href="namespacevcl.html#acf35775c9f8314906299b1b19f6c5f9b">RegularGrid2</a>&lt;ScalarType&gt;, ValueType, <a class="el" href="classvcl_1_1Matrix.html">AllowDuplicates</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4258b9247c46311b39535faa3c2cfaa7" name="a4258b9247c46311b39535faa3c2cfaa7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4258b9247c46311b39535faa3c2cfaa7">&#9670;&#160;</a></span>HashTableGrid3</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classvcl_1_1Matrix.html">typename</a> ValueType , <a class="el" href="classvcl_1_1Matrix.html">typename</a> ScalarType  = double, <a class="el" href="classvcl_1_1Matrix.html">bool</a> AllowDuplicates = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">using</a> <a class="el" href="namespacevcl.html#a4258b9247c46311b39535faa3c2cfaa7">vcl::HashTableGrid3</a> = <a class="el" href="classvcl_1_1Matrix.html">typedef</a> <a class="el" href="classvcl_1_1HashTableGrid.html">HashTableGrid</a>&lt;<a class="el" href="namespacevcl.html#a8d7cc878c7f7ccb25c576ebf7ad2df5b">RegularGrid3</a>&lt;ScalarType&gt;, ValueType, <a class="el" href="classvcl_1_1Matrix.html">AllowDuplicates</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7eaa15c791dc5118a8eea9677c6ba9b7" name="a7eaa15c791dc5118a8eea9677c6ba9b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7eaa15c791dc5118a8eea9677c6ba9b7">&#9670;&#160;</a></span>Histogramd</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">using</a> <a class="el" href="namespacevcl.html#a7eaa15c791dc5118a8eea9677c6ba9b7">vcl::Histogramd</a> = <a class="el" href="classvcl_1_1Matrix.html">typedef</a> <a class="el" href="classvcl_1_1Histogram.html">Histogram</a>&lt;<a class="el" href="classvcl_1_1Matrix.html">double</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a294d3a64b949108ec1f6381b950945e9" name="a294d3a64b949108ec1f6381b950945e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a294d3a64b949108ec1f6381b950945e9">&#9670;&#160;</a></span>Histogramf</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">using</a> <a class="el" href="namespacevcl.html#a294d3a64b949108ec1f6381b950945e9">vcl::Histogramf</a> = <a class="el" href="classvcl_1_1Matrix.html">typedef</a> <a class="el" href="classvcl_1_1Histogram.html">Histogram</a>&lt;<a class="el" href="classvcl_1_1Matrix.html">float</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2b8b0e2e4450f76fb433f95326f85e6d" name="a2b8b0e2e4450f76fb433f95326f85e6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b8b0e2e4450f76fb433f95326f85e6d">&#9670;&#160;</a></span>Matrix33</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classvcl_1_1Matrix.html">typename</a> Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">using</a> <a class="el" href="namespacevcl.html#a2b8b0e2e4450f76fb433f95326f85e6d">vcl::Matrix33</a> = <a class="el" href="classvcl_1_1Matrix.html">typedef</a> <a class="el" href="classvcl_1_1Matrix.html">Matrix</a>&lt;Scalar, 3, 3&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a21e274a73f9088730a856902ede6ee37" name="a21e274a73f9088730a856902ede6ee37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21e274a73f9088730a856902ede6ee37">&#9670;&#160;</a></span>Matrix33d</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">using</a> <a class="el" href="namespacevcl.html#a21e274a73f9088730a856902ede6ee37">vcl::Matrix33d</a> = <a class="el" href="classvcl_1_1Matrix.html">typedef</a> <a class="el" href="namespacevcl.html#a2b8b0e2e4450f76fb433f95326f85e6d">Matrix33</a>&lt;<a class="el" href="classvcl_1_1Matrix.html">double</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac96c7ac5d789e9dbf055e35fa5a24835" name="ac96c7ac5d789e9dbf055e35fa5a24835"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac96c7ac5d789e9dbf055e35fa5a24835">&#9670;&#160;</a></span>Matrix33f</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">using</a> <a class="el" href="namespacevcl.html#ac96c7ac5d789e9dbf055e35fa5a24835">vcl::Matrix33f</a> = <a class="el" href="classvcl_1_1Matrix.html">typedef</a> <a class="el" href="namespacevcl.html#a2b8b0e2e4450f76fb433f95326f85e6d">Matrix33</a>&lt;<a class="el" href="classvcl_1_1Matrix.html">float</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa2e70d03403788ee68a3f150a70d8039" name="aa2e70d03403788ee68a3f150a70d8039"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2e70d03403788ee68a3f150a70d8039">&#9670;&#160;</a></span>Matrix33i</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">using</a> <a class="el" href="namespacevcl.html#aa2e70d03403788ee68a3f150a70d8039">vcl::Matrix33i</a> = <a class="el" href="classvcl_1_1Matrix.html">typedef</a> <a class="el" href="namespacevcl.html#a2b8b0e2e4450f76fb433f95326f85e6d">Matrix33</a>&lt;<a class="el" href="classvcl_1_1Matrix.html">int</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1ebaf363f3eba42f665854a59613068c" name="a1ebaf363f3eba42f665854a59613068c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ebaf363f3eba42f665854a59613068c">&#9670;&#160;</a></span>Matrix44</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classvcl_1_1Matrix.html">typename</a> Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">using</a> <a class="el" href="namespacevcl.html#a1ebaf363f3eba42f665854a59613068c">vcl::Matrix44</a> = <a class="el" href="classvcl_1_1Matrix.html">typedef</a> <a class="el" href="classvcl_1_1Matrix.html">Matrix</a>&lt;Scalar, 4, 4&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0c9537d456b6db5dc5f2216dfc8bccdc" name="a0c9537d456b6db5dc5f2216dfc8bccdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c9537d456b6db5dc5f2216dfc8bccdc">&#9670;&#160;</a></span>Matrix44d</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">using</a> <a class="el" href="namespacevcl.html#a0c9537d456b6db5dc5f2216dfc8bccdc">vcl::Matrix44d</a> = <a class="el" href="classvcl_1_1Matrix.html">typedef</a> <a class="el" href="namespacevcl.html#a1ebaf363f3eba42f665854a59613068c">Matrix44</a>&lt;<a class="el" href="classvcl_1_1Matrix.html">double</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6891233f7166ae9569a840d151cfe140" name="a6891233f7166ae9569a840d151cfe140"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6891233f7166ae9569a840d151cfe140">&#9670;&#160;</a></span>Matrix44f</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">using</a> <a class="el" href="namespacevcl.html#a6891233f7166ae9569a840d151cfe140">vcl::Matrix44f</a> = <a class="el" href="classvcl_1_1Matrix.html">typedef</a> <a class="el" href="namespacevcl.html#a1ebaf363f3eba42f665854a59613068c">Matrix44</a>&lt;<a class="el" href="classvcl_1_1Matrix.html">float</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af09e528e12eb6fb1fc6e596b46da8beb" name="af09e528e12eb6fb1fc6e596b46da8beb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af09e528e12eb6fb1fc6e596b46da8beb">&#9670;&#160;</a></span>Matrix44i</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">using</a> <a class="el" href="namespacevcl.html#af09e528e12eb6fb1fc6e596b46da8beb">vcl::Matrix44i</a> = <a class="el" href="classvcl_1_1Matrix.html">typedef</a> <a class="el" href="namespacevcl.html#a1ebaf363f3eba42f665854a59613068c">Matrix44</a>&lt;<a class="el" href="classvcl_1_1Matrix.html">int</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a80bd96a312570b98777680da87ba0232" name="a80bd96a312570b98777680da87ba0232"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80bd96a312570b98777680da87ba0232">&#9670;&#160;</a></span>NestedInitializerLists</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classvcl_1_1Matrix.html">typename</a> T , std::size_t L&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">using</a> <a class="el" href="namespacevcl.html#a80bd96a312570b98777680da87ba0232">vcl::NestedInitializerLists</a> = <a class="el" href="classvcl_1_1Matrix.html">typedef</a> detail::NestedInitializerListsTraits&lt;T, <a class="el" href="classvcl_1_1Matrix.html">L</a>&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The NestedInitializerLists class manages nested std::initializer_list&lt;T&gt; types of L levels L must be known at compile time, and compilation will fail if the NestedInitializerLists used does not correspond to the number of used levels. </p>

</div>
</div>
<a id="a08ef90973b043cbb709bec85607f8313" name="a08ef90973b043cbb709bec85607f8313"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08ef90973b043cbb709bec85607f8313">&#9670;&#160;</a></span>Planed</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">using</a> <a class="el" href="namespacevcl.html#a08ef90973b043cbb709bec85607f8313">vcl::Planed</a> = <a class="el" href="classvcl_1_1Matrix.html">typedef</a> <a class="el" href="classvcl_1_1Plane.html">Plane</a>&lt;<a class="el" href="classvcl_1_1Matrix.html">double</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6fa66e0f1a04578cf69387027e898c8d" name="a6fa66e0f1a04578cf69387027e898c8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fa66e0f1a04578cf69387027e898c8d">&#9670;&#160;</a></span>Planef</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">using</a> <a class="el" href="namespacevcl.html#a6fa66e0f1a04578cf69387027e898c8d">vcl::Planef</a> = <a class="el" href="classvcl_1_1Matrix.html">typedef</a> <a class="el" href="classvcl_1_1Plane.html">Plane</a>&lt;<a class="el" href="classvcl_1_1Matrix.html">float</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a924ac7eb7740e67b7701c82f079ca13b" name="a924ac7eb7740e67b7701c82f079ca13b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a924ac7eb7740e67b7701c82f079ca13b">&#9670;&#160;</a></span>Polygon2</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classvcl_1_1Matrix.html">typename</a> Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">using</a> <a class="el" href="namespacevcl.html#a924ac7eb7740e67b7701c82f079ca13b">vcl::Polygon2</a> = <a class="el" href="classvcl_1_1Matrix.html">typedef</a> <a class="el" href="classvcl_1_1Polygon.html">Polygon</a>&lt;<a class="el" href="group__space__core.html#ga6d15a5d1bc87330938ae9b8a55373334">Point2</a>&lt;Scalar&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a386fd968f85ff551b4d58e109c21db9a" name="a386fd968f85ff551b4d58e109c21db9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a386fd968f85ff551b4d58e109c21db9a">&#9670;&#160;</a></span>Polygon2d</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">using</a> <a class="el" href="namespacevcl.html#a386fd968f85ff551b4d58e109c21db9a">vcl::Polygon2d</a> = <a class="el" href="classvcl_1_1Matrix.html">typedef</a> <a class="el" href="classvcl_1_1Polygon.html">Polygon</a>&lt;<a class="el" href="group__space__core.html#ga4b02e85ff4d51fe7d689f8dd0e87ecd5">Point2d</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2d13400e95eb6871c2e4f6169ef08c23" name="a2d13400e95eb6871c2e4f6169ef08c23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d13400e95eb6871c2e4f6169ef08c23">&#9670;&#160;</a></span>Polygon2f</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">using</a> <a class="el" href="namespacevcl.html#a2d13400e95eb6871c2e4f6169ef08c23">vcl::Polygon2f</a> = <a class="el" href="classvcl_1_1Matrix.html">typedef</a> <a class="el" href="classvcl_1_1Polygon.html">Polygon</a>&lt;<a class="el" href="group__space__core.html#gac9560ad588438ce539ec3fdc5658746a">Point2f</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac04b9a59a6c30f22d15b0d1932e60457" name="ac04b9a59a6c30f22d15b0d1932e60457"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac04b9a59a6c30f22d15b0d1932e60457">&#9670;&#160;</a></span>Polygon3</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classvcl_1_1Matrix.html">typename</a> Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">using</a> <a class="el" href="namespacevcl.html#ac04b9a59a6c30f22d15b0d1932e60457">vcl::Polygon3</a> = <a class="el" href="classvcl_1_1Matrix.html">typedef</a> <a class="el" href="classvcl_1_1Polygon.html">Polygon</a>&lt;<a class="el" href="group__space__core.html#ga13f2718b0763def563b8bd9f65982833">Point3</a>&lt;Scalar&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac010b9e655ca9ca0c32f8c61b1eb56a2" name="ac010b9e655ca9ca0c32f8c61b1eb56a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac010b9e655ca9ca0c32f8c61b1eb56a2">&#9670;&#160;</a></span>Polygon3d</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">using</a> <a class="el" href="namespacevcl.html#ac010b9e655ca9ca0c32f8c61b1eb56a2">vcl::Polygon3d</a> = <a class="el" href="classvcl_1_1Matrix.html">typedef</a> <a class="el" href="classvcl_1_1Polygon.html">Polygon</a>&lt;<a class="el" href="group__space__core.html#gabb47c1364fb2fe1464a54417684f011e">Point3d</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4a359353bfe1b3e56f12a750b2de4abc" name="a4a359353bfe1b3e56f12a750b2de4abc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a359353bfe1b3e56f12a750b2de4abc">&#9670;&#160;</a></span>Polygon3f</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">using</a> <a class="el" href="namespacevcl.html#a4a359353bfe1b3e56f12a750b2de4abc">vcl::Polygon3f</a> = <a class="el" href="classvcl_1_1Matrix.html">typedef</a> <a class="el" href="classvcl_1_1Polygon.html">Polygon</a>&lt;<a class="el" href="group__space__core.html#gae19b0e9639a4f90c91e46910ee66f54c">Point3f</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acf35775c9f8314906299b1b19f6c5f9b" name="acf35775c9f8314906299b1b19f6c5f9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf35775c9f8314906299b1b19f6c5f9b">&#9670;&#160;</a></span>RegularGrid2</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classvcl_1_1Matrix.html">typename</a> Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">using</a> <a class="el" href="namespacevcl.html#acf35775c9f8314906299b1b19f6c5f9b">vcl::RegularGrid2</a> = <a class="el" href="classvcl_1_1Matrix.html">typedef</a> <a class="el" href="classvcl_1_1RegularGrid.html">RegularGrid</a>&lt;Scalar, 2&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8d7cc878c7f7ccb25c576ebf7ad2df5b" name="a8d7cc878c7f7ccb25c576ebf7ad2df5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d7cc878c7f7ccb25c576ebf7ad2df5b">&#9670;&#160;</a></span>RegularGrid3</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classvcl_1_1Matrix.html">typename</a> Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">using</a> <a class="el" href="namespacevcl.html#a8d7cc878c7f7ccb25c576ebf7ad2df5b">vcl::RegularGrid3</a> = <a class="el" href="classvcl_1_1Matrix.html">typedef</a> <a class="el" href="classvcl_1_1RegularGrid.html">RegularGrid</a>&lt;Scalar, 3&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af8c7ce5479499796837976d3247e4df8" name="af8c7ce5479499796837976d3247e4df8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8c7ce5479499796837976d3247e4df8">&#9670;&#160;</a></span>Segment2</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classvcl_1_1Matrix.html">typename</a> <a class="el" href="classvcl_1_1Matrix.html">S</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">using</a> <a class="el" href="namespacevcl.html#af8c7ce5479499796837976d3247e4df8">vcl::Segment2</a> = <a class="el" href="classvcl_1_1Matrix.html">typedef</a> <a class="el" href="classvcl_1_1Segment.html">Segment</a>&lt;<a class="el" href="group__space__core.html#ga6d15a5d1bc87330938ae9b8a55373334">Point2</a>&lt;<a class="el" href="classvcl_1_1Matrix.html">S</a>&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae5da8472ea5b5275ab7109e52d50af04" name="ae5da8472ea5b5275ab7109e52d50af04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5da8472ea5b5275ab7109e52d50af04">&#9670;&#160;</a></span>Segment2d</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">using</a> <a class="el" href="namespacevcl.html#ae5da8472ea5b5275ab7109e52d50af04">vcl::Segment2d</a> = <a class="el" href="classvcl_1_1Matrix.html">typedef</a> <a class="el" href="classvcl_1_1Segment.html">Segment</a>&lt;<a class="el" href="group__space__core.html#ga4b02e85ff4d51fe7d689f8dd0e87ecd5">Point2d</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a83dc041e1243c07111706a89433af7a9" name="a83dc041e1243c07111706a89433af7a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83dc041e1243c07111706a89433af7a9">&#9670;&#160;</a></span>Segment2f</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">using</a> <a class="el" href="namespacevcl.html#a83dc041e1243c07111706a89433af7a9">vcl::Segment2f</a> = <a class="el" href="classvcl_1_1Matrix.html">typedef</a> <a class="el" href="classvcl_1_1Segment.html">Segment</a>&lt;<a class="el" href="group__space__core.html#gac9560ad588438ce539ec3fdc5658746a">Point2f</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9ca08e736f7887a86fa4fc2dd396cdc5" name="a9ca08e736f7887a86fa4fc2dd396cdc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ca08e736f7887a86fa4fc2dd396cdc5">&#9670;&#160;</a></span>Segment2i</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">using</a> <a class="el" href="namespacevcl.html#a9ca08e736f7887a86fa4fc2dd396cdc5">vcl::Segment2i</a> = <a class="el" href="classvcl_1_1Matrix.html">typedef</a> <a class="el" href="classvcl_1_1Segment.html">Segment</a>&lt;<a class="el" href="group__space__core.html#ga94bdb300286f9b4bf31987102e011f8d">Point2i</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afc9c518fdcc207d621776ebeeedc0db5" name="afc9c518fdcc207d621776ebeeedc0db5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc9c518fdcc207d621776ebeeedc0db5">&#9670;&#160;</a></span>Segment3</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classvcl_1_1Matrix.html">typename</a> <a class="el" href="classvcl_1_1Matrix.html">S</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">using</a> <a class="el" href="namespacevcl.html#afc9c518fdcc207d621776ebeeedc0db5">vcl::Segment3</a> = <a class="el" href="classvcl_1_1Matrix.html">typedef</a> <a class="el" href="classvcl_1_1Segment.html">Segment</a>&lt;<a class="el" href="group__space__core.html#ga13f2718b0763def563b8bd9f65982833">Point3</a>&lt;<a class="el" href="classvcl_1_1Matrix.html">S</a>&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a77d6ff7d119b08bd6bc8d5e84b9fe2ec" name="a77d6ff7d119b08bd6bc8d5e84b9fe2ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77d6ff7d119b08bd6bc8d5e84b9fe2ec">&#9670;&#160;</a></span>Segment3d</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">using</a> <a class="el" href="namespacevcl.html#a77d6ff7d119b08bd6bc8d5e84b9fe2ec">vcl::Segment3d</a> = <a class="el" href="classvcl_1_1Matrix.html">typedef</a> <a class="el" href="classvcl_1_1Segment.html">Segment</a>&lt;<a class="el" href="group__space__core.html#gabb47c1364fb2fe1464a54417684f011e">Point3d</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a01b4f12a5cd0b2470b2abcd9890f1de1" name="a01b4f12a5cd0b2470b2abcd9890f1de1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01b4f12a5cd0b2470b2abcd9890f1de1">&#9670;&#160;</a></span>Segment3f</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">using</a> <a class="el" href="namespacevcl.html#a01b4f12a5cd0b2470b2abcd9890f1de1">vcl::Segment3f</a> = <a class="el" href="classvcl_1_1Matrix.html">typedef</a> <a class="el" href="classvcl_1_1Segment.html">Segment</a>&lt;<a class="el" href="group__space__core.html#gae19b0e9639a4f90c91e46910ee66f54c">Point3f</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0694142b42086cf347becff6f0db0c9c" name="a0694142b42086cf347becff6f0db0c9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0694142b42086cf347becff6f0db0c9c">&#9670;&#160;</a></span>Segment3i</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">using</a> <a class="el" href="namespacevcl.html#a0694142b42086cf347becff6f0db0c9c">vcl::Segment3i</a> = <a class="el" href="classvcl_1_1Matrix.html">typedef</a> <a class="el" href="classvcl_1_1Segment.html">Segment</a>&lt;<a class="el" href="group__space__core.html#ga54b0dffe79fabd0458fc78332c91e73a">Point3i</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a125a3b42c101ab958048c730060aa8c8" name="a125a3b42c101ab958048c730060aa8c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a125a3b42c101ab958048c730060aa8c8">&#9670;&#160;</a></span>Sphered</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">using</a> <a class="el" href="namespacevcl.html#a125a3b42c101ab958048c730060aa8c8">vcl::Sphered</a> = <a class="el" href="classvcl_1_1Matrix.html">typedef</a> <a class="el" href="classvcl_1_1Sphere.html">Sphere</a>&lt;<a class="el" href="classvcl_1_1Matrix.html">double</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a918b0af3e76ff4b82da382ddfab126d0" name="a918b0af3e76ff4b82da382ddfab126d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a918b0af3e76ff4b82da382ddfab126d0">&#9670;&#160;</a></span>Spheref</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">using</a> <a class="el" href="namespacevcl.html#a918b0af3e76ff4b82da382ddfab126d0">vcl::Spheref</a> = <a class="el" href="classvcl_1_1Matrix.html">typedef</a> <a class="el" href="classvcl_1_1Sphere.html">Sphere</a>&lt;<a class="el" href="classvcl_1_1Matrix.html">float</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2bbbace04824cfa901027d8e90d830c6" name="a2bbbace04824cfa901027d8e90d830c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bbbace04824cfa901027d8e90d830c6">&#9670;&#160;</a></span>StaticGrid2</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classvcl_1_1Matrix.html">typename</a> ValueType , <a class="el" href="classvcl_1_1Matrix.html">typename</a> ScalarType  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">using</a> <a class="el" href="namespacevcl.html#a2bbbace04824cfa901027d8e90d830c6">vcl::StaticGrid2</a> = <a class="el" href="classvcl_1_1Matrix.html">typedef</a> <a class="el" href="classvcl_1_1StaticGrid.html">StaticGrid</a>&lt;<a class="el" href="namespacevcl.html#acf35775c9f8314906299b1b19f6c5f9b">RegularGrid2</a>&lt;ScalarType&gt;, ValueType&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afa27c3398ca14cd8a5a7e1423d7a68cd" name="afa27c3398ca14cd8a5a7e1423d7a68cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa27c3398ca14cd8a5a7e1423d7a68cd">&#9670;&#160;</a></span>StaticGrid3</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classvcl_1_1Matrix.html">typename</a> ValueType , <a class="el" href="classvcl_1_1Matrix.html">typename</a> ScalarType  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">using</a> <a class="el" href="namespacevcl.html#afa27c3398ca14cd8a5a7e1423d7a68cd">vcl::StaticGrid3</a> = <a class="el" href="classvcl_1_1Matrix.html">typedef</a> <a class="el" href="classvcl_1_1StaticGrid.html">StaticGrid</a>&lt;<a class="el" href="namespacevcl.html#a8d7cc878c7f7ccb25c576ebf7ad2df5b">RegularGrid3</a>&lt;ScalarType&gt;, ValueType&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aec42e251f09249cda2fe0463b81c0f79" name="aec42e251f09249cda2fe0463b81c0f79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec42e251f09249cda2fe0463b81c0f79">&#9670;&#160;</a></span>TexCoordd</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">using</a> <a class="el" href="namespacevcl.html#aec42e251f09249cda2fe0463b81c0f79">vcl::TexCoordd</a> = <a class="el" href="classvcl_1_1Matrix.html">typedef</a> <a class="el" href="classvcl_1_1TexCoord.html">TexCoord</a>&lt;<a class="el" href="classvcl_1_1Matrix.html">double</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6ccd8e32ef2f6bf0decb43463f41fb2b" name="a6ccd8e32ef2f6bf0decb43463f41fb2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ccd8e32ef2f6bf0decb43463f41fb2b">&#9670;&#160;</a></span>TexCoordf</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">using</a> <a class="el" href="namespacevcl.html#a6ccd8e32ef2f6bf0decb43463f41fb2b">vcl::TexCoordf</a> = <a class="el" href="classvcl_1_1Matrix.html">typedef</a> <a class="el" href="classvcl_1_1TexCoord.html">TexCoord</a>&lt;<a class="el" href="classvcl_1_1Matrix.html">float</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a917984925513fc8634c94e269ee0cf82" name="a917984925513fc8634c94e269ee0cf82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a917984925513fc8634c94e269ee0cf82">&#9670;&#160;</a></span>TexCoordi</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">using</a> <a class="el" href="namespacevcl.html#a917984925513fc8634c94e269ee0cf82">vcl::TexCoordi</a> = <a class="el" href="classvcl_1_1Matrix.html">typedef</a> <a class="el" href="classvcl_1_1TexCoord.html">TexCoord</a>&lt;<a class="el" href="classvcl_1_1Matrix.html">int</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aac0ef38a541827b51057bfae9e8c5039" name="aac0ef38a541827b51057bfae9e8c5039"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac0ef38a541827b51057bfae9e8c5039">&#9670;&#160;</a></span>Triangle2</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classvcl_1_1Matrix.html">typename</a> Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">using</a> <a class="el" href="namespacevcl.html#aac0ef38a541827b51057bfae9e8c5039">vcl::Triangle2</a> = <a class="el" href="classvcl_1_1Matrix.html">typedef</a> <a class="el" href="classvcl_1_1Triangle.html">Triangle</a>&lt;<a class="el" href="group__space__core.html#ga6d15a5d1bc87330938ae9b8a55373334">Point2</a>&lt;Scalar&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8e9344ae874797a2a653deab133d870f" name="a8e9344ae874797a2a653deab133d870f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e9344ae874797a2a653deab133d870f">&#9670;&#160;</a></span>Triangle2d</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">using</a> <a class="el" href="namespacevcl.html#a8e9344ae874797a2a653deab133d870f">vcl::Triangle2d</a> = <a class="el" href="classvcl_1_1Matrix.html">typedef</a> <a class="el" href="classvcl_1_1Triangle.html">Triangle</a>&lt;<a class="el" href="group__space__core.html#ga4b02e85ff4d51fe7d689f8dd0e87ecd5">Point2d</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad1f6b217d733de32db193f0e751ece25" name="ad1f6b217d733de32db193f0e751ece25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1f6b217d733de32db193f0e751ece25">&#9670;&#160;</a></span>Triangle2f</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">using</a> <a class="el" href="namespacevcl.html#ad1f6b217d733de32db193f0e751ece25">vcl::Triangle2f</a> = <a class="el" href="classvcl_1_1Matrix.html">typedef</a> <a class="el" href="classvcl_1_1Triangle.html">Triangle</a>&lt;<a class="el" href="group__space__core.html#gac9560ad588438ce539ec3fdc5658746a">Point2f</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae03921c36e8b060269d9ff90b068db39" name="ae03921c36e8b060269d9ff90b068db39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae03921c36e8b060269d9ff90b068db39">&#9670;&#160;</a></span>Triangle3</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classvcl_1_1Matrix.html">typename</a> Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">using</a> <a class="el" href="namespacevcl.html#ae03921c36e8b060269d9ff90b068db39">vcl::Triangle3</a> = <a class="el" href="classvcl_1_1Matrix.html">typedef</a> <a class="el" href="classvcl_1_1Triangle.html">Triangle</a>&lt;<a class="el" href="group__space__core.html#ga13f2718b0763def563b8bd9f65982833">Point3</a>&lt;Scalar&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a02db1e7fb252318c4435c8ca9944401e" name="a02db1e7fb252318c4435c8ca9944401e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02db1e7fb252318c4435c8ca9944401e">&#9670;&#160;</a></span>Triangle3d</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">using</a> <a class="el" href="namespacevcl.html#a02db1e7fb252318c4435c8ca9944401e">vcl::Triangle3d</a> = <a class="el" href="classvcl_1_1Matrix.html">typedef</a> <a class="el" href="classvcl_1_1Triangle.html">Triangle</a>&lt;<a class="el" href="group__space__core.html#gabb47c1364fb2fe1464a54417684f011e">Point3d</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afa2a67863f5edd83d508344306bd7bb3" name="afa2a67863f5edd83d508344306bd7bb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa2a67863f5edd83d508344306bd7bb3">&#9670;&#160;</a></span>Triangle3f</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">using</a> <a class="el" href="namespacevcl.html#afa2a67863f5edd83d508344306bd7bb3">vcl::Triangle3f</a> = <a class="el" href="classvcl_1_1Matrix.html">typedef</a> <a class="el" href="classvcl_1_1Triangle.html">Triangle</a>&lt;<a class="el" href="group__space__core.html#gae19b0e9639a4f90c91e46910ee66f54c">Point3f</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a92c93a12005e031d04c92971247414ef" name="a92c93a12005e031d04c92971247414ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92c93a12005e031d04c92971247414ef">&#9670;&#160;</a></span>TriangleWrapper2</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classvcl_1_1Matrix.html">typename</a> Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">using</a> <a class="el" href="namespacevcl.html#a92c93a12005e031d04c92971247414ef">vcl::TriangleWrapper2</a> = <a class="el" href="classvcl_1_1Matrix.html">typedef</a> <a class="el" href="classvcl_1_1TriangleWrapper.html">TriangleWrapper</a>&lt;<a class="el" href="group__space__core.html#ga6d15a5d1bc87330938ae9b8a55373334">Point2</a>&lt;Scalar&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a27931fc2ea467c03c1019dc025d218e5" name="a27931fc2ea467c03c1019dc025d218e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27931fc2ea467c03c1019dc025d218e5">&#9670;&#160;</a></span>TriangleWrapper2d</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">using</a> <a class="el" href="namespacevcl.html#a27931fc2ea467c03c1019dc025d218e5">vcl::TriangleWrapper2d</a> = <a class="el" href="classvcl_1_1Matrix.html">typedef</a> <a class="el" href="classvcl_1_1TriangleWrapper.html">TriangleWrapper</a>&lt;<a class="el" href="group__space__core.html#ga4b02e85ff4d51fe7d689f8dd0e87ecd5">Point2d</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5ff16ee6b33f9bdd47405cb91f29e2d0" name="a5ff16ee6b33f9bdd47405cb91f29e2d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ff16ee6b33f9bdd47405cb91f29e2d0">&#9670;&#160;</a></span>TriangleWrapper2f</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">using</a> <a class="el" href="namespacevcl.html#a5ff16ee6b33f9bdd47405cb91f29e2d0">vcl::TriangleWrapper2f</a> = <a class="el" href="classvcl_1_1Matrix.html">typedef</a> <a class="el" href="classvcl_1_1TriangleWrapper.html">TriangleWrapper</a>&lt;<a class="el" href="group__space__core.html#gac9560ad588438ce539ec3fdc5658746a">Point2f</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a439efbe438907a52943d563d8a12daab" name="a439efbe438907a52943d563d8a12daab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a439efbe438907a52943d563d8a12daab">&#9670;&#160;</a></span>TriangleWrapper3</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classvcl_1_1Matrix.html">typename</a> Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">using</a> <a class="el" href="namespacevcl.html#a439efbe438907a52943d563d8a12daab">vcl::TriangleWrapper3</a> = <a class="el" href="classvcl_1_1Matrix.html">typedef</a> <a class="el" href="classvcl_1_1TriangleWrapper.html">TriangleWrapper</a>&lt;<a class="el" href="group__space__core.html#ga13f2718b0763def563b8bd9f65982833">Point3</a>&lt;Scalar&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ace2761031333634f83908ed3d4e5fb19" name="ace2761031333634f83908ed3d4e5fb19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace2761031333634f83908ed3d4e5fb19">&#9670;&#160;</a></span>TriangleWrapper3d</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">using</a> <a class="el" href="namespacevcl.html#ace2761031333634f83908ed3d4e5fb19">vcl::TriangleWrapper3d</a> = <a class="el" href="classvcl_1_1Matrix.html">typedef</a> <a class="el" href="classvcl_1_1TriangleWrapper.html">TriangleWrapper</a>&lt;<a class="el" href="group__space__core.html#gabb47c1364fb2fe1464a54417684f011e">Point3d</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a295b4c2f1ffcf361e32166b44a5a4476" name="a295b4c2f1ffcf361e32166b44a5a4476"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a295b4c2f1ffcf361e32166b44a5a4476">&#9670;&#160;</a></span>TriangleWrapper3f</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">using</a> <a class="el" href="namespacevcl.html#a295b4c2f1ffcf361e32166b44a5a4476">vcl::TriangleWrapper3f</a> = <a class="el" href="classvcl_1_1Matrix.html">typedef</a> <a class="el" href="classvcl_1_1TriangleWrapper.html">TriangleWrapper</a>&lt;<a class="el" href="group__space__core.html#gae19b0e9639a4f90c91e46910ee66f54c">Point3f</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af74b42dd9d759d565bb701a5b845d05c" name="af74b42dd9d759d565bb701a5b845d05c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af74b42dd9d759d565bb701a5b845d05c">&#9670;&#160;</a></span>uint</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">using</a> <a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">vcl::uint</a> = <a class="el" href="classvcl_1_1Matrix.html">typedef</a> <a class="el" href="classvcl_1_1Matrix.html">unsigned</a> <a class="el" href="classvcl_1_1Matrix.html">int</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5ee777e6ef2036ffa4ea83d39f83663b" name="a5ee777e6ef2036ffa4ea83d39f83663b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ee777e6ef2036ffa4ea83d39f83663b">&#9670;&#160;</a></span>ushort</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">using</a> <a class="el" href="namespacevcl.html#a5ee777e6ef2036ffa4ea83d39f83663b">vcl::ushort</a> = <a class="el" href="classvcl_1_1Matrix.html">typedef</a> <a class="el" href="classvcl_1_1Matrix.html">unsigned</a> <a class="el" href="classvcl_1_1Matrix.html">short</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a06db57219f01121229b9d6a138d3a24f" name="a06db57219f01121229b9d6a138d3a24f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06db57219f01121229b9d6a138d3a24f">&#9670;&#160;</a></span>VertexSampler</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;VertexConcept VertexType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">using</a> <a class="el" href="namespacevcl.html#a06db57219f01121229b9d6a138d3a24f">vcl::VertexSampler</a> = <a class="el" href="classvcl_1_1Matrix.html">typedef</a> detail::VertexSampler&lt;VertexType, <a class="el" href="classvcl_1_1Matrix.html">false</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a5a4e8376b2d47797f9167f2a8dd6fb0e" name="a5a4e8376b2d47797f9167f2a8dd6fb0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a4e8376b2d47797f9167f2a8dd6fb0e">&#9670;&#160;</a></span>HausdorffSamplingMethod</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">enum</a> <a class="el" href="namespacevcl.html#a5a4e8376b2d47797f9167f2a8dd6fb0e">vcl::HausdorffSamplingMethod</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a5a4e8376b2d47797f9167f2a8dd6fb0ea33aad0431cadce18cad82201cb732f49" name="a5a4e8376b2d47797f9167f2a8dd6fb0ea33aad0431cadce18cad82201cb732f49"></a>HAUSDORFF_VERTEX_UNIFORM&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a5a4e8376b2d47797f9167f2a8dd6fb0eac8770691ceb41b51c7ab63b70f1da9c6" name="a5a4e8376b2d47797f9167f2a8dd6fb0eac8770691ceb41b51c7ab63b70f1da9c6"></a>HAUSDORFF_EDGE_UNIFORM&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a5a4e8376b2d47797f9167f2a8dd6fb0eaf9d0153b4af81b71be3972e5a9e3307a" name="a5a4e8376b2d47797f9167f2a8dd6fb0eaf9d0153b4af81b71be3972e5a9e3307a"></a>HAUSDORFF_MONTECARLO&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="aaca879a6bfd47ff8429d6b2f6cfa9440" name="aaca879a6bfd47ff8429d6b2f6cfa9440"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaca879a6bfd47ff8429d6b2f6cfa9440">&#9670;&#160;</a></span>VCLibPrincipalCurvatureAlgorithm</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">enum</a> <a class="el" href="namespacevcl.html#aaca879a6bfd47ff8429d6b2f6cfa9440">vcl::VCLibPrincipalCurvatureAlgorithm</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aaca879a6bfd47ff8429d6b2f6cfa9440a16e818963316b0b43fcbdec6d75f25ed" name="aaca879a6bfd47ff8429d6b2f6cfa9440a16e818963316b0b43fcbdec6d75f25ed"></a>VCL_PRINCIPAL_CURVATURE_TAUBIN95&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aaca879a6bfd47ff8429d6b2f6cfa9440a2c812dad0f96c382657b60bb2d2f8180" name="aaca879a6bfd47ff8429d6b2f6cfa9440a2c812dad0f96c382657b60bb2d2f8180"></a>VCL_PRINCIPAL_CURVATURE_PCA&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="af4e08b69bd34fcb7b7b8648ea27ee31e" name="af4e08b69bd34fcb7b7b8648ea27ee31e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4e08b69bd34fcb7b7b8648ea27ee31e">&#9670;&#160;</a></span>addPerElementCustomComponent()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a> ELEM_ID, MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">void</a> vcl::addPerElementCustomComponent </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="structvcl_1_1MeshInfo_1_1CustomComponent.html">MeshInfo::CustomComponent</a> &amp;&#160;</td>
          <td class="paramname"><em>cc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae7feb8594f6727f2475dbc1d337b32fc" name="ae7feb8594f6727f2475dbc1d337b32fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7feb8594f6727f2475dbc1d337b32fc">&#9670;&#160;</a></span>addPerFaceCustomComponent()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">void</a> vcl::addPerFaceCustomComponent </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="structvcl_1_1MeshInfo_1_1CustomComponent.html">MeshInfo::CustomComponent</a> &amp;&#160;</td>
          <td class="paramname"><em>cc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af68e89e67c2fd8636c9dba90319b94a8" name="af68e89e67c2fd8636c9dba90319b94a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af68e89e67c2fd8636c9dba90319b94a8">&#9670;&#160;</a></span>addPerVertexCustomComponent()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">void</a> vcl::addPerVertexCustomComponent </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="structvcl_1_1MeshInfo_1_1CustomComponent.html">MeshInfo::CustomComponent</a> &amp;&#160;</td>
          <td class="paramname"><em>cc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acad48a316f6b47d2ce4fa978be50a97e" name="acad48a316f6b47d2ce4fa978be50a97e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acad48a316f6b47d2ce4fa978be50a97e">&#9670;&#160;</a></span>addTriangleFacesFromPolygon() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a> vcl::addTriangleFacesFromPolygon </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> std::vector&lt; <a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>polygon</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a vector of indices of vertices in a mesh representing a polyon, this function adds N triangular faces to the mesh, that are the triangulation of the input polygon. <a class="el" href="classvcl_1_1Triangle.html">Triangle</a> edges that are internal in the polygon are marked as faux. This function returns the index of the first added triangle. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classvcl_1_1BadVertexIndexException.html">BadVertexIndexException</a></td><td>if there is a vertex index in the polygon that is out of range, or that references a vertex that results deleted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MeshType</td><td>the type of the face that satisfies the FaceMeshConcept.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">m</td><td>the mesh on which add the triangulation of the polygon. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">polygon</td><td>the vertex indices in the mesh representing the polygon. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the first triangle added to the mesh. </dd></dl>

</div>
</div>
<a id="aab5bd336ab6b6a6138f89ffbb56ef3b5" name="aab5bd336ab6b6a6138f89ffbb56ef3b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab5bd336ab6b6a6138f89ffbb56ef3b5">&#9670;&#160;</a></span>addTriangleFacesFromPolygon() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType, FaceConcept FaceType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">void</a> vcl::addTriangleFacesFromPolygon </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FaceType &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> std::vector&lt; <a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>polygon</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a vector of indices of vertices in a mesh representing a polyon, this function adds N triangular faces to the mesh, that are the triangulation of the input polygon. <a class="el" href="classvcl_1_1Triangle.html">Triangle</a> edges that are internal in the polygon are marked as faux. </p>
<p>This function assumes that the first (triangular) face has been already added to the mesh and just needs to be filled with vertex references. This is useful in some cases (e.g. when reading from file and you realize just at some point that you need to manage a polygon). In all the other cases, you should use the function that does not take a face in input, that is:</p>
<div class="fragment"><div class="line"><a class="code hl_typedef" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a> <a class="code hl_class" href="classvcl_1_1Matrix.html">fid</a> = <a class="code hl_function" href="namespacevcl.html#aab5bd336ab6b6a6138f89ffbb56ef3b5">addTriangleFacesFromPolygon</a>(mesh, polygon);</div>
<div class="ttc" id="aclassvcl_1_1Matrix_html"><div class="ttname"><a href="classvcl_1_1Matrix.html">vcl::Matrix</a></div><div class="ttdef"><b>Definition</b> matrix.h:36</div></div>
<div class="ttc" id="anamespacevcl_html_aab5bd336ab6b6a6138f89ffbb56ef3b5"><div class="ttname"><a href="namespacevcl.html#aab5bd336ab6b6a6138f89ffbb56ef3b5">vcl::addTriangleFacesFromPolygon</a></div><div class="ttdeci">void addTriangleFacesFromPolygon(MeshType &amp;m, FaceType &amp;f, const std::vector&lt; uint &gt; &amp;polygon)</div><div class="ttdoc">Given a vector of indices of vertices in a mesh representing a polyon, this function adds N triangula...</div><div class="ttdef"><b>Definition</b> polygon.h:57</div></div>
<div class="ttc" id="anamespacevcl_html_af74b42dd9d759d565bb701a5b845d05c"><div class="ttname"><a href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">vcl::uint</a></div><div class="ttdeci">unsigned int uint</div><div class="ttdef"><b>Definition</b> base.h:34</div></div>
</div><!-- fragment --><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classvcl_1_1BadVertexIndexException.html">BadVertexIndexException</a></td><td>if there is a vertex index in the polygon that is out of range, or that references a vertex that results deleted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MeshType</td><td>the type of the face that satisfies the FaceMeshConcept. </td></tr>
    <tr><td class="paramname">FaceType</td><td>the type of the face that satisfies the FaceConcept.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">m</td><td>the mesh on which add the triangulation of the polygon. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">f</td><td>the first face of the triangulation, that will be filled. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">polygon</td><td>the vertex indices in the mesh representing the polygon. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a90d821ff0dab1c3c45fdfe82ce48448f" name="a90d821ff0dab1c3c45fdfe82ce48448f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90d821ff0dab1c3c45fdfe82ce48448f">&#9670;&#160;</a></span>applyTransformMatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType, <a class="el" href="classvcl_1_1Matrix.html">typename</a> <a class="el" href="classvcl_1_1Matrix.html">ScalarM</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">void</a> vcl::applyTransformMatrix </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="namespacevcl.html#a1ebaf363f3eba42f665854a59613068c">Matrix44</a>&lt; <a class="el" href="classvcl_1_1Matrix.html">ScalarM</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">bool</a>&#160;</td>
          <td class="paramname"><em>updateNormals</em> = <code><a class="el" href="classvcl_1_1Matrix.html">true</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a58e916cd5d73eca35e6f8ae1be248637" name="a58e916cd5d73eca35e6f8ae1be248637"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58e916cd5d73eca35e6f8ae1be248637">&#9670;&#160;</a></span>asConst() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classvcl_1_1Matrix.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">void</a> vcl::asConst </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> T &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a943a3fda661e6e71d8fd7106f41dd878" name="a943a3fda661e6e71d8fd7106f41dd878"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a943a3fda661e6e71d8fd7106f41dd878">&#9670;&#160;</a></span>asConst() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classvcl_1_1Matrix.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">constexpr</a> T * vcl::asConst </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> T *&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Utility function that converts a const pointer/reference to a non-const pointer/reference.   </p>
<p>It is useful when you need to re-use the same code for const and non-const member functions.</p>
<dl class="section warning"><dt>Warning</dt><dd>The function should be used only in contexts where the constness of the pointer/reference is guaranteed to be removed (see <a href="https://en.cppreference.com/w/cpp/language/const_cast">const_cast</a>).</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the pointer/reference. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The const pointer/reference to be const-casted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The non-const pointer/reference.   </dd></dl>

</div>
</div>
<a id="abe5c457181ae725f99627c541993a3a8" name="abe5c457181ae725f99627c541993a3a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe5c457181ae725f99627c541993a3a8">&#9670;&#160;</a></span>asConst() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classvcl_1_1Matrix.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">constexpr</a> T * vcl::asConst </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Utility function that converts a const pointer/reference to a non-const pointer/reference.   </p>
<p>It is useful when you need to re-use the same code for const and non-const member functions.</p>
<dl class="section warning"><dt>Warning</dt><dd>The function should be used only in contexts where the constness of the pointer/reference is guaranteed to be removed (see <a href="https://en.cppreference.com/w/cpp/language/const_cast">const_cast</a>).</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the pointer/reference. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The const pointer/reference to be const-casted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The non-const pointer/reference.   </dd></dl>

</div>
</div>
<a id="a66e2e1e0ec5d91e9def735ecf4f84b0e" name="a66e2e1e0ec5d91e9def735ecf4f84b0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66e2e1e0ec5d91e9def735ecf4f84b0e">&#9670;&#160;</a></span>barycenter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">MeshType::VertexType::CoordType vcl::barycenter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the barycenter of the mesh, that is the simple average of all the vertex coordintes of the mesh. </p>
<p>Requirements:</p><ul>
<li><a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>:<ul>
<li>Vertices</li>
</ul>
</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>input mesh on which compute the barycenter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The barycenter of the input mesh. </dd></dl>

</div>
</div>
<a id="a6f45446c5f7bcad8bd9dd9c515bf1e55" name="a6f45446c5f7bcad8bd9dd9c515bf1e55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f45446c5f7bcad8bd9dd9c515bf1e55">&#9670;&#160;</a></span>bestGridSize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;PointConcept PointType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Point.html">Point</a>&lt; <a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a>, PointType::DIM &gt; vcl::bestGridSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> PointType &amp;&#160;</td>
          <td class="paramname"><em>lengths</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a>&#160;</td>
          <td class="paramname"><em>nElements</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the best sizes (number of cells per dimension) of a Grid, starting from the lengths of the grid and the number of elements to place in the grid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lengths</td><td></td></tr>
    <tr><td class="paramname">nElements</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a86c0811cfbc37a3b319d57902e81e949" name="a86c0811cfbc37a3b319d57902e81e949"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86c0811cfbc37a3b319d57902e81e949">&#9670;&#160;</a></span>borderLength()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">double</a> vcl::borderLength </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the border length of the given <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>, that is the sum of the length of the edges that are on border in the given mesh. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>mesh on which compute the border length. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The border length of the given mesh. </dd></dl>

</div>
</div>
<a id="a47188a6c411a5a4fbd8542d5ce1525aa" name="a47188a6c411a5a4fbd8542d5ce1525aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47188a6c411a5a4fbd8542d5ce1525aa">&#9670;&#160;</a></span>checkFlipEdge()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceConcept FaceType&gt; <br />
requires comp::HasAdjacentFaces&lt;FaceType&gt;</div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">bool</a> vcl::checkFlipEdge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> FaceType &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a>&#160;</td>
          <td class="paramname"><em>edge</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a boolean value indicating whether the edge flip operation is allowed or not. </p>
<p>This function requires AdjacentFaces component, that must be available and computed before calling this function.</p>
<p>The function first checks if the specified edge is a boundary edge, in which case the flip operation is not allowed. If the edge is not a boundary edge, the function checks whether the mesh is well-oriented by verifying that the vertices of the edge to be flipped are the same in the adjacent face.</p>
<p>Next, the function checks if the flipped edge already exists in the mesh. To do this, the function performs a depth-first search starting from the current face, following the edges that share the opposite vertex to the edge being flipped. The search checks if the vertex on the other end of the flipped edge is already connected to any other face in the mesh. If it is, the flip operation is not allowed.</p>
<p>The depth-first search is limited to the faces that share the opposite vertex to the edge being flipped, so it does not perform an exhaustive search of the entire mesh. However, it is sufficient to detect non-manifoldness caused by the flipped edge.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classvcl_1_1MissingComponentException.html">vcl::MissingComponentException</a></td><td>If the "AdjacentFaces" component is not available on <code>f</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FaceType</td><td>the type of the face that satisfies the FaceConcept.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>The face that contains the edge to flip. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">edge</td><td>The index of the edge to flip.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the edge flip is allowed, false otherwise. </dd></dl>

</div>
</div>
<a id="a3701f183f5eab726b026aebed8237d7e" name="a3701f183f5eab726b026aebed8237d7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3701f183f5eab726b026aebed8237d7e">&#9670;&#160;</a></span>checkMeshPointers()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">bool</a> vcl::checkMeshPointers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a748cd8beb49f3c7a18dbd1efdcd8bf21" name="a748cd8beb49f3c7a18dbd1efdcd8bf21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a748cd8beb49f3c7a18dbd1efdcd8bf21">&#9670;&#160;</a></span>clampPerFaceQuality()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">void</a> vcl::clampPerFaceQuality </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">typename</a> MeshType::FaceType::QualityType&#160;</td>
          <td class="paramname"><em>minS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">typename</a> MeshType::FaceType::QualityType&#160;</td>
          <td class="paramname"><em>maxS</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clamps the face quality of a mesh in a given interval. </p>
<p>Requirements:</p><ul>
<li><a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>:<ul>
<li>Faces:<ul>
<li>Quality</li>
</ul>
</li>
</ul>
</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">m</td><td>mesh on which clamp the face quality </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">minS</td><td>minimum value of the clamping interval </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxS</td><td>maximum value of the clamping interval </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a696dc0c7e7d1e45751850aaa7a51f247" name="a696dc0c7e7d1e45751850aaa7a51f247"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a696dc0c7e7d1e45751850aaa7a51f247">&#9670;&#160;</a></span>clampPerVertexQuality()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">void</a> vcl::clampPerVertexQuality </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">typename</a> MeshType::VertexType::QualityType&#160;</td>
          <td class="paramname"><em>minS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">typename</a> MeshType::VertexType::QualityType&#160;</td>
          <td class="paramname"><em>maxS</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clamps the vertex quality of a mesh in a given interval. </p>
<p>Requirements:</p><ul>
<li><a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>:<ul>
<li>Vertices:<ul>
<li>Quality</li>
</ul>
</li>
</ul>
</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">m</td><td>mesh on which clamp the vertex quality </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">minS</td><td>minimum value of the clamping interval </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxS</td><td>maximum value of the clamping interval </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0416a0056c7bbd35f81e72bb9b536db0" name="a0416a0056c7bbd35f81e72bb9b536db0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0416a0056c7bbd35f81e72bb9b536db0">&#9670;&#160;</a></span>clearEdgeSelection()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;EdgeMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">void</a> vcl::clearEdgeSelection </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abae51c1f51e5b5ca5f12018bb6ae1a40" name="abae51c1f51e5b5ca5f12018bb6ae1a40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abae51c1f51e5b5ca5f12018bb6ae1a40">&#9670;&#160;</a></span>clearFaceEdgesSelection()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">void</a> vcl::clearFaceEdgesSelection </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abb5edd39f9dd2fc2220d8b08be523e29" name="abb5edd39f9dd2fc2220d8b08be523e29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb5edd39f9dd2fc2220d8b08be523e29">&#9670;&#160;</a></span>clearFaceSelection()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">void</a> vcl::clearFaceSelection </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5c9ac6a7be92ef3620293918623eac14" name="a5c9ac6a7be92ef3620293918623eac14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c9ac6a7be92ef3620293918623eac14">&#9670;&#160;</a></span>clearPerElementNormals()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a> ELEM_ID, LoggerConcept LogType = NullLogger&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">void</a> vcl::clearPerElementNormals </td>
          <td>(</td>
          <td class="paramtype">MeshConcept <a class="el" href="classvcl_1_1Matrix.html">auto</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">LogType</a> &amp;&#160;</td>
          <td class="paramname"><em>log</em> = <code><a class="el" href="group__miscellaneous.html#ga3377e3c875ec245e90ac5a395105ce99">nullLogger</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets to zero the normals of all the <code>ELEM_ID</code> elements of the mesh, including the unreferenced ones. </p>
<p>Requirements:</p><ul>
<li><a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>:<ul>
<li><code>ELEM_ID</code>:<ul>
<li>Normal</li>
</ul>
</li>
</ul>
</li>
</ul>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ELEM_ID</td><td>The ID of an <a class="el" href="classvcl_1_1Element.html" title="The Element class.">Element</a>, that is a value in the ElementIDEnum.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">mesh</td><td>The mesh on which clear the <code>ELEM_ID</code> normals. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">log</td><td>The logger used to log the performed operations. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aec301aa1e068ae4ceeeef43761b9ee04" name="aec301aa1e068ae4ceeeef43761b9ee04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec301aa1e068ae4ceeeef43761b9ee04">&#9670;&#160;</a></span>clearPerFaceAdjacentFaces()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">void</a> vcl::clearPerFaceAdjacentFaces </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clears the adjacent faces of each face of the mesh. </p>
<p>Since the number of adjacent faces per face is tied to the number of vertices of the face, at the end of this function each face will have f-&gt;vertexNumber() adjacent faces set to nullptr.</p>
<p>Requirements:</p><ul>
<li><a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>:<ul>
<li>Faces:<ul>
<li>AdjacentFaces</li>
</ul>
</li>
</ul>
</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>the mesh on which clear the per face adjacent faces. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad02648e687324278cf2df5230af63c22" name="ad02648e687324278cf2df5230af63c22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad02648e687324278cf2df5230af63c22">&#9670;&#160;</a></span>clearPerFaceNormals()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;LoggerConcept LogType = NullLogger&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">void</a> vcl::clearPerFaceNormals </td>
          <td>(</td>
          <td class="paramtype">FaceMeshConcept <a class="el" href="classvcl_1_1Matrix.html">auto</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">LogType</a> &amp;&#160;</td>
          <td class="paramname"><em>log</em> = <code><a class="el" href="group__miscellaneous.html#ga3377e3c875ec245e90ac5a395105ce99">nullLogger</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as clearPerElementNormals, but for the face normals. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacevcl.html#a5c9ac6a7be92ef3620293918623eac14" title="Sets to zero the normals of all the ELEM_ID elements of the mesh, including the unreferenced ones.">clearPerElementNormals</a> </dd></dl>

</div>
</div>
<a id="a385c6f0e9e2d7ad9df7f19e967163331" name="a385c6f0e9e2d7ad9df7f19e967163331"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a385c6f0e9e2d7ad9df7f19e967163331">&#9670;&#160;</a></span>clearPerReferencedVertexNormals()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType, LoggerConcept LogType = NullLogger&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">void</a> vcl::clearPerReferencedVertexNormals </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">LogType</a> &amp;&#160;</td>
          <td class="paramname"><em>log</em> = <code><a class="el" href="group__miscellaneous.html#ga3377e3c875ec245e90ac5a395105ce99">nullLogger</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets to zero all the normals of vertices that are referenced by at least one element, leaving unchanged all the normals of the unreferenced vertices that may be still useful. </p>
<p>Requirements:</p><ul>
<li><a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>:<ul>
<li>Vertices:<ul>
<li>Normal</li>
</ul>
</li>
</ul>
</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">mesh</td><td>The mesh on which clear the referenced vertex normals. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">log</td><td>The logger used to log the performed operations. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a54e8371c2ddda188c9540ea7e7bddf78" name="a54e8371c2ddda188c9540ea7e7bddf78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54e8371c2ddda188c9540ea7e7bddf78">&#9670;&#160;</a></span>clearPerVertexAdjacentFaces()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">void</a> vcl::clearPerVertexAdjacentFaces </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clears the adjacent faces of each vertex of the mesh. </p>
<p>Since the number of adjacent faces per vertex is dynamic, at the end of this function each vertex will have 0 adjacent Faces.</p>
<p>Requirements:</p><ul>
<li><a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>:<ul>
<li>Vertices:<ul>
<li>AdjacentFaces</li>
</ul>
</li>
</ul>
</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>the mesh on which clear the per vertex adjacent faces. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a312c8ca27b3e94994a1f03bc1a3d826d" name="a312c8ca27b3e94994a1f03bc1a3d826d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a312c8ca27b3e94994a1f03bc1a3d826d">&#9670;&#160;</a></span>clearPerVertexAdjacentVertices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">void</a> vcl::clearPerVertexAdjacentVertices </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clears the adjacent vertices of each vertex of the mesh. </p>
<p>Since the number of adjacent vertices per vertex is dynamic, at the end of this function each vertex will have 0 adjacent vertices.</p>
<p>Requirements:</p><ul>
<li><a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>:<ul>
<li>Vertices:<ul>
<li>AdjacentVertices</li>
</ul>
</li>
</ul>
</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>the mesh on which clear the per vertex adjacent vertices. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a96aac67d3963514cab5023c1749f8cd7" name="a96aac67d3963514cab5023c1749f8cd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96aac67d3963514cab5023c1749f8cd7">&#9670;&#160;</a></span>clearPerVertexNormals()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;LoggerConcept LogType = NullLogger&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">void</a> vcl::clearPerVertexNormals </td>
          <td>(</td>
          <td class="paramtype">MeshConcept <a class="el" href="classvcl_1_1Matrix.html">auto</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">LogType</a> &amp;&#160;</td>
          <td class="paramname"><em>log</em> = <code><a class="el" href="group__miscellaneous.html#ga3377e3c875ec245e90ac5a395105ce99">nullLogger</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as clearPerElementNormals, but for the vertex normals. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacevcl.html#a5c9ac6a7be92ef3620293918623eac14" title="Sets to zero the normals of all the ELEM_ID elements of the mesh, including the unreferenced ones.">clearPerElementNormals</a> </dd></dl>

</div>
</div>
<a id="a7b0bc5dbd8005d39d14ccf664ffca33c" name="a7b0bc5dbd8005d39d14ccf664ffca33c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b0bc5dbd8005d39d14ccf664ffca33c">&#9670;&#160;</a></span>clearVertexSelection()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">void</a> vcl::clearVertexSelection </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab5a54ddc3c9d67e0c7ed179e78c2ca06" name="ab5a54ddc3c9d67e0c7ed179e78c2ca06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5a54ddc3c9d67e0c7ed179e78c2ca06">&#9670;&#160;</a></span>colorFromInterval() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Color.html">Color</a> vcl::colorFromInterval </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">float</a>&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">float</a>&#160;</td>
          <td class="paramname"><em>max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">float</a>&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Color.html#a32ace7bd7fccf742b39f6cd83042a10f">Color::ColorMap</a>&#160;</td>
          <td class="paramname"><em>cm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a color in the interval from the minimum color to the maximum color of the given colormap <code>cm</code>, depending on the position of the given value in the given interval [min, max]. </p>
<p>If the given value is less than the minimum value of the interval, the minimum color will be returned. If the given value is higher than the maximum value of the interval, the maximum color will be returned. If min and max are equal, the Grey color will be returned.</p>
<p>This function works also if the values of the interval are swapped.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">min</td><td>minimum value of the interval </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max</td><td>maximum value of the interval </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>the value in the interval to ramp. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cm</td><td>the colormap on which compute the color. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A color in the given colormap representing the position of value in the interval [min, max]. </dd></dl>

</div>
</div>
<a id="a5851edce0478bfc7f4084e3529ae6962" name="a5851edce0478bfc7f4084e3529ae6962"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5851edce0478bfc7f4084e3529ae6962">&#9670;&#160;</a></span>colorFromInterval() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Color.html">Color</a> vcl::colorFromInterval </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">float</a>&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Color.html#a32ace7bd7fccf742b39f6cd83042a10f">Color::ColorMap</a>&#160;</td>
          <td class="paramname"><em>cm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a <code>value</code> in the interval [0, 1], it returns the color in the position in the given ColorMap <code>cm</code> corresponding to the position of <code>value</code> in the interval [0, 1]. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>a float value between 0 and 1. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">[cm]</td><td>cm: the colormap used to compute the color. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The color in the position of <code>value</code> in the given colormap. </dd></dl>

</div>
</div>
<a id="a99b591f2eba1ded24ebf6f4b0ee4353f" name="a99b591f2eba1ded24ebf6f4b0ee4353f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99b591f2eba1ded24ebf6f4b0ee4353f">&#9670;&#160;</a></span>colorFromIntervalGreyShade() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Color.html">Color</a> vcl::colorFromIntervalGreyShade </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">float</a>&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">float</a>&#160;</td>
          <td class="paramname"><em>max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">float</a>&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a color in the grey shade colormap depending on the position of the given value in the given interval [min, max]. </p>
<p>If the given value is less than the minimum value of the interval, the minimum color of the colormap will be returned. If the given value is higher than the maximum value of the interval, the maximum color in the colormap will be returned. If min and max are equal, the Grey color will be returned.</p>
<p>This function works also if the values of the interval are swapped.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">min</td><td>minimum value of the interval </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max</td><td>maximum value of the interval </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>the value in the interval to ramp. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A color in the grey shade colormap representing the position of value in the interval [min, max]. </dd></dl>

</div>
</div>
<a id="a8232d4e3c3aca4125e84cb8f124ebc29" name="a8232d4e3c3aca4125e84cb8f124ebc29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8232d4e3c3aca4125e84cb8f124ebc29">&#9670;&#160;</a></span>colorFromIntervalGreyShade() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Color.html">Color</a> vcl::colorFromIntervalGreyShade </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">float</a>&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a color in the grey shade colormap depending on the position of the given value in the interval [0, 1]. </p>
<p>If the given value is less than 0, the minimum color of the colormap will be returned. If the given value is higher than 1, the maximum color in the colormap will be returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>the value between 0 and 1 to ramp. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A color in the grey shade colormap representing the position of value in the interval [0, 1]. </dd></dl>

</div>
</div>
<a id="a9725bc9a2f5b27ce885e76be92185a20" name="a9725bc9a2f5b27ce885e76be92185a20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9725bc9a2f5b27ce885e76be92185a20">&#9670;&#160;</a></span>colorFromIntervalParula() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Color.html">Color</a> vcl::colorFromIntervalParula </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">float</a>&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">float</a>&#160;</td>
          <td class="paramname"><em>max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">float</a>&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a color in the Paraula colormap depending on the position of the given value in the given interval [min, max]. </p>
<p>If the given value is less than the minimum value of the interval, the minimum color of the colormap will be returned. If the given value is higher than the maximum value of the interval, the maximum color in the colormap will be returned. If min and max are equal, the Grey color will be returned.</p>
<p>This function works also if the values of the interval are swapped.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">min</td><td>minimum value of the interval </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max</td><td>maximum value of the interval </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>the value in the interval to ramp. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A color in the Parula colormap representing the position of value in the interval [min, max]. </dd></dl>

</div>
</div>
<a id="a7728ec836fa169f447a90a4d2eee3df5" name="a7728ec836fa169f447a90a4d2eee3df5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7728ec836fa169f447a90a4d2eee3df5">&#9670;&#160;</a></span>colorFromIntervalParula() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Color.html">Color</a> vcl::colorFromIntervalParula </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">float</a>&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a color in the Paraula colormap depending on the position of the given value in the interval [0, 1]. </p>
<p>If the given value is less than 0, the minimum color of the colormap will be returned. If the given value is higher than 1, the maximum color in the colormap will be returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>the value between 0 and 1 to ramp. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A color in the Parula colormap representing the position of value in the interval [0, 1]. </dd></dl>

</div>
</div>
<a id="afa361024b35e8aef9609826b177ac1cb" name="afa361024b35e8aef9609826b177ac1cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa361024b35e8aef9609826b177ac1cb">&#9670;&#160;</a></span>colorFromIntervalRedBlue() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Color.html">Color</a> vcl::colorFromIntervalRedBlue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">float</a>&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">float</a>&#160;</td>
          <td class="paramname"><em>max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">float</a>&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a color in the interval from Red to Blue depending on the position of the given value in the given interval [min, max]. </p>
<p>If the given value is less than the minimum value of the interval, the Red color will be returned. If the given value is higher than the maximum value of the interval, the Blue color will be returned. If min and max are equal, the Grey color will be returned.</p>
<p>This function works also if the values of the interval are swapped.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">min</td><td>minimum value of the interval </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max</td><td>maximum value of the interval </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>the value in the interval to ramp. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A color between Red and Blue representing the position of value in the interval [min, max]. </dd></dl>

</div>
</div>
<a id="a6c348d7127fb95f134332b8c275846f7" name="a6c348d7127fb95f134332b8c275846f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c348d7127fb95f134332b8c275846f7">&#9670;&#160;</a></span>colorFromIntervalRedBlue() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Color.html">Color</a> vcl::colorFromIntervalRedBlue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">float</a>&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a color in the interval from Red to Blue depending on the position of the given value in the interval [0, 1]. </p>
<p>If the given value is less than 0, the Red color will be returned. If the given value is higher than 1, the Blue color will be returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>the value between 0 and 1 to ramp. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A color between Red and Blue representing the position of value in the interval [0, 1]. </dd></dl>

</div>
</div>
<a id="a9dcc49648719fc830554b892110ff8f2" name="a9dcc49648719fc830554b892110ff8f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9dcc49648719fc830554b892110ff8f2">&#9670;&#160;</a></span>colorLerp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Color.html">Color</a> vcl::colorLerp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="classvcl_1_1Color.html">Color</a> &amp;&#160;</td>
          <td class="paramname"><em>c0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="classvcl_1_1Color.html">Color</a> &amp;&#160;</td>
          <td class="paramname"><em>c1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">float</a>&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given an interval of colors (from <code>c0</code> to <code>c1</code>) and a value in the interval [0, 1], returns the linear interpolation color between <code>c0</code> and <code>c1</code> based on <code>value</code> in the [0, 1] interval. If <code>value</code> is out of range, it will be set to the nearest extreme of the interval. </p>
<p>Linear interpolation is computed in the RGBA values of the two colors.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">c0</td><td>minimum in the input color interval. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">c1</td><td>minimum in the input color interval. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>a float value between 0 and 1. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The linear interpolation between <code>c0</code> and <code>c1</code>. </dd></dl>

</div>
</div>
<a id="a7e24134fa80806f677e3d5d72cd9c9e9" name="a7e24134fa80806f677e3d5d72cd9c9e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e24134fa80806f677e3d5d72cd9c9e9">&#9670;&#160;</a></span>colorScattering()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classvcl_1_1Color.html">Color</a> &gt; vcl::colorScattering </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">float</a>&#160;</td>
          <td class="paramname"><em>sat</em> = <code>0.3</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">float</a>&#160;</td>
          <td class="paramname"><em>val</em> = <code>0.9</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a number <code>n</code>, returns a vector of <code>n</code> colors so that each color differs as much as possible from the previous one of the vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the number of colors in the returned vector </td></tr>
    <tr><td class="paramname">sat</td><td>the saturation in the returned colors </td></tr>
    <tr><td class="paramname">val</td><td>the value in the returned colors </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector of different colors. </dd></dl>

</div>
</div>
<a id="aca4e61e9eb02bae8617f346aaf830452" name="aca4e61e9eb02bae8617f346aaf830452"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca4e61e9eb02bae8617f346aaf830452">&#9670;&#160;</a></span>compactVector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classvcl_1_1Matrix.html">typename</a> T , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">void</a> vcl::compactVector </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T, Args... &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> std::vector&lt; <a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>newIndices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>It will take care of compacting the vector vec, depending on the content of the vector newIndices. </p>
<p>Given the vector newIndices having the following features:</p><ul>
<li>has the same size of vec</li>
<li>for each position i:<ul>
<li>newIndices[i] contains the new position of the element vec[i] after the compactness</li>
<li>newIndices[i] contains the value UINT_NULL if the element vec[i] must be deleted</li>
</ul>
</li>
</ul>
<p>Non-null elements of newIndices must be unique, and their value must be less than the new size of vec after the compactness. The new size of vec will be the number of non-null elements of newIndices.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td></td></tr>
    <tr><td class="paramname">newIndices</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af9101a04223deed528addeb4dbf722bf" name="af9101a04223deed528addeb4dbf722bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9101a04223deed528addeb4dbf722bf">&#9670;&#160;</a></span>containsCaseInsensitive()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">bool</a> vcl::containsCaseInsensitive </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> std::string &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> std::string &amp;&#160;</td>
          <td class="paramname"><em>substr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <code>true</code> if the <code>input</code> string contains <code>substr</code> as a substring, without taking into account case sensitiveness. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>input string. </td></tr>
    <tr><td class="paramname">substr</td><td>substring to look into <code>input</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <code>substr</code> was found in <code>input</code> </dd></dl>

</div>
</div>
<a id="a49e57acf0c1cb51e98f7a176051d99ee" name="a49e57acf0c1cb51e98f7a176051d99ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49e57acf0c1cb51e98f7a176051d99ee">&#9670;&#160;</a></span>covarianceMatrixOfMesh()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">auto</a> vcl::covarianceMatrixOfMesh </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute covariance matrix of a mesh, i.e. the integral int_{m} { (x-b)(x-b)^T }dx where b is the barycenter and x spans over the mesh m. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The 3x3 covariance matrix of the given mesh. </dd></dl>

</div>
</div>
<a id="a46a67e9dd1e0a9805f812c10328caaa2" name="a46a67e9dd1e0a9805f812c10328caaa2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46a67e9dd1e0a9805f812c10328caaa2">&#9670;&#160;</a></span>covarianceMatrixOfPointCloud() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">auto</a> vcl::covarianceMatrixOfPointCloud </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the covariance matrix of a <a class="el" href="classvcl_1_1Point.html" title="The Point class represents an N-dimensional point containing N scalar values.">Point</a> Cloud <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>. </p>
<p>Requirements:</p><ul>
<li><a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>:<ul>
<li>Vertices</li>
</ul>
</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The 3x3 covariance matrix of the given point cloud. </dd></dl>

</div>
</div>
<a id="af9fd633374c0d8ab86df9e354a9a0fb5" name="af9fd633374c0d8ab86df9e354a9a0fb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9fd633374c0d8ab86df9e354a9a0fb5">&#9670;&#160;</a></span>covarianceMatrixOfPointCloud() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Point3Concept PointType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">auto</a> vcl::covarianceMatrixOfPointCloud </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> std::vector&lt; PointType &gt; &amp;&#160;</td>
          <td class="paramname"><em>pointVec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the covariance matrix of a set of points. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pointVec</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The 3x3 covariance matrix of the given set of points. </dd></dl>

</div>
</div>
<a id="a74127bca614f622db4ffc101f3d6c241" name="a74127bca614f622db4ffc101f3d6c241"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74127bca614f622db4ffc101f3d6c241">&#9670;&#160;</a></span>creaseFaceEdges()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; <a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a>, <a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a> &gt; &gt; vcl::creaseFaceEdges </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">double</a>&#160;</td>
          <td class="paramname"><em>angleRadNeg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">double</a>&#160;</td>
          <td class="paramname"><em>angleRadPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">bool</a>&#160;</td>
          <td class="paramname"><em>alsoBorderEdges</em> = <code><a class="el" href="classvcl_1_1Matrix.html">false</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a vector of pairs &lt;face index; edge index&gt; of the edges that have a dihedral angle outside the given range. </p>
<p>If alsoBorderEdges is true, border edges are also considered.</p>
<p>The algorithm requires the adjacency information of the faces.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>Input mesh. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">angleRadNeg</td><td>Minimum angle in radians. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">angleRadPos</td><td>Maximum angle in radians. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alsoBorderEdges</td><td>If true, also border edges are considered. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of pairs &lt;face index; edge index&gt; of the edges that have a dihedral angle outside the given range. </dd></dl>

</div>
</div>
<a id="ac4dbcbe1f5e5f94f45c7830d6e08ade9" name="ac4dbcbe1f5e5f94f45c7830d6e08ade9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4dbcbe1f5e5f94f45c7830d6e08ade9">&#9670;&#160;</a></span>createCircle()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Polygon2Concept PolygonType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">PolygonType</a> vcl::createCircle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">typename</a> PolygonType::ScalarType&#160;</td>
          <td class="paramname"><em>radius</em> = <code>1.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a 2D circle polygon with n vertices and the given radius. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">PolygonType</td><td>The polygon type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>The number of vertices. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">radius</td><td>The radius of the circle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The circle polygon. </dd></dl>

</div>
</div>
<a id="a6dace96b8290fefb07363487ec841514" name="a6dace96b8290fefb07363487ec841514"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6dace96b8290fefb07363487ec841514">&#9670;&#160;</a></span>createCone()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">MeshType vcl::createCone </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">auto</a>&#160;</td>
          <td class="paramname"><em>radiusBottom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">auto</a>&#160;</td>
          <td class="paramname"><em>radiusTop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">auto</a>&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a>&#160;</td>
          <td class="paramname"><em>subdivisions</em> = <code>36</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a712bfd97ace55544f86b53c6cce60a71" name="a712bfd97ace55544f86b53c6cce60a71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a712bfd97ace55544f86b53c6cce60a71">&#9670;&#160;</a></span>createCylinder()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">MeshType vcl::createCylinder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">auto</a>&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">auto</a>&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a>&#160;</td>
          <td class="paramname"><em>subdivisions</em> = <code>36</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a17051e34bedc366cb41d655f7365a071" name="a17051e34bedc366cb41d655f7365a071"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17051e34bedc366cb41d655f7365a071">&#9670;&#160;</a></span>deserialize() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classvcl_1_1Matrix.html">typename</a> T , std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">void</a> vcl::deserialize </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>is</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; T, <a class="el" href="classvcl_1_1Matrix.html">N</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deserialize specializations ///. </p>

</div>
</div>
<a id="af2b134ebe097914129ec9e8c8ecaf10a" name="af2b134ebe097914129ec9e8c8ecaf10a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2b134ebe097914129ec9e8c8ecaf10a">&#9670;&#160;</a></span>deserialize() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">void</a> vcl::deserialize </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>is</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af9fed85edca355a0134d16d95c47419a" name="af9fed85edca355a0134d16d95c47419a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9fed85edca355a0134d16d95c47419a">&#9670;&#160;</a></span>deserialize() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classvcl_1_1Matrix.html">typename</a> T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">void</a> vcl::deserialize </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>is</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a801af2c87c0523fd06c3adafecc9b2fb" name="a801af2c87c0523fd06c3adafecc9b2fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a801af2c87c0523fd06c3adafecc9b2fb">&#9670;&#160;</a></span>deserialize() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classvcl_1_1Matrix.html">typename</a> T , typename... Others&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">void</a> vcl::deserialize </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>is</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">Others</a> &amp;...&#160;</td>
          <td class="paramname"><em>others</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a18e098749891a7daa5a62a0f768bac62" name="a18e098749891a7daa5a62a0f768bac62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18e098749891a7daa5a62a0f768bac62">&#9670;&#160;</a></span>deserialize() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;IsNotClass T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">void</a> vcl::deserialize </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>is</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::endian&#160;</td>
          <td class="paramname"><em>endian</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deserialize data from an input stream, using the specified endian format. </p>
<p>The endian format specifies the format of the data read from the input stream. If the endian format is different from the native one, the data is swapped.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">is</td><td>input stream. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">data</td><td>deserialized data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">endian</td><td>endian format of the deserialization. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adba0ad72ed6db7296eac1c91786ca106" name="adba0ad72ed6db7296eac1c91786ca106"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adba0ad72ed6db7296eac1c91786ca106">&#9670;&#160;</a></span>deserializeN()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classvcl_1_1Matrix.html">typename</a> T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">void</a> vcl::deserializeN </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>is</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::endian&#160;</td>
          <td class="paramname"><em>endian</em> = <code>std::endian::little</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deserialize an array of contiguous data from an input stream, using the specified format. </p>
<p>The endian format specifies the format of the data read from the input stream. If the endian format is different from the native one, the data is swapped.</p>
<p>By default, the deserialization is done in binary little endian format.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">is</td><td>input stream. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">data</td><td>pointer to the deserialized data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>number of elements to deserialize. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">endian</td><td>endian format of the deserialization. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3109cc4c0e2128888f2a3fa6ae27a98f" name="a3109cc4c0e2128888f2a3fa6ae27a98f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3109cc4c0e2128888f2a3fa6ae27a98f">&#9670;&#160;</a></span>detachAdjacentFacesOnEdge()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceConcept FaceType&gt; <br />
requires comp::HasAdjacentFaces&lt;FaceType&gt;</div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">void</a> vcl::detachAdjacentFacesOnEdge </td>
          <td>(</td>
          <td class="paramtype">FaceType &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a>&#160;</td>
          <td class="paramname"><em>edge</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Detaches the face <code>f</code> on the given edge, which consists on updating adjacent faces such that any face that was linking the face <code>f</code> won't link it anymore. It manages also non-manifold edges. </p>
<p>If the given pair face-edge is on border, nothing is done. If the given pair face-edge is a normal manifold edge, this operation will set nullptr as adjacent face of f (making edge a border) and vice versa on the adjacent face. If the given pair face-edge is a non-manifold edge, the function will "remove" the current face from the ring of faces incident on the edge. The given face f will have the given edge set as a border (nullptr).</p>
<p>This function is designed to work with faces that have an available "AdjacentFaces" component. If the component is not available, a <a class="el" href="classvcl_1_1MissingComponentException.html">MissingComponentException</a> is thrown.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classvcl_1_1MissingComponentException.html">vcl::MissingComponentException</a></td><td>If the "AdjacentFaces" component is not available on <code>f</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FaceType</td><td>the type of the face that satisfies the FaceConcept.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>The face to detach on the given edge. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">edge</td><td>The index of the edge to detach the face from. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af67d9147410404febe19163fb506397d" name="af67d9147410404febe19163fb506397d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af67d9147410404febe19163fb506397d">&#9670;&#160;</a></span>detachFace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceConcept FaceType&gt; <br />
requires comp::HasAdjacentFaces&lt;FaceType&gt;</div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">void</a> vcl::detachFace </td>
          <td>(</td>
          <td class="paramtype">FaceType &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Detaches the given face from all its adjacent vertices and adjacent faces. </p>
<p>The detachFace function detaches the given face from all its adjacent vertices and adjacent faces. This means that every vertex and face will no longer link to the face <code>f</code> as an adjacent face, and <code>f</code> will no longer have any adjacent faces (all their values are set to nullptr). The vertices of the face <code>f</code> are unchanged.</p>
<p>This function is designed to work with faces that have an available "Adjacent
Faces" component. If the component is not available, a <a class="el" href="classvcl_1_1MissingComponentException.html">MissingComponentException</a> is thrown.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classvcl_1_1MissingComponentException.html">MissingComponentException</a></td><td>if the adjacent faces component is not available on the face.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FaceType</td><td>the type of the face that satisfies the FaceConcept.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>The face to detach from its vertices and adjacent faces. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3983ab4b434d669a765240b81daa236e" name="a3983ab4b434d669a765240b81daa236e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3983ab4b434d669a765240b81daa236e">&#9670;&#160;</a></span>earCut()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceConcept Face&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a> &gt; vcl::earCut </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="classvcl_1_1Face.html">Face</a> &amp;&#160;</td>
          <td class="paramname"><em>polygon</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the earcut algorithm of a 3D <em>planar</em> polygon, that returns a triangulation of the polygon. </p>
<p>Returns a list of indices in which each index is the index of a point of the 3D input polgon, organized in triplets, each one of these is a triangle of the resulting triangulation.</p>
<p>This algorithm first computes the normal of the given polygon, then projects it in a 2D plane and executes the classic 2D EarCut algorithm.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="el" href="classvcl_1_1Face.html" title="The Face class represents an Face element of the vcl::Mesh class.">Face</a></td><td>the type of the face that satisfies the FaceConcept.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">polygon</td><td>A (polygonal) face of a <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">vcl::Mesh</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of indices, representing the triplets of the triangulation of the polygon. </dd></dl>

</div>
</div>
<a id="a77bd6f212cc6ca4ad37ce181c2ba6d1b" name="a77bd6f212cc6ca4ad37ce181c2ba6d1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77bd6f212cc6ca4ad37ce181c2ba6d1b">&#9670;&#160;</a></span>edgeAdjacentFacesNumber()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceConcept FaceType&gt; <br />
requires comp::HasAdjacentFaces&lt;FaceType&gt;</div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a> vcl::edgeAdjacentFacesNumber </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> FaceType &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a>&#160;</td>
          <td class="paramname"><em>edge</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of adjacent faces to the given edge of the face f. </p>
<p>If the given edge is manifold, the returned number will be 1 (if the edge is on border - just one face) or 2 (two adjacent faces on the edge). If the edge is non manifold, the number of faces adjacent to the given face will be counted.</p>
<p>This function requires AdjacentFaces component, that must be available and computed before calling this function.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classvcl_1_1MissingComponentException.html">vcl::MissingComponentException</a></td><td>If the "AdjacentFaces" component is not available on <code>f</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FaceType</td><td>the type of the face that satisfies the FaceConcept.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>the face containing the edge </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">edge</td><td>the index of the edge of the face </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of adjacent faces to the given edge of the face <code>f</code> </dd></dl>

</div>
</div>
<a id="a59d8e830fa317191e2d02ff5cafc7149" name="a59d8e830fa317191e2d02ff5cafc7149"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59d8e830fa317191e2d02ff5cafc7149">&#9670;&#160;</a></span>edgeMatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MatrixConcept Matrix, EdgeMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">Matrix</a> vcl::edgeMatrix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a #V*3 <a class="el" href="classvcl_1_1Matrix.html">Matrix</a> of scalars containing the coordinates of the vertices of a <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>. The function is templated on the <a class="el" href="classvcl_1_1Matrix.html">Matrix</a> itself. </p>
<p>This function works with every <a class="el" href="classvcl_1_1Matrix.html">Matrix</a> type that satisfies the MatrixConcept.</p>
<p>Usage example with an Eigen <a class="el" href="classvcl_1_1Matrix.html">Matrix</a>:</p>
<div class="fragment"><div class="line">   Eigen::MatrixX3d <a class="code hl_class" href="classvcl_1_1Matrix.html">V</a> = <a class="code hl_class" href="classvcl_1_1Matrix.html">vcl::vertexMatrix&lt;Eigen::MatrixX3d&gt;</a>(<a class="code hl_class" href="classvcl_1_1Matrix.html">myMesh</a>);</div>
<div class="line">   <span class="keyword">@end</span><span class="keywordflow">if</span></div>
<div class="line">  </div>
<div class="line">   @note This function does not guarantee that the rows of the matrix</div>
<div class="line">   correspond to the vertex indices of the mesh. This scenario is possible</div>
<div class="line">   when the mesh has deleted vertices. To be sure to have a direct</div>
<div class="line">   correspondence, compact the vertex container before calling <span class="keyword">this</span> function.</div>
<div class="line">  </div>
<div class="line">   @tparam Matrix: type of the matrix to be returned, it must satisfy the</div>
<div class="line">   MatrixConcept.</div>
<div class="line">   @tparam MeshType: type of the input mesh, it must satisfy the MeshConcept.</div>
<div class="line">  </div>
<div class="line">   @param[in] mesh: input mesh</div>
<div class="line">   @<span class="keywordflow">return</span> \#V*3 matrix of scalars (vertex coordinates)</div>
<div class="line">  /</div>
<div class="line"><span class="keyword">template</span>&lt;MatrixConcept Matrix, MeshConcept MeshType&gt;</div>
<div class="line">Matrix vertexMatrix(<span class="keyword">const</span> MeshType&amp; mesh)</div>
<div class="line">{</div>
<div class="line">    Matrix V(mesh.vertexNumber(), 3);</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_typedef" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a> i = 0;</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; v : mesh.vertices()) {</div>
<div class="line">        <span class="keywordflow">for</span> (<a class="code hl_typedef" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a> j = 0; j &lt; 3; ++j) {</div>
<div class="line">            V(i, j) = v.coord()[j];</div>
<div class="line">        }</div>
<div class="line">        ++i;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> V;</div>
<div class="line">}</div>
<div class="line"> </div>
</div><!-- fragment --><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classvcl_1_1MissingCompactnessException.html">vcl::MissingCompactnessException</a></td><td>if the vertex container is not compact.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function does not guarantee that the rows of the matrix correspond to the edge indices of the mesh. This scenario is possible when the mesh has deleted edges. To be sure to have a direct correspondence, compact the edge container before calling this function.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="el" href="classvcl_1_1Matrix.html">Matrix</a></td><td>type of the matrix to be returned, it must satisfy the MatrixConcept. </td></tr>
    <tr><td class="paramname">MeshType</td><td>type of the input mesh, it must satisfy the EdgeMeshConcept.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>input mesh </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>#E*2 matrix of integers (edge indices) </dd></dl>

</div>
</div>
<a id="a11baff43762bd72ed51ae9884a8ae4b8" name="a11baff43762bd72ed51ae9884a8ae4b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11baff43762bd72ed51ae9884a8ae4b8">&#9670;&#160;</a></span>edgeSelectionNumber()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;EdgeMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a> vcl::edgeSelectionNumber </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="add776c0c02e7ef2d7657fce701c437e7" name="add776c0c02e7ef2d7657fce701c437e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add776c0c02e7ef2d7657fce701c437e7">&#9670;&#160;</a></span>elementColorsMatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a> ELEM_ID, MatrixConcept Matrix, MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">Matrix</a> vcl::elementColorsMatrix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a #E*4 <a class="el" href="classvcl_1_1Matrix.html">Matrix</a> of integers containing the colors of the elements identified by <code>ELEM_ID</code> of a <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>. The function is templated on the <a class="el" href="classvcl_1_1Matrix.html">Matrix</a> itself. </p>
<p>This function works with every <a class="el" href="classvcl_1_1Matrix.html">Matrix</a> type that satisfies the MatrixConcept, and requires that the mesh has per-element colors.</p>
<p>Usage example with Eigen <a class="el" href="classvcl_1_1Matrix.html">Matrix</a>:</p>
<div class="fragment"><div class="line">Eigen::MatrixX4i <a class="code hl_class" href="classvcl_1_1Matrix.html">EC</a> =</div>
<div class="line">    <a class="code hl_class" href="classvcl_1_1Matrix.html">vcl::elementColorsMatrix&lt;ElemId::VERTEX, Eigen::MatrixX4i&gt;</a>(<a class="code hl_class" href="classvcl_1_1Matrix.html">myMesh</a>);</div>
</div><!-- fragment --><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classvcl_1_1MissingComponentException.html">vcl::MissingComponentException</a></td><td>if the mesh does not have per-element colors available.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function does not guarantee that the rows of the matrix correspond to the element indices of the mesh. This scenario is possible when the mesh has deleted elements. To be sure to have a direct correspondence, compact the element container before calling this function.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ELEM_ID</td><td>the ID of the element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>input mesh </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>#E*4 matrix of integers (element colors) </dd></dl>

</div>
</div>
<a id="a0aeda48720e2d34688e56a6ab79b7600" name="a0aeda48720e2d34688e56a6ab79b7600"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0aeda48720e2d34688e56a6ab79b7600">&#9670;&#160;</a></span>elementNormalsMatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a> ELEM_ID, MatrixConcept Matrix, MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">Matrix</a> vcl::elementNormalsMatrix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a #E <a class="el" href="classvcl_1_1Vector.html" title="The Vector class is a generic container of objects of type T, that could have fixed or dynamic size,...">Vector</a> of booleans (or integers) containing the selection status of the elements identified by <code>ELEM_ID</code> of a <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>. The function is templated on the <a class="el" href="classvcl_1_1Vector.html" title="The Vector class is a generic container of objects of type T, that could have fixed or dynamic size,...">Vector</a> itself. </p>
<p>This function works with every <a class="el" href="classvcl_1_1Vector.html" title="The Vector class is a generic container of objects of type T, that could have fixed or dynamic size,...">Vector</a> type that has a constructor with a size_t argument and an operator[uint].</p>
<p>Usage example with Eigen <a class="el" href="classvcl_1_1Vector.html" title="The Vector class is a generic container of objects of type T, that could have fixed or dynamic size,...">Vector</a>:</p>
<div class="fragment"><div class="line">   Eigen::VectorXi <a class="code hl_class" href="classvcl_1_1Matrix.html">S</a> =</div>
<div class="line">       <a class="code hl_class" href="classvcl_1_1Matrix.html">vcl::elementSelectionVector&lt;ElemId::VERTEX, Eigen::VectorXi&gt;</a>(<a class="code hl_class" href="classvcl_1_1Matrix.html">myMesh</a>);</div>
<div class="line">   <span class="keyword">@end</span><span class="keywordflow">if</span></div>
<div class="line">  </div>
<div class="line">   @note This function does not guarantee that the rows of the vector</div>
<div class="line">   correspond to the element indices of the mesh. This scenario is possible</div>
<div class="line">   when the mesh has deleted elements. To be sure to have a direct</div>
<div class="line">   correspondence, compact the element container before calling <span class="keyword">this</span> function.</div>
<div class="line">  </div>
<div class="line">   @tparam ELEM_ID: the ID of the element.</div>
<div class="line">   @tparam Vect: type of the vector to be returned.</div>
<div class="line">   @tparam MeshType: type of the input mesh, it must satisfy the MeshConcept.</div>
<div class="line">  </div>
<div class="line">   @param[in] mesh: input mesh</div>
<div class="line">   @<span class="keywordflow">return</span> \#E vector of booleans or integers (element selection)</div>
<div class="line">  /</div>
<div class="line"><span class="keyword">template</span>&lt;u<span class="keywordtype">int</span> ELEM_ID, <span class="keyword">typename</span> Vect, MeshConcept MeshType&gt;</div>
<div class="line">Vect elementSelectionVector(<span class="keyword">const</span> MeshType&amp; mesh)</div>
<div class="line">{</div>
<div class="line">    Vect S(mesh.template number&lt;ELEM_ID&gt;());</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_typedef" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a> i = 0;</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; e : mesh.template elements&lt;ELEM_ID&gt;())</div>
<div class="line">        S[i] = e.selected();</div>
<div class="line">    <span class="keywordflow">return</span> S;</div>
<div class="line">}</div>
<div class="line"> </div>
</div><!-- fragment --><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classvcl_1_1MissingComponentException.html">vcl::MissingComponentException</a></td><td>if the mesh does not have per-element normals available.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function does not guarantee that the rows of the matrix correspond to the element indices of the mesh. This scenario is possible when the mesh has deleted elements. To be sure to have a direct correspondence, compact the element container before calling this function.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ELEM_ID</td><td>the ID of the element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>input mesh </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>#E*3 matrix of scalars (element normals) </dd></dl>

</div>
</div>
<a id="a8e07fcb626e0c670f8f92e930d0b2c46" name="a8e07fcb626e0c670f8f92e930d0b2c46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e07fcb626e0c670f8f92e930d0b2c46">&#9670;&#160;</a></span>elementQualityVector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a> ELEM_ID, <a class="el" href="classvcl_1_1Matrix.html">typename</a> <a class="el" href="classvcl_1_1Matrix.html">Vect</a> , MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">Vect</a> vcl::elementQualityVector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a #E <a class="el" href="classvcl_1_1Vector.html" title="The Vector class is a generic container of objects of type T, that could have fixed or dynamic size,...">Vector</a> of scalars containing the quality of the elements identified by <code>ELEM_ID</code> of a <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>. The function is templated on the <a class="el" href="classvcl_1_1Vector.html" title="The Vector class is a generic container of objects of type T, that could have fixed or dynamic size,...">Vector</a> itself. </p>
<p>This function works with every <a class="el" href="classvcl_1_1Vector.html" title="The Vector class is a generic container of objects of type T, that could have fixed or dynamic size,...">Vector</a> type that has a constructor with a size_t argument and an operator[uint], and requires that the mesh has per-element quality.</p>
<p>Usage example with Eigen <a class="el" href="classvcl_1_1Vector.html" title="The Vector class is a generic container of objects of type T, that could have fixed or dynamic size,...">Vector</a>:</p>
<div class="fragment"><div class="line">Eigen::VectorXd <a class="code hl_class" href="classvcl_1_1Matrix.html">EQ</a> =</div>
<div class="line">    <a class="code hl_class" href="classvcl_1_1Matrix.html">vcl::elementQualityVector&lt;ElemId::VERTEX, Eigen::VectorXd&gt;</a>(<a class="code hl_class" href="classvcl_1_1Matrix.html">myMesh</a>);</div>
</div><!-- fragment --><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classvcl_1_1MissingComponentException.html">vcl::MissingComponentException</a></td><td>if the mesh does not have per-element quality available.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function does not guarantee that the rows of the vector correspond to the element indices of the mesh. This scenario is possible when the mesh has deleted elements. To be sure to have a direct correspondence, compact the element container before calling this function.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ELEM_ID</td><td>the ID of the element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>input mesh </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>#V vector of scalars (element quality) </dd></dl>

</div>
</div>
<a id="a617cf756eac51fcf6b566ce5d4c09393" name="a617cf756eac51fcf6b566ce5d4c09393"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a617cf756eac51fcf6b566ce5d4c09393">&#9670;&#160;</a></span>enableIfPerVertexAdjacentFacesOptional()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">bool</a> vcl::enableIfPerVertexAdjacentFacesOptional </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6e15c93274d1207f45bb0673fce3ba8a" name="a6e15c93274d1207f45bb0673fce3ba8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e15c93274d1207f45bb0673fce3ba8a">&#9670;&#160;</a></span>enableIfPerVertexAdjacentVerticesOptional()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">bool</a> vcl::enableIfPerVertexAdjacentVerticesOptional </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a802d56a620a24d04972ba5d483a2730a" name="a802d56a620a24d04972ba5d483a2730a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a802d56a620a24d04972ba5d483a2730a">&#9670;&#160;</a></span>enableIfPerVertexColorOptional()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">bool</a> vcl::enableIfPerVertexColorOptional </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a64bde18cc07f8804c0c96e5def984f26" name="a64bde18cc07f8804c0c96e5def984f26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64bde18cc07f8804c0c96e5def984f26">&#9670;&#160;</a></span>enableIfPerVertexMarkOptional()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">bool</a> vcl::enableIfPerVertexMarkOptional </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af4a7a739d6f30a2e4768b7b12c663418" name="af4a7a739d6f30a2e4768b7b12c663418"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4a7a739d6f30a2e4768b7b12c663418">&#9670;&#160;</a></span>enableIfPerVertexNormalOptional()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">bool</a> vcl::enableIfPerVertexNormalOptional </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a579b161f8a4132e5106608bebc70e363" name="a579b161f8a4132e5106608bebc70e363"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a579b161f8a4132e5106608bebc70e363">&#9670;&#160;</a></span>enableIfPerVertexPrincipalCurvatureOptional()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">bool</a> vcl::enableIfPerVertexPrincipalCurvatureOptional </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa9eb68875b4658e81e104725173df6fd" name="aa9eb68875b4658e81e104725173df6fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9eb68875b4658e81e104725173df6fd">&#9670;&#160;</a></span>enableIfPerVertexQualityOptional()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">bool</a> vcl::enableIfPerVertexQualityOptional </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a369d2067cce035b7b4a710c5b364a28c" name="a369d2067cce035b7b4a710c5b364a28c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a369d2067cce035b7b4a710c5b364a28c">&#9670;&#160;</a></span>enableIfPerVertexTexCoordOptional()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">bool</a> vcl::enableIfPerVertexTexCoordOptional </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0c29a82cbd4cf6f0d20392b1d1eb885c" name="a0c29a82cbd4cf6f0d20392b1d1eb885c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c29a82cbd4cf6f0d20392b1d1eb885c">&#9670;&#160;</a></span>enableOptionalComponentsFromInfo()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">void</a> vcl::enableOptionalComponentsFromInfo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1MeshInfo.html">MeshInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables all the components that are in the file mesh info and that may be enabled in the mesh. If these components are not available in the mesh, the info file will be modified in order to tell that a particular component cannot be saved into the mesh. </p>
<p>This function is useful when you know what components are going to be load from a file, and you want that all the components that you are going to read in the file will be saved in the mesh, if possible.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">info</td><td></td></tr>
    <tr><td class="paramname">m</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a38f2bc5486a49a170ae57d8fb6b9b8df" name="a38f2bc5486a49a170ae57d8fb6b9b8df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38f2bc5486a49a170ae57d8fb6b9b8df">&#9670;&#160;</a></span>epsilonEquals() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classvcl_1_1Matrix.html">typename</a> Scalar , <a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a> N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">bool</a> vcl::epsilonEquals </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="classvcl_1_1Point.html">Point</a>&lt; Scalar, <a class="el" href="classvcl_1_1Matrix.html">N</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="classvcl_1_1Point.html">Point</a>&lt; Scalar, <a class="el" href="classvcl_1_1Matrix.html">N</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>p2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> Scalar &amp;&#160;</td>
          <td class="paramname"><em>epsilon</em> = <code>std::numeric_limits&lt;Scalar&gt;::epsilon()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares two points for equality. </p>
<p>This function is a specialization of the epsilonEquals function template for two points. It compares two points for equality by comparing each coordinate of the points for equality within a specified epsilon value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p1</td><td>The first point to compare. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p2</td><td>The second point to compare. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">epsilon</td><td>The epsilon value for equality comparison. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the points are equal within the epsilon value, false otherwise. </dd></dl>

</div>
</div>
<a id="a834f1e7b99e2c76775d28618ed24d281" name="a834f1e7b99e2c76775d28618ed24d281"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a834f1e7b99e2c76775d28618ed24d281">&#9670;&#160;</a></span>epsilonEquals() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classvcl_1_1Matrix.html">typename</a> Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">bool</a> vcl::epsilonEquals </td>
          <td>(</td>
          <td class="paramtype">Scalar&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Scalar&#160;</td>
          <td class="paramname"><em>p2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Scalar&#160;</td>
          <td class="paramname"><em>epsilon</em> = <code>std::numeric_limits&lt;Scalar&gt;::epsilon()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a12529598a32a7b21eac27744b3578600" name="a12529598a32a7b21eac27744b3578600"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12529598a32a7b21eac27744b3578600">&#9670;&#160;</a></span>faceAngleOnVertexRad()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceConcept FaceType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">auto</a> vcl::faceAngleOnVertexRad </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> FaceType &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a>&#160;</td>
          <td class="paramname"><em>vi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the internal angle (in radians) of the vi-th vertex of the face. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FaceType</td><td>the type of the face that satisfies the FaceConcept.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>the input face. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vi</td><td>the index of the vertex in the face on which calculate the angle </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the angle in radians at the vi-th vertex. </dd></dl>

</div>
</div>
<a id="a9fc3b9cae851d7a729f40dc2f4ebe824" name="a9fc3b9cae851d7a729f40dc2f4ebe824"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fc3b9cae851d7a729f40dc2f4ebe824">&#9670;&#160;</a></span>faceArea()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceConcept FaceType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">auto</a> vcl::faceArea </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> FaceType &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the area of a face. Works both for triangle and polygonal faces, and it is optimized in case of triangle faces. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FaceType</td><td>the type of the face that satisfies the FaceConcept.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>the input face. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the area of the face. </dd></dl>

</div>
</div>
<a id="a53b4f63db0979e578ebfa4b9e8b41f8a" name="a53b4f63db0979e578ebfa4b9e8b41f8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53b4f63db0979e578ebfa4b9e8b41f8a">&#9670;&#160;</a></span>faceBarycenter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceConcept FaceType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">FaceType::VertexType::CoordType vcl::faceBarycenter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> FaceType &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the barycenter of a face. Works both for triangle and polygonal faces, and it is optimized in case of triangle faces. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FaceType</td><td>the type of the face that satisfies the FaceConcept.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>the input face. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the barycenter of the face. </dd></dl>

</div>
</div>
<a id="abb99398069d243b6bb7b09e55a279792" name="abb99398069d243b6bb7b09e55a279792"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb99398069d243b6bb7b09e55a279792">&#9670;&#160;</a></span>faceBoxIntersect()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceConcept FaceType, PointConcept PointType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">bool</a> vcl::faceBoxIntersect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> FaceType &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="classvcl_1_1Box.html">Box</a>&lt; PointType &gt; &amp;&#160;</td>
          <td class="paramname"><em>box</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a480cf1413039e05d9065485c52076ce9" name="a480cf1413039e05d9065485c52076ce9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a480cf1413039e05d9065485c52076ce9">&#9670;&#160;</a></span>faceColorsMatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MatrixConcept Matrix, FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">Matrix</a> vcl::faceColorsMatrix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a #F*4 <a class="el" href="classvcl_1_1Matrix.html">Matrix</a> of integers containing the colors of the faces of a <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>. The function is templated on the <a class="el" href="classvcl_1_1Matrix.html">Matrix</a> itself. </p>
<p>This function works with every <a class="el" href="classvcl_1_1Matrix.html">Matrix</a> type that satisfies the MatrixConcept, and requires that the mesh has per-face colors.</p>
<p>Usage example with Eigen <a class="el" href="classvcl_1_1Matrix.html">Matrix</a>:</p>
<div class="fragment"><div class="line">Eigen::MatrixX4i <a class="code hl_class" href="classvcl_1_1Matrix.html">FC</a> = <a class="code hl_class" href="classvcl_1_1Matrix.html">vcl::faceColorsMatrix&lt;Eigen::MatrixX4i&gt;</a>(<a class="code hl_class" href="classvcl_1_1Matrix.html">myMesh</a>);</div>
</div><!-- fragment --><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classvcl_1_1MissingComponentException.html">vcl::MissingComponentException</a></td><td>if the mesh does not have per-face colors available.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function does not guarantee that the rows of the matrix correspond to the face indices of the mesh. This scenario is possible when the mesh has deleted faces. To be sure to have a direct correspondence, compact the face container before calling this function.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>input mesh </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>#F*4 matrix of integers (face colors) </dd></dl>

</div>
</div>
<a id="a2177afd92cfc4dbe6468aa05892b016f" name="a2177afd92cfc4dbe6468aa05892b016f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2177afd92cfc4dbe6468aa05892b016f">&#9670;&#160;</a></span>faceDihedralAngleOnEdge()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceConcept FaceType&gt; <br />
requires comp::HasAdjacentFaces&lt;FaceType&gt;</div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">auto</a> vcl::faceDihedralAngleOnEdge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> FaceType &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a>&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the signed dihedral angle between the normals of the given face and its adjacent face on the edge <code>e</code>. </p>
<p>*</p>
<p>The angle between the normal is signed according to the concavity/convexity of the dihedral angle: negative if the edge shared between the two faces is concave, positive otherwise. The surface it is assumend to be oriented. It simply use the projection of the opposite vertex onto the plane of the other one. It does not assume anything on face normals.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FaceType</td><td>the type of the face that satisfies the FaceConcept.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>The face for which to compute the dihedral angle on an edge. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">e</td><td>The index of the edge shared between the two faces. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The signed dihedral angle between the normals of the given face and its adjacent face on the edge e. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classvcl_1_1MissingComponentException.html">vcl::MissingComponentException</a></td><td>If the "AdjacentFaces" component is not available on <code>f</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a711865422c63688724ec6328b4e7c4cd" name="a711865422c63688724ec6328b4e7c4cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a711865422c63688724ec6328b4e7c4cd">&#9670;&#160;</a></span>faceEdgesOnBorderNumber()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceConcept FaceType&gt; <br />
requires comp::HasAdjacentFaces&lt;FaceType&gt;</div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a> vcl::faceEdgesOnBorderNumber </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> FaceType &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of edges that are on border (no adjacent faces) on the given face. </p>
<p>This function requires AdjacentFaces component, that must be available and computed before calling this function.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classvcl_1_1MissingComponentException.html">vcl::MissingComponentException</a></td><td>if the "AdjacentFaces" component is not available on <code>f</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FaceType</td><td>the type of the face that satisfies the FaceConcept.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>The face to check for border edges. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of edges on the border of the face. </dd></dl>

</div>
</div>
<a id="a3c0e3b298085bade007d415e0adff385" name="a3c0e3b298085bade007d415e0adff385"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c0e3b298085bade007d415e0adff385">&#9670;&#160;</a></span>faceEdgesSelectionNumber()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a> vcl::faceEdgesSelectionNumber </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a350d3edc324e0bef955a2c2ef8e20859" name="a350d3edc324e0bef955a2c2ef8e20859"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a350d3edc324e0bef955a2c2ef8e20859">&#9670;&#160;</a></span>faceNormal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceConcept FaceType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">FaceType::VertexType::CoordType vcl::faceNormal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> FaceType &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the normal of a face, without modifying the face. Works both for triangle and polygonal faces, and it is optimized in case of triangle faces. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FaceType</td><td>the type of the face that satisfies the FaceConcept.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>the input face. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the normal of the face. </dd></dl>

</div>
</div>
<a id="a6bc50612a1185ec7d1add143f93eb0ec" name="a6bc50612a1185ec7d1add143f93eb0ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bc50612a1185ec7d1add143f93eb0ec">&#9670;&#160;</a></span>faceNormalsMatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MatrixConcept Matrix, FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">Matrix</a> vcl::faceNormalsMatrix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a #F*3 <a class="el" href="classvcl_1_1Matrix.html">Matrix</a> of scalars containing the normals of the faces of a <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>. The function is templated on the <a class="el" href="classvcl_1_1Matrix.html">Matrix</a> itself. </p>
<p>This function works with every <a class="el" href="classvcl_1_1Matrix.html">Matrix</a> type that satisfies the MatrixConcept, and requires that the mesh has per-face normals.</p>
<p>Usage example with Eigen <a class="el" href="classvcl_1_1Matrix.html">Matrix</a>:</p>
<div class="fragment"><div class="line">Eigen::MatrixX3d <a class="code hl_class" href="classvcl_1_1Matrix.html">FN</a> = <a class="code hl_class" href="classvcl_1_1Matrix.html">vcl::faceNormalsMatrix&lt;Eigen::MatrixX3d&gt;</a>(<a class="code hl_class" href="classvcl_1_1Matrix.html">myMesh</a>);</div>
</div><!-- fragment --><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classvcl_1_1MissingComponentException.html">vcl::MissingComponentException</a></td><td>if the mesh does not have per-face normals available.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function does not guarantee that the rows of the matrix correspond to the face indices of the mesh. This scenario is possible when the mesh has deleted faces. To be sure to have a direct correspondence, compact the face container before calling this function.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>input mesh </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>#F*3 matrix of scalars (face normals) </dd></dl>

</div>
</div>
<a id="a1dccfede16e36e5ded5213fb13643943" name="a1dccfede16e36e5ded5213fb13643943"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dccfede16e36e5ded5213fb13643943">&#9670;&#160;</a></span>facePerimeter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceConcept FaceType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">auto</a> vcl::facePerimeter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> FaceType &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the perimeter of a face. Works both for triangle and polygonal faces, and it is optimized in case of triangle faces. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FaceType</td><td>the type of the face that satisfies the FaceConcept.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>the input face. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the perimeter of the face. </dd></dl>

</div>
</div>
<a id="a4cdee5764b3aa8dbc91ff6a114e9bfc1" name="a4cdee5764b3aa8dbc91ff6a114e9bfc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cdee5764b3aa8dbc91ff6a114e9bfc1">&#9670;&#160;</a></span>faceQualityAverage()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">auto</a> vcl::faceQualityAverage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a scalar that is the average of the face quality. </p>
<p>Requirements:</p><ul>
<li><a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>:<ul>
<li>Faces:<ul>
<li>Quality</li>
</ul>
</li>
</ul>
</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>the input <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a> on which compute the average of the quality. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The average of the face quality of the given mesh. </dd></dl>

</div>
</div>
<a id="af44349f8534585f6e0cef128edb98ca0" name="af44349f8534585f6e0cef128edb98ca0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af44349f8534585f6e0cef128edb98ca0">&#9670;&#160;</a></span>faceQualityHistogram()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType, <a class="el" href="classvcl_1_1Matrix.html">typename</a> <a class="el" href="classvcl_1_1Matrix.html">HScalar</a>  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Histogram.html">Histogram</a>&lt; <a class="el" href="classvcl_1_1Matrix.html">HScalar</a> &gt; vcl::faceQualityHistogram </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">bool</a>&#160;</td>
          <td class="paramname"><em>selectionOnly</em> = <code><a class="el" href="classvcl_1_1Matrix.html">false</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a>&#160;</td>
          <td class="paramname"><em>histSize</em> = <code>10000</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a42145b026908d9eafadd429eba4fa0be" name="a42145b026908d9eafadd429eba4fa0be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42145b026908d9eafadd429eba4fa0be">&#9670;&#160;</a></span>faceQualityMinMax()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">auto</a> vcl::faceQualityMinMax </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a pair containing the min and the maximum face quality. </p>
<p>Requirements:</p><ul>
<li><a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>:<ul>
<li>Faces:<ul>
<li>Quality</li>
</ul>
</li>
</ul>
</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>the input <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a> on which compute the minimum and the maximum quality. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code>std::pair</code> having as first element the minimum, and as second element the maximum quality. </dd></dl>

</div>
</div>
<a id="a7afddefac9fc869e5cb82367856f19e9" name="a7afddefac9fc869e5cb82367856f19e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7afddefac9fc869e5cb82367856f19e9">&#9670;&#160;</a></span>faceQualityVector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classvcl_1_1Matrix.html">typename</a> <a class="el" href="classvcl_1_1Matrix.html">Vect</a> , FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">Vect</a> vcl::faceQualityVector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a #F <a class="el" href="classvcl_1_1Vector.html" title="The Vector class is a generic container of objects of type T, that could have fixed or dynamic size,...">Vector</a> of scalars containing the quality of the faces of a <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>. The function is templated on the <a class="el" href="classvcl_1_1Vector.html" title="The Vector class is a generic container of objects of type T, that could have fixed or dynamic size,...">Vector</a> itself. </p>
<p>This function works with every <a class="el" href="classvcl_1_1Vector.html" title="The Vector class is a generic container of objects of type T, that could have fixed or dynamic size,...">Vector</a> type that has a constructor with a size_t argument and an operator(uint), and requires that the mesh has per-face quality.</p>
<p>Usage example with Eigen <a class="el" href="classvcl_1_1Vector.html" title="The Vector class is a generic container of objects of type T, that could have fixed or dynamic size,...">Vector</a>:</p>
<div class="fragment"><div class="line">Eigen::VectorXd <a class="code hl_class" href="classvcl_1_1Matrix.html">FQ</a> = <a class="code hl_class" href="classvcl_1_1Matrix.html">vcl::faceQualityVector&lt;Eigen::VectorXd&gt;</a>(<a class="code hl_class" href="classvcl_1_1Matrix.html">myMesh</a>);</div>
</div><!-- fragment --><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classvcl_1_1MissingComponentException.html">vcl::MissingComponentException</a></td><td>if the mesh does not have per-face quality available.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function does not guarantee that the rows of the vector correspond to the face indices of the mesh. This scenario is possible when the mesh has deleted faces. To be sure to have a direct correspondence, compact the face container before calling this function.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>input mesh </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>#F vector of scalars (face quality) </dd></dl>

</div>
</div>
<a id="a5585995167e0f9338ebb153314c0067b" name="a5585995167e0f9338ebb153314c0067b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5585995167e0f9338ebb153314c0067b">&#9670;&#160;</a></span>faceSelectionNumber()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a> vcl::faceSelectionNumber </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab347f62d57311e2bc794dcca4a3809ee" name="ab347f62d57311e2bc794dcca4a3809ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab347f62d57311e2bc794dcca4a3809ee">&#9670;&#160;</a></span>faceSphereIntersect() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceConcept FaceType, <a class="el" href="classvcl_1_1Matrix.html">typename</a> <a class="el" href="classvcl_1_1Matrix.html">SScalar</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">bool</a> vcl::faceSphereIntersect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> FaceType &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="classvcl_1_1Sphere.html">Sphere</a>&lt; <a class="el" href="classvcl_1_1Matrix.html">SScalar</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>sphere</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the intersection between a sphere and a face, that may be also polygonal. </p>
<p>If the face is a triangle, the triangleSphereIntersect function will be used. If the face is polygonal, the face is first triangulated using an earcut algorithm, and then for each triangle, the triangleSphereIntersect is computed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>the input face </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sphere</td><td>the input sphere </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true iff there is an intersection between the sphere and the face </dd></dl>

</div>
</div>
<a id="a9835f248a812a2d5010e4ab228f862f4" name="a9835f248a812a2d5010e4ab228f862f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9835f248a812a2d5010e4ab228f862f4">&#9670;&#160;</a></span>faceSphereIntersect() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceConcept FaceType, PointConcept PointType, <a class="el" href="classvcl_1_1Matrix.html">typename</a> <a class="el" href="classvcl_1_1Matrix.html">SScalar</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">bool</a> vcl::faceSphereIntersect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> FaceType &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="classvcl_1_1Sphere.html">Sphere</a>&lt; <a class="el" href="classvcl_1_1Matrix.html">SScalar</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>sphere</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PointType &amp;&#160;</td>
          <td class="paramname"><em>witness</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::pair&lt; <a class="el" href="classvcl_1_1Matrix.html">SScalar</a>, <a class="el" href="classvcl_1_1Matrix.html">SScalar</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>res</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the intersection between a sphere and a face, that may be also polygonal. </p>
<p>If the face is a triangle, the triangleSphereIntersect function will be used. If the face is polygonal, the face is first triangulated using an earcut algorithm, and then for each triangle, the triangleSphereIntersect is computed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>the input face </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sphere</td><td>the input sphere </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">witness</td><td>the point on the triangle nearest to the center of the sphere (even when there isn't intersection) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">res</td><td>if not null, in the first item is stored the minimum distance between the face and the sphere, while in the second item is stored the penetration depth </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true iff there is an intersection between the sphere and the face </dd></dl>

</div>
</div>
<a id="ae41a0dea61c2ea301966406de57ae461" name="ae41a0dea61c2ea301966406de57ae461"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae41a0dea61c2ea301966406de57ae461">&#9670;&#160;</a></span>fillAndShuffleFaceIndexVector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a> &gt; vcl::fillAndShuffleFaceIndexVector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">bool</a>&#160;</td>
          <td class="paramname"><em>deterministic</em> = <code><a class="el" href="classvcl_1_1Matrix.html">false</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab9b1a38c4fad92ad74bbc461e64f1c08" name="ab9b1a38c4fad92ad74bbc461e64f1c08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9b1a38c4fad92ad74bbc461e64f1c08">&#9670;&#160;</a></span>fillAndShuffleFacePointerVector() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="classvcl_1_1Matrix.html">typename</a> MeshType::FaceType * &gt; vcl::fillAndShuffleFacePointerVector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">bool</a>&#160;</td>
          <td class="paramname"><em>deterministic</em> = <code><a class="el" href="classvcl_1_1Matrix.html">false</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad656a119fe2eb1573d28a28e6576d41d" name="ad656a119fe2eb1573d28a28e6576d41d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad656a119fe2eb1573d28a28e6576d41d">&#9670;&#160;</a></span>fillAndShuffleFacePointerVector() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classvcl_1_1Matrix.html">typename</a> MeshType::FaceType * &gt; vcl::fillAndShuffleFacePointerVector </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">bool</a>&#160;</td>
          <td class="paramname"><em>deterministic</em> = <code><a class="el" href="classvcl_1_1Matrix.html">false</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac9667638a4f4f3faea6994a61ce7119e" name="ac9667638a4f4f3faea6994a61ce7119e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9667638a4f4f3faea6994a61ce7119e">&#9670;&#160;</a></span>fillAndShuffleVertexIndexVector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a> &gt; vcl::fillAndShuffleVertexIndexVector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">bool</a>&#160;</td>
          <td class="paramname"><em>deterministic</em> = <code><a class="el" href="classvcl_1_1Matrix.html">false</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa78e0576d6ad4f8e4af89367f38dabe5" name="aa78e0576d6ad4f8e4af89367f38dabe5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa78e0576d6ad4f8e4af89367f38dabe5">&#9670;&#160;</a></span>fillAndShuffleVertexPointerVector() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="classvcl_1_1Matrix.html">typename</a> MeshType::VertexType * &gt; vcl::fillAndShuffleVertexPointerVector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">bool</a>&#160;</td>
          <td class="paramname"><em>deterministic</em> = <code><a class="el" href="classvcl_1_1Matrix.html">false</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1d6bf09841cfbbaaa328de2d552fc090" name="a1d6bf09841cfbbaaa328de2d552fc090"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d6bf09841cfbbaaa328de2d552fc090">&#9670;&#160;</a></span>fillAndShuffleVertexPointerVector() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classvcl_1_1Matrix.html">typename</a> MeshType::VertexType * &gt; vcl::fillAndShuffleVertexPointerVector </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">bool</a>&#160;</td>
          <td class="paramname"><em>deterministic</em> = <code><a class="el" href="classvcl_1_1Matrix.html">false</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a66a5b3121ca08d3686ae7637a9e30cf7" name="a66a5b3121ca08d3686ae7637a9e30cf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66a5b3121ca08d3686ae7637a9e30cf7">&#9670;&#160;</a></span>fillAndSortMeshEdgeUtilVector() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classvcl_1_1ConstMeshEdgeUtil.html">ConstMeshEdgeUtil</a>&lt; MeshType &gt; &gt; vcl::fillAndSortMeshEdgeUtilVector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">bool</a>&#160;</td>
          <td class="paramname"><em>includeFauxEdges</em> = <code><a class="el" href="classvcl_1_1Matrix.html">true</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8ff4adce6cdd2cc82aec090338c4ccfe" name="a8ff4adce6cdd2cc82aec090338c4ccfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ff4adce6cdd2cc82aec090338c4ccfe">&#9670;&#160;</a></span>fillAndSortMeshEdgeUtilVector() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classvcl_1_1MeshEdgeUtil.html">MeshEdgeUtil</a>&lt; MeshType &gt; &gt; vcl::fillAndSortMeshEdgeUtilVector </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">bool</a>&#160;</td>
          <td class="paramname"><em>includeFauxEdges</em> = <code><a class="el" href="classvcl_1_1Matrix.html">true</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a45834fe7b55127feba8ce3050653ca96" name="a45834fe7b55127feba8ce3050653ca96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45834fe7b55127feba8ce3050653ca96">&#9670;&#160;</a></span>findCaseInsensitive()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string::const_iterator vcl::findCaseInsensitive </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> std::string &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> std::string &amp;&#160;</td>
          <td class="paramname"><em>substr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Looks into <code>input</code> if there is a substring equal to <code>substr</code>, without taking into account case sensitiveness. Returns an iterator pointing to the beginning position in <code>input</code> of the substring, return an iterator <code>end()</code> if the substring was not found. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>input string. </td></tr>
    <tr><td class="paramname">substr</td><td>substring to look into <code>input</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an iterator pointing to the substring, or an iterator pointing to <code>end()</code>. </dd></dl>

</div>
</div>
<a id="abbf2dd04b5f4477ba07ab217dd603d14" name="abbf2dd04b5f4477ba07ab217dd603d14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbf2dd04b5f4477ba07ab217dd603d14">&#9670;&#160;</a></span>fitPlaneToPointCloud()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classvcl_1_1Matrix.html">typename</a> Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Plane.html">Plane</a>&lt; Scalar &gt; vcl::fitPlaneToPointCloud </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> std::vector&lt; <a class="el" href="group__space__core.html#ga13f2718b0763def563b8bd9f65982833">Point3</a>&lt; Scalar &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>pointVec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the plane best fitting a set of points The algorithm used is the classical Covariance matrix eigenvector approach. </p>

</div>
</div>
<a id="a066ed60f6a8fcdc525e7038fd8d2a6f2" name="a066ed60f6a8fcdc525e7038fd8d2a6f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a066ed60f6a8fcdc525e7038fd8d2a6f2">&#9670;&#160;</a></span>fitPlaneToWeightedPointCloud()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Point3Concept PointType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Plane.html">Plane</a>&lt; <a class="el" href="classvcl_1_1Matrix.html">typename</a> PointType::ScalarType &gt; vcl::fitPlaneToWeightedPointCloud </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> std::vector&lt; PointType &gt; &amp;&#160;</td>
          <td class="paramname"><em>pointVec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> std::vector&lt; <a class="el" href="classvcl_1_1Matrix.html">typename</a> PointType::ScalarType &gt; &amp;&#160;</td>
          <td class="paramname"><em>weights</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the plane best fitting a wighted set of points The algorithm used is the wighted Covariance matrix eigenvector approach. </p>

</div>
</div>
<a id="ac557c4a143d0e7c137c1e92099d9f105" name="ac557c4a143d0e7c137c1e92099d9f105"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac557c4a143d0e7c137c1e92099d9f105">&#9670;&#160;</a></span>formatCapability()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1MeshInfo.html">MeshInfo</a> vcl::formatCapability </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> std::string &amp;&#160;</td>
          <td class="paramname"><em>format</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aeb189433c1c9d7bf52a96ff359f364ec" name="aeb189433c1c9d7bf52a96ff359f364ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb189433c1c9d7bf52a96ff359f364ec">&#9670;&#160;</a></span>hashCombine()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classvcl_1_1Matrix.html">typename</a> T , typename... Rest&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">void</a> vcl::hashCombine </td>
          <td>(</td>
          <td class="paramtype">std::size_t &amp;&#160;</td>
          <td class="paramname"><em>seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> T &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="classvcl_1_1Matrix.html">Rest</a> &amp;...&#160;</td>
          <td class="paramname"><em>rest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starting from a seed, computes the hash of a series of objects. </p>
<p><a href="https://stackoverflow.com/a/57595105/5851101">https://stackoverflow.com/a/57595105/5851101</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">seed</td><td>input seed and output hash </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>first argument object </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rest</td><td>rest of the argument objects </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9082710ebf39cdd11a256086220d007a" name="a9082710ebf39cdd11a256086220d007a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9082710ebf39cdd11a256086220d007a">&#9670;&#160;</a></span>hausdorffDistance()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType1, MeshConcept MeshType2, LoggerConcept LogType = NullLogger&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvcl_1_1HausdorffDistResult.html">HausdorffDistResult</a> vcl::hausdorffDistance </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="classvcl_1_1Matrix.html">MeshType1</a> &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="classvcl_1_1Matrix.html">MeshType2</a> &amp;&#160;</td>
          <td class="paramname"><em>m2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">LogType</a> &amp;&#160;</td>
          <td class="paramname"><em>log</em> = <code><a class="el" href="group__miscellaneous.html#ga3377e3c875ec245e90ac5a395105ce99">nullLogger</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacevcl.html#a5a4e8376b2d47797f9167f2a8dd6fb0e">HausdorffSamplingMethod</a>&#160;</td>
          <td class="paramname"><em>sampMethod</em> = <code><a class="el" href="namespacevcl.html#a5a4e8376b2d47797f9167f2a8dd6fb0ea33aad0431cadce18cad82201cb732f49">HAUSDORFF_VERTEX_UNIFORM</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a>&#160;</td>
          <td class="paramname"><em>nSamples</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">bool</a>&#160;</td>
          <td class="paramname"><em>deterministic</em> = <code><a class="el" href="classvcl_1_1Matrix.html">false</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9bdac4366b8757c10172f6e1ad61976d" name="a9bdac4366b8757c10172f6e1ad61976d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bdac4366b8757c10172f6e1ad61976d">&#9670;&#160;</a></span>importEdgeColorsFromMatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;EdgeMeshConcept MeshType, MatrixConcept ECMatrix&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">void</a> vcl::importEdgeColorsFromMatrix </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="classvcl_1_1Matrix.html">ECMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>edgeColors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abd8cc56f370e2fca77dc3da2a248d1f5" name="abd8cc56f370e2fca77dc3da2a248d1f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd8cc56f370e2fca77dc3da2a248d1f5">&#9670;&#160;</a></span>importEdgesFromMatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;EdgeMeshConcept MeshType, MatrixConcept EMatrix&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">void</a> vcl::importEdgesFromMatrix </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="classvcl_1_1Matrix.html">EMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>edges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">bool</a>&#160;</td>
          <td class="paramname"><em>clearBeforeSet</em> = <code><a class="el" href="classvcl_1_1Matrix.html">true</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a909af3aba8fff954b61d9c98f7470eab" name="a909af3aba8fff954b61d9c98f7470eab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a909af3aba8fff954b61d9c98f7470eab">&#9670;&#160;</a></span>importFaceColorsFromMatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType, MatrixConcept FCMatrix&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">void</a> vcl::importFaceColorsFromMatrix </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="classvcl_1_1Matrix.html">FCMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>faceColors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab91626832747d82bfe051ffc6a9d8619" name="ab91626832747d82bfe051ffc6a9d8619"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab91626832747d82bfe051ffc6a9d8619">&#9670;&#160;</a></span>importFaceNormalsFromMatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType, MatrixConcept FNMatrix&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">void</a> vcl::importFaceNormalsFromMatrix </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="classvcl_1_1Matrix.html">FNMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>faceNormals</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a41c8a076bfadd5ab22ebd08eab05237d" name="a41c8a076bfadd5ab22ebd08eab05237d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41c8a076bfadd5ab22ebd08eab05237d">&#9670;&#160;</a></span>importFacesFromMatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType, MatrixConcept FMatrix&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">void</a> vcl::importFacesFromMatrix </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="classvcl_1_1Matrix.html">FMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>faces</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">bool</a>&#160;</td>
          <td class="paramname"><em>clearBeforeSet</em> = <code><a class="el" href="classvcl_1_1Matrix.html">true</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af39dbdcb3c98584459fdb4b3e87e3332" name="af39dbdcb3c98584459fdb4b3e87e3332"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af39dbdcb3c98584459fdb4b3e87e3332">&#9670;&#160;</a></span>importMeshFromMatrices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType, MatrixConcept VMatrix, MatrixConcept FMatrix = Eigen::MatrixX3i, MatrixConcept EMatrix = Eigen::MatrixX2i, MatrixConcept VNMatrix = Eigen::MatrixX3d, MatrixConcept FNMatrix = Eigen::MatrixX3d&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">void</a> vcl::importMeshFromMatrices </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="classvcl_1_1Matrix.html">VMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="classvcl_1_1Matrix.html">FMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>faces</em> = <code><a class="el" href="classvcl_1_1Matrix.html">FMatrix</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="classvcl_1_1Matrix.html">EMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>edges</em> = <code><a class="el" href="classvcl_1_1Matrix.html">EMatrix</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="classvcl_1_1Matrix.html">VNMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>vertexNormals</em> = <code><a class="el" href="classvcl_1_1Matrix.html">VNMatrix</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="classvcl_1_1Matrix.html">FNMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>faceNormals</em> = <code><a class="el" href="classvcl_1_1Matrix.html">FNMatrix</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the given input <code>mesh</code> from the input vertex matrix, and the other matrices that are given as arguments. </p>
<p>The function accepts several input matrices/vectors, that are used only if their number of rows is different from zero. It tries to fill all the data contained in the non-empty input matrices into the <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>:</p><ul>
<li>if a <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a> is not able to store same data, the relative input matrix is ignored. For example, if the <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a> has no faces, the function will ignore the input face matrix, also if that is not empty.</li>
<li>if a <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a> is able to store some data and the relative input matrix is not empty, the data will be stored in the <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>. If the matrix has not the expected size, an exception is thrown.</li>
</ul>
<p>The mesh is cleared and all the optional components are disabled before adding the data from the input matrices.</p>
<dl class="section note"><dt>Note</dt><dd>If the <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a> is not able to store some data from the matrices, that data will be ignored. For example, if the <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a> has no faces, the function will ignore the input face matrix, also if that is not empty.</dd>
<dd>
Only the optional components having their corresponding input matrix not empty will be enabled and filled. All the other optional components will be left disabled.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classvcl_1_1WrongSizeException.html">vcl::WrongSizeException</a></td><td>if the sizes of the non-empty input matrices have not the expected sizes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MeshType</td><td>the type of the mesh to be created. It must satisfy the MeshConcept. </td></tr>
    <tr><td class="paramname">VMatrix</td><td>the type of the input vertex matrix. It must satisfy the MatrixConcept. </td></tr>
    <tr><td class="paramname">FMatrix</td><td>the type of the input face matrix. It must satisfy the MatrixConcept. </td></tr>
    <tr><td class="paramname">EMatrix</td><td>the type of the input edge matrix. It must satisfy the MatrixConcept. </td></tr>
    <tr><td class="paramname">VNMatrix</td><td>the type of the input vertex normal matrix. It must satisfy the MatrixConcept. </td></tr>
    <tr><td class="paramname">FNMatrix</td><td>the type of the input face normal matrix. It must satisfy the MatrixConcept.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>the mesh on which import all the input data from the matrices. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vertices</td><td>a #V*3 matrix containing the coordinates of the vertices of the mesh. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">faces</td><td>a #F*3 matrix containing the indices of the vertices of the faces of the mesh. If the number of rows of this matrix is zero, the function will not add faces to the mesh. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">edges</td><td>a #E*2 matrix containing the indices of the vertices of the edges of the mesh. If the number of rows of this matrix is zero, the function will not add edges to the mesh. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vertexNormals</td><td>a #V*3 matrix containing the normals of the vertices of the mesh. If the number of rows of this matrix is zero, the function will not add vertex normals to the mesh. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">faceNormals</td><td>a #F*3 matrix containing the normals of the faces of the mesh. If the number of rows of this matrix is zero, the function will not add face normals to the mesh. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac0b73844d3c33491eb38e6e34017eb98" name="ac0b73844d3c33491eb38e6e34017eb98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0b73844d3c33491eb38e6e34017eb98">&#9670;&#160;</a></span>importVertexColorsFromMatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType, MatrixConcept VCMatrix&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">void</a> vcl::importVertexColorsFromMatrix </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="classvcl_1_1Matrix.html">VCMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>vertexColors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a255e7edcea02d432b2aa8a1c46dae3e5" name="a255e7edcea02d432b2aa8a1c46dae3e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a255e7edcea02d432b2aa8a1c46dae3e5">&#9670;&#160;</a></span>importVertexNormalsFromMatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType, MatrixConcept VNMatrix&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">void</a> vcl::importVertexNormalsFromMatrix </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="classvcl_1_1Matrix.html">VNMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>vertexNormals</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a02ca8fdd4a9b050d0f0ac4d5e1c13bde" name="a02ca8fdd4a9b050d0f0ac4d5e1c13bde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02ca8fdd4a9b050d0f0ac4d5e1c13bde">&#9670;&#160;</a></span>importVerticesFromMatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType, MatrixConcept VMatrix&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">void</a> vcl::importVerticesFromMatrix </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="classvcl_1_1Matrix.html">VMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">bool</a>&#160;</td>
          <td class="paramname"><em>clearBeforeSet</em> = <code><a class="el" href="classvcl_1_1Matrix.html">true</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the vertices of the given input <code>mesh</code> from the input vertex matrix. </p>
<p>If the argument <code>clearBeforeSet</code> is set to <code>true</code> (default), the function container of the mesh and then adds a number of vertices that depends on the number of rows of the input vertex matrix. In this scenario, all the other components of the vertices stored in the mesh before calling this function are lost.</p>
<p>If the argument <code>clearBeforeSet</code> is set to <code>false</code>, the function checks that the number of rows of the input vertex matrix is equal to the number of vertices of the mesh. If this is not the case, an exception is thrown. Then, the function sets the coordinates of the vertices of the mesh from the input vertex matrix. In this scenario, all the other components of the vertices stored in the mesh before calling this function are preserved.</p>
<p>All the other containers of the mesh and the optional components of vertices are left as they are. Pointers to vertices stored in the mesh are still valid (if the number of vertices and their index in the container is not changed).</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classvcl_1_1WrongSizeException.html">vcl::WrongSizeException</a></td><td>if the sizes of the input matrix are not valid (e.g. columns != 3 or rows != mesh.vertexNumber()).</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MeshType</td><td>the type of the mesh to be filled. It must satisfy the MeshConcept. </td></tr>
    <tr><td class="paramname">VMatrix</td><td>the type of the input vertex matrix. It must satisfy the MatrixConcept.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>the mesh on which import the input vertices. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vertices</td><td>a #V*3 matrix containing the coordinates of the vertices of the mesh. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">clearBeforeSet</td><td>if <code>true</code>, the function clears the container of the vertices of the mesh before adding the vertices from the input matrix. If <code>false</code>, the function sets the coordinates in the input matrix to the vertices of the mesh, leaving all the other components untouched. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad6ce6ce1ca6a9813f3437aa0aeee2d94" name="ad6ce6ce1ca6a9813f3437aa0aeee2d94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6ce6ce1ca6a9813f3437aa0aeee2d94">&#9670;&#160;</a></span>indexInTypePack()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a> vcl::indexInTypePack </td>
          <td>(</td>
          <td class="paramtype">std::type_index&#160;</td>
          <td class="paramname"><em>ti</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvcl_1_1TypeWrapper.html">TypeWrapper</a>&lt; Args... &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a70dad48ffd4a840c11d422b0c3121393" name="a70dad48ffd4a840c11d422b0c3121393"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70dad48ffd4a840c11d422b0c3121393">&#9670;&#160;</a></span>intersectFunction()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classvcl_1_1Matrix.html">typename</a> <a class="el" href="classvcl_1_1Matrix.html">Obj1</a> , <a class="el" href="classvcl_1_1Matrix.html">typename</a> <a class="el" href="classvcl_1_1Matrix.html">Obj2</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">auto</a> vcl::intersectFunction </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a proper intersect function between a Obj1 object and an Obj2 object. </p>
<p>This function will return a function defined in a specialization of the struct <a class="el" href="structvcl_1_1IntersFunctionStruct.html">IntersFunctionStruct</a>.</p>
<p>The returned function is a std::function that takes in input two const references of the desired types and returns a boolean that tells if the two objects intersect.</p>
<p>If the intersection function for your types is not defined, you can write your own <a class="el" href="structvcl_1_1IntersFunctionStruct.html">IntersFunctionStruct</a> specialization that defines a proper <code>static const inline</code> object called <code>intersFun</code> of <code>std::function</code> type.</p>
<dl class="section note"><dt>Note</dt><dd>The intersectFunction works only for non-pointer types. This means that you cannot ask for the intersect function between a <a class="el" href="namespacevcl.html#a6539e58b4183d50e78e631047cd7ad12">vcl::Box3</a> and a <a class="el" href="classvcl_1_1Face.html" title="The Face class represents an Face element of the vcl::Mesh class.">vcl::Face</a>*. If you are working with template types that you don't know if they are pointers or not, you can do the following: <div class="fragment"><div class="line"><span class="comment">// don&#39;t know if T1 and T2 are pointers or non-pointers</span></div>
<div class="line"><span class="keyword">auto</span> f = <a class="code hl_class" href="classvcl_1_1Matrix.html">intersectFunction&lt;RemoveCVRefAndPointer&lt;T1&gt;</a>,</div>
<div class="line"><a class="code hl_class" href="classvcl_1_1Matrix.html">RemoveCVRefAndPointer&lt;T2&gt;</a>&gt;();</div>
<div class="line"><span class="comment">// obj1 is of type T1, obj2 is of type T2 (may be pointers or non-pointers)</span></div>
<div class="line"><span class="keywordtype">bool</span> <a class="code hl_class" href="classvcl_1_1Matrix.html">theyIntersect</a> = f(<a class="code hl_function" href="group__types.html#gaada6c7f7d741d8f7885af287bcc6f746">dereferencePtr</a>(<a class="code hl_class" href="classvcl_1_1Matrix.html">obj1</a>), <a class="code hl_function" href="group__types.html#gaada6c7f7d741d8f7885af287bcc6f746">dereferencePtr</a>(<a class="code hl_class" href="classvcl_1_1Matrix.html">obj2</a>));</div>
<div class="ttc" id="agroup__types_html_gaada6c7f7d741d8f7885af287bcc6f746"><div class="ttname"><a href="group__types.html#gaada6c7f7d741d8f7885af287bcc6f746">vcl::dereferencePtr</a></div><div class="ttdeci">auto dereferencePtr(T &amp;&amp;obj)</div><div class="ttdoc">Utility function that applies the unary operator '*' to the argument only if the object is a pointer.</div><div class="ttdef"><b>Definition</b> pointers.h:69</div></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a33948b0cb8e44bec17d4b0dfef8bd254" name="a33948b0cb8e44bec17d4b0dfef8bd254"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33948b0cb8e44bec17d4b0dfef8bd254">&#9670;&#160;</a></span>isDegenerate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classvcl_1_1Matrix.html">typename</a> Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">bool</a> vcl::isDegenerate </td>
          <td>(</td>
          <td class="paramtype">Scalar&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af888cb13421f6fb92d776927f302518b" name="af888cb13421f6fb92d776927f302518b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af888cb13421f6fb92d776927f302518b">&#9670;&#160;</a></span>isFaceEdgeOnBorder()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceConcept FaceType&gt; <br />
requires comp::HasAdjacentFaces&lt;FaceType&gt;</div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">bool</a> vcl::isFaceEdgeOnBorder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> FaceType &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a>&#160;</td>
          <td class="paramname"><em>edge</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if an edge in the given face is on the border. </p>
<p>An edge is considered to be on the border if it is not shared by another face.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classvcl_1_1MissingComponentException.html">vcl::MissingComponentException</a></td><td>If the "AdjacentFaces" component is not available on <code>f</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FaceType</td><td>the type of the face that satisfies the FaceConcept.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>The face to check. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">edge</td><td>The index of the edge to check.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the edge is on the border, false otherwise. </dd></dl>

</div>
</div>
<a id="a25a86f4bcf104c60099849828d71e06f" name="a25a86f4bcf104c60099849828d71e06f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25a86f4bcf104c60099849828d71e06f">&#9670;&#160;</a></span>isFaceManifoldOnEdge()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceConcept FaceType&gt; <br />
requires comp::HasAdjacentFaces&lt;FaceType&gt;</div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">bool</a> vcl::isFaceManifoldOnEdge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> FaceType &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a>&#160;</td>
          <td class="paramname"><em>edge</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if an edge in the given face is manifold. </p>
<p>An edge is considered manifold if it is either a boundary edge or if it is shared by exactly two faces.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classvcl_1_1MissingComponentException.html">vcl::MissingComponentException</a></td><td>If the "AdjacentFaces" component is not available on <code>f</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FaceType</td><td>the type of the face that satisfies the FaceConcept.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>The face to check. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">edge</td><td>The index of the edge to check.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the edge is manifold, false otherwise. </dd></dl>

</div>
</div>
<a id="a3e568fca42924a53fde391597ff4e560" name="a3e568fca42924a53fde391597ff4e560"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e568fca42924a53fde391597ff4e560">&#9670;&#160;</a></span>isPerVertexAdjacentFacesAvailable()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">bool</a> vcl::isPerVertexAdjacentFacesAvailable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a84a2badab79a21f537f854257457ae8e" name="a84a2badab79a21f537f854257457ae8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84a2badab79a21f537f854257457ae8e">&#9670;&#160;</a></span>isPerVertexAdjacentVerticesAvailable()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">bool</a> vcl::isPerVertexAdjacentVerticesAvailable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac805cc3d735ee5883647218cdd1ee7e0" name="ac805cc3d735ee5883647218cdd1ee7e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac805cc3d735ee5883647218cdd1ee7e0">&#9670;&#160;</a></span>isPerVertexColorAvailable()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">bool</a> vcl::isPerVertexColorAvailable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7dc8c6d96d74cceffb34a1a480864563" name="a7dc8c6d96d74cceffb34a1a480864563"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dc8c6d96d74cceffb34a1a480864563">&#9670;&#160;</a></span>isPerVertexMarkAvailable()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">bool</a> vcl::isPerVertexMarkAvailable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af37173d6ec6aa5b11580217057aa6e24" name="af37173d6ec6aa5b11580217057aa6e24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af37173d6ec6aa5b11580217057aa6e24">&#9670;&#160;</a></span>isPerVertexNormalAvailable()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">bool</a> vcl::isPerVertexNormalAvailable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aeba9629e5f1c2363b2b35bc865f9d11e" name="aeba9629e5f1c2363b2b35bc865f9d11e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeba9629e5f1c2363b2b35bc865f9d11e">&#9670;&#160;</a></span>isPerVertexPrincipalCurvatureAvailable()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">bool</a> vcl::isPerVertexPrincipalCurvatureAvailable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a09449154647e40fd0a3c1e965a91bf49" name="a09449154647e40fd0a3c1e965a91bf49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09449154647e40fd0a3c1e965a91bf49">&#9670;&#160;</a></span>isPerVertexQualityAvailable()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">bool</a> vcl::isPerVertexQualityAvailable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a91da20c5938a63be8d206b547892a205" name="a91da20c5938a63be8d206b547892a205"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91da20c5938a63be8d206b547892a205">&#9670;&#160;</a></span>isPerVertexTexCoordAvailable()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">bool</a> vcl::isPerVertexTexCoordAvailable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab7606be147f292f38e1e22a709708a19" name="ab7606be147f292f38e1e22a709708a19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7606be147f292f38e1e22a709708a19">&#9670;&#160;</a></span>KDTree() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1KDTree.html">vcl::KDTree</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td> -&gt;  <a class="el" href="classvcl_1_1KDTree.html">KDTree</a>&lt; <a class="el" href="classvcl_1_1Matrix.html">typename</a> MeshType::VertexType::CoordType &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab1ec171b583b3872ae8b1b5e6a513b49" name="ab1ec171b583b3872ae8b1b5e6a513b49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1ec171b583b3872ae8b1b5e6a513b49">&#9670;&#160;</a></span>KDTree() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1KDTree.html">vcl::KDTree</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a>&#160;</td>
          <td class="paramname"><em>pointsPerCell</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  <a class="el" href="classvcl_1_1KDTree.html">KDTree</a>&lt; <a class="el" href="classvcl_1_1Matrix.html">typename</a> MeshType::VertexType::CoordType &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae5c4a6423ece2f30e5d81a3f5b0026b9" name="ae5c4a6423ece2f30e5d81a3f5b0026b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5c4a6423ece2f30e5d81a3f5b0026b9">&#9670;&#160;</a></span>KDTree() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1KDTree.html">vcl::KDTree</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a>&#160;</td>
          <td class="paramname"><em>pointsPerCell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a>&#160;</td>
          <td class="paramname"><em>maxDepth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  <a class="el" href="classvcl_1_1KDTree.html">KDTree</a>&lt; <a class="el" href="classvcl_1_1Matrix.html">typename</a> MeshType::VertexType::CoordType &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae9e8e92d81c40489de3567c10b3db44c" name="ae9e8e92d81c40489de3567c10b3db44c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9e8e92d81c40489de3567c10b3db44c">&#9670;&#160;</a></span>KDTree() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1KDTree.html">vcl::KDTree</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a>&#160;</td>
          <td class="paramname"><em>pointsPerCell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a>&#160;</td>
          <td class="paramname"><em>maxDepth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">bool</a>&#160;</td>
          <td class="paramname"><em>balanced</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  <a class="el" href="classvcl_1_1KDTree.html">KDTree</a>&lt; <a class="el" href="classvcl_1_1Matrix.html">typename</a> MeshType::VertexType::CoordType &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6effb8d19dc6c62592f8f2cfff8a6854" name="a6effb8d19dc6c62592f8f2cfff8a6854"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6effb8d19dc6c62592f8f2cfff8a6854">&#9670;&#160;</a></span>laplacianSmoothing()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">void</a> vcl::laplacianSmoothing </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a>&#160;</td>
          <td class="paramname"><em>step</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">bool</a>&#160;</td>
          <td class="paramname"><em>smoothSelected</em> = <code><a class="el" href="classvcl_1_1Matrix.html">false</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">bool</a>&#160;</td>
          <td class="paramname"><em>cotangentWeight</em> = <code><a class="el" href="classvcl_1_1Matrix.html">false</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>vertexCoordLaplacianSmoothing the classical Laplacian smoothing. Each vertex is moved onto the average of the adjacent vertices. </p>
<p>Requirements:</p><ul>
<li><a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>:<ul>
<li>Vertices</li>
<li>Faces</li>
</ul>
</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>the mesh that will be smoothed </td></tr>
    <tr><td class="paramname">step</td><td></td></tr>
    <tr><td class="paramname">smoothSelected</td><td></td></tr>
    <tr><td class="paramname">cotangentWeight</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa6613e39304926dee856b8b9770b3be5" name="aa6613e39304926dee856b8b9770b3be5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6613e39304926dee856b8b9770b3be5">&#9670;&#160;</a></span>lnOfFactorial()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">double</a> vcl::lnOfFactorial </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">int</a>&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes and caches the result of the natural logarithm of n! </p>
<p>If n &gt; 1024, uses the Stirling approximation. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a8c3f56025fbf5454a944171424439fca" name="a8c3f56025fbf5454a944171424439fca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c3f56025fbf5454a944171424439fca">&#9670;&#160;</a></span>loadImageData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classvcl_1_1Matrix.html">unsigned</a> <a class="el" href="classvcl_1_1Matrix.html">char</a> &gt; vcl::loadImageData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">int</a> &amp;&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">int</a> &amp;&#160;</td>
          <td class="paramname"><em>h</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a212fbf643d263ad106507f7aa462cf46" name="a212fbf643d263ad106507f7aa462cf46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a212fbf643d263ad106507f7aa462cf46">&#9670;&#160;</a></span>max() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classvcl_1_1Matrix.html">typename</a> <a class="el" href="classvcl_1_1Matrix.html">Head</a> , typename... Tail&gt; <br />
requires (sizeof...(<a class="el" href="classvcl_1_1Matrix.html">tail</a>) &gt; 0)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">constexpr</a> <a class="el" href="classvcl_1_1Matrix.html">auto</a> vcl::max </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="classvcl_1_1Matrix.html">Head</a> &amp;&#160;</td>
          <td class="paramname"><em>head0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="classvcl_1_1Matrix.html">Head</a> &amp;&#160;</td>
          <td class="paramname"><em>head1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="classvcl_1_1Matrix.html">Tail</a> &amp;...&#160;</td>
          <td class="paramname"><em>tail</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a49a9bdba85989ec5842081c5c84d4fc7" name="a49a9bdba85989ec5842081c5c84d4fc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49a9bdba85989ec5842081c5c84d4fc7">&#9670;&#160;</a></span>max() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;PointConcept PointType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">constexpr</a> <a class="el" href="classvcl_1_1Matrix.html">auto</a> vcl::max </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> PointType &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> PointType &amp;&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a69cc63a5ad2974d082145ed1dee7846b" name="a69cc63a5ad2974d082145ed1dee7846b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69cc63a5ad2974d082145ed1dee7846b">&#9670;&#160;</a></span>max() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classvcl_1_1Matrix.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">constexpr</a> <a class="el" href="classvcl_1_1Matrix.html">auto</a> vcl::max </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> T &amp;&#160;</td>
          <td class="paramname"><em>el1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> T &amp;&#160;</td>
          <td class="paramname"><em>el2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae60ae8879b69a995723ada3f73422606" name="ae60ae8879b69a995723ada3f73422606"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae60ae8879b69a995723ada3f73422606">&#9670;&#160;</a></span>meshFromMatrices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType, MatrixConcept VMatrix, MatrixConcept FMatrix = Eigen::MatrixX3i, MatrixConcept VNMatrix = Eigen::MatrixX3d, MatrixConcept FNMatrix = Eigen::MatrixX3d&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">MeshType vcl::meshFromMatrices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="classvcl_1_1Matrix.html">VMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="classvcl_1_1Matrix.html">FMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>faces</em> = <code><a class="el" href="classvcl_1_1Matrix.html">FMatrix</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="classvcl_1_1Matrix.html">VNMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>vertexNormals</em> = <code><a class="el" href="classvcl_1_1Matrix.html">VNMatrix</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="classvcl_1_1Matrix.html">FNMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>faceNormals</em> = <code><a class="el" href="classvcl_1_1Matrix.html">FNMatrix</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates and returns a new mesh from the input vertex and face (if any) matrices, and the other matrices that are given as arguments. </p>
<p>The function accepts several input matrices/vectors, that are used only if their number of rows is different from zero. It tries to fill all the data contained in the non-empty input matrices into the <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>:</p><ul>
<li>if a <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a> is not able to store same data, the relative input matrix is ignored. For example, if the <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a> has no faces, the function will ignore the input face matrix, also if that is not empty.</li>
<li>if a <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a> is able to store some data and the relative input matrix is not empty, the data will be stored in the <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>. If the matrix has not the expected size, an exception is thrown.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>All the disabled optional components will be enabled if their corresponding input matrix is not empty.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classvcl_1_1WrongSizeException.html">vcl::WrongSizeException</a></td><td>if the sizes of the non-empty input matrices have not the expected sizes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MeshType</td><td>the type of the mesh to be created. It must satisfy the MeshConcept. </td></tr>
    <tr><td class="paramname">VMatrix</td><td>the type of the input vertex matrix. It must satisfy the MatrixConcept. </td></tr>
    <tr><td class="paramname">FMatrix</td><td>the type of the input face matrix. It must satisfy the MatrixConcept. </td></tr>
    <tr><td class="paramname">VNMatrix</td><td>the type of the input vertex normal matrix. It must satisfy the MatrixConcept. </td></tr>
    <tr><td class="paramname">FNMatrix</td><td>the type of the input face normal matrix. It must satisfy the MatrixConcept.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vertices</td><td>a #V*3 matrix containing the coordinates of the vertices of the mesh. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">faces</td><td>a #F*3 matrix containing the indices of the vertices of the faces of the mesh. If the number of rows of this matrix is zero, the function will not add faces to the mesh. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vertexNormals</td><td>a #V*3 matrix containing the normals of the vertices of the mesh. If the number of rows of this matrix is zero, the function will not add vertex normals to the mesh. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">faceNormals</td><td>a #F*3 matrix containing the normals of the faces of the mesh. If the number of rows of this matrix is zero, the function will not add face normals to the mesh.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new mesh containing the data passed as argument. </dd></dl>

</div>
</div>
<a id="adac28fe9c51f808b6120eb2d9387484b" name="adac28fe9c51f808b6120eb2d9387484b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adac28fe9c51f808b6120eb2d9387484b">&#9670;&#160;</a></span>meshPlaneIntersection()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;EdgeMeshConcept EdgeMesh, FaceMeshConcept MeshType, PlaneConcept PlaneType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">EdgeMesh</a> vcl::meshPlaneIntersection </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="classvcl_1_1Matrix.html">PlaneType</a> &amp;&#160;</td>
          <td class="paramname"><em>pl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Takes a mesh and a plane as inputs and computes the intersection between the mesh and the plane. It creates a new EdgeMesh to represent the intersection edges. </p>
<p>First, for each vertex in the original mesh, it computes its distance to the plane and stores it in a vector. Then, for each face in the original mesh, it checks each of its edges to see if they intersect the plane. If an edge intersects the plane, the intersection point is computed and added to a vector of intersection points. If the edge lies exactly on the plane, its vertices are added to the intersection points.</p>
<p>Once all intersection points have been computed, the function creates a new edge mesh and adds an edge between each pair of consecutive intersection points that forms a line segment on the plane. If the original mesh has per-vertex normals, the function also computes and stores the normal at each intersection point.</p>
<p>Requirements:</p><ul>
<li>EdgeMesh:<ul>
<li>Vertices<ul>
<li>Normals (optional)</li>
</ul>
</li>
<li>Edges</li>
</ul>
</li>
<li>MeshType:<ul>
<li>Vertices<ul>
<li>Normals (optional)</li>
</ul>
</li>
<li>Faces</li>
</ul>
</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td></td></tr>
    <tr><td class="paramname">pl</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the intersection between the original mesh and the plane as a collection of line segments with optional normal vectors. </dd></dl>

</div>
</div>
<a id="a5da120ef4b6039bf54902d14cb8b7519" name="a5da120ef4b6039bf54902d14cb8b7519"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5da120ef4b6039bf54902d14cb8b7519">&#9670;&#160;</a></span>meshSphereIntersection() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType, <a class="el" href="classvcl_1_1Matrix.html">typename</a> <a class="el" href="classvcl_1_1Matrix.html">SScalar</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">MeshType vcl::meshSphereIntersection </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="classvcl_1_1Sphere.html">vcl::Sphere</a>&lt; <a class="el" href="classvcl_1_1Matrix.html">SScalar</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>sphere</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as meshSphereIntersection(MeshType, Sphere, double);. </p>
<p>The tolerance is set as 1/10^5*2*pi*radius. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td></td></tr>
    <tr><td class="paramname">sphere</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a1e4c155f781f7c3e6fca2b922398fb82" name="a1e4c155f781f7c3e6fca2b922398fb82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e4c155f781f7c3e6fca2b922398fb82">&#9670;&#160;</a></span>meshSphereIntersection() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType, <a class="el" href="classvcl_1_1Matrix.html">typename</a> <a class="el" href="classvcl_1_1Matrix.html">SScalar</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">MeshType vcl::meshSphereIntersection </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="classvcl_1_1Sphere.html">vcl::Sphere</a>&lt; <a class="el" href="classvcl_1_1Matrix.html">SScalar</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>sphere</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">double</a>&#160;</td>
          <td class="paramname"><em>tol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the intersection between a mesh and a ball. </p>
<p>given a mesh return a new mesh made by a copy of all the faces entirely includeded in the ball plus new faces created by refining the ones intersected by the ball border. It works by recursively splitting the triangles that cross the border, as long as their area is greater than a given value tol. NOTE: the returned mesh is a triangle soup</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td></td></tr>
    <tr><td class="paramname">sphere</td><td></td></tr>
    <tr><td class="paramname">tol</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a9c1835cef3addd7dbae2b21a43523f3a" name="a9c1835cef3addd7dbae2b21a43523f3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c1835cef3addd7dbae2b21a43523f3a">&#9670;&#160;</a></span>min() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classvcl_1_1Matrix.html">typename</a> <a class="el" href="classvcl_1_1Matrix.html">Head</a> , typename... Tail&gt; <br />
requires (sizeof...(<a class="el" href="classvcl_1_1Matrix.html">tail</a>) &gt; 0)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">constexpr</a> <a class="el" href="classvcl_1_1Matrix.html">auto</a> vcl::min </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="classvcl_1_1Matrix.html">Head</a> &amp;&#160;</td>
          <td class="paramname"><em>head0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="classvcl_1_1Matrix.html">Head</a> &amp;&#160;</td>
          <td class="paramname"><em>head1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="classvcl_1_1Matrix.html">Tail</a> &amp;...&#160;</td>
          <td class="paramname"><em>tail</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac11460526cb6d79733a8dfe0e15614f4" name="ac11460526cb6d79733a8dfe0e15614f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac11460526cb6d79733a8dfe0e15614f4">&#9670;&#160;</a></span>min() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;PointConcept PointType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">constexpr</a> <a class="el" href="classvcl_1_1Matrix.html">auto</a> vcl::min </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> PointType &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> PointType &amp;&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3edcb561672a6be17e9453bd1ea446d5" name="a3edcb561672a6be17e9453bd1ea446d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3edcb561672a6be17e9453bd1ea446d5">&#9670;&#160;</a></span>min() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classvcl_1_1Matrix.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">constexpr</a> <a class="el" href="classvcl_1_1Matrix.html">auto</a> vcl::min </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> T &amp;&#160;</td>
          <td class="paramname"><em>el1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> T &amp;&#160;</td>
          <td class="paramname"><em>el2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a304004401342d3afd55a2dd3a521d807" name="a304004401342d3afd55a2dd3a521d807"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a304004401342d3afd55a2dd3a521d807">&#9670;&#160;</a></span>multiplyPerElementNormalsByMatrix() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a> ELEM_ID, <a class="el" href="classvcl_1_1Matrix.html">typename</a> <a class="el" href="classvcl_1_1Matrix.html">MScalar</a> , LoggerConcept LogType = NullLogger&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">void</a> vcl::multiplyPerElementNormalsByMatrix </td>
          <td>(</td>
          <td class="paramtype">MeshConcept <a class="el" href="classvcl_1_1Matrix.html">auto</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="namespacevcl.html#a1ebaf363f3eba42f665854a59613068c">Matrix44</a>&lt; <a class="el" href="classvcl_1_1Matrix.html">MScalar</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">bool</a>&#160;</td>
          <td class="paramname"><em>removeScalingFromMatrix</em> = <code><a class="el" href="classvcl_1_1Matrix.html">true</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">LogType</a> &amp;&#160;</td>
          <td class="paramname"><em>log</em> = <code><a class="el" href="group__miscellaneous.html#ga3377e3c875ec245e90ac5a395105ce99">nullLogger</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiplies the normals of all the <code>ELEM_ID</code> elements by the given TRS 4x4 <a class="el" href="classvcl_1_1Matrix.html">Matrix</a>. </p>
<p>The normals are multiplied by the 3x3 rotation matrix of the given TRS matrix. If removeScalingFromMatrix is true (default), the scale component is removed from the matrix.</p>
<p>Requirements:</p><ul>
<li><a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>:<ul>
<li><code>ELEM_ID</code>:<ul>
<li>Normal</li>
</ul>
</li>
</ul>
</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">mesh</td><td>the mesh on which multiply the element normals. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mat</td><td>the 4x4 TRS matrix that is multiplied to the normals. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">removeScalingFromMatrix</td><td>if true (default), the scale component is removed from the matrix. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">log</td><td>The logger used to log the performed operations. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abd84dece22955e70f1ae77fc5c8d6b24" name="abd84dece22955e70f1ae77fc5c8d6b24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd84dece22955e70f1ae77fc5c8d6b24">&#9670;&#160;</a></span>multiplyPerElementNormalsByMatrix() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a> ELEM_ID, <a class="el" href="classvcl_1_1Matrix.html">typename</a> <a class="el" href="classvcl_1_1Matrix.html">MScalar</a> , LoggerConcept LogType = NullLogger&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">void</a> vcl::multiplyPerElementNormalsByMatrix </td>
          <td>(</td>
          <td class="paramtype">MeshConcept <a class="el" href="classvcl_1_1Matrix.html">auto</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacevcl.html#a2b8b0e2e4450f76fb433f95326f85e6d">Matrix33</a>&lt; <a class="el" href="classvcl_1_1Matrix.html">MScalar</a> &gt;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">bool</a>&#160;</td>
          <td class="paramname"><em>removeScalingFromMatrix</em> = <code><a class="el" href="classvcl_1_1Matrix.html">true</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">LogType</a> &amp;&#160;</td>
          <td class="paramname"><em>log</em> = <code><a class="el" href="group__miscellaneous.html#ga3377e3c875ec245e90ac5a395105ce99">nullLogger</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiplies the normals of all the <code>ELEM_ID</code> elements by the given 3x3 <a class="el" href="classvcl_1_1Matrix.html">Matrix</a>. </p>
<p>If removeScalingFromMatrix is true (default), the scale component is removed from the matrix.</p>
<p>Requirements:</p><ul>
<li><a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>:<ul>
<li><code>ELEM_ID</code>:<ul>
<li>Normal</li>
</ul>
</li>
</ul>
</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">mesh</td><td>the mesh on which multiply the element normals. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mat</td><td>the 3x3 matrix that is multiplied to the normals. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">removeScalingFromMatrix</td><td>if true (default), the scale component is removed from the matrix. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">log</td><td>The logger used to log the performed operations. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad958cfae923a7b224814e64c78f6a9bb" name="ad958cfae923a7b224814e64c78f6a9bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad958cfae923a7b224814e64c78f6a9bb">&#9670;&#160;</a></span>multiplyPerFaceNormalsByMatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classvcl_1_1Matrix.html">typename</a> <a class="el" href="classvcl_1_1Matrix.html">Matrix</a> , LoggerConcept LogType = NullLogger&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">void</a> vcl::multiplyPerFaceNormalsByMatrix </td>
          <td>(</td>
          <td class="paramtype">FaceMeshConcept <a class="el" href="classvcl_1_1Matrix.html">auto</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="classvcl_1_1Matrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">bool</a>&#160;</td>
          <td class="paramname"><em>removeScalingFromMatrix</em> = <code><a class="el" href="classvcl_1_1Matrix.html">true</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">LogType</a> &amp;&#160;</td>
          <td class="paramname"><em>log</em> = <code><a class="el" href="group__miscellaneous.html#ga3377e3c875ec245e90ac5a395105ce99">nullLogger</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as multiplyPerElementNormalsByMatrix, but for the face normals. </p>
<p>Accepts both 3x3 and 4x4 matrices.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacevcl.html#abd84dece22955e70f1ae77fc5c8d6b24" title="Multiplies the normals of all the ELEM_ID elements by the given 3x3 Matrix.">multiplyPerElementNormalsByMatrix</a> </dd></dl>

</div>
</div>
<a id="a884a9e1e47cbc016ed1dc5ce1fa6e37a" name="a884a9e1e47cbc016ed1dc5ce1fa6e37a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a884a9e1e47cbc016ed1dc5ce1fa6e37a">&#9670;&#160;</a></span>multiplyPerVertexNormalsByMatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classvcl_1_1Matrix.html">typename</a> <a class="el" href="classvcl_1_1Matrix.html">Matrix</a> , LoggerConcept LogType = NullLogger&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">void</a> vcl::multiplyPerVertexNormalsByMatrix </td>
          <td>(</td>
          <td class="paramtype">MeshConcept <a class="el" href="classvcl_1_1Matrix.html">auto</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="classvcl_1_1Matrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">bool</a>&#160;</td>
          <td class="paramname"><em>removeScalingFromMatrix</em> = <code><a class="el" href="classvcl_1_1Matrix.html">true</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">LogType</a> &amp;&#160;</td>
          <td class="paramname"><em>log</em> = <code><a class="el" href="group__miscellaneous.html#ga3377e3c875ec245e90ac5a395105ce99">nullLogger</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as multiplyPerElementNormalsByMatrix, but for the vertex normals. </p>
<p>Accepts both 3x3 and 4x4 matrices.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacevcl.html#abd84dece22955e70f1ae77fc5c8d6b24" title="Multiplies the normals of all the ELEM_ID elements by the given 3x3 Matrix.">multiplyPerElementNormalsByMatrix</a> </dd></dl>

</div>
</div>
<a id="a033ff1897830e289bcecfd482bfe9074" name="a033ff1897830e289bcecfd482bfe9074"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a033ff1897830e289bcecfd482bfe9074">&#9670;&#160;</a></span>normalizePerElementNormals()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a> ELEM_ID, LoggerConcept LogType = NullLogger&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">void</a> vcl::normalizePerElementNormals </td>
          <td>(</td>
          <td class="paramtype">MeshConcept <a class="el" href="classvcl_1_1Matrix.html">auto</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">LogType</a> &amp;&#160;</td>
          <td class="paramname"><em>log</em> = <code><a class="el" href="group__miscellaneous.html#ga3377e3c875ec245e90ac5a395105ce99">nullLogger</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Normalizes the length of the normals of all the <code>ELEM_ID</code> elements. </p>
<p>Requirements:</p><ul>
<li><a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>:<ul>
<li><code>ELEM_ID</code>:<ul>
<li>Normal</li>
</ul>
</li>
</ul>
</li>
</ul>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ELEM_ID</td><td>The ID of an <a class="el" href="classvcl_1_1Element.html" title="The Element class.">Element</a>, that is a value in the ElementIDEnum.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">mesh</td><td>the mesh on which normalize the <code>ELEM_ID</code> normals. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">log</td><td>The logger used to log the performed operations. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af9d81a913adbce049dfe4ebb667b833c" name="af9d81a913adbce049dfe4ebb667b833c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9d81a913adbce049dfe4ebb667b833c">&#9670;&#160;</a></span>normalizePerFaceNormals()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;LoggerConcept LogType = NullLogger&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">void</a> vcl::normalizePerFaceNormals </td>
          <td>(</td>
          <td class="paramtype">FaceMeshConcept <a class="el" href="classvcl_1_1Matrix.html">auto</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">LogType</a> &amp;&#160;</td>
          <td class="paramname"><em>log</em> = <code><a class="el" href="group__miscellaneous.html#ga3377e3c875ec245e90ac5a395105ce99">nullLogger</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as normalizePerElementNormals, but for the face normals. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacevcl.html#a033ff1897830e289bcecfd482bfe9074" title="Normalizes the length of the normals of all the ELEM_ID elements.">normalizePerElementNormals</a> </dd></dl>

</div>
</div>
<a id="a607cbcdaf24e6dd7cec3e23a28fb450f" name="a607cbcdaf24e6dd7cec3e23a28fb450f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a607cbcdaf24e6dd7cec3e23a28fb450f">&#9670;&#160;</a></span>normalizePerFaceQuality()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">void</a> vcl::normalizePerFaceQuality </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">typename</a> MeshType::FaceType::QualityType&#160;</td>
          <td class="paramname"><em>minS</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">typename</a> MeshType::FaceType::QualityType&#160;</td>
          <td class="paramname"><em>maxS</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Normalizes the face quality of a mesh in a given interval (default [0, 1]). </p>
<p>Requirements:</p><ul>
<li><a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>:<ul>
<li>Faces:<ul>
<li>Quality</li>
</ul>
</li>
</ul>
</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">m</td><td>mesh on which normalize the face quality </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">minS</td><td>minimum value of the normalizing interval </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxS</td><td>maximum value of the normalizing interval </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acb813f7e8bd797fe133e12b9c356ffa4" name="acb813f7e8bd797fe133e12b9c356ffa4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb813f7e8bd797fe133e12b9c356ffa4">&#9670;&#160;</a></span>normalizePerReferencedVertexNormals()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType, LoggerConcept LogType = NullLogger&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">void</a> vcl::normalizePerReferencedVertexNormals </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">LogType</a> &amp;&#160;</td>
          <td class="paramname"><em>log</em> = <code><a class="el" href="group__miscellaneous.html#ga3377e3c875ec245e90ac5a395105ce99">nullLogger</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Normalizes the length of normals the referenced vertices. </p>
<p>Requirements:</p><ul>
<li><a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>:<ul>
<li><a class="el" href="classvcl_1_1Vertex.html" title="The Vertex class represents an Vertex element of the vcl::Mesh class.">Vertex</a>:<ul>
<li>Normal</li>
</ul>
</li>
<li><a class="el" href="classvcl_1_1Face.html" title="The Face class represents an Face element of the vcl::Mesh class.">Face</a></li>
</ul>
</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">mesh</td><td>the mesh on which normalize the vertex normals. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">log</td><td>The logger used to log the performed operations. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aacf4094f5263defa68fd1e925f5e967d" name="aacf4094f5263defa68fd1e925f5e967d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacf4094f5263defa68fd1e925f5e967d">&#9670;&#160;</a></span>normalizePerVertexNormals()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;LoggerConcept LogType = NullLogger&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">void</a> vcl::normalizePerVertexNormals </td>
          <td>(</td>
          <td class="paramtype">MeshConcept <a class="el" href="classvcl_1_1Matrix.html">auto</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">LogType</a> &amp;&#160;</td>
          <td class="paramname"><em>log</em> = <code><a class="el" href="group__miscellaneous.html#ga3377e3c875ec245e90ac5a395105ce99">nullLogger</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as normalizePerElementNormals, but for the vertex normals. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacevcl.html#a033ff1897830e289bcecfd482bfe9074" title="Normalizes the length of the normals of all the ELEM_ID elements.">normalizePerElementNormals</a> </dd></dl>

</div>
</div>
<a id="ad1a6ca42d06d208218a4aa820f220696" name="ad1a6ca42d06d208218a4aa820f220696"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1a6ca42d06d208218a4aa820f220696">&#9670;&#160;</a></span>normalizePerVertexQuality()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">void</a> vcl::normalizePerVertexQuality </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">typename</a> MeshType::VertexType::QualityType&#160;</td>
          <td class="paramname"><em>minS</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">typename</a> MeshType::VertexType::QualityType&#160;</td>
          <td class="paramname"><em>maxS</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Normalizes the vertex quality of a mesh in a given interval (default [0, 1]). </p>
<p>Requirements:</p><ul>
<li><a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>:<ul>
<li>Vertices:<ul>
<li>Quality</li>
</ul>
</li>
</ul>
</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">m</td><td>mesh on which normalize the vertex quality </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">minS</td><td>minimum value of the normalizing interval </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxS</td><td>maximum value of the normalizing interval </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a89b928a94b582f3a2b6922c429342a6a" name="a89b928a94b582f3a2b6922c429342a6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89b928a94b582f3a2b6922c429342a6a">&#9670;&#160;</a></span>objFormatCapability()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1MeshInfo.html">MeshInfo</a> vcl::objFormatCapability </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af5fcaf6c89c8030d5989da2c50af169a" name="af5fcaf6c89c8030d5989da2c50af169a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5fcaf6c89c8030d5989da2c50af169a">&#9670;&#160;</a></span>offFormatCapability()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1MeshInfo.html">MeshInfo</a> vcl::offFormatCapability </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a214c7dfb93183997081c69d2008b7904" name="a214c7dfb93183997081c69d2008b7904"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a214c7dfb93183997081c69d2008b7904">&#9670;&#160;</a></span>openInputFileStream()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ifstream vcl::openInputFileStream </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> std::string &amp;&#160;</td>
          <td class="paramname"><em>ext</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Open an input stream from a file. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classvcl_1_1CannotOpenFileException.html">CannotOpenFileException</a></td><td>if the file cannot be opened.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filename</td><td>the name of the file to open. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ext</td><td>the extension of the file to open. If empty, the filename is used as is. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the input stream. </dd></dl>

</div>
</div>
<a id="aea5f889621e9a85c0c893d082b34b474" name="aea5f889621e9a85c0c893d082b34b474"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea5f889621e9a85c0c893d082b34b474">&#9670;&#160;</a></span>openOutputFileStream()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ofstream vcl::openOutputFileStream </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> std::string &amp;&#160;</td>
          <td class="paramname"><em>ext</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="acb087e661b9a756b25bc45f9b9fbf367" name="acb087e661b9a756b25bc45f9b9fbf367"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb087e661b9a756b25bc45f9b9fbf367">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classvcl_1_1Matrix.html">typename</a> T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; <a class="el" href="classvcl_1_1Matrix.html">vcl::operator</a>&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="classvcl_1_1BitSet.html">BitSet</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>bs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Output stream operator for <a class="el" href="classvcl_1_1BitSet.html" title="The BitSet class allows to treat an integral type as an array of booleans of a guaranteed size.">BitSet</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">os</td><td>the output stream </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bs</td><td>the <a class="el" href="classvcl_1_1BitSet.html" title="The BitSet class allows to treat an integral type as an array of booleans of a guaranteed size.">BitSet</a> to output </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream </dd></dl>

</div>
</div>
<a id="a10783cb155a40826adff62ef42123efe" name="a10783cb155a40826adff62ef42123efe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10783cb155a40826adff62ef42123efe">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classvcl_1_1Matrix.html">typename</a> Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; <a class="el" href="classvcl_1_1Matrix.html">vcl::operator</a>&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="classvcl_1_1Array.html">Array</a>&lt; Scalar, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a05dd102880d029a4ce6a952207559088" name="a05dd102880d029a4ce6a952207559088"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05dd102880d029a4ce6a952207559088">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; <a class="el" href="classvcl_1_1Matrix.html">vcl::operator</a>&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="classvcl_1_1Color.html">Color</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overload of stream operator to allow a pretty print of a <a class="el" href="classvcl_1_1Color.html" title="The Color class represents a 32 bit color.">vcl::Color</a>. </p>

</div>
</div>
<a id="ac74faed2021a2b157f5b80757ee694d8" name="ac74faed2021a2b157f5b80757ee694d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac74faed2021a2b157f5b80757ee694d8">&#9670;&#160;</a></span>parallelFor() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classvcl_1_1Matrix.html">typename</a> Iterator , <a class="el" href="classvcl_1_1Matrix.html">typename</a> <a class="el" href="classvcl_1_1Matrix.html">Lambda</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">void</a> vcl::parallelFor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> Iterator &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> Iterator &amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">Lambda</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>F</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function executes a parallel for over the elements iterated between <code>begin</code> and <code>end</code> iterators, if parallel requirements have been found in the system. </p>
<p>Example of usage on a <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">vcl::Mesh</a>, iterating over vertices:</p>
<div class="fragment"><div class="line"><a class="code hl_function" href="namespacevcl.html#abde6b767fa0b116a5fd8b2a5fa0af488">vcl::parallelFor</a>(<a class="code hl_class" href="classvcl_1_1Matrix.html">m</a>.vertices().begin(), <a class="code hl_class" href="classvcl_1_1Matrix.html">m</a>.vertices().end(),</div>
<div class="line">    [&amp;](VertexType&amp; v) {</div>
<div class="line">        <span class="comment">// make some computing on v</span></div>
<div class="line">    });</div>
<div class="ttc" id="anamespacevcl_html_abde6b767fa0b116a5fd8b2a5fa0af488"><div class="ttname"><a href="namespacevcl.html#abde6b767fa0b116a5fd8b2a5fa0af488">vcl::parallelFor</a></div><div class="ttdeci">void parallelFor(Iterator &amp;&amp;begin, Iterator &amp;&amp;end, Lambda &amp;&amp;F)</div><div class="ttdoc">This function executes a parallel for over the elements iterated between begin and end iterators,...</div><div class="ttdef"><b>Definition</b> parallel.h:75</div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">begin</td><td>iterator of the first element to iterate </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">end</td><td>iterator of the end of the iterated container </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>lambda function that takes the iterated type as input </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad43b0e6c5acf9f903daf25853361a24c" name="ad43b0e6c5acf9f903daf25853361a24c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad43b0e6c5acf9f903daf25853361a24c">&#9670;&#160;</a></span>parallelFor() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="conceptvcl_1_1Range.html">vcl::Range</a> Rng, <a class="el" href="classvcl_1_1Matrix.html">typename</a> <a class="el" href="classvcl_1_1Matrix.html">Lambda</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">void</a> vcl::parallelFor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="classvcl_1_1Matrix.html">Rng</a> &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">Lambda</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>F</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function executes a parallel for over a range if parallel requirements have been found in the system. </p>
<p>Example of usage on a <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">vcl::Mesh</a>, iterating over vertices:</p>
<div class="fragment"><div class="line"><a class="code hl_function" href="namespacevcl.html#abde6b767fa0b116a5fd8b2a5fa0af488">vcl::parallelFor</a>(<a class="code hl_class" href="classvcl_1_1Matrix.html">m</a>.vertices(), [&amp;](VertexType&amp; v) {</div>
<div class="line">    <span class="comment">// make some computing on v</span></div>
<div class="line">});</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">r</td><td>a range having begin() and end() functions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>lambda function that takes the iterated type as input </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abde6b767fa0b116a5fd8b2a5fa0af488" name="abde6b767fa0b116a5fd8b2a5fa0af488"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abde6b767fa0b116a5fd8b2a5fa0af488">&#9670;&#160;</a></span>parallelFor() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classvcl_1_1Matrix.html">typename</a> Iterator , <a class="el" href="classvcl_1_1Matrix.html">typename</a> <a class="el" href="classvcl_1_1Matrix.html">Lambda</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">void</a> vcl::parallelFor </td>
          <td>(</td>
          <td class="paramtype">Iterator &amp;&amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator &amp;&amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">Lambda</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>F</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function executes a parallel for over the elements iterated between <code>begin</code> and <code>end</code> iterators, if parallel requirements have been found in the system. </p>
<p>Example of usage on a <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">vcl::Mesh</a>, iterating over vertices:</p>
<div class="fragment"><div class="line"><a class="code hl_function" href="namespacevcl.html#abde6b767fa0b116a5fd8b2a5fa0af488">vcl::parallelFor</a>(<a class="code hl_class" href="classvcl_1_1Matrix.html">m</a>.vertices().begin(), <a class="code hl_class" href="classvcl_1_1Matrix.html">m</a>.vertices().end(),</div>
<div class="line">    [&amp;](VertexType&amp; v) {</div>
<div class="line">        <span class="comment">// make some computing on v</span></div>
<div class="line">    });</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">begin</td><td>iterator of the first element to iterate </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">end</td><td>iterator of the end of the iterated container </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>lambda function that takes the iterated type as input </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0bbb25a5a74276bc05a251ab860a286d" name="a0bbb25a5a74276bc05a251ab860a286d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bbb25a5a74276bc05a251ab860a286d">&#9670;&#160;</a></span>parallelFor() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="conceptvcl_1_1Range.html">vcl::Range</a> Rng, <a class="el" href="classvcl_1_1Matrix.html">typename</a> <a class="el" href="classvcl_1_1Matrix.html">Lambda</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">void</a> vcl::parallelFor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">Rng</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">Lambda</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>F</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function executes a parallel for over a range if parallel requirements have been found in the system. </p>
<p>Example of usage on a <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">vcl::Mesh</a>, iterating over vertices:</p>
<div class="fragment"><div class="line"><a class="code hl_function" href="namespacevcl.html#abde6b767fa0b116a5fd8b2a5fa0af488">vcl::parallelFor</a>(<a class="code hl_class" href="classvcl_1_1Matrix.html">m</a>.vertices(), [&amp;](VertexType&amp; v) {</div>
<div class="line">    <span class="comment">// make some computing on v</span></div>
<div class="line">});</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">r</td><td>a range having begin() and end() functions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>lambda function that takes the iterated type as input </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab1ac25199a4bfa15b8fe336c1c6486b2" name="ab1ac25199a4bfa15b8fe336c1c6486b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1ac25199a4bfa15b8fe336c1c6486b2">&#9670;&#160;</a></span>perEdgeMeshFilter() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;EdgeMeshConcept InMeshType, EdgeMeshConcept OutMeshType = InMeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">OutMeshType</a> vcl::perEdgeMeshFilter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="classvcl_1_1Matrix.html">InMeshType</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> std::function&lt; <a class="el" href="classvcl_1_1Matrix.html">bool</a>(<a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="classvcl_1_1Matrix.html">typename</a> InMeshType::EdgeType &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>edgeFilter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">bool</a>&#160;</td>
          <td class="paramname"><em>saveBirthIndicesInCustomComponent</em> = <code><a class="el" href="classvcl_1_1Matrix.html">true</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates and returns a new mesh that is composed of the edges of the input mesh <code>m</code> filtered using the <code>edgeFilter</code> function. Only vertices belonging to the imported edges will be imported in the output mesh. </p>
<p>Only the edges for which the <code>edgeFilter</code> function returns true` and their vertices will be put in the output mesh. Only the order of the edges in the output mesh is preserved.</p>
<p>By default, the type of the output mesh will be the same of the input mesh type.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">InMeshType</td><td>type of the input mesh. It must satisfy the <code>EdgeMeshConcept</code>. </td></tr>
    <tr><td class="paramname">OutMeshType</td><td>type of the output mesh. It must satisfy the <code>EdgeMeshConcept</code>. By default, it is the same of the input mesh type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>input mesh </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">edgeFilter</td><td>a function that takes a edge as input and returns a boolean value that tells whether the edge should be imported in the output mesh or not. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">saveBirthIndicesInCustomComponent</td><td>if <code>true</code> (default), and if the output mesh type has the per vertex and/or per edge CustomComponents component, will set a per vertex/per edge custom component of type <code>uint</code> in the output mesh telling, for each vertex/edge, the index of its birth vertex/birth edge in the input mesh. The names of the custom components are <code>"birthVertex"</code> and <code>"birthEdge"</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a> created by filtering the edges of the input mesh <code>m</code>. </dd></dl>

</div>
</div>
<a id="a1323394fc4f4b4636d074c5235a48986" name="a1323394fc4f4b4636d074c5235a48986"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1323394fc4f4b4636d074c5235a48986">&#9670;&#160;</a></span>perEdgeMeshFilter() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;EdgeMeshConcept InMeshType, EdgeMeshConcept OutMeshType = InMeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">OutMeshType</a> vcl::perEdgeMeshFilter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="classvcl_1_1Matrix.html">InMeshType</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Range <a class="el" href="classvcl_1_1Matrix.html">auto</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>edgeFilterRng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">bool</a>&#160;</td>
          <td class="paramname"><em>saveBirthIndicesInCustomComponent</em> = <code><a class="el" href="classvcl_1_1Matrix.html">true</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates and returns a new mesh that is composed of the edges of the input mesh <code>m</code> filtered using the <code>edgeFilterRng</code> range. Only vertices belonging to the imported edges will be imported in the output mesh. </p>
<p>Only the edges having the corresponding boolean in <code>edgeFilterRng</code> evaluated to <code>true</code> and their vertices will be put in the output mesh. Only the order of the edges in the output mesh is preserved.</p>
<p>By default, the type of the output mesh will be the same of the input mesh type.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">InMeshType</td><td>type of the input mesh. It must satisfy the <code>EdgeMeshConcept</code>. </td></tr>
    <tr><td class="paramname">OutMeshType</td><td>type of the output mesh. It must satisfy the <code>EdgeMeshConcept</code>. By default, it is the same of the input mesh type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>input mesh </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">edgeFilterRng</td><td>range of values that are evaluated as booleans, one for each edge of the input mesh. Its type must satisfy the <code>Range</code> concept. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">saveBirthIndicesInCustomComponent</td><td>if <code>true</code> (default), and if the output mesh type has the per vertex and/or per edge CustomComponents component, will set a per vertex/per edge custom component of type <code>uint</code> in the output mesh telling, for each vertex/edge, the index of its birth vertex/birth edge in the input mesh. The names of the custom components are <code>"birthVertex"</code> and <code>"birthEdge"</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a> created by filtering the edges of the input mesh <code>m</code>. </dd></dl>

</div>
</div>
<a id="ac48b7e9d567cbcd77636fd03df2b6471" name="ac48b7e9d567cbcd77636fd03df2b6471"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac48b7e9d567cbcd77636fd03df2b6471">&#9670;&#160;</a></span>perEdgeSelectionMeshFilter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;EdgeMeshConcept InMeshType, EdgeMeshConcept OutMeshType = InMeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">OutMeshType</a> vcl::perEdgeSelectionMeshFilter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="classvcl_1_1Matrix.html">InMeshType</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">bool</a>&#160;</td>
          <td class="paramname"><em>saveBirthIndicesInCustomComponent</em> = <code><a class="el" href="classvcl_1_1Matrix.html">true</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates and returns a new mesh that is composed of the selected edges of the input mesh <code>m</code>. Only vertices belonging to the imported edges will be imported in the output mesh. </p>
<p>Only the delected edges and their vertices will be put in the output mesh. Only the order of the edges in the output mesh is preserved.</p>
<p>By default, the type of the output mesh will be the same of the input mesh type.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">InMeshType</td><td>type of the input mesh. It must satisfy the <code>EdgeMeshConcept</code>. </td></tr>
    <tr><td class="paramname">OutMeshType</td><td>type of the output mesh. It must satisfy the <code>EdgeMeshConcept</code>. By default, it is the same of the input mesh type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>input mesh </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">saveBirthIndicesInCustomComponent</td><td>if <code>true</code> (default), and if the output mesh type has the per vertex and/or per edge CustomComponents component, will set a per vertex/per edge custom component of type <code>uint</code> in the output mesh telling, for each vertex/edge, the index of its birth vertex/birth edge in the input mesh. The names of the custom components are <code>"birthVertex"</code> and <code>"birthEdge"</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a> created by filtering the selected edges of the input mesh <code>m</code>. </dd></dl>

</div>
</div>
<a id="a4cb9e347987116b6b9c58d6da2732c15" name="a4cb9e347987116b6b9c58d6da2732c15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cb9e347987116b6b9c58d6da2732c15">&#9670;&#160;</a></span>perFaceEdgeMeshFilter() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;EdgeMeshConcept OutMeshType, FaceMeshConcept InMeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">OutMeshType</a> vcl::perFaceEdgeMeshFilter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="classvcl_1_1Matrix.html">InMeshType</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> std::function&lt; <a class="el" href="classvcl_1_1Matrix.html">bool</a>(<a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="classvcl_1_1Matrix.html">typename</a> InMeshType::FaceType &amp;, <a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a>)&gt; &amp;&#160;</td>
          <td class="paramname"><em>faceEdgeFilter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">bool</a>&#160;</td>
          <td class="paramname"><em>dontDuplicateEdges</em> = <code><a class="el" href="classvcl_1_1Matrix.html">true</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">bool</a>&#160;</td>
          <td class="paramname"><em>saveBirthIndicesInCustomComponent</em> = <code><a class="el" href="classvcl_1_1Matrix.html">true</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates and returns a new mesh that is composed of the edges computed from the face edges of the input mesh <code>m</code> filtered using the <code>faceEdgeFilter</code> function. Only vertices belonging to the imported face edges will be imported in the output mesh. </p>
<p>Only the edges for which the <code>faceEdgeFilter</code> function returns true` and their vertices will be put in the output mesh.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">InMeshType</td><td>type of the input mesh. It must satisfy the <code>FaceMeshConcept</code>. </td></tr>
    <tr><td class="paramname">OutMeshType</td><td>type of the output mesh. It must satisfy the <code>EdgeMeshConcept</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>input mesh </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">faceEdgeFilter</td><td>a function that takes a face and an uint as input and returns a boolean value that tells whether the edge (uint) of the face should be "imported" in the output mesh or not. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dontDuplicateEdges</td><td>if <code>true</code> (default), the output mesh will not have duplicated edges (same vertices, also in different order). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">saveBirthIndicesInCustomComponent</td><td>if <code>true</code> (default), and if the output mesh type has the per vertex CustomComponents component, will set a per vertex custom component of type <code>uint</code> in the output mesh telling, for each vertex, the index of its birth vertex in the input mesh. The names of the custom component is <code>"birthVertex"</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a> created by filtering the face edges of the input mesh <code>m</code>. </dd></dl>

</div>
</div>
<a id="a4a5f7e2e6ea0896a34c2c2f633c8ba16" name="a4a5f7e2e6ea0896a34c2c2f633c8ba16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a5f7e2e6ea0896a34c2c2f633c8ba16">&#9670;&#160;</a></span>perFaceEdgeMeshFilter() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;EdgeMeshConcept OutMeshType, FaceMeshConcept InMeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">OutMeshType</a> vcl::perFaceEdgeMeshFilter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="classvcl_1_1Matrix.html">InMeshType</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> std::function&lt; <a class="el" href="classvcl_1_1Matrix.html">bool</a>(<a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a>, <a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a>)&gt; &amp;&#160;</td>
          <td class="paramname"><em>faceEdgeFilter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">bool</a>&#160;</td>
          <td class="paramname"><em>dontDuplicateEdges</em> = <code><a class="el" href="classvcl_1_1Matrix.html">true</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">bool</a>&#160;</td>
          <td class="paramname"><em>saveBirthIndicesInCustomComponent</em> = <code><a class="el" href="classvcl_1_1Matrix.html">true</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates and returns a new mesh that is composed of the edges computed from the face edges of the input mesh <code>m</code> filtered using the <code>faceEdgeFilter</code> function. Only vertices belonging to the imported face edges will be imported in the output mesh. </p>
<p>Only the edges for which the <code>faceEdgeFilter</code> function returns true` and their vertices will be put in the output mesh.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">InMeshType</td><td>type of the input mesh. It must satisfy the <code>FaceMeshConcept</code>. </td></tr>
    <tr><td class="paramname">OutMeshType</td><td>type of the output mesh. It must satisfy the <code>EdgeMeshConcept</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>input mesh </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">faceEdgeFilter</td><td>a function that takes a face and an uint as input and returns a boolean value that tells whether the edge (uint) of the face should be "imported" in the output mesh or not. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dontDuplicateEdges</td><td>if <code>true</code> (default), the output mesh will not have duplicated edges (same vertices, also in different order). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">saveBirthIndicesInCustomComponent</td><td>if <code>true</code> (default), and if the output mesh type has the per vertex CustomComponents component, will set a per vertex custom component of type <code>uint</code> in the output mesh telling, for each vertex, the index of its birth vertex in the input mesh. The names of the custom component is <code>"birthVertex"</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a> created by filtering the face edges of the input mesh <code>m</code>. </dd></dl>

</div>
</div>
<a id="a273be5bb8149e465275c9e441cd6869d" name="a273be5bb8149e465275c9e441cd6869d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a273be5bb8149e465275c9e441cd6869d">&#9670;&#160;</a></span>perFaceEdgeSelectionMeshFilter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;EdgeMeshConcept OutMeshType, FaceMeshConcept InMeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">OutMeshType</a> vcl::perFaceEdgeSelectionMeshFilter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="classvcl_1_1Matrix.html">InMeshType</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">bool</a>&#160;</td>
          <td class="paramname"><em>dontDuplicateEdges</em> = <code><a class="el" href="classvcl_1_1Matrix.html">true</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">bool</a>&#160;</td>
          <td class="paramname"><em>saveBirthIndicesInCustomComponent</em> = <code><a class="el" href="classvcl_1_1Matrix.html">true</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates and returns a new mesh that is composed of the edges computed from the selected face edges of the input mesh <code>m</code>. Only vertices belonging to the imported face edges will be imported in the output mesh. </p>
<p>Only the selected edges and their vertices will be put in the output mesh.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">InMeshType</td><td>type of the input mesh. It must satisfy the <code>FaceMeshConcept</code>. </td></tr>
    <tr><td class="paramname">OutMeshType</td><td>type of the output mesh. It must satisfy the <code>EdgeMeshConcept</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>input mesh </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dontDuplicateEdges</td><td>if <code>true</code> (default), the output mesh will not have duplicated edges (same vertices, also in different order). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">saveBirthIndicesInCustomComponent</td><td>if <code>true</code> (default), and if the output mesh type has the per vertex CustomComponents component, will set a per vertex custom component of type <code>uint</code> in the output mesh telling, for each vertex, the index of its birth vertex in the input mesh. The names of the custom component is <code>"birthVertex"</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a> created by filtering the selected face edges of the input mesh <code>m</code>. </dd></dl>

</div>
</div>
<a id="a107e67416dfe237c0209483eb0a85312" name="a107e67416dfe237c0209483eb0a85312"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a107e67416dfe237c0209483eb0a85312">&#9670;&#160;</a></span>perFaceMeshFilter() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept InMeshType, FaceMeshConcept OutMeshType = InMeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">OutMeshType</a> vcl::perFaceMeshFilter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="classvcl_1_1Matrix.html">InMeshType</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> std::function&lt; <a class="el" href="classvcl_1_1Matrix.html">bool</a>(<a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="classvcl_1_1Matrix.html">typename</a> InMeshType::FaceType &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>faceFilter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">bool</a>&#160;</td>
          <td class="paramname"><em>saveBirthIndicesInCustomComponent</em> = <code><a class="el" href="classvcl_1_1Matrix.html">true</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates and returns a new mesh that is composed of the faces of the input mesh <code>m</code> filtered using the <code>faceFilter</code> function. Only vertices belonging to the imported faces will be imported in the output mesh. </p>
<p>Only the faces for which the <code>faceFilter</code> function returns true` and their vertices will be put in the output mesh. Only the order of the faces in the output mesh is preserved.</p>
<p>By default, the type of the output mesh will be the same of the input mesh type.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">InMeshType</td><td>type of the input mesh. It must satisfy the <code>FaceMeshConcept</code>. </td></tr>
    <tr><td class="paramname">OutMeshType</td><td>type of the output mesh. It must satisfy the <code>FaceMeshConcept</code>. By default, it is the same of the input mesh type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>input mesh </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">faceFilter</td><td>a function that takes a face as input and returns a boolean value that tells whether the face should be imported in the output mesh or not. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">saveBirthIndicesInCustomComponent</td><td>if <code>true</code> (default), and if the output mesh type has the per vertex and/or per face CustomComponents component, will set a per vertex/per face custom component of type <code>uint</code> in the output mesh telling, for each vertex/face, the index of its birth vertex/birth face in the input mesh. The names of the custom components are <code>"birthVertex"</code> and <code>"birthFace"</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a> created by filtering the faces of the input mesh <code>m</code>. </dd></dl>

</div>
</div>
<a id="ace4273fd5df9842c19d335bcab94d287" name="ace4273fd5df9842c19d335bcab94d287"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace4273fd5df9842c19d335bcab94d287">&#9670;&#160;</a></span>perFaceMeshFilter() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept InMeshType, FaceMeshConcept OutMeshType = InMeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">OutMeshType</a> vcl::perFaceMeshFilter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="classvcl_1_1Matrix.html">InMeshType</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Range <a class="el" href="classvcl_1_1Matrix.html">auto</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>faceFilterRng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">bool</a>&#160;</td>
          <td class="paramname"><em>saveBirthIndicesInCustomComponent</em> = <code><a class="el" href="classvcl_1_1Matrix.html">true</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates and returns a new mesh that is composed of the faces of the input mesh <code>m</code> filtered using the <code>faceFilterRng</code> range. Only vertices belonging to the imported faces will be imported in the output mesh. </p>
<p>Only the faces having the corresponding boolean in <code>faceFilterRng</code> evaluated to <code>true</code> and their vertices will be put in the output mesh. Only the order of the faces in the output mesh is preserved.</p>
<p>By default, the type of the output mesh will be the same of the input mesh type.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">InMeshType</td><td>type of the input mesh. It must satisfy the <code>FaceMeshConcept</code>. </td></tr>
    <tr><td class="paramname">OutMeshType</td><td>type of the output mesh. It must satisfy the <code>FaceMeshConcept</code>. By default, it is the same of the input mesh type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>input mesh </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">faceFilterRng</td><td>range of values that are evaluated as booleans, one for each face of the input mesh. Its type must satisfy the <code>Range</code> concept. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">saveBirthIndicesInCustomComponent</td><td>if <code>true</code> (default), and if the output mesh type has the per vertex and/or per face CustomComponents component, will set a per vertex/per face custom component of type <code>uint</code> in the output mesh telling, for each vertex/face, the index of its birth vertex/birth face in the input mesh. The names of the custom components are <code>"birthVertex"</code> and <code>"birthFace"</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a> created by filtering the faces of the input mesh <code>m</code>. </dd></dl>

</div>
</div>
<a id="a86df839f39f7541f73198a9e5c6e921f" name="a86df839f39f7541f73198a9e5c6e921f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86df839f39f7541f73198a9e5c6e921f">&#9670;&#160;</a></span>perFaceSelectionMeshFilter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept InMeshType, FaceMeshConcept OutMeshType = InMeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">OutMeshType</a> vcl::perFaceSelectionMeshFilter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="classvcl_1_1Matrix.html">InMeshType</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">bool</a>&#160;</td>
          <td class="paramname"><em>saveBirthIndicesInCustomComponent</em> = <code><a class="el" href="classvcl_1_1Matrix.html">true</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates and returns a new mesh that is composed of the selected faces of the input mesh <code>m</code>. Only vertices belonging to the imported faces will be imported in the output mesh. </p>
<p>Only the delected faces and their vertices will be put in the output mesh. Only the order of the faces in the output mesh is preserved.</p>
<p>By default, the type of the output mesh will be the same of the input mesh type.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">InMeshType</td><td>type of the input mesh. It must satisfy the <code>FaceMeshConcept</code>. </td></tr>
    <tr><td class="paramname">OutMeshType</td><td>type of the output mesh. It must satisfy the <code>FaceMeshConcept</code>. By default, it is the same of the input mesh type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>input mesh </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">saveBirthIndicesInCustomComponent</td><td>if <code>true</code> (default), and if the output mesh type has the per vertex and/or per face CustomComponents component, will set a per vertex/per face custom component of type <code>uint</code> in the output mesh telling, for each vertex/face, the index of its birth vertex/birth face in the input mesh. The names of the custom components are <code>"birthVertex"</code> and <code>"birthFace"</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a> created by filtering the selected faces of the input mesh <code>m</code>. </dd></dl>

</div>
</div>
<a id="afc2f93864498c3b143e13c1b0009bdc4" name="afc2f93864498c3b143e13c1b0009bdc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc2f93864498c3b143e13c1b0009bdc4">&#9670;&#160;</a></span>perlinNoise()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">double</a> vcl::perlinNoise </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">double</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">double</a>&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">double</a>&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>3D Perlin noise, returns a value in the [-1,1] range with period 255 </p>
<p>based on the java reference implementation published on <a href="http://mrl.nyu.edu/~perlin/noise/">http://mrl.nyu.edu/~perlin/noise/</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td></td></tr>
    <tr><td class="paramname">y</td><td></td></tr>
    <tr><td class="paramname">z</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="aff5df6a9918702220e5134fc3602a67f" name="aff5df6a9918702220e5134fc3602a67f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff5df6a9918702220e5134fc3602a67f">&#9670;&#160;</a></span>perVertexMeshFilter() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept InMeshType, MeshConcept OutMeshType = InMeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">OutMeshType</a> vcl::perVertexMeshFilter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="classvcl_1_1Matrix.html">InMeshType</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> std::function&lt; <a class="el" href="classvcl_1_1Matrix.html">bool</a>(<a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="classvcl_1_1Matrix.html">typename</a> InMeshType::VertexType &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>vertexFilter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">bool</a>&#160;</td>
          <td class="paramname"><em>saveBirthIndicesInCustomComponent</em> = <code><a class="el" href="classvcl_1_1Matrix.html">true</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates and returns a new mesh that is composed of the vertices of the input mesh <code>m</code> filtered using the <code>vertexFilter</code> function. </p>
<p>Only the vertices for which the <code>vertexFilter</code> returns <code>true</code> will be put in the output mesh. The order of the vertices in the output mesh is preserved.</p>
<p>By default, the type of the output mesh will be the same of the input mesh type.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">InMeshType</td><td>type of the input mesh. It must satisfy the <code>MeshConcept</code>. </td></tr>
    <tr><td class="paramname">OutMeshType</td><td>type of the output mesh. It must satisfy the <code>MeshConcept</code>. By default, it is the same of the input mesh type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>input mesh </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vertexFilter</td><td>a function that takes a vertex as input and returns a boolean value that tells whether the vertex should be put in the output mesh. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">saveBirthIndicesInCustomComponent</td><td>if <code>true</code> (default), and if the output mesh type has the per vertex CustomComponents component, will set a per vertex custom component of type <code>uint</code> in the output mesh telling, for each vertex, the index of its birth vertex in the input mesh. The name of the custom component is <code>"birthVertex"</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a> created by filtering the vertices of the input mesh <code>m</code>. </dd></dl>

</div>
</div>
<a id="a8d3830ce96c420a6f11c93650c709fa6" name="a8d3830ce96c420a6f11c93650c709fa6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d3830ce96c420a6f11c93650c709fa6">&#9670;&#160;</a></span>perVertexMeshFilter() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept InMeshType, MeshConcept OutMeshType = InMeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">OutMeshType</a> vcl::perVertexMeshFilter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="classvcl_1_1Matrix.html">InMeshType</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Range <a class="el" href="classvcl_1_1Matrix.html">auto</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>vertexFilterRng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">bool</a>&#160;</td>
          <td class="paramname"><em>saveBirthIndicesInCustomComponent</em> = <code><a class="el" href="classvcl_1_1Matrix.html">true</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates and returns a new mesh that is composed of the vertices of the input mesh <code>m</code> filtered using the <code>vertexFilterRng</code> range. </p>
<p>Only the vertices having the corresponding boolean in <code>vertexFilterRng</code> evaluated to <code>true</code> will be put in the output mesh. The order of the vertices in the output mesh is preserved.</p>
<p>By default, the type of the output mesh will be the same of the input mesh type.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">InMeshType</td><td>type of the input mesh. It must satisfy the <code>MeshConcept</code>. </td></tr>
    <tr><td class="paramname">OutMeshType</td><td>type of the output mesh. It must satisfy the <code>MeshConcept</code>. By default, it is the same of the input mesh type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>input mesh </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vertexFilterRng</td><td>range of values that are evaluated as booleans, one for each vertex of the input mesh. Its type must satisfy the <code>Range</code> concept. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">saveBirthIndicesInCustomComponent</td><td>if <code>true</code> (default), and if the output mesh type has the per vertex CustomComponents component, will set a per vertex custom component of type <code>uint</code> in the output mesh telling, for each vertex, the index of its birth vertex in the input mesh. The name of the custom component is <code>"birthVertex"</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a> created by filtering the vertices of the input mesh <code>m</code>. </dd></dl>

</div>
</div>
<a id="a87898c7e54aece94b1ce1f2e0066a682" name="a87898c7e54aece94b1ce1f2e0066a682"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87898c7e54aece94b1ce1f2e0066a682">&#9670;&#160;</a></span>perVertexSelectionMeshFilter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept InMeshType, MeshConcept OutMeshType = InMeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">OutMeshType</a> vcl::perVertexSelectionMeshFilter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="classvcl_1_1Matrix.html">InMeshType</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">bool</a>&#160;</td>
          <td class="paramname"><em>saveBirthIndicesInCustomComponent</em> = <code><a class="el" href="classvcl_1_1Matrix.html">true</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates and returns a new mesh that is composed of the selected vertices of the input mesh <code>m</code>. </p>
<p>Only the selected vertices will be put in the output mesh. The order of the vertices in the output mesh is preserved.</p>
<p>By default, the type of the output mesh will be the same of the input mesh type.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">InMeshType</td><td>type of the input mesh. It must satisfy the <code>MeshConcept</code>. </td></tr>
    <tr><td class="paramname">OutMeshType</td><td>type of the output mesh. It must satisfy the <code>MeshConcept</code>. By default, it is the same of the input mesh type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>input mesh </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">saveBirthIndicesInCustomComponent</td><td>if <code>true</code> (default), and if the output mesh type has the per vertex CustomComponents component, will set a per vertex custom component of type <code>uint</code> in the output mesh telling, for each vertex, the index of its birth vertex in the input mesh. The name of the custom component is <code>"birthVertex"</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a> created by filtering by selection the vertices of the input mesh <code>m</code>. </dd></dl>

</div>
</div>
<a id="a27474522dfcc3be4ce96d6a8b44fcc09" name="a27474522dfcc3be4ce96d6a8b44fcc09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27474522dfcc3be4ce96d6a8b44fcc09">&#9670;&#160;</a></span>planeBoxIntersect()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;PlaneConcept PlaneType, Box3Concept BoxType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">bool</a> vcl::planeBoxIntersect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="classvcl_1_1Matrix.html">PlaneType</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> BoxType &amp;&#160;</td>
          <td class="paramname"><em>box</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if a plane intersects with a box. </p>
<p>Uses the algorithm from <a href="https://gdbooks.gitbooks.io/3dcollisions/content/Chapter2/static_aabb_plane.html">https://gdbooks.gitbooks.io/3dcollisions/content/Chapter2/static_aabb_plane.html</a></p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">PlaneType</td><td>The type of plane used in the intersection check </td></tr>
    <tr><td class="paramname">BoxType</td><td>The type of box used in the intersection check, must satisfy the Box3Concept</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>The plane to check intersection with </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">box</td><td>The box to check intersection with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the plane intersects with the box, false otherwise </dd></dl>

</div>
</div>
<a id="a5603e96ba08d11993828c0e47f2657b2" name="a5603e96ba08d11993828c0e47f2657b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5603e96ba08d11993828c0e47f2657b2">&#9670;&#160;</a></span>planeSegmentIntersect() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;PlaneConcept PlaneType, Segment3Concept SegmentType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">bool</a> vcl::planeSegmentIntersect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="classvcl_1_1Matrix.html">PlaneType</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="classvcl_1_1Matrix.html">SegmentType</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function computes the intersection between a plane and a 3D segment. If the intersection exists, it returns true, otherwise, it returns false. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>the plane to compute the intersection with. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>the 3D segment to compute the intersection with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A boolean value indicating whether an intersection was found or not. </dd></dl>

</div>
</div>
<a id="a095d688d385405cbf305d7f501f672a6" name="a095d688d385405cbf305d7f501f672a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a095d688d385405cbf305d7f501f672a6">&#9670;&#160;</a></span>planeSegmentIntersect() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;PlaneConcept PlaneType, Segment3Concept SegmentType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">bool</a> vcl::planeSegmentIntersect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="classvcl_1_1Matrix.html">PlaneType</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="classvcl_1_1Matrix.html">SegmentType</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">typename</a> SegmentType::PointType &amp;&#160;</td>
          <td class="paramname"><em>intersection</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function computes the intersection between a plane and a 3D segment. If the intersection exists, it returns true and stores the intersection point in the output parameter intersection, otherwise, it returns false. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>the plane to compute the intersection with. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>the 3D segment to compute the intersection with. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">intersection</td><td>A reference to the point that stores the resulting intersection between the plane and the segment. This parameter is only written to if the function returns true. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A boolean value indicating whether an intersection was found or not. </dd></dl>

</div>
</div>
<a id="a088781f7755d7dc3343571923f25d4cb" name="a088781f7755d7dc3343571923f25d4cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a088781f7755d7dc3343571923f25d4cb">&#9670;&#160;</a></span>plyFormatCapability()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1MeshInfo.html">MeshInfo</a> vcl::plyFormatCapability </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aaf860b9816e4dc7fc87d0bf27aaa0670" name="aaf860b9816e4dc7fc87d0bf27aaa0670"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf860b9816e4dc7fc87d0bf27aaa0670">&#9670;&#160;</a></span>Point()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classvcl_1_1Matrix.html">typename</a> <a class="el" href="classvcl_1_1Matrix.html">S</a> , typename... Scalars&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Point.html">vcl::Point</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">S</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Scalars...&#160;</td>
          <td class="paramname"><em>scalars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  <a class="el" href="classvcl_1_1Point.html">Point</a>&lt; <a class="el" href="classvcl_1_1Matrix.html">S</a>, sizeof...(<a class="el" href="classvcl_1_1Matrix.html">Scalars</a>)+1 &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa433f6d104a81e917270cca3d9ed26ed" name="aa433f6d104a81e917270cca3d9ed26ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa433f6d104a81e917270cca3d9ed26ed">&#9670;&#160;</a></span>pointCloudMeshFromMatrices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType, MatrixConcept VMatrix, MatrixConcept VNMatrix = Eigen::MatrixX3d&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">MeshType vcl::pointCloudMeshFromMatrices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="classvcl_1_1Matrix.html">VMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="classvcl_1_1Matrix.html">VNMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>vertexNormals</em> = <code><a class="el" href="classvcl_1_1Matrix.html">VNMatrix</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates and returns a new point cloud mesh from the input vertex matrix and the other matrices that are given as arguments. </p>
<p>The function accepts several input matrices/vectors, that are used only if their number of rows is different from zero. It tries to fill all the data contained in the non-empty input matrices into the <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>:</p><ul>
<li>if a <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a> is not able to store same data, the relative input matrix is ignored. For example, if the <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a> has no per <a class="el" href="classvcl_1_1Vertex.html" title="The Vertex class represents an Vertex element of the vcl::Mesh class.">Vertex</a> Normals, the function will ignore the input vertex normals matrix, also if that is not empty.</li>
<li>if a <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a> is able to store some data and the relative input matrix is not empty, the data will be stored in the <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>. If the matrix has not the expected size, an exception is thrown.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>All the disabled optional components will be enabled if their corresponding input matrix is not empty.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classvcl_1_1WrongSizeException.html">vcl::WrongSizeException</a></td><td>if the sizes of the non-empty input matrices have not the expected sizes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MeshType</td><td>the type of the mesh to be created. It must satisfy the MeshConcept. </td></tr>
    <tr><td class="paramname">VMatrix</td><td>the type of the input vertex matrix. It must satisfy the MatrixConcept. </td></tr>
    <tr><td class="paramname">VNMatrix</td><td>the type of the input vertex normal matrix. It must satisfy the MatrixConcept.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vertices</td><td>a #V*3 matrix containing the coordinates of the vertices of the mesh. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vertexNormals</td><td>a #V*3 matrix containing the normals of the vertices of the mesh. If the number of rows of this matrix is zero, the function will not add vertex normals to the mesh.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new point cloud mesh containing the data passed as argument. </dd></dl>

</div>
</div>
<a id="a8efd5f55775e66de7f1f69b35bd1561a" name="a8efd5f55775e66de7f1f69b35bd1561a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8efd5f55775e66de7f1f69b35bd1561a">&#9670;&#160;</a></span>pointFaceDistance() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Point3Concept PointType, FaceConcept FaceType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">auto</a> vcl::pointFaceDistance </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> PointType &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> FaceType &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">bool</a>&#160;</td>
          <td class="paramname"><em>signedDist</em> = <code><a class="el" href="classvcl_1_1Matrix.html">false</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the distance between a 3D point and a 3D triangle face. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">PointType</td><td>The type of point. Must satisfy the Point3Concept. </td></tr>
    <tr><td class="paramname">FaceType</td><td>The type of face. Must satisfy the FaceConcept.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>The point to calculate the distance from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>The face to calculate the distance to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">signedDist</td><td>Whether to calculate the signed distance. Default is false. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The distance between the point and the face. </dd></dl>

</div>
</div>
<a id="a02f5dd6bd231e193440d954eee9d3aef" name="a02f5dd6bd231e193440d954eee9d3aef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02f5dd6bd231e193440d954eee9d3aef">&#9670;&#160;</a></span>pointFaceDistance() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Point3Concept PointType, FaceConcept FaceType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">auto</a> vcl::pointFaceDistance </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> PointType &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> FaceType &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PointType &amp;&#160;</td>
          <td class="paramname"><em>closest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">bool</a>&#160;</td>
          <td class="paramname"><em>signedDist</em> = <code><a class="el" href="classvcl_1_1Matrix.html">false</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3a294ad7cda738cd64d09b432874830c" name="a3a294ad7cda738cd64d09b432874830c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a294ad7cda738cd64d09b432874830c">&#9670;&#160;</a></span>pointFaceDistance() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Point3Concept PointType, FaceConcept FaceType, <a class="el" href="classvcl_1_1Matrix.html">typename</a> ScalarType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">auto</a> vcl::pointFaceDistance </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> PointType &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> FaceType &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScalarType&#160;</td>
          <td class="paramname"><em>maxDist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">bool</a>&#160;</td>
          <td class="paramname"><em>signedDist</em> = <code><a class="el" href="classvcl_1_1Matrix.html">false</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9abd2d46a87cb3d18987a37e11ed6ccc" name="a9abd2d46a87cb3d18987a37e11ed6ccc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9abd2d46a87cb3d18987a37e11ed6ccc">&#9670;&#160;</a></span>pointFaceDistance() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Point3Concept PointType, FaceConcept FaceType, <a class="el" href="classvcl_1_1Matrix.html">typename</a> ScalarType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">auto</a> vcl::pointFaceDistance </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> PointType &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> FaceType &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScalarType&#160;</td>
          <td class="paramname"><em>maxDist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PointType &amp;&#160;</td>
          <td class="paramname"><em>closest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">bool</a>&#160;</td>
          <td class="paramname"><em>signedDist</em> = <code><a class="el" href="classvcl_1_1Matrix.html">false</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the distance between a 3D point and a 3D triangle face. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">PointType</td><td>The type of point. Must satisfy the Point3Concept. </td></tr>
    <tr><td class="paramname">FaceType</td><td>The type of face. Must satisfy the FaceConcept.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>The point to calculate the distance from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>The face to calculate the distance to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxDist</td><td>The maximum distance to consider. If the distance is greater than this value, the function returns immediately. Default is std::numeric_limits&lt;ScalarType&gt;::max(). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">closest</td><td>The closest point on the triangle to the given point. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">signedDist</td><td>Whether to calculate the signed distance. Default is false. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The distance between the point and the face. </dd></dl>

</div>
</div>
<a id="a1826187003e1e307765b32879a69b748" name="a1826187003e1e307765b32879a69b748"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1826187003e1e307765b32879a69b748">&#9670;&#160;</a></span>pointPlaneDistance()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Point3Concept PointType, PlaneConcept PlaneType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">auto</a> vcl::pointPlaneDistance </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> PointType &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="classvcl_1_1Matrix.html">PlaneType</a> &amp;&#160;</td>
          <td class="paramname"><em>plane</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">bool</a>&#160;</td>
          <td class="paramname"><em>signedDist</em> = <code><a class="el" href="classvcl_1_1Matrix.html">false</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7e95f3d99f53e335c7e17af14b42f991" name="a7e95f3d99f53e335c7e17af14b42f991"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e95f3d99f53e335c7e17af14b42f991">&#9670;&#160;</a></span>pointSegmentDistance() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;PointConcept PointType, SegmentConcept SegmentType&gt; <br />
requires (PointType::DIM == SegmentType::DIM)</div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">auto</a> vcl::pointSegmentDistance </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> PointType &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="classvcl_1_1Matrix.html">SegmentType</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1d8430571d9a6027e6d7e3bac4816b95" name="a1d8430571d9a6027e6d7e3bac4816b95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d8430571d9a6027e6d7e3bac4816b95">&#9670;&#160;</a></span>pointSegmentDistance() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;PointConcept PointType, SegmentConcept SegmentType&gt; <br />
requires (PointType::DIM == SegmentType::DIM)</div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">auto</a> vcl::pointSegmentDistance </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> PointType &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="classvcl_1_1Matrix.html">SegmentType</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PointType &amp;&#160;</td>
          <td class="paramname"><em>closest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aee130ece16518760ce1f2c1a9da3a6e1" name="aee130ece16518760ce1f2c1a9da3a6e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee130ece16518760ce1f2c1a9da3a6e1">&#9670;&#160;</a></span>poissonRandomNumber() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">int</a> vcl::poissonRandomNumber </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">double</a>&#160;</td>
          <td class="paramname"><em>lambda</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a212c052ae1efd3426a5ea49051f8011c" name="a212c052ae1efd3426a5ea49051f8011c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a212c052ae1efd3426a5ea49051f8011c">&#9670;&#160;</a></span>poissonRandomNumber() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">int</a> vcl::poissonRandomNumber </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">double</a>&#160;</td>
          <td class="paramname"><em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::mt19937 &amp;&#160;</td>
          <td class="paramname"><em>gen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>algorithm poisson random number (Knuth): init: Let L ← e^−λ, k ← 0 and p ← 1. do: k ← k + 1. Generate uniform random number u in [0,1] and let p ← p × u. while p &gt; L. return k − 1. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lambda</td><td></td></tr>
    <tr><td class="paramname">gen</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="aef13acb79205bb8fe990f66e1fa203f3" name="aef13acb79205bb8fe990f66e1fa203f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef13acb79205bb8fe990f66e1fa203f3">&#9670;&#160;</a></span>poissonRatioOfUniformsInteger() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">int</a> vcl::poissonRatioOfUniformsInteger </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">double</a>&#160;</td>
          <td class="paramname"><em>L</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2cc1884dbb897a34716178c7b06e7bb2" name="a2cc1884dbb897a34716178c7b06e7bb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cc1884dbb897a34716178c7b06e7bb2">&#9670;&#160;</a></span>poissonRatioOfUniformsInteger() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">int</a> vcl::poissonRatioOfUniformsInteger </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">double</a>&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::mt19937 &amp;&#160;</td>
          <td class="paramname"><em>gen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This subfunction generates a integer with the poisson distribution using the ratio-of-uniforms rejection method (PRUAt). This approach is STABLE even for large L (e.g. it does not suffer from the overflow limit of the classical Knuth implementation) Execution time does not depend on L, except that it matters whether is within the range where ln(n!) is tabulated. </p>
<p>Reference:</p>
<p>E. Stadlober "The ratio of uniforms approach for generating discrete random variates". Journal of Computational and Applied Mathematics, vol. 31, no. 1, 1990, pp. 181-189.</p>
<p>Partially adapted/inspired from some subfunctions of the Agner Fog stocc library ( www.agner.org/random ) Same licensing scheme.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">L</td><td></td></tr>
    <tr><td class="paramname">gen</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a3d0305c02567d29d5bc48a0cdbaacda3" name="a3d0305c02567d29d5bc48a0cdbaacda3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d0305c02567d29d5bc48a0cdbaacda3">&#9670;&#160;</a></span>randomPolygonBarycentricCoordinate() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classvcl_1_1Matrix.html">typename</a> ScalarType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; ScalarType &gt; vcl::randomPolygonBarycentricCoordinate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a>&#160;</td>
          <td class="paramname"><em>polySize</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7c7c00f108bb07302bfb7643c66f3ef4" name="a7c7c00f108bb07302bfb7643c66f3ef4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c7c00f108bb07302bfb7643c66f3ef4">&#9670;&#160;</a></span>randomPolygonBarycentricCoordinate() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classvcl_1_1Matrix.html">typename</a> ScalarType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; ScalarType &gt; vcl::randomPolygonBarycentricCoordinate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a>&#160;</td>
          <td class="paramname"><em>polySize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::mt19937 &amp;&#160;</td>
          <td class="paramname"><em>gen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7496693362c10758d4bc28814e02d5c6" name="a7496693362c10758d4bc28814e02d5c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7496693362c10758d4bc28814e02d5c6">&#9670;&#160;</a></span>randomTriangleBarycentricCoordinate() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Point3Concept PointType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">PointType vcl::randomTriangleBarycentricCoordinate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1928216d4ca321551feca3fc03054e03" name="a1928216d4ca321551feca3fc03054e03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1928216d4ca321551feca3fc03054e03">&#9670;&#160;</a></span>randomTriangleBarycentricCoordinate() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Point3Concept PointType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">PointType vcl::randomTriangleBarycentricCoordinate </td>
          <td>(</td>
          <td class="paramtype">std::mt19937 &amp;&#160;</td>
          <td class="paramname"><em>gen</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate the barycentric coords of a random point over a triangle, with a uniform distribution over the triangle. It uses the parallelogram folding trick. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gen</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a8b5e5d8a685a997ee41edc94bc5136c1" name="a8b5e5d8a685a997ee41edc94bc5136c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b5e5d8a685a997ee41edc94bc5136c1">&#9670;&#160;</a></span>readAndTokenizeNextNonEmptyLine()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Tokenizer.html">vcl::Tokenizer</a> vcl::readAndTokenizeNextNonEmptyLine </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">char</a>&#160;</td>
          <td class="paramname"><em>separator</em> = <code>'&#160;'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads and returns the next non-empty line from a txt stream, tokenized with the given separator. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classvcl_1_1MalformedFileException.html">MalformedFileException</a></td><td>if the stream ends before a non-empty line is found.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">file</td><td>the stream to read from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">separator</td><td>the separator to use for tokenization. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the next non-empty line read from the stream, tokenized with the given separator. </dd></dl>

</div>
</div>
<a id="adb72715db26888853fcf3ee0e3fe18e8" name="adb72715db26888853fcf3ee0e3fe18e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb72715db26888853fcf3ee0e3fe18e8">&#9670;&#160;</a></span>readAndTokenizeNextNonEmptyLineNoThrow()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Tokenizer.html">vcl::Tokenizer</a> vcl::readAndTokenizeNextNonEmptyLineNoThrow </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">char</a>&#160;</td>
          <td class="paramname"><em>separator</em> = <code>'&#160;'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads and returns the next non-empty line from a txt stream, tokenized with the given separator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">file</td><td>the stream to read from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">separator</td><td>the separator to use for tokenization. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the next non-empty line read from the stream, tokenized with the given separator. If the stream ends before a non-empty line is found, returns an empty tokenizer. </dd></dl>

</div>
</div>
<a id="a30dae01a527b0defe0f238b3b0b510b8" name="a30dae01a527b0defe0f238b3b0b510b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30dae01a527b0defe0f238b3b0b510b8">&#9670;&#160;</a></span>readNextNonEmptyLine()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string vcl::readNextNonEmptyLine </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>file</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads and returns the next non-empty line from a txt stream. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classvcl_1_1MalformedFileException.html">MalformedFileException</a></td><td>if the stream ends before a non-empty line is found.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>the stream to read from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the next non-empty line read from the file. </dd></dl>

</div>
</div>
<a id="aa3982745418fd935c79298714bdf9f75" name="aa3982745418fd935c79298714bdf9f75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3982745418fd935c79298714bdf9f75">&#9670;&#160;</a></span>readNextNonEmptyLineNoThrow()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string vcl::readNextNonEmptyLineNoThrow </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>file</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads and returns the next non-empty line from a txt stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">file</td><td>the stream to read from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the next non-empty line read from the stream. If the stream ends before a non-empty line is found, returns an empty string. </dd></dl>

</div>
</div>
<a id="a1420d0b9ba83dea9e692db635533f46c" name="a1420d0b9ba83dea9e692db635533f46c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1420d0b9ba83dea9e692db635533f46c">&#9670;&#160;</a></span>RegularGrid()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;PointConcept PointType, <a class="el" href="classvcl_1_1Matrix.html">typename</a> <a class="el" href="classvcl_1_1Matrix.html">D</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1RegularGrid.html">vcl::RegularGrid</a> </td>
          <td>(</td>
          <td class="paramtype">PointType&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PointType&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">D</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  <a class="el" href="classvcl_1_1RegularGrid.html">RegularGrid</a>&lt; <a class="el" href="classvcl_1_1Matrix.html">typename</a> PointType::ScalarType, PointType::DIM &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afbeefcb5ecbc42c311e46711ee48ecd2" name="afbeefcb5ecbc42c311e46711ee48ecd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbeefcb5ecbc42c311e46711ee48ecd2">&#9670;&#160;</a></span>removeCarriageReturn()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">void</a> vcl::removeCarriageReturn </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the carriage return character (<code>\r</code>) from the end of the string. </p>
<p>This is useful when reading text files in Windows, where the end of line is represented by the sequence <code>\r\n</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">s</td><td>input string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1f6666a7b9cd7293ab07aaf6cbc1dc4c" name="a1f6666a7b9cd7293ab07aaf6cbc1dc4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f6666a7b9cd7293ab07aaf6cbc1dc4c">&#9670;&#160;</a></span>requirePerVertexAdjacentFaces()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classvcl_1_1Matrix.html">typename</a> MeshType &gt; <br />
requires HasPerVertexAdjacentFaces&lt;MeshType&gt;</div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">void</a> vcl::requirePerVertexAdjacentFaces </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a224534742afebeedf036df597231c700" name="a224534742afebeedf036df597231c700"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a224534742afebeedf036df597231c700">&#9670;&#160;</a></span>requirePerVertexAdjacentVertices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classvcl_1_1Matrix.html">typename</a> MeshType &gt; <br />
requires HasPerVertexAdjacentVertices&lt;MeshType&gt;</div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">void</a> vcl::requirePerVertexAdjacentVertices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3fc65a005474dd6f983d5f9b235b5387" name="a3fc65a005474dd6f983d5f9b235b5387"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fc65a005474dd6f983d5f9b235b5387">&#9670;&#160;</a></span>requirePerVertexColor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classvcl_1_1Matrix.html">typename</a> MeshType &gt; <br />
requires HasPerVertexColor&lt;MeshType&gt;</div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">void</a> vcl::requirePerVertexColor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad1b0cb92a48a555d7084bb6fb94ef359" name="ad1b0cb92a48a555d7084bb6fb94ef359"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1b0cb92a48a555d7084bb6fb94ef359">&#9670;&#160;</a></span>requirePerVertexMark()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classvcl_1_1Matrix.html">typename</a> MeshType &gt; <br />
requires HasPerVertexMark&lt;MeshType&gt;</div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">void</a> vcl::requirePerVertexMark </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab43f884f6ca679c8f57255e11ddaa768" name="ab43f884f6ca679c8f57255e11ddaa768"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab43f884f6ca679c8f57255e11ddaa768">&#9670;&#160;</a></span>requirePerVertexNormal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classvcl_1_1Matrix.html">typename</a> MeshType &gt; <br />
requires HasPerVertexNormal&lt;MeshType&gt;</div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">void</a> vcl::requirePerVertexNormal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af330a765b2c7772ff85378f617ade27b" name="af330a765b2c7772ff85378f617ade27b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af330a765b2c7772ff85378f617ade27b">&#9670;&#160;</a></span>requirePerVertexPrincipalCurvature()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classvcl_1_1Matrix.html">typename</a> MeshType &gt; <br />
requires HasPerVertexPrincipalCurvature&lt;MeshType&gt;</div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">void</a> vcl::requirePerVertexPrincipalCurvature </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a49287ff6e3778f10a280b1166006dff9" name="a49287ff6e3778f10a280b1166006dff9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49287ff6e3778f10a280b1166006dff9">&#9670;&#160;</a></span>requirePerVertexQuality()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classvcl_1_1Matrix.html">typename</a> MeshType &gt; <br />
requires HasPerVertexQuality&lt;MeshType&gt;</div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">void</a> vcl::requirePerVertexQuality </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5f20fd534d1bb822fe5b13f2515025ee" name="a5f20fd534d1bb822fe5b13f2515025ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f20fd534d1bb822fe5b13f2515025ee">&#9670;&#160;</a></span>requirePerVertexTexCoord()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classvcl_1_1Matrix.html">typename</a> MeshType &gt; <br />
requires HasPerVertexTexCoord&lt;MeshType&gt;</div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">void</a> vcl::requirePerVertexTexCoord </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae5e94dd9b89e9bc4fb21701af6e788ca" name="ae5e94dd9b89e9bc4fb21701af6e788ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5e94dd9b89e9bc4fb21701af6e788ca">&#9670;&#160;</a></span>requireVertexContainerCompactness()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">void</a> vcl::requireVertexContainerCompactness </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac6bb8ad7dfb2216bcaee9bdd3e4d8e12" name="ac6bb8ad7dfb2216bcaee9bdd3e4d8e12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6bb8ad7dfb2216bcaee9bdd3e4d8e12">&#9670;&#160;</a></span>rotate() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType, <a class="el" href="classvcl_1_1Matrix.html">typename</a> Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">void</a> vcl::rotate </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="namespacevcl.html#a2b8b0e2e4450f76fb433f95326f85e6d">Matrix33</a>&lt; Scalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">bool</a>&#160;</td>
          <td class="paramname"><em>updateNormals</em> = <code><a class="el" href="classvcl_1_1Matrix.html">true</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aebd717b5286241cd152d92711bb16bbf" name="aebd717b5286241cd152d92711bb16bbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebd717b5286241cd152d92711bb16bbf">&#9670;&#160;</a></span>rotate() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType, PointConcept PointType, <a class="el" href="classvcl_1_1Matrix.html">typename</a> Scalar  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">void</a> vcl::rotate </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> PointType &amp;&#160;</td>
          <td class="paramname"><em>axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> Scalar &amp;&#160;</td>
          <td class="paramname"><em>angleRad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">bool</a>&#160;</td>
          <td class="paramname"><em>updateNormals</em> = <code><a class="el" href="classvcl_1_1Matrix.html">true</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5adf25d966528e8fee208143f6e894b4" name="a5adf25d966528e8fee208143f6e894b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5adf25d966528e8fee208143f6e894b4">&#9670;&#160;</a></span>rotateDeg()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType, PointConcept PointType, <a class="el" href="classvcl_1_1Matrix.html">typename</a> Scalar  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">void</a> vcl::rotateDeg </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> PointType &amp;&#160;</td>
          <td class="paramname"><em>axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> Scalar &amp;&#160;</td>
          <td class="paramname"><em>angleDeg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">bool</a>&#160;</td>
          <td class="paramname"><em>updateNormals</em> = <code><a class="el" href="classvcl_1_1Matrix.html">true</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aefa0051d67bdf4a551140929a2cc0b2f" name="aefa0051d67bdf4a551140929a2cc0b2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefa0051d67bdf4a551140929a2cc0b2f">&#9670;&#160;</a></span>rotationMatrix() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MatrixConcept MatrixType, Point3Concept PointType, <a class="el" href="classvcl_1_1Matrix.html">typename</a> ScalarType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">MatrixType</a> vcl::rotationMatrix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> PointType &amp;&#160;</td>
          <td class="paramname"><em>axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> ScalarType &amp;&#160;</td>
          <td class="paramname"><em>angleRad</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given an 3D axis and an angle expressed in randiants, returns a transform matrix that represents the rotation matrix of the given axis/angle. </p>
<p>The MatrixType must be at least a 3x3 matrix having the setIdentity() member function. If the matrix is a higher than 3x3 (e.g. 4x4), only the 3x3 submatrix will be set, leaving the identity values in the other cells of the matrix.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">axis</td><td></td></tr>
    <tr><td class="paramname">angleRad</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a4870ee93dae22bb750da059cefa6d9f2" name="a4870ee93dae22bb750da059cefa6d9f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4870ee93dae22bb750da059cefa6d9f2">&#9670;&#160;</a></span>rotationMatrix() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MatrixConcept MatrixType, Point3Concept PointType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">MatrixType</a> vcl::rotationMatrix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> PointType &amp;&#160;</td>
          <td class="paramname"><em>fromVector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> PointType &amp;&#160;</td>
          <td class="paramname"><em>toVector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given two 3D vectors, returns a transform matrix that represents the rotation matrix from the first vector to the second vector. </p>
<p>The MatrixType must be at least a 3x3 matrix having the setIdentity() member function. If the matrix is a higher than 3x3 (e.g. 4x4), only the 3x3 submatrix will be set, leaving the identity values in the other cells of the matrix.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fromVector</td><td></td></tr>
    <tr><td class="paramname">toVector</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a7f6b127154a5e14946cb66492d214de8" name="a7f6b127154a5e14946cb66492d214de8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f6b127154a5e14946cb66492d214de8">&#9670;&#160;</a></span>rotationMatrixDeg()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MatrixConcept MatrixType, Point3Concept PointType, <a class="el" href="classvcl_1_1Matrix.html">typename</a> ScalarType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">MatrixType</a> vcl::rotationMatrixDeg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> PointType &amp;&#160;</td>
          <td class="paramname"><em>axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> ScalarType &amp;&#160;</td>
          <td class="paramname"><em>angleDeg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given an 3D axis and an angle expressed in degrees, fills the given matrix with a transform matrix that represents the rotation matrix of the given axis/angle. </p>
<p>The MatrixType must be at least a 3x3 matrix having the setIdentity() member function. If the matrix is a higher than 3x3 (e.g. 4x4), only the 3x3 submatrix will be set, leaving the identity values in the other cells of the matrix.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">axis</td><td></td></tr>
    <tr><td class="paramname">angleDeg</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a9deecac6d9fa88da2ace760ed105ed9d" name="a9deecac6d9fa88da2ace760ed105ed9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9deecac6d9fa88da2ace760ed105ed9d">&#9670;&#160;</a></span>save()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType, LoggerConcept LogType = NullLogger&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">void</a> vcl::save </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="structvcl_1_1SaveSettings.html">SaveSettings</a> &amp;&#160;</td>
          <td class="paramname"><em>settings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">LogType</a> &amp;&#160;</td>
          <td class="paramname"><em>log</em> = <code><a class="el" href="group__miscellaneous.html#ga3377e3c875ec245e90ac5a395105ce99">nullLogger</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Saves a mesh to a file with the given filename. Checks automatically the file format to save from the given filename. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MeshType</td><td>The type of mesh to save. It must satisfy the MeshConcept. </td></tr>
    <tr><td class="paramname">LogType</td><td>The type of logger to use. It must satisfy the LoggerConcept.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>The mesh object to save. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filename</td><td>The filename of the file where to save the mesh data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">settings</td><td>Settings for saving the file. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">log</td><td>The logger object to use for logging messages during saving. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab7970b2e595a2606a0a6d38a792cd3ad" name="ab7970b2e595a2606a0a6d38a792cd3ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7970b2e595a2606a0a6d38a792cd3ad">&#9670;&#160;</a></span>saveImageData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">void</a> vcl::saveImageData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">int</a>&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">int</a>&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="classvcl_1_1Matrix.html">unsigned</a> <a class="el" href="classvcl_1_1Matrix.html">char</a> *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a>&#160;</td>
          <td class="paramname"><em>quality</em> = <code>90</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aba2732159a83341a0a30e462023d2984" name="aba2732159a83341a0a30e462023d2984"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba2732159a83341a0a30e462023d2984">&#9670;&#160;</a></span>saveObj() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType, LoggerConcept LogType = NullLogger&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">void</a> vcl::saveObj </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="structvcl_1_1SaveSettings.html">SaveSettings</a> &amp;&#160;</td>
          <td class="paramname"><em>settings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">LogType</a> &amp;&#160;</td>
          <td class="paramname"><em>log</em> = <code><a class="el" href="group__miscellaneous.html#ga3377e3c875ec245e90ac5a395105ce99">nullLogger</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab88bf72e736841da046b3989aaef757f" name="ab88bf72e736841da046b3989aaef757f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab88bf72e736841da046b3989aaef757f">&#9670;&#160;</a></span>saveObj() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType, LoggerConcept LogType = NullLogger&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">void</a> vcl::saveObj </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">LogType</a> &amp;&#160;</td>
          <td class="paramname"><em>log</em> = <code><a class="el" href="group__miscellaneous.html#ga3377e3c875ec245e90ac5a395105ce99">nullLogger</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="structvcl_1_1SaveSettings.html">SaveSettings</a> &amp;&#160;</td>
          <td class="paramname"><em>settings</em> = <code><a class="el" href="structvcl_1_1SaveSettings.html">SaveSettings</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac7e5770fccdeac13be7dc8d0061f9659" name="ac7e5770fccdeac13be7dc8d0061f9659"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7e5770fccdeac13be7dc8d0061f9659">&#9670;&#160;</a></span>saveObj() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType, LoggerConcept LogType = NullLogger&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">void</a> vcl::saveObj </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>fp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="structvcl_1_1SaveSettings.html">SaveSettings</a> &amp;&#160;</td>
          <td class="paramname"><em>settings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">LogType</a> &amp;&#160;</td>
          <td class="paramname"><em>log</em> = <code><a class="el" href="group__miscellaneous.html#ga3377e3c875ec245e90ac5a395105ce99">nullLogger</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac380fcb4c9c863de61d8849d980afa2e" name="ac380fcb4c9c863de61d8849d980afa2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac380fcb4c9c863de61d8849d980afa2e">&#9670;&#160;</a></span>saveObj() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType, LoggerConcept LogType = NullLogger&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">void</a> vcl::saveObj </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>fp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">LogType</a> &amp;&#160;</td>
          <td class="paramname"><em>log</em> = <code><a class="el" href="group__miscellaneous.html#ga3377e3c875ec245e90ac5a395105ce99">nullLogger</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="structvcl_1_1SaveSettings.html">SaveSettings</a> &amp;&#160;</td>
          <td class="paramname"><em>settings</em> = <code><a class="el" href="structvcl_1_1SaveSettings.html">SaveSettings</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5b3bf569c152577b42fd7457844810da" name="a5b3bf569c152577b42fd7457844810da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b3bf569c152577b42fd7457844810da">&#9670;&#160;</a></span>saveObj() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType, LoggerConcept LogType = NullLogger&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">void</a> vcl::saveObj </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>fp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>mtlfp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="structvcl_1_1SaveSettings.html">SaveSettings</a> &amp;&#160;</td>
          <td class="paramname"><em>settings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">LogType</a> &amp;&#160;</td>
          <td class="paramname"><em>log</em> = <code><a class="el" href="group__miscellaneous.html#ga3377e3c875ec245e90ac5a395105ce99">nullLogger</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0c4772dc391aa32c2a0b6b3b88f375a5" name="a0c4772dc391aa32c2a0b6b3b88f375a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c4772dc391aa32c2a0b6b3b88f375a5">&#9670;&#160;</a></span>saveObj() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType, LoggerConcept LogType = NullLogger&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">void</a> vcl::saveObj </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>fp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>mtlfp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">LogType</a> &amp;&#160;</td>
          <td class="paramname"><em>log</em> = <code><a class="el" href="group__miscellaneous.html#ga3377e3c875ec245e90ac5a395105ce99">nullLogger</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="structvcl_1_1SaveSettings.html">SaveSettings</a> &amp;&#160;</td>
          <td class="paramname"><em>settings</em> = <code><a class="el" href="structvcl_1_1SaveSettings.html">SaveSettings</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac36029862245b69a249d5a407990436b" name="ac36029862245b69a249d5a407990436b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac36029862245b69a249d5a407990436b">&#9670;&#160;</a></span>saveOff() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType, LoggerConcept LogType = NullLogger&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">void</a> vcl::saveOff </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="structvcl_1_1SaveSettings.html">SaveSettings</a> &amp;&#160;</td>
          <td class="paramname"><em>settings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">LogType</a> &amp;&#160;</td>
          <td class="paramname"><em>log</em> = <code><a class="el" href="group__miscellaneous.html#ga3377e3c875ec245e90ac5a395105ce99">nullLogger</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab19ae9a0cb55d721a21e0d74dbbc4be9" name="ab19ae9a0cb55d721a21e0d74dbbc4be9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab19ae9a0cb55d721a21e0d74dbbc4be9">&#9670;&#160;</a></span>saveOff() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType, LoggerConcept LogType = NullLogger&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">void</a> vcl::saveOff </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">LogType</a> &amp;&#160;</td>
          <td class="paramname"><em>log</em> = <code><a class="el" href="group__miscellaneous.html#ga3377e3c875ec245e90ac5a395105ce99">nullLogger</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="structvcl_1_1SaveSettings.html">SaveSettings</a> &amp;&#160;</td>
          <td class="paramname"><em>settings</em> = <code><a class="el" href="structvcl_1_1SaveSettings.html">SaveSettings</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a55a3e435c00920652599f2e25aff5668" name="a55a3e435c00920652599f2e25aff5668"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55a3e435c00920652599f2e25aff5668">&#9670;&#160;</a></span>saveOff() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType, LoggerConcept LogType = NullLogger&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">void</a> vcl::saveOff </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>fp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="structvcl_1_1SaveSettings.html">SaveSettings</a> &amp;&#160;</td>
          <td class="paramname"><em>settings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">LogType</a> &amp;&#160;</td>
          <td class="paramname"><em>log</em> = <code><a class="el" href="group__miscellaneous.html#ga3377e3c875ec245e90ac5a395105ce99">nullLogger</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af30239e4decbd70237fd851685ca91af" name="af30239e4decbd70237fd851685ca91af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af30239e4decbd70237fd851685ca91af">&#9670;&#160;</a></span>saveOff() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType, LoggerConcept LogType = NullLogger&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">void</a> vcl::saveOff </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>fp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">LogType</a> &amp;&#160;</td>
          <td class="paramname"><em>log</em> = <code><a class="el" href="group__miscellaneous.html#ga3377e3c875ec245e90ac5a395105ce99">nullLogger</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="structvcl_1_1SaveSettings.html">SaveSettings</a> &amp;&#160;</td>
          <td class="paramname"><em>settings</em> = <code><a class="el" href="structvcl_1_1SaveSettings.html">SaveSettings</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0d5216e450e5401b0a2140547a181cc4" name="a0d5216e450e5401b0a2140547a181cc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d5216e450e5401b0a2140547a181cc4">&#9670;&#160;</a></span>savePly() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType, LoggerConcept LogType = NullLogger&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">void</a> vcl::savePly </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="structvcl_1_1SaveSettings.html">SaveSettings</a> &amp;&#160;</td>
          <td class="paramname"><em>settings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">LogType</a> &amp;&#160;</td>
          <td class="paramname"><em>log</em> = <code><a class="el" href="group__miscellaneous.html#ga3377e3c875ec245e90ac5a395105ce99">nullLogger</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abb4c76b10afab737e57b2bc224a60bba" name="abb4c76b10afab737e57b2bc224a60bba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb4c76b10afab737e57b2bc224a60bba">&#9670;&#160;</a></span>savePly() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType, LoggerConcept LogType = NullLogger&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">void</a> vcl::savePly </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">LogType</a> &amp;&#160;</td>
          <td class="paramname"><em>log</em> = <code><a class="el" href="group__miscellaneous.html#ga3377e3c875ec245e90ac5a395105ce99">nullLogger</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="structvcl_1_1SaveSettings.html">SaveSettings</a> &amp;&#160;</td>
          <td class="paramname"><em>settings</em> = <code><a class="el" href="structvcl_1_1SaveSettings.html">SaveSettings</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad2d567e8169973c8b6948d7ba9ae2f5b" name="ad2d567e8169973c8b6948d7ba9ae2f5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2d567e8169973c8b6948d7ba9ae2f5b">&#9670;&#160;</a></span>savePly() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType, LoggerConcept LogType = NullLogger&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">void</a> vcl::savePly </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>fp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="structvcl_1_1SaveSettings.html">SaveSettings</a> &amp;&#160;</td>
          <td class="paramname"><em>settings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">LogType</a> &amp;&#160;</td>
          <td class="paramname"><em>log</em> = <code><a class="el" href="group__miscellaneous.html#ga3377e3c875ec245e90ac5a395105ce99">nullLogger</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae7f540d003359dcb537a9a9bd371ecc3" name="ae7f540d003359dcb537a9a9bd371ecc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7f540d003359dcb537a9a9bd371ecc3">&#9670;&#160;</a></span>savePly() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType, LoggerConcept LogType = NullLogger&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">void</a> vcl::savePly </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>fp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">LogType</a> &amp;&#160;</td>
          <td class="paramname"><em>log</em> = <code><a class="el" href="group__miscellaneous.html#ga3377e3c875ec245e90ac5a395105ce99">nullLogger</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="structvcl_1_1SaveSettings.html">SaveSettings</a> &amp;&#160;</td>
          <td class="paramname"><em>settings</em> = <code><a class="el" href="structvcl_1_1SaveSettings.html">SaveSettings</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9236f9a9fb72ab815a010ad4f16bd024" name="a9236f9a9fb72ab815a010ad4f16bd024"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9236f9a9fb72ab815a010ad4f16bd024">&#9670;&#160;</a></span>saveStl() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType, LoggerConcept LogType = NullLogger&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">void</a> vcl::saveStl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="structvcl_1_1SaveSettings.html">SaveSettings</a> &amp;&#160;</td>
          <td class="paramname"><em>settings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">LogType</a> &amp;&#160;</td>
          <td class="paramname"><em>log</em> = <code><a class="el" href="group__miscellaneous.html#ga3377e3c875ec245e90ac5a395105ce99">nullLogger</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a979472e4bb92ef4df1a5001732090736" name="a979472e4bb92ef4df1a5001732090736"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a979472e4bb92ef4df1a5001732090736">&#9670;&#160;</a></span>saveStl() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType, LoggerConcept LogType = NullLogger&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">void</a> vcl::saveStl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">LogType</a> &amp;&#160;</td>
          <td class="paramname"><em>log</em> = <code><a class="el" href="group__miscellaneous.html#ga3377e3c875ec245e90ac5a395105ce99">nullLogger</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="structvcl_1_1SaveSettings.html">SaveSettings</a> &amp;&#160;</td>
          <td class="paramname"><em>settings</em> = <code><a class="el" href="structvcl_1_1SaveSettings.html">SaveSettings</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abafec546bb33b770cc260e75643ac101" name="abafec546bb33b770cc260e75643ac101"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abafec546bb33b770cc260e75643ac101">&#9670;&#160;</a></span>saveStl() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType, LoggerConcept LogType = NullLogger&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">void</a> vcl::saveStl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>fp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="structvcl_1_1SaveSettings.html">SaveSettings</a> &amp;&#160;</td>
          <td class="paramname"><em>settings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">LogType</a> &amp;&#160;</td>
          <td class="paramname"><em>log</em> = <code><a class="el" href="group__miscellaneous.html#ga3377e3c875ec245e90ac5a395105ce99">nullLogger</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a466fdb28942beb260111ef9ce39130d3" name="a466fdb28942beb260111ef9ce39130d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a466fdb28942beb260111ef9ce39130d3">&#9670;&#160;</a></span>saveStl() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType, LoggerConcept LogType = NullLogger&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">void</a> vcl::saveStl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>fp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">LogType</a> &amp;&#160;</td>
          <td class="paramname"><em>log</em> = <code><a class="el" href="group__miscellaneous.html#ga3377e3c875ec245e90ac5a395105ce99">nullLogger</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="structvcl_1_1SaveSettings.html">SaveSettings</a> &amp;&#160;</td>
          <td class="paramname"><em>settings</em> = <code><a class="el" href="structvcl_1_1SaveSettings.html">SaveSettings</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a63bff22265d64d974b4fe4267b6dbac0" name="a63bff22265d64d974b4fe4267b6dbac0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63bff22265d64d974b4fe4267b6dbac0">&#9670;&#160;</a></span>scalarWeightedBarycenter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">MeshType::VertexType::CoordType vcl::scalarWeightedBarycenter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the barycenter of the mesh weighted on the per vertex quality values. </p>
<p>The output baryceter is computed as a weighted average of the vertices of the mesh, using the per <a class="el" href="classvcl_1_1Vertex.html" title="The Vertex class represents an Vertex element of the vcl::Mesh class.">Vertex</a> Quality values as weights.</p>
<p>Requirements:</p><ul>
<li><a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>:<ul>
<li>Vertices:<ul>
<li>Quality</li>
</ul>
</li>
</ul>
</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>input mesh on which compute the barycenter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The barycenter weighted on the per vertex quality. </dd></dl>

</div>
</div>
<a id="a5217f309d49911db6e36a4f6d31acdaa" name="a5217f309d49911db6e36a4f6d31acdaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5217f309d49911db6e36a4f6d31acdaa">&#9670;&#160;</a></span>scale() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType, PointConcept PointType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">void</a> vcl::scale </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> PointType &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad7f4da00ff716cc6e58e2e9ade275d6a" name="ad7f4da00ff716cc6e58e2e9ade275d6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7f4da00ff716cc6e58e2e9ade275d6a">&#9670;&#160;</a></span>scale() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType, <a class="el" href="classvcl_1_1Matrix.html">typename</a> Scalar  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">void</a> vcl::scale </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> Scalar &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad22242be96fcd8ea8fd0f4ab4bd9c8fa" name="ad22242be96fcd8ea8fd0f4ab4bd9c8fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad22242be96fcd8ea8fd0f4ab4bd9c8fa">&#9670;&#160;</a></span>selectCreaseFaceEdges()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">void</a> vcl::selectCreaseFaceEdges </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">double</a>&#160;</td>
          <td class="paramname"><em>angleRadNeg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">double</a>&#160;</td>
          <td class="paramname"><em>angleRadPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">bool</a>&#160;</td>
          <td class="paramname"><em>alsoBorderEdges</em> = <code><a class="el" href="classvcl_1_1Matrix.html">false</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aaec6c356404a0bf3eb24a29e867004df" name="aaec6c356404a0bf3eb24a29e867004df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaec6c356404a0bf3eb24a29e867004df">&#9670;&#160;</a></span>selectNonManifoldVertices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">void</a> vcl::selectNonManifoldVertices </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">bool</a>&#160;</td>
          <td class="paramname"><em>clearSelectionFirst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1752045db61b3ba5688131a9795199b1" name="a1752045db61b3ba5688131a9795199b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1752045db61b3ba5688131a9795199b1">&#9670;&#160;</a></span>serialize() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classvcl_1_1Matrix.html">typename</a> T , std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">void</a> vcl::serialize </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> std::array&lt; T, <a class="el" href="classvcl_1_1Matrix.html">N</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Serialize specializations ///. </p>

</div>
</div>
<a id="ac4b850dbc2d9419d8f8bce37ea4a6e68" name="ac4b850dbc2d9419d8f8bce37ea4a6e68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4b850dbc2d9419d8f8bce37ea4a6e68">&#9670;&#160;</a></span>serialize() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">void</a> vcl::serialize </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab54d08593ddeb3bded76b3c06ae69ba5" name="ab54d08593ddeb3bded76b3c06ae69ba5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab54d08593ddeb3bded76b3c06ae69ba5">&#9670;&#160;</a></span>serialize() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classvcl_1_1Matrix.html">typename</a> T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">void</a> vcl::serialize </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8ed54da403c1a9f64bc3a0d01b47b4d0" name="a8ed54da403c1a9f64bc3a0d01b47b4d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ed54da403c1a9f64bc3a0d01b47b4d0">&#9670;&#160;</a></span>serialize() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classvcl_1_1Matrix.html">typename</a> T , typename... Others&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">void</a> vcl::serialize </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> T &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="classvcl_1_1Matrix.html">Others</a> &amp;...&#160;</td>
          <td class="paramname"><em>others</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae0f9865a748e4167c16d86a685220bc5" name="ae0f9865a748e4167c16d86a685220bc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0f9865a748e4167c16d86a685220bc5">&#9670;&#160;</a></span>serialize() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;IsNotClass T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">void</a> vcl::serialize </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> T &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::endian&#160;</td>
          <td class="paramname"><em>endian</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Serialize data to an output stream, using the specified endian format. </p>
<p>The endian format specifies if the data should be converted to a different endianness w.r.t. the native one.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">os</td><td>output stream. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>data to serialize. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">endian</td><td>endian format of the serialization. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a80c041438e1f1466941101be64525eda" name="a80c041438e1f1466941101be64525eda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80c041438e1f1466941101be64525eda">&#9670;&#160;</a></span>serializeN()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classvcl_1_1Matrix.html">typename</a> T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">void</a> vcl::serializeN </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> T *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::endian&#160;</td>
          <td class="paramname"><em>endian</em> = <code>std::endian::little</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Serialize an array of contiguous data to an output stream, using the specified format. </p>
<p>The endian format specifies if the data should be converted to a different endianness w.r.t. the native one.</p>
<p>By default, the serialization is done in binary little endian format.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">os</td><td>output stream. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>pointer to the data to serialize. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>number of elements to serialize. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">endian</td><td>endian format of the serialization. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa949e95f7bfb9d8dedc0f7e15e5d3ab9" name="aa949e95f7bfb9d8dedc0f7e15e5d3ab9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa949e95f7bfb9d8dedc0f7e15e5d3ab9">&#9670;&#160;</a></span>setPerFaceQuality()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">void</a> vcl::setPerFaceQuality </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">typename</a> MeshType::FaceType::QualityType&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets a constant value to all the face quality of the mesh. </p>
<p>Requirements:</p><ul>
<li><a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>:<ul>
<li>Faces:<ul>
<li>Quality</li>
</ul>
</li>
</ul>
</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">m</td><td>mesh on which set the face quality </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>quality value to set </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab9e9aa9515cb4086de430109e361cfde" name="ab9e9aa9515cb4086de430109e361cfde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9e9aa9515cb4086de430109e361cfde">&#9670;&#160;</a></span>setPerFaceQualityFromFaceArea()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">void</a> vcl::setPerFaceQualityFromFaceArea </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assign to the face quality of the mesh the area of each face. </p>
<p>Requirements:</p><ul>
<li><a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>:<ul>
<li>Faces<ul>
<li>Quality</li>
</ul>
</li>
</ul>
</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">m</td><td>mesh on which set the face quality to the face area </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a745a7eed34f93850095b2c81f127d9f6" name="a745a7eed34f93850095b2c81f127d9f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a745a7eed34f93850095b2c81f127d9f6">&#9670;&#160;</a></span>setPerVertexQuality()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">void</a> vcl::setPerVertexQuality </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">typename</a> MeshType::VertexType::QualityType&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets a constant value to all the vertex quality of the mesh. </p>
<p>Requirements:</p><ul>
<li><a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>:<ul>
<li>Vertices:<ul>
<li>Quality</li>
</ul>
</li>
</ul>
</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">m</td><td>mesh on which set the vertex quality </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>quality value to set </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4120bcf201dd0de7e75bbd2e39a658df" name="a4120bcf201dd0de7e75bbd2e39a658df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4120bcf201dd0de7e75bbd2e39a658df">&#9670;&#160;</a></span>setPerVertexQualityFromPrincipalCurvatureCurvedness()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">void</a> vcl::setPerVertexQualityFromPrincipalCurvatureCurvedness </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the Curvedness C from the Principal Curvature, as defined by [Koenderink 1992] and stores it in the per-vertex quality. </p>
<p>C = Sqrt((k1*k1+k2*k2)/2.0)</p>
<p>J. Koenderink and A. van Doorn. Surface shape and curvature scales. <a class="el" href="classvcl_1_1Image.html" title="The Image class stores an Image in 4 bytes RGBA format.">Image</a> and vision computing, 10(8):557–565, 1992. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2b31235ba7d846238e202713eaaa0495" name="a2b31235ba7d846238e202713eaaa0495"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b31235ba7d846238e202713eaaa0495">&#9670;&#160;</a></span>setPerVertexQualityFromPrincipalCurvatureGaussian()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">void</a> vcl::setPerVertexQualityFromPrincipalCurvatureGaussian </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7b1d34773ec1878660fe407a4768b67b" name="a7b1d34773ec1878660fe407a4768b67b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b1d34773ec1878660fe407a4768b67b">&#9670;&#160;</a></span>setPerVertexQualityFromPrincipalCurvatureMaxValue()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">void</a> vcl::setPerVertexQualityFromPrincipalCurvatureMaxValue </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a88a3a13cc9462bac2a7e1e578cddf540" name="a88a3a13cc9462bac2a7e1e578cddf540"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88a3a13cc9462bac2a7e1e578cddf540">&#9670;&#160;</a></span>setPerVertexQualityFromPrincipalCurvatureMean()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">void</a> vcl::setPerVertexQualityFromPrincipalCurvatureMean </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a88daff53e6272feb2b26432246c0f848" name="a88daff53e6272feb2b26432246c0f848"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88daff53e6272feb2b26432246c0f848">&#9670;&#160;</a></span>setPerVertexQualityFromPrincipalCurvatureMinValue()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">void</a> vcl::setPerVertexQualityFromPrincipalCurvatureMinValue </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2fa908d1710912a11715aedca11ecb76" name="a2fa908d1710912a11715aedca11ecb76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fa908d1710912a11715aedca11ecb76">&#9670;&#160;</a></span>setPerVertexQualityFromPrincipalCurvatureShapeIndex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">void</a> vcl::setPerVertexQualityFromPrincipalCurvatureShapeIndex </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the Shape Index S from the Principal Curvature, as defined by [Koenderink 1992] and stores it in the per-vertex quality. </p>
<p>S = 2/pi atan(k1+k2/k1-k2)</p>
<p>J. Koenderink and A. van Doorn. Surface shape and curvature scales. <a class="el" href="classvcl_1_1Image.html" title="The Image class stores an Image in 4 bytes RGBA format.">Image</a> and vision computing, 10(8):557–565, 1992. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af8b71c44c2c2e9adcc6bad8e278e7010" name="af8b71c44c2c2e9adcc6bad8e278e7010"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8b71c44c2c2e9adcc6bad8e278e7010">&#9670;&#160;</a></span>setPerVertexQualityFromVertexValence()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">void</a> vcl::setPerVertexQualityFromVertexValence </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assign to the vertex quality of the mesh the valence of each vertex, that is the number of adjacent faces of the vertex. </p>
<p>Requirements:</p><ul>
<li><a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>:<ul>
<li>Vertices:<ul>
<li>Quality</li>
</ul>
</li>
<li>Faces</li>
</ul>
</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">m</td><td>mesh on which set the vertex quality to the vertex valence </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aeae3bed7ce8fef5657452d857cf87bed" name="aeae3bed7ce8fef5657452d857cf87bed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeae3bed7ce8fef5657452d857cf87bed">&#9670;&#160;</a></span>setTransformMatrixRotation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MatrixConcept MatrixType, Point3Concept PointType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">void</a> vcl::setTransformMatrixRotation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">MatrixType</a> &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> PointType &amp;&#160;</td>
          <td class="paramname"><em>fromVector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> PointType &amp;&#160;</td>
          <td class="paramname"><em>toVector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given two 3D vectors, fills the given matrix with a transform matrix that represents the rotation matrix from the first vector to the second vector. </p>
<p>The given matrix must be at least a 3x3 matrix. If the matrix is a higher than 3x3 (e.g. 4x4), only the 3x3 submatrix will be set, leaving unchanged the other values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix</td><td></td></tr>
    <tr><td class="paramname">fromVector</td><td></td></tr>
    <tr><td class="paramname">toVector</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a24901186f1a77f31a23d64f30f0b0dc3" name="a24901186f1a77f31a23d64f30f0b0dc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24901186f1a77f31a23d64f30f0b0dc3">&#9670;&#160;</a></span>setTransformMatrixRotation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MatrixConcept MatrixType, Point3Concept PointType, <a class="el" href="classvcl_1_1Matrix.html">typename</a> ScalarType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">void</a> vcl::setTransformMatrixRotation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">MatrixType</a> &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PointType&#160;</td>
          <td class="paramname"><em>axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> ScalarType &amp;&#160;</td>
          <td class="paramname"><em>angleRad</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given an 3D axis and an angle expressed in randiants, fills the given matrix with a transform matrix that represents the rotation matrix of the given axis/angle. </p>
<p>The given matrix must be at least a 3x3 matrix. If the matrix is a higher than 3x3 (e.g. 4x4), only the 3x3 submatrix will be set, leaving unchanged the other values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix</td><td></td></tr>
    <tr><td class="paramname">axis</td><td></td></tr>
    <tr><td class="paramname">angleRad</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abd5d95d87600e42a0da835735e35ea99" name="abd5d95d87600e42a0da835735e35ea99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd5d95d87600e42a0da835735e35ea99">&#9670;&#160;</a></span>setTransformMatrixRotationDeg()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MatrixConcept MatrixType, Point3Concept PointType, <a class="el" href="classvcl_1_1Matrix.html">typename</a> ScalarType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">void</a> vcl::setTransformMatrixRotationDeg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">MatrixType</a> &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PointType&#160;</td>
          <td class="paramname"><em>axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> ScalarType &amp;&#160;</td>
          <td class="paramname"><em>angleDeg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given an 3D axis and an angle expressed in degrees, fills the given matrix with a transform matrix that represents the rotation matrix of the given axis/angle. </p>
<p>The given matrix must be at least a 3x3 matrix. If the matrix is a higher than 3x3 (e.g. 4x4), only the 3x3 submatrix will be set, leaving unchanged the other values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix</td><td></td></tr>
    <tr><td class="paramname">axis</td><td></td></tr>
    <tr><td class="paramname">angleDeg</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2bc1039bda53b44dfcefd9be1cdf1d9a" name="a2bc1039bda53b44dfcefd9be1cdf1d9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bc1039bda53b44dfcefd9be1cdf1d9a">&#9670;&#160;</a></span>setTransformMatrixScale() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MatrixConcept MatrixType, Point3Concept PointType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">void</a> vcl::setTransformMatrixScale </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">MatrixType</a> &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> PointType &amp;&#160;</td>
          <td class="paramname"><em>scale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a060ef5e5d4c2fcf544a6102154e0eed8" name="a060ef5e5d4c2fcf544a6102154e0eed8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a060ef5e5d4c2fcf544a6102154e0eed8">&#9670;&#160;</a></span>setTransformMatrixScale() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MatrixConcept MatrixType, <a class="el" href="classvcl_1_1Matrix.html">typename</a> ScalarType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">void</a> vcl::setTransformMatrixScale </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">MatrixType</a> &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> ScalarType &amp;&#160;</td>
          <td class="paramname"><em>scale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a097be0ad25e27900059458ab8dc0b041" name="a097be0ad25e27900059458ab8dc0b041"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a097be0ad25e27900059458ab8dc0b041">&#9670;&#160;</a></span>setTransformMatrixTranslation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MatrixConcept MatrixType, Point3Concept PointType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">void</a> vcl::setTransformMatrixTranslation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">MatrixType</a> &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> PointType &amp;&#160;</td>
          <td class="paramname"><em>translation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aecc52dfd02e09e49a5dd1612183a2cb8" name="aecc52dfd02e09e49a5dd1612183a2cb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecc52dfd02e09e49a5dd1612183a2cb8">&#9670;&#160;</a></span>shellBarycenter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">MeshType::VertexType::CoordType vcl::shellBarycenter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the barycenter of the surface thin-shell. E.g. it assume a 'empty' model where all the mass is located on the surface and compute the barycenter of that thinshell. Works for any polygonal model (no problem with open, nonmanifold selfintersecting models). Useful for computing the barycenter of 2D planar figures. </p>
<p>Requirements:</p><ul>
<li><a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>:<ul>
<li>Vertices</li>
<li>Faces</li>
</ul>
</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a33f84f8e28d1adf77369c920bb0e46b5" name="a33f84f8e28d1adf77369c920bb0e46b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33f84f8e28d1adf77369c920bb0e46b5">&#9670;&#160;</a></span>smoothPerVertexNormalsPointCloud() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType, PointConcept PointType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">void</a> vcl::smoothPerVertexNormalsPointCloud </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="classvcl_1_1KDTree.html">KDTree</a>&lt; PointType &gt; &amp;&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a>&#160;</td>
          <td class="paramname"><em>neighborNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a>&#160;</td>
          <td class="paramname"><em>iterNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>smoothPerVertexNormalsPointCloud </p>
<p>Requirements:</p><ul>
<li><a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>:<ul>
<li>Vertices:<ul>
<li>Normal</li>
</ul>
</li>
</ul>
</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td></td></tr>
    <tr><td class="paramname">tree</td><td></td></tr>
    <tr><td class="paramname">neighborNum</td><td></td></tr>
    <tr><td class="paramname">iterNum</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9a2005cb82322d607914a2e2dcd63e66" name="a9a2005cb82322d607914a2e2dcd63e66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a2005cb82322d607914a2e2dcd63e66">&#9670;&#160;</a></span>smoothPerVertexNormalsPointCloud() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">void</a> vcl::smoothPerVertexNormalsPointCloud </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a>&#160;</td>
          <td class="paramname"><em>neighborNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a>&#160;</td>
          <td class="paramname"><em>iterNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>smoothPerVertexNormalsPointCloud </p>
<p>Requirements:</p><ul>
<li><a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>:<ul>
<li>Vertices:<ul>
<li>Normal</li>
</ul>
</li>
</ul>
</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td></td></tr>
    <tr><td class="paramname">neighborNum</td><td></td></tr>
    <tr><td class="paramname">iterNum</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0a1a624c7abe7c703618b7f512c33039" name="a0a1a624c7abe7c703618b7f512c33039"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a1a624c7abe7c703618b7f512c33039">&#9670;&#160;</a></span>Sphere()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Point3Concept P, <a class="el" href="classvcl_1_1Matrix.html">typename</a> T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Sphere.html">vcl::Sphere</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">P</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  <a class="el" href="classvcl_1_1Sphere.html">Sphere</a>&lt; <a class="el" href="classvcl_1_1Matrix.html">typename</a> P::ScalarType &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9349b9ea771a0058a9cb4a57eedd624b" name="a9349b9ea771a0058a9cb4a57eedd624b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9349b9ea771a0058a9cb4a57eedd624b">&#9670;&#160;</a></span>sphereBoxIntersect()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SphereConcept SphereType, Box3Concept BoxType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">bool</a> vcl::sphereBoxIntersect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="classvcl_1_1Matrix.html">SphereType</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> BoxType &amp;&#160;</td>
          <td class="paramname"><em>box</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks if a sphere intersects with a box in 3D space.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SphereType</td><td>A type that satisfies the SphereConcept concept. </td></tr>
    <tr><td class="paramname">BoxType</td><td>A type that satisfies the Box3Concept concept.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>The sphere to check for intersection. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">box</td><td>The box to check for intersection. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the sphere intersects with the box, false otherwise. </dd></dl>

</div>
</div>
<a id="a438da980623645640c78105766bde287" name="a438da980623645640c78105766bde287"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a438da980623645640c78105766bde287">&#9670;&#160;</a></span>sphericalFibonacciPointSet()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Point3Concept PointType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; PointType &gt; vcl::sphericalFibonacciPointSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a>&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a vector of <code>n</code> points distributed in a unit sphere. </p>
<p>This function returns a vector of <code>n</code> points that are uniformly distributed on a unit sphere, using the Spherical Fibonacci <a class="el" href="classvcl_1_1Point.html" title="The Point class represents an N-dimensional point containing N scalar values.">Point</a> Sets algorithm described in the paper "Spherical Fibonacci Mapping" by Benjamin Keinert, Matthias Innmann, Michael Sanger, and Marc Stamminger (TOG 2015).</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">PointType</td><td>The type of the point to generate. This type must satisfy the <code>Point3Concept</code> concept.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>The number of points to generate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of <code>n</code> points distributed in a unit sphere. </dd></dl>

</div>
</div>
<a id="ab1f5ecc820f6ab64fb437ba12296601c" name="ab1f5ecc820f6ab64fb437ba12296601c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1f5ecc820f6ab64fb437ba12296601c">&#9670;&#160;</a></span>StaticGrid() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;PointIteratorConcept It&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1StaticGrid.html">vcl::StaticGrid</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">It</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">It</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  <a class="el" href="classvcl_1_1StaticGrid.html">StaticGrid</a>&lt; <a class="el" href="classvcl_1_1RegularGrid.html">RegularGrid</a>&lt; <a class="el" href="classvcl_1_1Matrix.html">typename</a> It::value_type, It::value_type::DIM &gt;, <a class="el" href="classvcl_1_1Matrix.html">typename</a> It::value_type::ScalarType &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7586ced2cedb8cd2aa668c8136b24603" name="a7586ced2cedb8cd2aa668c8136b24603"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7586ced2cedb8cd2aa668c8136b24603">&#9670;&#160;</a></span>StaticGrid() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;PointIteratorConcept It, <a class="el" href="classvcl_1_1Matrix.html">typename</a> <a class="el" href="classvcl_1_1Matrix.html">F</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1StaticGrid.html">vcl::StaticGrid</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">It</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">It</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">F</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  <a class="el" href="classvcl_1_1StaticGrid.html">StaticGrid</a>&lt; <a class="el" href="classvcl_1_1RegularGrid.html">RegularGrid</a>&lt; <a class="el" href="classvcl_1_1Matrix.html">typename</a> It::value_type, It::value_type::DIM &gt;, <a class="el" href="classvcl_1_1Matrix.html">typename</a> It::value_type::ScalarType &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae6d4557abc45cc5daf2fe2e389b91ce9" name="ae6d4557abc45cc5daf2fe2e389b91ce9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6d4557abc45cc5daf2fe2e389b91ce9">&#9670;&#160;</a></span>StaticGrid() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;VertexPointerRangeConcept Rng&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1StaticGrid.html">vcl::StaticGrid</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">Rng</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt;  <a class="el" href="classvcl_1_1StaticGrid.html">StaticGrid</a>&lt; <a class="el" href="classvcl_1_1RegularGrid.html">RegularGrid</a>&lt; <a class="el" href="classvcl_1_1Matrix.html">typename</a> std::remove_pointer_t&lt; <a class="el" href="classvcl_1_1Matrix.html">typename</a> std::ranges::iterator_t&lt; <a class="el" href="classvcl_1_1Matrix.html">Rng</a> &gt;::value_type &gt;::CoordType::ScalarType, 3 &gt;, <a class="el" href="classvcl_1_1Matrix.html">typename</a> std::ranges::iterator_t&lt; <a class="el" href="classvcl_1_1Matrix.html">Rng</a> &gt;::value_type &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aaa57501f92552253dc35fc6cf5797540" name="aaa57501f92552253dc35fc6cf5797540"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa57501f92552253dc35fc6cf5797540">&#9670;&#160;</a></span>stlFormatCapability()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1MeshInfo.html">MeshInfo</a> vcl::stlFormatCapability </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6cc79547db9d6b6a15264fc004fec4dc" name="a6cc79547db9d6b6a15264fc004fec4dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cc79547db9d6b6a15264fc004fec4dc">&#9670;&#160;</a></span>stratifiedMontecarloPointSampling()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SamplerConcept SamplerType, FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">SamplerType</a> vcl::stratifiedMontecarloPointSampling </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a>&#160;</td>
          <td class="paramname"><em>nSamples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">bool</a>&#160;</td>
          <td class="paramname"><em>deterministic</em> = <code><a class="el" href="classvcl_1_1Matrix.html">false</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5dfa8d4e30b457c12c3e5e21b4fc123a" name="a5dfa8d4e30b457c12c3e5e21b4fc123a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5dfa8d4e30b457c12c3e5e21b4fc123a">&#9670;&#160;</a></span>surfaceArea()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">double</a> vcl::surfaceArea </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the surface area of the given <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>, that is the sum of the areas of each face of the mesh. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>mesh on which compute the surface area. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The surface area of the given mesh. </dd></dl>

</div>
</div>
<a id="a7d1a7878d6acec093a915b11413984aa" name="a7d1a7878d6acec093a915b11413984aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d1a7878d6acec093a915b11413984aa">&#9670;&#160;</a></span>taubinSmoothing()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">void</a> vcl::taubinSmoothing </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a>&#160;</td>
          <td class="paramname"><em>step</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">float</a>&#160;</td>
          <td class="paramname"><em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">float</a>&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">bool</a>&#160;</td>
          <td class="paramname"><em>smoothSelected</em> = <code><a class="el" href="classvcl_1_1Matrix.html">false</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1578b48cbfdb04c6675ac5a3b535bb83" name="a1578b48cbfdb04c6675ac5a3b535bb83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1578b48cbfdb04c6675ac5a3b535bb83">&#9670;&#160;</a></span>toDeg()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classvcl_1_1Matrix.html">typename</a> Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Scalar vcl::toDeg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> Scalar &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9bb7f6b147a8bc291fee7ef462f8a1bd" name="a9bb7f6b147a8bc291fee7ef462f8a1bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bb7f6b147a8bc291fee7ef462f8a1bd">&#9670;&#160;</a></span>toLower()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string vcl::toLower </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a53f705e848cce98dd23542a2d109e55b" name="a53f705e848cce98dd23542a2d109e55b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53f705e848cce98dd23542a2d109e55b">&#9670;&#160;</a></span>toRad()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classvcl_1_1Matrix.html">typename</a> Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Scalar vcl::toRad </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> Scalar &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9231ca38abac20eb8ced8246ab485899" name="a9231ca38abac20eb8ced8246ab485899"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9231ca38abac20eb8ced8246ab485899">&#9670;&#160;</a></span>toString()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classvcl_1_1Matrix.html">typename</a> T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string vcl::toString </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a value of type <code>T</code> to a string. </p>
<p>With respect to <code>std::to_string</code>, this function also works with pointers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>value to convert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>string representation of <code>val</code>. </dd></dl>

</div>
</div>
<a id="ac83671737ba679edb3511815c82494d1" name="ac83671737ba679edb3511815c82494d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac83671737ba679edb3511815c82494d1">&#9670;&#160;</a></span>toUpper()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string vcl::toUpper </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7c4a60eeed3ddead3611508975cb6045" name="a7c4a60eeed3ddead3611508975cb6045"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c4a60eeed3ddead3611508975cb6045">&#9670;&#160;</a></span>translate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType, PointConcept PointType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">void</a> vcl::translate </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> PointType &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9b3c4b3e9c618082e4fbd063afafccb4" name="a9b3c4b3e9c618082e4fbd063afafccb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b3c4b3e9c618082e4fbd063afafccb4">&#9670;&#160;</a></span>triangleBoxIntersect()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ConstTriangle3Concept TriangleType, Box3Concept BoxType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">bool</a> vcl::triangleBoxIntersect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="classvcl_1_1Matrix.html">TriangleType</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> BoxType &amp;&#160;</td>
          <td class="paramname"><em>box</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if a triangle intersects with a box. <a href="https://gist.github.com/jflipts/fc68d4eeacfcc04fbdb2bf38e0911850">https://gist.github.com/jflipts/fc68d4eeacfcc04fbdb2bf38e0911850</a>. </p>

</div>
</div>
<a id="ae809f70498bbba6366c684a9649c3fcf" name="ae809f70498bbba6366c684a9649c3fcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae809f70498bbba6366c684a9649c3fcf">&#9670;&#160;</a></span>trianglePointIntersect()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ConstTriangle2Concept TriangleType, Point2Concept PointType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">bool</a> vcl::trianglePointIntersect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="classvcl_1_1Matrix.html">TriangleType</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> PointType &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if a 3D point intersects/is inside a 3D triangle having its points in counterclockwise order. </p>
<p>Checks if a 2D point intersects with/is inside a given 2D triangle having its points in counterclockwise order.</p>
<p>The function checks if a point lies within a given triangle using barycentric coordinates. It first calculates the area of the triangle, and then calculates the barycentric coordinates of the point with respect to the triangle. If the barycentric coordinates satisfy certain conditions, then the point is considered to intersect with the triangle.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TriangleType</td><td>A type that satisfies the ConstTriangle2Concept concept. </td></tr>
    <tr><td class="paramname">PointType</td><td>A type that satisfies the Point2Concept concept.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>The triangle to test for intersection. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>The point to test for intersection with the triangle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the point intersects with/is inside the triangle, false otherwise.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TriangleType</td><td>A type that satisfies the ConstTriangle3Concept concept. </td></tr>
    <tr><td class="paramname">PointType</td><td>A type that satisfies the Point3Concept concept.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>The triangle to test for intersection. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>The point to test for intersection with the triangle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the point intersects with/is inside the triangle, false otherwise. </dd></dl>

</div>
</div>
<a id="a30d36d085ff633eeb80dd0397fd620bc" name="a30d36d085ff633eeb80dd0397fd620bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30d36d085ff633eeb80dd0397fd620bc">&#9670;&#160;</a></span>triangleSphereIntersect() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ConstTriangle3Concept TriangleType, SphereConcept SphereType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">bool</a> vcl::triangleSphereIntersect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="classvcl_1_1Matrix.html">TriangleType</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="classvcl_1_1Matrix.html">SphereType</a> &amp;&#160;</td>
          <td class="paramname"><em>sphere</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the intersection between a sphere and a triangle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>the 3D input triangle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sphere</td><td>the input sphere </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true iff there is an intersection between the sphere and the triangle </dd></dl>

</div>
</div>
<a id="a10776247e8f8601139d42d7000b86cb3" name="a10776247e8f8601139d42d7000b86cb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10776247e8f8601139d42d7000b86cb3">&#9670;&#160;</a></span>triangleSphereIntersect() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ConstTriangle3Concept TriangleType, SphereConcept SphereType, Point3Concept PointType, <a class="el" href="classvcl_1_1Matrix.html">typename</a> ScalarType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">bool</a> vcl::triangleSphereIntersect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="classvcl_1_1Matrix.html">TriangleType</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> <a class="el" href="classvcl_1_1Matrix.html">SphereType</a> &amp;&#160;</td>
          <td class="paramname"><em>sphere</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PointType &amp;&#160;</td>
          <td class="paramname"><em>witness</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::pair&lt; ScalarType, ScalarType &gt; &amp;&#160;</td>
          <td class="paramname"><em>res</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the intersection between a sphere and a triangle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>the 3D input triangle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sphere</td><td>the input sphere </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">witness</td><td>the point on the triangle nearest to the center of the sphere (even when there isn't intersection) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">res</td><td>if not null, in the first item is stored the minimum distance between the triangle and the sphere, while in the second item is stored the penetration depth </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true iff there is an intersection between the sphere and the triangle </dd></dl>

</div>
</div>
<a id="a08ddfb40632cb38ec4750610e0e2ebaa" name="a08ddfb40632cb38ec4750610e0e2ebaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08ddfb40632cb38ec4750610e0e2ebaa">&#9670;&#160;</a></span>tupleIndexByType()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classvcl_1_1Matrix.html">typename</a> T , <a class="el" href="classvcl_1_1Matrix.html">typename</a> <a class="el" href="classvcl_1_1Matrix.html">U</a> , typename... Us&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">constexpr</a> <a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a> vcl::tupleIndexByType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> std::tuple&lt; <a class="el" href="classvcl_1_1Matrix.html">U</a>, Us... &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the index of a type T in a std::tuple&lt;U, Us...&gt; passed as parameter; Returns UINT_NULL if the type T is not found in the tuple. </p>

</div>
</div>
<a id="a359b253b8af6d1ae3ac24625e8ac7a56" name="a359b253b8af6d1ae3ac24625e8ac7a56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a359b253b8af6d1ae3ac24625e8ac7a56">&#9670;&#160;</a></span>updateBorder()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">void</a> vcl::updateBorder </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes per-face border flags without requiring any kind of topology info. </p>
<p>Requirements:</p><ul>
<li><a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>:<ul>
<li>Vertices</li>
<li>Faces</li>
</ul>
</li>
</ul>
<p>Complexity: O(NF log (NF))</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>the mesh on which the border flags will be updated </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3db69fc234fc8072747aabf1724f9b92" name="a3db69fc234fc8072747aabf1724f9b92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3db69fc234fc8072747aabf1724f9b92">&#9670;&#160;</a></span>updatePerFaceAdjacentFaces()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">void</a> vcl::updatePerFaceAdjacentFaces </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates the per face adjacent face component. </p>
<p>All the faces that does not have an adjacent face (border) will have the adjacent face set to nullptr.</p>
<p>If there are non-manifold edges (edges on which there are more than two incident faces), then a chain-link composed of all the incident faces is built.</p>
<p>Assuming that we have 3 faces f0, f1 and f2 on the same edge composed of vi and vj, we can define the edge indices in the three faces as:</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classvcl_1_1Matrix.html">e0</a> = <a class="code hl_class" href="classvcl_1_1Matrix.html">f0</a>.indexOfEdge(<a class="code hl_class" href="classvcl_1_1Matrix.html">vi</a>, <a class="code hl_class" href="classvcl_1_1Matrix.html">vj</a>);</div>
<div class="line"><a class="code hl_class" href="classvcl_1_1Matrix.html">e1</a> = <a class="code hl_class" href="classvcl_1_1Matrix.html">f1</a>.indexOfEdge(<a class="code hl_class" href="classvcl_1_1Matrix.html">vi</a>, <a class="code hl_class" href="classvcl_1_1Matrix.html">vj</a>);</div>
<div class="line"><a class="code hl_class" href="classvcl_1_1Matrix.html">e2</a> = <a class="code hl_class" href="classvcl_1_1Matrix.html">f2</a>.indexOfEdge(<a class="code hl_class" href="classvcl_1_1Matrix.html">vi</a>, <a class="code hl_class" href="classvcl_1_1Matrix.html">vj</a>);</div>
</div><!-- fragment --><p>The adjacencies will cycle like:</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classvcl_1_1Matrix.html">f0</a>-&gt;adjFace(<a class="code hl_class" href="classvcl_1_1Matrix.html">e0</a>) == <a class="code hl_class" href="classvcl_1_1Matrix.html">f1</a>;</div>
<div class="line"><a class="code hl_class" href="classvcl_1_1Matrix.html">f1</a>-&gt;adjFace(<a class="code hl_class" href="classvcl_1_1Matrix.html">e1</a>) == <a class="code hl_class" href="classvcl_1_1Matrix.html">f2</a>;</div>
<div class="line"><a class="code hl_class" href="classvcl_1_1Matrix.html">f2</a>-&gt;adjFace(<a class="code hl_class" href="classvcl_1_1Matrix.html">e2</a>) == <a class="code hl_class" href="classvcl_1_1Matrix.html">f0</a>;</div>
</div><!-- fragment --><p>or a similar permutation of the faces.</p>
<p>In general, an edge is non-manifold if it is true the expression:</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classvcl_1_1Matrix.html">fj</a> = <a class="code hl_class" href="classvcl_1_1Matrix.html">fi</a>-&gt;adjFace(<a class="code hl_class" href="classvcl_1_1Matrix.html">ei</a>);</div>
<div class="line"><a class="code hl_class" href="classvcl_1_1Matrix.html">fj</a>-&gt;adjFace(<a class="code hl_class" href="classvcl_1_1Matrix.html">ej</a>) != <a class="code hl_class" href="classvcl_1_1Matrix.html">fi</a>; <span class="comment">// if true, the edge is non-manifold</span></div>
</div><!-- fragment --><p>Requirements:</p><ul>
<li><a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>:<ul>
<li>Faces:<ul>
<li>AdjacentFaces</li>
</ul>
</li>
</ul>
</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>the mesh on which update the per face adjacent faces. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a30ed1f8a6c4deb5ed255be33dec7ae1a" name="a30ed1f8a6c4deb5ed255be33dec7ae1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30ed1f8a6c4deb5ed255be33dec7ae1a">&#9670;&#160;</a></span>updatePerFaceNormals()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;LoggerConcept LogType = NullLogger&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">void</a> vcl::updatePerFaceNormals </td>
          <td>(</td>
          <td class="paramtype">FaceMeshConcept <a class="el" href="classvcl_1_1Matrix.html">auto</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">bool</a>&#160;</td>
          <td class="paramname"><em>normalize</em> = <code><a class="el" href="classvcl_1_1Matrix.html">true</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">LogType</a> &amp;&#160;</td>
          <td class="paramname"><em>log</em> = <code><a class="el" href="group__miscellaneous.html#ga3377e3c875ec245e90ac5a395105ce99">nullLogger</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes and sets the face normal. </p>
<p>The function works both for <a class="el" href="classvcl_1_1Triangle.html">Triangle</a> and Polygonal faces.</p>
<p>For polygonal faces, the normal is computed as the normalized sum of the cross products of each triplet of consecutive vertices of the face.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classvcl_1_1Polygon.html#a1682137a9e9d27da0544591a46e50fd8">vcl::Polygon::normal()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">mesh</td><td>the mesh on which compute the face normals. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">normalize</td><td>if true (default), normals are normalized after computation. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">log</td><td>The logger used to log the performed operations. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af3ecae45cc9e58f948dc04178fd6669b" name="af3ecae45cc9e58f948dc04178fd6669b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3ecae45cc9e58f948dc04178fd6669b">&#9670;&#160;</a></span>updatePerVertexAdjacentFaces()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">void</a> vcl::updatePerVertexAdjacentFaces </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates the adjacent faces of each vertex of the mesh. </p>
<p>Requirements:</p><ul>
<li><a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>:<ul>
<li>Vertices:<ul>
<li>AdjacentFaces</li>
</ul>
</li>
<li>Faces</li>
</ul>
</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>the mesh on which update the per vertex adjacent faces. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6b6e8d46b2b867729d95c72ab1925df2" name="a6b6e8d46b2b867729d95c72ab1925df2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b6e8d46b2b867729d95c72ab1925df2">&#9670;&#160;</a></span>updatePerVertexAdjacentVertices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">void</a> vcl::updatePerVertexAdjacentVertices </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates the adjacent vertices of each vertex of the mesh. </p>
<p>Requirements:</p><ul>
<li><a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>:<ul>
<li>Vertices:<ul>
<li>AdjacentVertices</li>
</ul>
</li>
<li>Faces</li>
</ul>
</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>the mesh on which update the per vertex adjacent faces. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a063ce05a627948b7fc5fbaa80bd8330d" name="a063ce05a627948b7fc5fbaa80bd8330d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a063ce05a627948b7fc5fbaa80bd8330d">&#9670;&#160;</a></span>updatePerVertexAndFaceNormals()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;LoggerConcept LogType = NullLogger&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">void</a> vcl::updatePerVertexAndFaceNormals </td>
          <td>(</td>
          <td class="paramtype">FaceMeshConcept <a class="el" href="classvcl_1_1Matrix.html">auto</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">bool</a>&#160;</td>
          <td class="paramname"><em>normalize</em> = <code><a class="el" href="classvcl_1_1Matrix.html">true</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">LogType</a> &amp;&#160;</td>
          <td class="paramname"><em>log</em> = <code><a class="el" href="group__miscellaneous.html#ga3377e3c875ec245e90ac5a395105ce99">nullLogger</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the face normals and then vertex normal as the angle weighted average. </p>
<p>The result is the same as calling <a class="el" href="namespacevcl.html#a30ed1f8a6c4deb5ed255be33dec7ae1a" title="Computes and sets the face normal.">updatePerFaceNormals()</a> and then <a class="el" href="namespacevcl.html#ab34ff241ba6e9a67648a4c86abc55624" title="Computes the vertex normal as the classic area weighted average.">updatePerVertexNormals()</a>, but it is more efficient because it exploits the (not yet normalized) face normals to compute the vertex normals.</p>
<p>Requirements:</p><ul>
<li><a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>:<ul>
<li>Vertices:<ul>
<li>Normal</li>
</ul>
</li>
<li>Faces<ul>
<li>Normal</li>
</ul>
</li>
</ul>
</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">mesh</td><td>the mesh on which compute the normals. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">normalize</td><td>if true (default), normals are normalized after computation. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">log</td><td>The logger used to log the performed operations. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab34ff241ba6e9a67648a4c86abc55624" name="ab34ff241ba6e9a67648a4c86abc55624"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab34ff241ba6e9a67648a4c86abc55624">&#9670;&#160;</a></span>updatePerVertexNormals()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;LoggerConcept LogType = NullLogger&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">void</a> vcl::updatePerVertexNormals </td>
          <td>(</td>
          <td class="paramtype">FaceMeshConcept <a class="el" href="classvcl_1_1Matrix.html">auto</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">bool</a>&#160;</td>
          <td class="paramname"><em>normalize</em> = <code><a class="el" href="classvcl_1_1Matrix.html">true</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">LogType</a> &amp;&#160;</td>
          <td class="paramname"><em>log</em> = <code><a class="el" href="group__miscellaneous.html#ga3377e3c875ec245e90ac5a395105ce99">nullLogger</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the vertex normal as the classic area weighted average. </p>
<p>This function does not need or exploit current face normals. Unreferenced vertex normals are left unchanged.</p>
<p>Requirements:</p><ul>
<li><a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>:<ul>
<li>Vertices:<ul>
<li>Normal</li>
</ul>
</li>
<li>Faces</li>
</ul>
</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">mesh</td><td>the mesh on which compute the vertex normals. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">normalize</td><td>if true (default), normals are normalized after computation. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">log</td><td>The logger used to log the performed operations. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad76bd2acfb577ac0946b35ee8b9acdb7" name="ad76bd2acfb577ac0946b35ee8b9acdb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad76bd2acfb577ac0946b35ee8b9acdb7">&#9670;&#160;</a></span>updatePerVertexNormalsAngleWeighted()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;LoggerConcept LogType = NullLogger&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">void</a> vcl::updatePerVertexNormalsAngleWeighted </td>
          <td>(</td>
          <td class="paramtype">FaceMeshConcept <a class="el" href="classvcl_1_1Matrix.html">auto</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">bool</a>&#160;</td>
          <td class="paramname"><em>normalize</em> = <code><a class="el" href="classvcl_1_1Matrix.html">true</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">LogType</a> &amp;&#160;</td>
          <td class="paramname"><em>log</em> = <code><a class="el" href="group__miscellaneous.html#ga3377e3c875ec245e90ac5a395105ce99">nullLogger</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the vertex normal as an angle weighted average. </p>
<p>The normal of a vertex <code>v</code> computed as a weighted sum the incident face normals. The weight is simlply the angle of the involved wedge. Described in:</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classvcl_1_1Matrix.html">G</a>. <a class="code hl_class" href="classvcl_1_1Matrix.html">Thurmer</a>, <a class="code hl_class" href="classvcl_1_1Matrix.html">C</a>. <a class="code hl_class" href="classvcl_1_1Matrix.html">A</a>. <a class="code hl_class" href="classvcl_1_1Matrix.html">Wuthrich</a></div>
<div class="line">  <span class="stringliteral">&quot;Computing vertex normals from polygonal facets&quot;</span></div>
<div class="line">  <a class="code hl_class" href="classvcl_1_1Matrix.html">Journal</a> <a class="code hl_class" href="classvcl_1_1Matrix.html">of</a> <a class="code hl_class" href="classvcl_1_1Matrix.html">Graphics</a> <a class="code hl_class" href="classvcl_1_1Matrix.html">Tools</a>, 1998</div>
</div><!-- fragment --><p>This function does not need or exploit current face normals. Unreferenced vertex normals are left unchanged.</p>
<p>Requirements:</p><ul>
<li><a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>:<ul>
<li>Vertices:<ul>
<li>Normal</li>
</ul>
</li>
<li>Faces</li>
</ul>
</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">mesh</td><td>the mesh on which compute the angle weighted vertex normals. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">normalize</td><td>if true (default), normals are normalized after computation. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">log</td><td>The logger used to log the performed operations. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae3c5aa91fdd7c8d4e5123493184f511d" name="ae3c5aa91fdd7c8d4e5123493184f511d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3c5aa91fdd7c8d4e5123493184f511d">&#9670;&#160;</a></span>updatePerVertexNormalsFromFaceNormals()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;LoggerConcept LogType = NullLogger&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">void</a> vcl::updatePerVertexNormalsFromFaceNormals </td>
          <td>(</td>
          <td class="paramtype">FaceMeshConcept <a class="el" href="classvcl_1_1Matrix.html">auto</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">bool</a>&#160;</td>
          <td class="paramname"><em>normalize</em> = <code><a class="el" href="classvcl_1_1Matrix.html">true</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">LogType</a> &amp;&#160;</td>
          <td class="paramname"><em>log</em> = <code><a class="el" href="group__miscellaneous.html#ga3377e3c875ec245e90ac5a395105ce99">nullLogger</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the vertex normal as the sum of the adjacent faces normals. </p>
<p>Unreferenced vertex normals are left unchanged.</p>
<p>Requirements:</p><ul>
<li><a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>:<ul>
<li>Vertices:<ul>
<li>Normal</li>
</ul>
</li>
<li>Faces<ul>
<li>Normal</li>
</ul>
</li>
</ul>
</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">mesh</td><td>the mesh on which compute the vertex normals. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">normalize</td><td>if true (default), normals are normalized after computation. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">log</td><td>The logger used to log the performed operations. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a764d9748bb6e05ba976be88ee7abe459" name="a764d9748bb6e05ba976be88ee7abe459"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a764d9748bb6e05ba976be88ee7abe459">&#9670;&#160;</a></span>updatePerVertexNormalsNelsonMaxWeighted()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;LoggerConcept LogType = NullLogger&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">void</a> vcl::updatePerVertexNormalsNelsonMaxWeighted </td>
          <td>(</td>
          <td class="paramtype">FaceMeshConcept <a class="el" href="classvcl_1_1Matrix.html">auto</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">bool</a>&#160;</td>
          <td class="paramname"><em>normalize</em> = <code><a class="el" href="classvcl_1_1Matrix.html">true</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">LogType</a> &amp;&#160;</td>
          <td class="paramname"><em>log</em> = <code><a class="el" href="group__miscellaneous.html#ga3377e3c875ec245e90ac5a395105ce99">nullLogger</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the vertex normal using the Max et al. weighting scheme. </p>
<p>The normal of a vertex v is computed according to the formula described in:</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classvcl_1_1Matrix.html">Max</a>, <a class="code hl_class" href="classvcl_1_1Matrix.html">N</a>.,</div>
<div class="line">  <span class="stringliteral">&quot;Weights for Computing Vertex Normals from Facet Normals&quot;</span>,</div>
<div class="line">  <a class="code hl_class" href="classvcl_1_1Matrix.html">Journal</a> <a class="code hl_class" href="classvcl_1_1Matrix.html">of</a> <a class="code hl_class" href="classvcl_1_1Matrix.html">Graphics</a> <a class="code hl_class" href="classvcl_1_1Matrix.html">Tools</a>, 4(2) (1999)</div>
</div><!-- fragment --><p>The weight for each wedge is the cross product of the two edge over the product of the square of the two edge lengths. According to the original paper it is perfect only for spherical surface, but it should perform well...</p>
<p>This function does not need or exploit current face normals. Unreferenced vertex normals are left unchanged.</p>
<p>Requirements:</p><ul>
<li><a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>:<ul>
<li>Vertices:<ul>
<li>Normal</li>
</ul>
</li>
<li>Faces</li>
</ul>
</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">mesh</td><td>the mesh on which compute the Max et al. weighted vertex normals. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">normalize</td><td>if true (default), normals are normalized after computation. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">log</td><td>The logger used to log the performed operations. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3c1237fab955f1bf4329842c6d3ed51a" name="a3c1237fab955f1bf4329842c6d3ed51a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c1237fab955f1bf4329842c6d3ed51a">&#9670;&#160;</a></span>updatePrincipalCurvature() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType, LoggerConcept LogType = NullLogger&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">void</a> vcl::updatePrincipalCurvature </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">LogType</a> &amp;&#160;</td>
          <td class="paramname"><em>log</em> = <code><a class="el" href="group__miscellaneous.html#ga3377e3c875ec245e90ac5a395105ce99">nullLogger</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8b3ad75679b446aabe75e8f1701bce67" name="a8b3ad75679b446aabe75e8f1701bce67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b3ad75679b446aabe75e8f1701bce67">&#9670;&#160;</a></span>updatePrincipalCurvature() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType, LoggerConcept LogType = NullLogger&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">void</a> vcl::updatePrincipalCurvature </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacevcl.html#aaca879a6bfd47ff8429d6b2f6cfa9440">VCLibPrincipalCurvatureAlgorithm</a>&#160;</td>
          <td class="paramname"><em>alg</em> = <code><a class="el" href="namespacevcl.html#aaca879a6bfd47ff8429d6b2f6cfa9440a16e818963316b0b43fcbdec6d75f25ed">VCL_PRINCIPAL_CURVATURE_TAUBIN95</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">LogType</a> &amp;&#160;</td>
          <td class="paramname"><em>log</em> = <code><a class="el" href="group__miscellaneous.html#ga3377e3c875ec245e90ac5a395105ce99">nullLogger</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac053ed0caa29edc306e54201f0bf6123" name="ac053ed0caa29edc306e54201f0bf6123"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac053ed0caa29edc306e54201f0bf6123">&#9670;&#160;</a></span>updatePrincipalCurvaturePCA()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType, LoggerConcept LogType = NullLogger&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">void</a> vcl::updatePrincipalCurvaturePCA </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">typename</a> MeshType::VertexType::CoordType::ScalarType&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">bool</a>&#160;</td>
          <td class="paramname"><em>montecarloSampling</em> = <code><a class="el" href="classvcl_1_1Matrix.html">true</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">LogType</a> &amp;&#160;</td>
          <td class="paramname"><em>log</em> = <code><a class="el" href="group__miscellaneous.html#ga3377e3c875ec245e90ac5a395105ce99">nullLogger</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the Principal Curvature meseaure as described in the paper: Robust principal curvatures on Multiple Scales, Yong-Liang Yang, Yu-Kun Lai, Shi-Min Hu Helmut Pottmann SGP 2004. If montecarloSampling==true the covariance is computed by montecarlo sampling on the mesh (faster); If montecarloSampling==false the covariance is computed by (analytic)integration over the surface (slower). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td></td></tr>
    <tr><td class="paramname">radius</td><td></td></tr>
    <tr><td class="paramname">montecarloSampling</td><td></td></tr>
    <tr><td class="paramname">log</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0953cccb4f94dded63edb630530e2197" name="a0953cccb4f94dded63edb630530e2197"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0953cccb4f94dded63edb630530e2197">&#9670;&#160;</a></span>updatePrincipalCurvatureTaubin95()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType, LoggerConcept LogType = NullLogger&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">void</a> vcl::updatePrincipalCurvatureTaubin95 </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">LogType</a> &amp;&#160;</td>
          <td class="paramname"><em>log</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a01810ffdfe2df3aa87e9de9c783a32a6" name="a01810ffdfe2df3aa87e9de9c783a32a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01810ffdfe2df3aa87e9de9c783a32a6">&#9670;&#160;</a></span>vertexColorsMatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MatrixConcept Matrix, MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">Matrix</a> vcl::vertexColorsMatrix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a #V*4 <a class="el" href="classvcl_1_1Matrix.html">Matrix</a> of integers containing the colors of the vertices of a <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>. The function is templated on the <a class="el" href="classvcl_1_1Matrix.html">Matrix</a> itself. </p>
<p>This function works with every <a class="el" href="classvcl_1_1Matrix.html">Matrix</a> type that satisfies the MatrixConcept, and requires that the mesh has per-vertex colors.</p>
<p>Usage example with Eigen <a class="el" href="classvcl_1_1Matrix.html">Matrix</a>:</p>
<div class="fragment"><div class="line">Eigen::MatrixX4i <a class="code hl_class" href="classvcl_1_1Matrix.html">VC</a> = <a class="code hl_class" href="classvcl_1_1Matrix.html">vcl::vertexColorsMatrix&lt;Eigen::MatrixX4i&gt;</a>(<a class="code hl_class" href="classvcl_1_1Matrix.html">myMesh</a>);</div>
</div><!-- fragment --><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classvcl_1_1MissingComponentException.html">vcl::MissingComponentException</a></td><td>if the mesh does not have per-vertex colors available.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function does not guarantee that the rows of the matrix correspond to the vertex indices of the mesh. This scenario is possible when the mesh has deleted vertices. To be sure to have a direct correspondence, compact the vertex container before calling this function.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>input mesh </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>#V*4 matrix of integers (vertex colors) </dd></dl>

</div>
</div>
<a id="aed0e167ce00c4dd8cf2b6400ceb24da3" name="aed0e167ce00c4dd8cf2b6400ceb24da3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed0e167ce00c4dd8cf2b6400ceb24da3">&#9670;&#160;</a></span>vertexNormalsMatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MatrixConcept Matrix, MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">Matrix</a> vcl::vertexNormalsMatrix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a #V*3 <a class="el" href="classvcl_1_1Matrix.html">Matrix</a> of scalars containing the normals of the vertices of a <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>. The function is templated on the <a class="el" href="classvcl_1_1Matrix.html">Matrix</a> itself. </p>
<p>This function works with every <a class="el" href="classvcl_1_1Matrix.html">Matrix</a> type that satisfies the MatrixConcept, and requires that the mesh has per-vertex normals.</p>
<p>Usage example with Eigen <a class="el" href="classvcl_1_1Matrix.html">Matrix</a>:</p>
<div class="fragment"><div class="line">Eigen::MatrixX3d <a class="code hl_class" href="classvcl_1_1Matrix.html">VN</a> = <a class="code hl_class" href="classvcl_1_1Matrix.html">vcl::vertexNormalsMatrix&lt;Eigen::MatrixX3d&gt;</a>(<a class="code hl_class" href="classvcl_1_1Matrix.html">myMesh</a>);</div>
</div><!-- fragment --><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classvcl_1_1MissingComponentException.html">vcl::MissingComponentException</a></td><td>if the mesh does not have per-vertex normals available.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function does not guarantee that the rows of the matrix correspond to the vertex indices of the mesh. This scenario is possible when the mesh has deleted vertices. To be sure to have a direct correspondence, compact the vertex container before calling this function.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>input mesh </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>#V*3 matrix of scalars (vertex normals) </dd></dl>

</div>
</div>
<a id="a9ed4ecc783b58f5327f0a6b68c071727" name="a9ed4ecc783b58f5327f0a6b68c071727"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ed4ecc783b58f5327f0a6b68c071727">&#9670;&#160;</a></span>vertexQualityAverage()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">auto</a> vcl::vertexQualityAverage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a scalar that is the average of the vertex quality. </p>
<p>Requirements:</p><ul>
<li><a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>:<ul>
<li>Vertices:<ul>
<li>Quality</li>
</ul>
</li>
</ul>
</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>the input <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a> on which compute the average of the quality. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The average of the vertex quality of the given mesh. </dd></dl>

</div>
</div>
<a id="a7cbfad9340b842c1bf68c7faf4ff9dc7" name="a7cbfad9340b842c1bf68c7faf4ff9dc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cbfad9340b842c1bf68c7faf4ff9dc7">&#9670;&#160;</a></span>vertexQualityHistogram()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType, <a class="el" href="classvcl_1_1Matrix.html">typename</a> <a class="el" href="classvcl_1_1Matrix.html">HScalar</a>  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Histogram.html">Histogram</a>&lt; <a class="el" href="classvcl_1_1Matrix.html">HScalar</a> &gt; vcl::vertexQualityHistogram </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">bool</a>&#160;</td>
          <td class="paramname"><em>selectionOnly</em> = <code><a class="el" href="classvcl_1_1Matrix.html">false</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a>&#160;</td>
          <td class="paramname"><em>histSize</em> = <code>10000</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae2972300f527bd1cce6182dde8b76c41" name="ae2972300f527bd1cce6182dde8b76c41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2972300f527bd1cce6182dde8b76c41">&#9670;&#160;</a></span>vertexQualityMinMax()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">auto</a> vcl::vertexQualityMinMax </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a pair containing the min and the maximum vertex quality. </p>
<p>Requirements:</p><ul>
<li><a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>:<ul>
<li>Vertices:<ul>
<li>Quality</li>
</ul>
</li>
</ul>
</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>the input <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a> on which compute the minimum and the maximum quality. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code>std::pair</code> having as first element the minimum, and as second element the maximum quality. </dd></dl>

</div>
</div>
<a id="a04201da836f3c6bc6eb9444319f7b492" name="a04201da836f3c6bc6eb9444319f7b492"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04201da836f3c6bc6eb9444319f7b492">&#9670;&#160;</a></span>vertexQualityVector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classvcl_1_1Matrix.html">typename</a> <a class="el" href="classvcl_1_1Matrix.html">Vect</a> , MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">Vect</a> vcl::vertexQualityVector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a #V <a class="el" href="classvcl_1_1Vector.html" title="The Vector class is a generic container of objects of type T, that could have fixed or dynamic size,...">Vector</a> of scalars containing the quality of the vertices of a <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>. The function is templated on the <a class="el" href="classvcl_1_1Vector.html" title="The Vector class is a generic container of objects of type T, that could have fixed or dynamic size,...">Vector</a> itself. </p>
<p>This function works with every <a class="el" href="classvcl_1_1Vector.html" title="The Vector class is a generic container of objects of type T, that could have fixed or dynamic size,...">Vector</a> type that has a constructor with a size_t argument and an operator(uint), and requires that the mesh has per-vertex quality.</p>
<p>Usage example with Eigen <a class="el" href="classvcl_1_1Vector.html" title="The Vector class is a generic container of objects of type T, that could have fixed or dynamic size,...">Vector</a>:</p>
<div class="fragment"><div class="line">Eigen::VectorXd <a class="code hl_class" href="classvcl_1_1Matrix.html">VQ</a> = <a class="code hl_class" href="classvcl_1_1Matrix.html">vcl::vertexQualityVector&lt;Eigen::VectorXd&gt;</a>(<a class="code hl_class" href="classvcl_1_1Matrix.html">myMesh</a>);</div>
</div><!-- fragment --><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classvcl_1_1MissingComponentException.html">vcl::MissingComponentException</a></td><td>if the mesh does not have per-vertex quality available.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function does not guarantee that the rows of the vector correspond to the vertex indices of the mesh. This scenario is possible when the mesh has deleted vertices. To be sure to have a direct correspondence, compact the vertex container before calling this function.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>input mesh </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>#V vector of scalars (vertex quality) </dd></dl>

</div>
</div>
<a id="ac6617580fead9a30c7c8db2e236e2a7a" name="ac6617580fead9a30c7c8db2e236e2a7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6617580fead9a30c7c8db2e236e2a7a">&#9670;&#160;</a></span>vertexQualityWeightedMontecarloPointSampling()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SamplerConcept SamplerType, FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">SamplerType</a> vcl::vertexQualityWeightedMontecarloPointSampling </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a>&#160;</td>
          <td class="paramname"><em>nSamples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">double</a>&#160;</td>
          <td class="paramname"><em>variance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">bool</a>&#160;</td>
          <td class="paramname"><em>deterministic</em> = <code><a class="el" href="classvcl_1_1Matrix.html">false</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa8a8d81401816c73db39eeae352e95bc" name="aa8a8d81401816c73db39eeae352e95bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8a8d81401816c73db39eeae352e95bc">&#9670;&#160;</a></span>vertexRadiusFromQuality()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classvcl_1_1Matrix.html">typename</a> MeshType::VertexType::QualityType &gt; vcl::vertexRadiusFromQuality </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">double</a>&#160;</td>
          <td class="paramname"><em>diskRadius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">double</a>&#160;</td>
          <td class="paramname"><em>radiusVariance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">bool</a>&#160;</td>
          <td class="paramname"><em>invert</em> = <code><a class="el" href="classvcl_1_1Matrix.html">false</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>When performing an adptive pruning for each sample we expect a varying radius to be removed. The radius is a PerVertex attribute that we compute from the current per vertex quality component. The expected radius of the sample is computed so that it linearly maps the quality between diskradius and diskradius*variance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td></td></tr>
    <tr><td class="paramname">diskRadius</td><td></td></tr>
    <tr><td class="paramname">radiusVariance</td><td></td></tr>
    <tr><td class="paramname">invert</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a598979803f34d74d1c4c9d4599d01eb8" name="a598979803f34d74d1c4c9d4599d01eb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a598979803f34d74d1c4c9d4599d01eb8">&#9670;&#160;</a></span>vertexRadiusFromWeights()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType, <a class="el" href="classvcl_1_1Matrix.html">typename</a> ScalarType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; ScalarType &gt; vcl::vertexRadiusFromWeights </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> std::vector&lt; ScalarType &gt; &amp;&#160;</td>
          <td class="paramname"><em>weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">double</a>&#160;</td>
          <td class="paramname"><em>diskRadius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">double</a>&#160;</td>
          <td class="paramname"><em>radiusVariance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">bool</a>&#160;</td>
          <td class="paramname"><em>invert</em> = <code><a class="el" href="classvcl_1_1Matrix.html">false</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>When performing an adptive pruning for each sample we expect a varying radius to be removed. The radius is a PerVertex attribute that we compute from the current per vertex weights given as argument. The expected radius of the sample is computed so that it linearly maps the quality between diskradius and diskradius*variance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td></td></tr>
    <tr><td class="paramname">weights</td><td></td></tr>
    <tr><td class="paramname">diskRadius</td><td></td></tr>
    <tr><td class="paramname">radiusVariance</td><td></td></tr>
    <tr><td class="paramname">invert</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a7ebad55b87f91b27b05663d9ce7ad406" name="a7ebad55b87f91b27b05663d9ce7ad406"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ebad55b87f91b27b05663d9ce7ad406">&#9670;&#160;</a></span>vertexSelectionNumber()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a> vcl::vertexSelectionNumber </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a29eebb11ad214c9832b49f81417aae34" name="a29eebb11ad214c9832b49f81417aae34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29eebb11ad214c9832b49f81417aae34">&#9670;&#160;</a></span>vertexWeightedMontecarloPointSampling()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SamplerConcept SamplerType, FaceMeshConcept MeshType, <a class="el" href="classvcl_1_1Matrix.html">typename</a> ScalarType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">SamplerType</a> vcl::vertexWeightedMontecarloPointSampling </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> std::vector&lt; ScalarType &gt; &amp;&#160;</td>
          <td class="paramname"><em>weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacevcl.html#af74b42dd9d759d565bb701a5b845d05c">uint</a>&#160;</td>
          <td class="paramname"><em>nSamples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">double</a>&#160;</td>
          <td class="paramname"><em>variance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">bool</a>&#160;</td>
          <td class="paramname"><em>deterministic</em> = <code><a class="el" href="classvcl_1_1Matrix.html">false</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9a3eb7aeb0da02be51ca136620616b43" name="a9a3eb7aeb0da02be51ca136620616b43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a3eb7aeb0da02be51ca136620616b43">&#9670;&#160;</a></span>volume()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">double</a> vcl::volume </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the volume of a closed surface <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>. Returned value is meaningful only if the input mesh is watertight. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>closed mesh on which compute the volume. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The volume of the given mesh. </dd></dl>

</div>
</div>
<a id="abe0d3154bb94af5fb7d34bd186eba0b3" name="abe0d3154bb94af5fb7d34bd186eba0b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe0d3154bb94af5fb7d34bd186eba0b3">&#9670;&#160;</a></span>weightedCovarianceMatrixOfPointCloud()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Point3Concept PointType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">auto</a> vcl::weightedCovarianceMatrixOfPointCloud </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> std::vector&lt; PointType &gt; &amp;&#160;</td>
          <td class="paramname"><em>pointVec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Matrix.html">const</a> std::vector&lt; <a class="el" href="classvcl_1_1Matrix.html">typename</a> PointType::ScalarType &gt; &amp;&#160;</td>
          <td class="paramname"><em>weights</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the weighted covariance matrix of a set of points. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pointVec</td><td></td></tr>
    <tr><td class="paramname">weights</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacevcl.html">vcl</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
