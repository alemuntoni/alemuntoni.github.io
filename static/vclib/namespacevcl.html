<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Visual Computing Library: vcl Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
       <script type="text/javascript">
           DoxygenAwesomeDarkModeToggle.init()
       </script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Visual Computing Library
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('namespacevcl.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#concepts">Concepts</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">vcl Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacevcl_1_1comp"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl_1_1comp.html">comp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacevcl_1_1edge"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl_1_1edge.html">edge</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacevcl_1_1edgemesh"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl_1_1edgemesh.html">edgemesh</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacevcl_1_1face"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl_1_1face.html">face</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacevcl_1_1io"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl_1_1io.html">io</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacevcl_1_1mesh"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl_1_1mesh.html">mesh</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacevcl_1_1pointcloud"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl_1_1pointcloud.html">pointcloud</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacevcl_1_1polymesh"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl_1_1polymesh.html">polymesh</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacevcl_1_1str"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl_1_1str.html">str</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacevcl_1_1trimesh"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl_1_1trimesh.html">trimesh</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacevcl_1_1Ui"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl_1_1Ui.html">Ui</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacevcl_1_1vert"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl_1_1vert.html">vert</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacevcl_1_1views"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl_1_1views.html">views</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1AbstractGrid.html">AbstractGrid</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classvcl_1_1AbstractGrid.html" title="The AbstractGrid class describes a generic Spatial Data Structure organized on a regular grid,...">AbstractGrid</a> class describes a generic Spatial Data Structure organized on a regular grid, that allows to store elements (ValueType) in a particular way that will be managed by its derived classes (e.g. <a class="el" href="classvcl_1_1StaticGrid.html">StaticGrid</a>, <a class="el" href="classvcl_1_1HashTableGrid.html" title="The HashTableGrid class stores N-Dimensional spatial elements (that could be anything on which it can...">HashTableGrid</a>).  <a href="classvcl_1_1AbstractGrid.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1Array.html">Array</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classvcl_1_1Array.html" title="The Array class is a dynamically allocated N-dimensional array stored in RowWise mode.">Array</a> class is a dynamically allocated N-dimensional array stored in RowWise mode.  <a href="classvcl_1_1Array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1BadCustomComponentTypeException.html">BadCustomComponentTypeException</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1BadVertexIndexException.html">BadVertexIndexException</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1BipartiteGraph.html">BipartiteGraph</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1BitProxy.html">BitProxy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classvcl_1_1BitProxy.html" title="The BitProxy class allows to access to a bool reference from a bit saved in a mask,...">BitProxy</a> class allows to access to a bool reference from a bit saved in a mask, and then allow assignment.  <a href="classvcl_1_1BitProxy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1BitSet.html">BitSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classvcl_1_1BitSet.html" title="The BitSet class allows to treat an integral type as an array of booleans of a guaranteed size.">BitSet</a> class allows to treat an integral type as an array of booleans of a guaranteed size.  <a href="classvcl_1_1BitSet.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1Box.html">Box</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class representing a box in N-dimensional space.  <a href="classvcl_1_1Box.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1CannotOpenFileException.html">CannotOpenFileException</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1CellIterator.html">CellIterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1Color.html">Color</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classvcl_1_1Color.html" title="The Color class represents a RGBA color.">Color</a> class represents a RGBA color.  <a href="classvcl_1_1Color.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvcl_1_1ComponentString.html">ComponentString</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="structvcl_1_1ComponentString.html" title="The ComponentString class is used to retrieve the string associated to a COMP_ID value,...">ComponentString</a> class is used to retrieve the string associated to a COMP_ID value, trough its member 'str'.  <a href="structvcl_1_1ComponentString.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1ConsoleLogger.html">ConsoleLogger</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1ConstMeshEdgeUtil.html">ConstMeshEdgeUtil</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1ConstStaticGridIterator.html">ConstStaticGridIterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvcl_1_1CreateSphereArgs.html">CreateSphereArgs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="structvcl_1_1CreateSphereArgs.html" title="The CreateSphereArgs structs contains a series of parameters to generate a sphere.">CreateSphereArgs</a> structs contains a series of parameters to generate a sphere.  <a href="structvcl_1_1CreateSphereArgs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1CustomComponentVectorHandle.html">CustomComponentVectorHandle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows to access directly to a custom component.  <a href="classvcl_1_1CustomComponentVectorHandle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvcl_1_1DistFunctionStruct.html">DistFunctionStruct</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvcl_1_1DistFunctionStruct_3_01Obj1_00_01Obj2_00_01ScalarType_01_4.html">DistFunctionStruct&lt; Obj1, Obj2, ScalarType &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1Distribution.html">Distribution</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classvcl_1_1Distribution.html" title="The Distribution class allows to collect a set of values and then compute some statistics like averag...">Distribution</a> class allows to collect a set of values and then compute some statistics like average, variance, standardDeviation, and percentiles.  <a href="classvcl_1_1Distribution.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1DrawableMesh.html">DrawableMesh</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1DrawableObject.html">DrawableObject</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classvcl_1_1DrawableObject.html" title="The DrawableObject class is the base class for all the objects that can be rendered in a viewer.">DrawableObject</a> class is the base class for all the objects that can be rendered in a viewer.  <a href="classvcl_1_1DrawableObject.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1DrawableObjectFrame.html">DrawableObjectFrame</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1DrawableObjectVector.html">DrawableObjectVector</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1DrawableObjectVectorFrame.html">DrawableObjectVectorFrame</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1Edge.html">Edge</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classvcl_1_1Edge.html" title="The Edge class represents an Edge element of the vcl::Mesh class.">Edge</a> class represents an <a class="el" href="classvcl_1_1Edge.html" title="The Edge class represents an Edge element of the vcl::Mesh class.">Edge</a> element of the <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">vcl::Mesh</a> class.  <a href="classvcl_1_1Edge.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1Edge_3_01MeshType_00_01TypeWrapper_3_01Comps_8_8_8_01_4_01_4.html">Edge&lt; MeshType, TypeWrapper&lt; Comps... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1EdgeAdjFaceIterator.html">EdgeAdjFaceIterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1EdgeMeshT.html">EdgeMeshT</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvcl_1_1ElemenetString.html">ElemenetString</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="structvcl_1_1ElemenetString.html" title="The ElemenetString class is used to retrieve the string associated to a ELEM_ID value,...">ElemenetString</a> class is used to retrieve the string associated to a ELEM_ID value, trough its member 'str'.  <a href="structvcl_1_1ElemenetString.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1Element.html">Element</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classvcl_1_1Element.html" title="The Element class.">Element</a> class.  <a href="classvcl_1_1Element.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1ElementContainerIterator.html">ElementContainerIterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1Face.html">Face</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classvcl_1_1Face.html" title="The Face class represents an Face element of the vcl::Mesh class.">Face</a> class represents an <a class="el" href="classvcl_1_1Face.html" title="The Face class represents an Face element of the vcl::Mesh class.">Face</a> element of the <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">vcl::Mesh</a> class.  <a href="classvcl_1_1Face.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1Face_3_01MeshType_00_01TypeWrapper_3_01Comps_8_8_8_01_4_01_4.html">Face&lt; MeshType, TypeWrapper&lt; Comps... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1FileInfo.html">FileInfo</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvcl_1_1FilterTypesByCondition.html">FilterTypesByCondition</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvcl_1_1FilterTypesByCondition_3_01Pred_00_01Head_00_01Tail_8_8_8_01_4.html">FilterTypesByCondition&lt; Pred, Head, Tail... &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all types that do not satisfy a condition, and get them as a tuple.  <a href="structvcl_1_1FilterTypesByCondition_3_01Pred_00_01Head_00_01Tail_8_8_8_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvcl_1_1FilterTypesByCondition_3_01Pred_00_01TypeWrapper_3_01Tail_8_8_8_01_4_01_4.html">FilterTypesByCondition&lt; Pred, TypeWrapper&lt; Tail... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvcl_1_1FirstElementPairComparator.html">FirstElementPairComparator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="structvcl_1_1FirstElementPairComparator.html" title="The FirstElementPairComparator struct is an utility comparator that allow to sort std::pair (or any t...">FirstElementPairComparator</a> struct is an utility comparator that allow to sort std::pair (or any type that has a sortable member called 'first') using only its first element. The second element of the Pair type is ignored and won't be considered by the comparator. This means that pairs having equal first elements but different second elements will be considered as equals.  <a href="structvcl_1_1FirstElementPairComparator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1FirstRefPair.html">FirstRefPair</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvcl_1_1FirstType.html">FirstType</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvcl_1_1FirstType_3_01TypeWrapper_3_01Args_8_8_8_01_4_01_4.html">FirstType&lt; TypeWrapper&lt; Args... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1GenericDrawableMesh.html">GenericDrawableMesh</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvcl_1_1GetTypeByCondition.html">GetTypeByCondition</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The the first type of a pack that satisties the given condition.  <a href="structvcl_1_1GetTypeByCondition.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvcl_1_1GetTypeByCondition_3_01Pred_00_01TypeWrapper_3_01Args_8_8_8_01_4_01_4.html">GetTypeByCondition&lt; Pred, TypeWrapper&lt; Args... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1GLArea.html">GLArea</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1HashTableGrid.html">HashTableGrid</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classvcl_1_1HashTableGrid.html" title="The HashTableGrid class stores N-Dimensional spatial elements (that could be anything on which it can...">HashTableGrid</a> class stores N-Dimensional spatial elements (that could be anything on which it can be computed a N-dimensional bounding box) in a regular grid, using a Hash Table having the Cell Grid coordinate as key type.  <a href="classvcl_1_1HashTableGrid.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvcl_1_1HausdorffDistResult.html">HausdorffDistResult</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1Histogram.html">Histogram</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1Image.html">Image</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classvcl_1_1Image.html" title="The Image class stores an Image in 8 bit RGBA format.">Image</a> class stores an <a class="el" href="classvcl_1_1Image.html" title="The Image class stores an Image in 8 bit RGBA format.">Image</a> in 8 bit RGBA format.  <a href="classvcl_1_1Image.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvcl_1_1IndexInTypes.html">IndexInTypes</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvcl_1_1IndexInTypes_3_01T_00_01TypeWrapper_3_01Us_8_8_8_01_4_01_4.html">IndexInTypes&lt; T, TypeWrapper&lt; Us... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvcl_1_1IntersFunctionStruct.html">IntersFunctionStruct</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvcl_1_1IntersFunctionStruct_3_01Obj1_00_01Obj2_01_4.html">IntersFunctionStruct&lt; Obj1, Obj2 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1KDTree.html">KDTree</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1KeyRefValueRefPair.html">KeyRefValueRefPair</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1KeyValueRefPair.html">KeyValueRefPair</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1Logger.html">Logger</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvcl_1_1MakeConstPointer.html">MakeConstPointer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvcl_1_1MakeConstPointer_3_01T_01_5_01_4.html">MakeConstPointer&lt; T * &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1MalformedFileException.html">MalformedFileException</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1Mesh.html">Mesh</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a> class represents a generic 3D mesh. A mesh is composed of a generic number of containers of Elements (which can be vertices, faces, edges...), plus some other components.  <a href="classvcl_1_1Mesh.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1MeshEdgeUtil.html">MeshEdgeUtil</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1MeshInertia.html">MeshInertia</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classvcl_1_1MeshInertia.html" title="The MeshInertia class.">MeshInertia</a> class.  <a href="classvcl_1_1MeshInertia.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1MeshInfo.html">MeshInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple class that allows to store which elements and their components have been imported/loaded or are going to be exported/saved on a mesh file or some other data structure.  <a href="classvcl_1_1MeshInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1MeshPos.html">MeshPos</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classvcl_1_1MeshPos.html" title="The MeshPos class describes a &quot;Position in a Mesh&quot; that can be identified with a triplet of Face-Vert...">MeshPos</a> class describes a "Position in a Mesh" that can be identified with a triplet of Face-Vertex-Edge, where:  <a href="classvcl_1_1MeshPos.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1MeshRenderBuffers.html">MeshRenderBuffers</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1MeshRenderSettings.html">MeshRenderSettings</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classvcl_1_1MeshRenderSettings.html" title="The MeshRenderSettings class allows an easy management of render settings of a Mesh....">MeshRenderSettings</a> class allows an easy management of render settings of a <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>. This class stores the rendering status of a <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a> and the rendering capability of a <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>.  <a href="classvcl_1_1MeshRenderSettings.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1MeshRenderSettingsFrame.html">MeshRenderSettingsFrame</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1MeshSampler.html">MeshSampler</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1MissingCompactnessException.html">MissingCompactnessException</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1MissingComponentException.html">MissingComponentException</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1MissingPolygonalRequirementException.html">MissingPolygonalRequirementException</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1MissingPreconditionException.html">MissingPreconditionException</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1MissingQuadRequirementException.html">MissingQuadRequirementException</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1MissingTriangularRequirementException.html">MissingTriangularRequirementException</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1NestedInitializerListsProcessor.html">NestedInitializerListsProcessor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classvcl_1_1NestedInitializerListsProcessor.html" title="The NestedInitializerListsProcessor class.">NestedInitializerListsProcessor</a> class.  <a href="classvcl_1_1NestedInitializerListsProcessor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1NestedInitializerListsProcessor_3_01T_00_011_01_4.html">NestedInitializerListsProcessor&lt; T, 1 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1NodeIterator.html">NodeIterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1NoIntersectionException.html">NoIntersectionException</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1NullLogger.html">NullLogger</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classvcl_1_1NullLogger.html" title="The NullLogger class is an empty class that is used as default type in all the library functions that...">NullLogger</a> class is an empty class that is used as default type in all the library functions that take as input a logger type.  <a href="classvcl_1_1NullLogger.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvcl_1_1NumberOfTypes.html">NumberOfTypes</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvcl_1_1NumberOfTypes_3_01TypeWrapper_3_01Args_8_8_8_01_4_01_4.html">NumberOfTypes&lt; TypeWrapper&lt; Args... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvcl_1_1PairComparator.html">PairComparator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="structvcl_1_1PairComparator.html" title="The PairComparator struct is an utility comparator to allow to sort pairs in lexical order.">PairComparator</a> struct is an utility comparator to allow to sort pairs in lexical order.  <a href="structvcl_1_1PairComparator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1Plane.html">Plane</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classvcl_1_1Plane.html" title="The Plane class represent a 2D plane in 3D space.">Plane</a> class represent a 2D plane in 3D space.  <a href="classvcl_1_1Plane.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1Point.html">Point</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classvcl_1_1Point.html" title="The Point class represents an N-dimensional point containing N scalar values.">Point</a> class represents an N-dimensional point containing N scalar values.  <a href="classvcl_1_1Point.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1PointCloudT.html">PointCloudT</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1PointSampler.html">PointSampler</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1Polygon.html">Polygon</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1PolyMeshT.html">PolyMeshT</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1PrincipalCurvature.html">PrincipalCurvature</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classvcl_1_1PrincipalCurvature.html" title="The PrincipalCurvature class stores the principal curvature directions and values at a point on a sur...">PrincipalCurvature</a> class stores the principal curvature directions and values at a point on a surface.  <a href="classvcl_1_1PrincipalCurvature.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1QClickableLabel.html">QClickableLabel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classvcl_1_1QClickableLabel.html" title="The QClickableLabel class.">QClickableLabel</a> class.  <a href="classvcl_1_1QClickableLabel.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1RefPair.html">RefPair</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1RegularGrid.html">RegularGrid</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1SecondRefPair.html">SecondRefPair</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1Segment.html">Segment</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class representing a line segment in n-dimensional space. The class is parameterized by a <code>PointConcept</code>, which must provide the <code>DIM</code> constant and the <code>[]</code> operator for accessing the point coordinates.  <a href="classvcl_1_1Segment.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1Sphere.html">Sphere</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1StaticGrid.html">StaticGrid</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1StaticGridIterator.html">StaticGridIterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1TexCoord.html">TexCoord</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1Timer.html">Timer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classvcl_1_1Timer.html" title="The Timer class allows to instantiate simple Timer objects that can be used everywhere.">Timer</a> class allows to instantiate simple <a class="el" href="classvcl_1_1Timer.html" title="The Timer class allows to instantiate simple Timer objects that can be used everywhere.">Timer</a> objects that can be used everywhere.  <a href="classvcl_1_1Timer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1Tokenizer.html">Tokenizer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classvcl_1_1Tokenizer.html" title="The Tokenizer class.">Tokenizer</a> class.  <a href="classvcl_1_1Tokenizer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1Triangle.html">Triangle</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1TriangleWrapper.html">TriangleWrapper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1TriMeshT.html">TriMeshT</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classvcl_1_1TriMeshT.html" title="The TriMeshT class.">TriMeshT</a> class.  <a href="classvcl_1_1TriMeshT.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1TriPolyIndexBiMap.html">TriPolyIndexBiMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classvcl_1_1TriPolyIndexBiMap.html" title="The TriPolyIndexBiMap class allows to store a bidirectional mapping between a Polygon Mesh and a Tria...">TriPolyIndexBiMap</a> class allows to store a bidirectional mapping between a <a class="el" href="classvcl_1_1Polygon.html">Polygon</a> <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a> and a <a class="el" href="classvcl_1_1Triangle.html">Triangle</a> <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a> generated by the polygon mesh.  <a href="classvcl_1_1TriPolyIndexBiMap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvcl_1_1TypesContainConditionType.html">TypesContainConditionType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Its value is set to true if there is at least one type in the given pack Args... that satisfies the given condition.  <a href="structvcl_1_1TypesContainConditionType.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvcl_1_1TypesContainConditionType_3_01Pred_00_01TypeWrapper_3_01Args_8_8_8_01_4_01_4.html">TypesContainConditionType&lt; Pred, TypeWrapper&lt; Args... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvcl_1_1TypeWrapper.html">TypeWrapper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple structure that wraps a list of variadic templates, without instantiating anything. Useful when you need to wrap a list of types, and consider them as a single type.  <a href="structvcl_1_1TypeWrapper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1UndirectedNode.html">UndirectedNode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1UnknownFileFormatException.html">UnknownFileFormatException</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvcl_1_1UnorderedPairComparator.html">UnorderedPairComparator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="structvcl_1_1UnorderedPairComparator.html" title="The UnorderedPairComparator struct is an utility comparator to allow to sort unordered std::pair&lt;T,...">UnorderedPairComparator</a> struct is an utility comparator to allow to sort unordered std::pair&lt;T, T&gt;, that means that it is not important the order of the first and the second element of the pair. This menas that pairs (1, 2) and (2, 1) are considered equal, and (3, 1) &lt; (2, 3).  <a href="structvcl_1_1UnorderedPairComparator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1Vector.html">Vector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classvcl_1_1Vector.html" title="The Vector class is a generic container of objects of type T, that could have fixed or dynamic size,...">Vector</a> class is a generic container of objects of type <code>T</code>, that could have fixed or dynamic size, depending on the templated size <code>N</code>.  <a href="classvcl_1_1Vector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1Vertex.html">Vertex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classvcl_1_1Vertex.html" title="The Vertex class represents an Vertex element of the vcl::Mesh class.">Vertex</a> class represents an <a class="el" href="classvcl_1_1Vertex.html" title="The Vertex class represents an Vertex element of the vcl::Mesh class.">Vertex</a> element of the <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">vcl::Mesh</a> class.  <a href="classvcl_1_1Vertex.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1Vertex_3_01MeshType_00_01TypeWrapper_3_01Comps_8_8_8_01_4_01_4.html">Vertex&lt; MeshType, TypeWrapper&lt; Comps... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1View.html">View</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classvcl_1_1View.html" title="The View class is a simple class that stores and exposes two iterators begin and end.">View</a> class is a simple class that stores and exposes two iterators begin and end.  <a href="classvcl_1_1View.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1ViewerMainWindow.html">ViewerMainWindow</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1WrongSizeException.html">WrongSizeException</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="concepts" name="concepts"></a>
Concepts</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1IsConst.html">IsConst</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility concept that is evaluated true if T is const or it is a pointer to const. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1IteratorConcept.html">IteratorConcept</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility concept that is evaluated true if T is an iterator. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1IteratesOverClass.html">IteratesOverClass</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility concept that is evaluated true if T is an iterator having its value_type that is a class. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1IteratesOverPointer.html">IteratesOverPointer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility concept that is evaluated true if T is an iterator having its value_type that is a pointer. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1LoggerConcept.html">LoggerConcept</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The LoggerConcept is evaluated to true when the input type is a valid Logger type. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1HasEdges.html">HasEdges</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">HasEdges concepts is satisfied when at least one of its template types is (or inherits from) a EdgeContainer. It can be used both to check if a Mesh has edges, or if in a list of types there is a EdgeContainer. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1HasFaces.html">HasFaces</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">HasFaces concepts is satisfied when at least one of its template types is (or inherits from) a FaceContainer. It can be used both to check if a Mesh has faces, or if in a list of types there is a FaceContainer. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1HasVertices.html">HasVertices</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">HasVertices concepts is satisfied when at least one of its types is (or inherits from) a VertexContainer. It can be used both to check if a Mesh has vertices, or if in a list of types there is a VertexContainer. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1EdgeMeshConcept.html">EdgeMeshConcept</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1EdgeConcept.html">EdgeConcept</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The EdgeConcept describes how a Edge element that can be used for a EdgeContainer should be organized. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1ElementConcept.html">ElementConcept</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1FaceConcept.html">FaceConcept</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The FaceConcept describes how a Face element that can be used for a FaceContainer should be organized. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1TriangleFaceConcept.html">TriangleFaceConcept</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1PolygonFaceConcept.html">PolygonFaceConcept</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The PolygonFaceConcept describes how a Face element class should be organized to be a polygonal face with dynamic size. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1VertexConcept.html">VertexConcept</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The VertexConcept describes how a Vertex element that can be used for a VertexContainer should be organized. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1HasTriangles.html">HasTriangles</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1HasQuads.html">HasQuads</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1HasPolygons.html">HasPolygons</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1FaceMeshConcept.html">FaceMeshConcept</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1TriangleMeshConcept.html">TriangleMeshConcept</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1QuadMeshConcept.html">QuadMeshConcept</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1PolygonMeshConcept.html">PolygonMeshConcept</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1MeshConcept.html">MeshConcept</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Mesh Concept is evaluated to true when the type is a Mesh. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1ElementOrMeshConcept.html">ElementOrMeshConcept</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">the ElementOrMesh Concept is evaluated to true when the type is either a Mesh or an Element. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1HasPerEdgeAdjacentEdges.html">HasPerEdgeAdjacentEdges</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept that checks if a Mesh has the per Edge AdjacentEdges component. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1HasPerEdgeAdjacentFaces.html">HasPerEdgeAdjacentFaces</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept that checks if a Mesh has the per Edge AdjacentFaces component. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1HasPerEdgeBitFlags.html">HasPerEdgeBitFlags</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept that checks if a Mesh has the per Edge BitFlags component. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1HasPerEdgeColor.html">HasPerEdgeColor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept that checks if a Mesh has the per Edge Color component. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1HasPerEdgeCustomComponents.html">HasPerEdgeCustomComponents</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept that checks if a Mesh has the per Edge CustomComponents component. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1HasPerEdgeMark.html">HasPerEdgeMark</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept that checks if a Mesh has the per Edge Mark component. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1HasPerEdgeQuality.html">HasPerEdgeQuality</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept that checks if a Mesh has the per Edge Quality component. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1HasPerEdgeVertexPointers.html">HasPerEdgeVertexPointers</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept that checks if a Mesh has the per Edge VertexPointers component. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1HasPerFaceAdjacentEdges.html">HasPerFaceAdjacentEdges</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept that checks if a Mesh has the per Face AdjacentEdges component. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1HasPerFaceAdjacentFaces.html">HasPerFaceAdjacentFaces</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept that checks if a Mesh has the per Face AdjacentFaces component. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1HasPerFaceBitFlags.html">HasPerFaceBitFlags</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept that checks if a Mesh has the per Face BitFlags component. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1HasPerFaceColor.html">HasPerFaceColor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept that checks if a Mesh has the per Face Color component. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1HasPerFaceCustomComponents.html">HasPerFaceCustomComponents</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept that checks if a Mesh has the per Face CustomComponents component. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1HasPerFaceMark.html">HasPerFaceMark</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept that checks if a Mesh has the per Face Mark component. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1HasPerFaceNormal.html">HasPerFaceNormal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept that checks if a Mesh has the per Face Normal component. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1HasPerFacePolygonBitFlags.html">HasPerFacePolygonBitFlags</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept that checks if a Mesh has the per Face PolygonBitFlags component. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1HasPerFacePrincipalCurvature.html">HasPerFacePrincipalCurvature</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept that checks if a Mesh has the per Face PrincipalCurvature component. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1HasPerFaceQuality.html">HasPerFaceQuality</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept that checks if a Mesh has the per Face Quality component. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1HasPerFaceTriangleBitFlags.html">HasPerFaceTriangleBitFlags</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept that checks if a Mesh has the per Face TriangleBitFlags component. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1HasPerFaceVertexPointers.html">HasPerFaceVertexPointers</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept that checks if a Mesh has the per Face VertexPointers component. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1HasPerFaceWedgeColors.html">HasPerFaceWedgeColors</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept that checks if a Mesh has the per Face WedgeColors component. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1HasPerFaceWedgeTexCoords.html">HasPerFaceWedgeTexCoords</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept that checks if a Mesh has the per Face WedgeTexCoords component. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1HasBoundingBox.html">HasBoundingBox</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept that is evaluated true if a Mesh has the BoundingBox component. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1HasColor.html">HasColor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept that is evaluated true if a Mesh has the Color component. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1HasMark.html">HasMark</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept that is evaluated true if a Mesh has the Mark component. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1HasName.html">HasName</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept that checks if a Mesh has the Name component. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1HasTexturePaths.html">HasTexturePaths</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept that checks if a Mesh has the TexturePaths component. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1HasTransformMatrix.html">HasTransformMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept that checks if a Mesh has the TransformMatrix component. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1HasPerVertexAdjacentEdges.html">HasPerVertexAdjacentEdges</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept that checks if a Mesh has the per Vertex AdjacentEdges component. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1HasPerVertexAdjacentFaces.html">HasPerVertexAdjacentFaces</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept that checks if a Mesh has the per Vertex AdjacentFaces component. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1HasPerVertexAdjacentVertices.html">HasPerVertexAdjacentVertices</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept that checks if a Mesh has the per Vertex AdjacentVertices component. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1HasPerVertexColor.html">HasPerVertexColor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept that checks if a Mesh has the per Vertex Color component. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1HasPerVertexMark.html">HasPerVertexMark</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept that checks if a Mesh has the per Vertex Mark component. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1HasPerVertexNormal.html">HasPerVertexNormal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept that checks if a Mesh has the per Vertex Normal component. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1HasPerVertexPrincipalCurvature.html">HasPerVertexPrincipalCurvature</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept that checks if a Mesh has the per Vertex PrincipalCurvature component. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1HasPerVertexQuality.html">HasPerVertexQuality</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept that checks if a Mesh has the per Vertex Quality component. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1HasPerVertexTexCoord.html">HasPerVertexTexCoord</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept that checks if a Mesh has the per Vertex TexCoord component. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1HasPerVertexCustomComponents.html">HasPerVertexCustomComponents</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept that checks if a Mesh has the per Vertex CustomComponents. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1IsPointer.html">IsPointer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility concept that is evaluated true if T is a Pointer, even if the type is a T is a reference to a pointer. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1IsPointerToConst.html">IsPointerToConst</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility concept that is evaluated true if T is a Pointer to a constant object. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1EdgeRangeConcept.html">EdgeRangeConcept</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The EdgeRangeConcept evaluates to true if Rng is a valid Range on Edges. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1EdgePointerRangeConcept.html">EdgePointerRangeConcept</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The EdgePointerRangeConcept evaluates to true if Rng is a valid Range on Edge Pointers. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1FaceRangeConcept.html">FaceRangeConcept</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The FaceRangeConcept evaluates to true if Rng is a valid Range on Faces. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1FacePointerRangeConcept.html">FacePointerRangeConcept</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The FacePointerRangeConcept evaluates to true if Rng is a valid Range on Face Pointers. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1VertexRangeConcept.html">VertexRangeConcept</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The VertexRangeConcept evaluates to true if Rng is a valid Range on Vertices. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1VertexPointerRangeConcept.html">VertexPointerRangeConcept</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The VertexPointerRangeConcept evaluates to true if Rng is a valid Range on Vertex Pointers. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1Range.html">Range</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility concept that is evaluated true if T is a range, e.g. if has a begin and an end. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1RangeOf.html">RangeOf</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility concept that is evaluated true the Range R has a value_type that is T. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1RangeOfConvertibleTo.html">RangeOfConvertibleTo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility concept that is evaluated true the Range R has a value_type that is convertible to T. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1ArrayConcept.html">ArrayConcept</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A concept representing a N-dimensional array. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1Array2Concept.html">Array2Concept</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A concept representing a 2-dimensional array. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1Array3Concept.html">Array3Concept</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A concept representing a 3-dimensional array. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1Array4Concept.html">Array4Concept</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A concept representing a 4-dimensional array. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1BoxConcept.html">BoxConcept</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A concept representing a N-Dimensional Box. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1Box2Concept.html">Box2Concept</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A concept that requires a type to satisfy the BoxConcept and have a dimension of 2. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1Box3Concept.html">Box3Concept</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A concept that requires a type to satisfy the BoxConcept and have a dimension of 3. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1EigenMatrixConcept.html">EigenMatrixConcept</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept for Eigen matrices. It is satisfied when <code>T</code> is an Eigen matrix. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1ResizableEigenMatrixConceipt.html">ResizableEigenMatrixConceipt</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept for Eigen matrices that can be resized. It is satisfied when <code>T</code> is an Eigen matrix. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1MatrixConcept.html">MatrixConcept</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept for 2D arrays (matrices). It is satisfied when <code>T</code> is a matrix, no matter its sizes. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1PlaneConcept.html">PlaneConcept</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A C++ concept that requires a type to represent a plane in 3D space. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1PointConcept.html">PointConcept</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept for types representing points in Euclidean space. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1Point2Concept.html">Point2Concept</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A concept for points in two-dimensional space. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1Point3Concept.html">Point3Concept</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A concept for points in three-dimensional space. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1Point4Concept.html">Point4Concept</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A concept for points in four-dimensional space. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1PointIteratorConcept.html">PointIteratorConcept</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept for iterators that iterate over Points (class that satisfies the PointConcept). <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1Point2IteratorConcept.html">Point2IteratorConcept</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept for iterators that iterate over 2D Points (class that satisfies the Point2Concept). <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1Point3IteratorConcept.html">Point3IteratorConcept</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept for iterators that iterate over 3D Points (class that satisfies the Point3Concept). <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1Point4IteratorConcept.html">Point4IteratorConcept</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept for iterators that iterate over 4D Points (class that satisfies the Point4Concept). <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1PolygonConcept.html">PolygonConcept</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1Polygon2Concept.html">Polygon2Concept</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1Polygon3Concept.html">Polygon3Concept</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1SamplerConcept.html">SamplerConcept</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A concept for a container that stores Point samples. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1SegmentConcept.html">SegmentConcept</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept for types representing line segments in Euclidean space. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1Segment2Concept.html">Segment2Concept</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A concept to check whether a type meets the requirements of a 2D segment. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1Segment3Concept.html">Segment3Concept</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A concept to check whether a type meets the requirements of a 3D segment. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1SphereConcept.html">SphereConcept</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept for types representing spheres in Euclidean space. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1ConstTriangleConcept.html">ConstTriangleConcept</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1TriangleConcept.html">TriangleConcept</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1ConstTriangle2Concept.html">ConstTriangle2Concept</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1Triangle2Concept.html">Triangle2Concept</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1ConstTriangle3Concept.html">ConstTriangle3Concept</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1Triangle3Concept.html">Triangle3Concept</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:aa909fb65065f7aa1f08e7ae17265653d"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename, typename... &gt; typename Container, typename T &gt; </td></tr>
<tr class="memitem:aa909fb65065f7aa1f08e7ae17265653d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#aa909fb65065f7aa1f08e7ae17265653d">ConstElementContainerIterator</a> = <a class="el" href="classvcl_1_1ElementContainerIterator.html">ElementContainerIterator</a>&lt; Container, T, true &gt;</td></tr>
<tr class="separator:aa909fb65065f7aa1f08e7ae17265653d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70592efcf2670361a337c528b34e4dfb"><td class="memTemplParams" colspan="2">template&lt;typename FaceType &gt; </td></tr>
<tr class="memitem:a70592efcf2670361a337c528b34e4dfb"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a70592efcf2670361a337c528b34e4dfb">ConstEdgeAdjFaceIterator</a> = <a class="el" href="classvcl_1_1EdgeAdjFaceIterator.html">EdgeAdjFaceIterator</a>&lt; FaceType, true &gt;</td></tr>
<tr class="separator:a70592efcf2670361a337c528b34e4dfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a294d3a64b949108ec1f6381b950945e9"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a294d3a64b949108ec1f6381b950945e9">Histogramf</a> = <a class="el" href="classvcl_1_1Histogram.html">Histogram</a>&lt; float &gt;</td></tr>
<tr class="separator:a294d3a64b949108ec1f6381b950945e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7eaa15c791dc5118a8eea9677c6ba9b7"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a7eaa15c791dc5118a8eea9677c6ba9b7">Histogramd</a> = <a class="el" href="classvcl_1_1Histogram.html">Histogram</a>&lt; double &gt;</td></tr>
<tr class="separator:a7eaa15c791dc5118a8eea9677c6ba9b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae166b0242a891e25bde6507bf6776730"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae166b0242a891e25bde6507bf6776730"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ae166b0242a891e25bde6507bf6776730">ConstCustomComponentVectorHandle</a> = <a class="el" href="classvcl_1_1CustomComponentVectorHandle.html">CustomComponentVectorHandle</a>&lt; const T &gt;</td></tr>
<tr class="separator:ae166b0242a891e25bde6507bf6776730"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbb0bc2af8032a1d07969e3785645a9c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#acbb0bc2af8032a1d07969e3785645a9c">EdgeMeshf</a> = <a class="el" href="classvcl_1_1EdgeMeshT.html">EdgeMeshT</a>&lt; float &gt;</td></tr>
<tr class="separator:acbb0bc2af8032a1d07969e3785645a9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadd5d4f0adc881097d2c62b003a449cc"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#aadd5d4f0adc881097d2c62b003a449cc">EdgeMesh</a> = <a class="el" href="classvcl_1_1EdgeMeshT.html">EdgeMeshT</a>&lt; double &gt;</td></tr>
<tr class="separator:aadd5d4f0adc881097d2c62b003a449cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1ddd0d2b0a8168f7a6134ed53cd1f3c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ae1ddd0d2b0a8168f7a6134ed53cd1f3c">PointCloudf</a> = <a class="el" href="classvcl_1_1PointCloudT.html">PointCloudT</a>&lt; float &gt;</td></tr>
<tr class="separator:ae1ddd0d2b0a8168f7a6134ed53cd1f3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2939073dbb778a3a2f5d9f93e3fb146"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ab2939073dbb778a3a2f5d9f93e3fb146">PointCloud</a> = <a class="el" href="classvcl_1_1PointCloudT.html">PointCloudT</a>&lt; double &gt;</td></tr>
<tr class="separator:ab2939073dbb778a3a2f5d9f93e3fb146"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adde03ea7837ce8e0d2e4e5aef04a1792"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#adde03ea7837ce8e0d2e4e5aef04a1792">PolyMeshf</a> = <a class="el" href="classvcl_1_1PolyMeshT.html">PolyMeshT</a>&lt; float &gt;</td></tr>
<tr class="separator:adde03ea7837ce8e0d2e4e5aef04a1792"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a416d891cfc10982e070d934a5ab00e7b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a416d891cfc10982e070d934a5ab00e7b">PolyMesh</a> = <a class="el" href="classvcl_1_1PolyMeshT.html">PolyMeshT</a>&lt; double &gt;</td></tr>
<tr class="separator:a416d891cfc10982e070d934a5ab00e7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa63bf0911d51c7377fd467056b2914ff"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__meshes.html#gaa63bf0911d51c7377fd467056b2914ff">TriMeshf</a> = <a class="el" href="classvcl_1_1TriMeshT.html">TriMeshT</a>&lt; float &gt;</td></tr>
<tr class="memdesc:gaa63bf0911d51c7377fd467056b2914ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">The TriMeshf class is a specialization of <a class="el" href="classvcl_1_1TriMeshT.html" title="The TriMeshT class.">TriMeshT</a> that uses <code>float</code> as scalar.  <br /></td></tr>
<tr class="separator:gaa63bf0911d51c7377fd467056b2914ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc7d9c9e25692d22fc9015ac3b3fa4d5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__meshes.html#gadc7d9c9e25692d22fc9015ac3b3fa4d5">TriMesh</a> = <a class="el" href="classvcl_1_1TriMeshT.html">TriMeshT</a>&lt; double &gt;</td></tr>
<tr class="memdesc:gadc7d9c9e25692d22fc9015ac3b3fa4d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">The TriMesh class is a specialization of <a class="el" href="classvcl_1_1TriMeshT.html" title="The TriMeshT class.">TriMeshT</a> that uses <code>double</code> as scalar.  <br /></td></tr>
<tr class="separator:gadc7d9c9e25692d22fc9015ac3b3fa4d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b13dcb16a658633be61033f53c3590e"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t L&gt; </td></tr>
<tr class="memitem:a5b13dcb16a658633be61033f53c3590e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a5b13dcb16a658633be61033f53c3590e">NestedInitializerLists</a> = internal::NestedInitializerListsTraits&lt; T, L &gt;::type</td></tr>
<tr class="memdesc:a5b13dcb16a658633be61033f53c3590e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The NestedInitializerLists class manages nested std::initializer_list&lt;T&gt; types of L levels L must be known at compile time, and compilation will fail if the NestedInitializerLists used does not correspond to the number of used levels.  <br /></td></tr>
<tr class="separator:a5b13dcb16a658633be61033f53c3590e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba483b2c91a7c9b1505b87003bdf14d9"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:gaba483b2c91a7c9b1505b87003bdf14d9"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__space.html#gaba483b2c91a7c9b1505b87003bdf14d9">Array2</a> = <a class="el" href="classvcl_1_1Array.html">Array</a>&lt; Scalar, 2 &gt;</td></tr>
<tr class="memdesc:gaba483b2c91a7c9b1505b87003bdf14d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience alias for a 2-dimensional <a class="el" href="classvcl_1_1Array.html" title="The Array class is a dynamically allocated N-dimensional array stored in RowWise mode.">Array</a>.  <br /></td></tr>
<tr class="separator:gaba483b2c91a7c9b1505b87003bdf14d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e4b5482856d73dda9465ed9cb7111ea"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:ga6e4b5482856d73dda9465ed9cb7111ea"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__space.html#ga6e4b5482856d73dda9465ed9cb7111ea">Array3</a> = <a class="el" href="classvcl_1_1Array.html">Array</a>&lt; Scalar, 3 &gt;</td></tr>
<tr class="memdesc:ga6e4b5482856d73dda9465ed9cb7111ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience alias for a 3-dimensional <a class="el" href="classvcl_1_1Array.html" title="The Array class is a dynamically allocated N-dimensional array stored in RowWise mode.">Array</a>.  <br /></td></tr>
<tr class="separator:ga6e4b5482856d73dda9465ed9cb7111ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab8fae8ad3697a3fd5f463d428f1b99d0"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:gab8fae8ad3697a3fd5f463d428f1b99d0"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__space.html#gab8fae8ad3697a3fd5f463d428f1b99d0">Array4</a> = <a class="el" href="classvcl_1_1Array.html">Array</a>&lt; Scalar, 4 &gt;</td></tr>
<tr class="memdesc:gab8fae8ad3697a3fd5f463d428f1b99d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience alias for a 4-dimensional <a class="el" href="classvcl_1_1Array.html" title="The Array class is a dynamically allocated N-dimensional array stored in RowWise mode.">Array</a>.  <br /></td></tr>
<tr class="separator:gab8fae8ad3697a3fd5f463d428f1b99d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadae55ab660469ee37aa80a2b619527fa"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__space.html#gadae55ab660469ee37aa80a2b619527fa">BitSet8</a> = <a class="el" href="classvcl_1_1BitSet.html">BitSet</a>&lt; char &gt;</td></tr>
<tr class="memdesc:gadae55ab660469ee37aa80a2b619527fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">BitSet8 is a <a class="el" href="classvcl_1_1BitSet.html" title="The BitSet class allows to treat an integral type as an array of booleans of a guaranteed size.">BitSet</a> of 8 bits.  <br /></td></tr>
<tr class="separator:gadae55ab660469ee37aa80a2b619527fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga786ec6ce6be37c1142bbf8869a43bad2"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__space.html#ga786ec6ce6be37c1142bbf8869a43bad2">BitSet16</a> = <a class="el" href="classvcl_1_1BitSet.html">BitSet</a>&lt; short &gt;</td></tr>
<tr class="memdesc:ga786ec6ce6be37c1142bbf8869a43bad2"><td class="mdescLeft">&#160;</td><td class="mdescRight">BitSet16 is a <a class="el" href="classvcl_1_1BitSet.html" title="The BitSet class allows to treat an integral type as an array of booleans of a guaranteed size.">BitSet</a> of 16 bits.  <br /></td></tr>
<tr class="separator:ga786ec6ce6be37c1142bbf8869a43bad2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec46141b5b3ac113188412f11ebe977e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__space.html#gaec46141b5b3ac113188412f11ebe977e">BitSet32</a> = <a class="el" href="classvcl_1_1BitSet.html">BitSet</a>&lt; int &gt;</td></tr>
<tr class="memdesc:gaec46141b5b3ac113188412f11ebe977e"><td class="mdescLeft">&#160;</td><td class="mdescRight">BitSet32 is a <a class="el" href="classvcl_1_1BitSet.html" title="The BitSet class allows to treat an integral type as an array of booleans of a guaranteed size.">BitSet</a> of 32 bits.  <br /></td></tr>
<tr class="separator:gaec46141b5b3ac113188412f11ebe977e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga63e94ce4d048118f147e2fb0c8c1eeaa"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__space.html#ga63e94ce4d048118f147e2fb0c8c1eeaa">BitSet64</a> = <a class="el" href="classvcl_1_1BitSet.html">BitSet</a>&lt; std::size_t &gt;</td></tr>
<tr class="memdesc:ga63e94ce4d048118f147e2fb0c8c1eeaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">BitSet64 is a <a class="el" href="classvcl_1_1BitSet.html" title="The BitSet class allows to treat an integral type as an array of booleans of a guaranteed size.">BitSet</a> of 64 bits.  <br /></td></tr>
<tr class="separator:ga63e94ce4d048118f147e2fb0c8c1eeaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad892770b57d7187fe007fc5c7b8e28c6"><td class="memTemplParams" colspan="2">template&lt;typename S &gt; </td></tr>
<tr class="memitem:ad892770b57d7187fe007fc5c7b8e28c6"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ad892770b57d7187fe007fc5c7b8e28c6">Box2</a> = <a class="el" href="classvcl_1_1Box.html">Box</a>&lt; <a class="el" href="group__space.html#ga6d15a5d1bc87330938ae9b8a55373334">Point2</a>&lt; S &gt; &gt;</td></tr>
<tr class="separator:ad892770b57d7187fe007fc5c7b8e28c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43d66b66fa1219da110325fc3c9020f9"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a43d66b66fa1219da110325fc3c9020f9">Box2i</a> = <a class="el" href="classvcl_1_1Box.html">Box</a>&lt; <a class="el" href="group__space.html#ga94bdb300286f9b4bf31987102e011f8d">Point2i</a> &gt;</td></tr>
<tr class="separator:a43d66b66fa1219da110325fc3c9020f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6dc1589c361fc5f1b6444b74aae377d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ae6dc1589c361fc5f1b6444b74aae377d">Box2f</a> = <a class="el" href="classvcl_1_1Box.html">Box</a>&lt; <a class="el" href="group__space.html#gac9560ad588438ce539ec3fdc5658746a">Point2f</a> &gt;</td></tr>
<tr class="separator:ae6dc1589c361fc5f1b6444b74aae377d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77d7b12e8258d508469b505f056917f1"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a77d7b12e8258d508469b505f056917f1">Box2d</a> = <a class="el" href="classvcl_1_1Box.html">Box</a>&lt; <a class="el" href="group__space.html#ga4b02e85ff4d51fe7d689f8dd0e87ecd5">Point2d</a> &gt;</td></tr>
<tr class="separator:a77d7b12e8258d508469b505f056917f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6539e58b4183d50e78e631047cd7ad12"><td class="memTemplParams" colspan="2">template&lt;typename S &gt; </td></tr>
<tr class="memitem:a6539e58b4183d50e78e631047cd7ad12"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a6539e58b4183d50e78e631047cd7ad12">Box3</a> = <a class="el" href="classvcl_1_1Box.html">Box</a>&lt; <a class="el" href="group__space.html#ga13f2718b0763def563b8bd9f65982833">Point3</a>&lt; S &gt; &gt;</td></tr>
<tr class="separator:a6539e58b4183d50e78e631047cd7ad12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84825556201de0537b996b08d1f8aeca"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a84825556201de0537b996b08d1f8aeca">Box3i</a> = <a class="el" href="classvcl_1_1Box.html">Box</a>&lt; <a class="el" href="group__space.html#ga54b0dffe79fabd0458fc78332c91e73a">Point3i</a> &gt;</td></tr>
<tr class="separator:a84825556201de0537b996b08d1f8aeca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad03a804ee48eb9b3cd5aaf47f7641b3f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ad03a804ee48eb9b3cd5aaf47f7641b3f">Box3f</a> = <a class="el" href="classvcl_1_1Box.html">Box</a>&lt; <a class="el" href="group__space.html#gae19b0e9639a4f90c91e46910ee66f54c">Point3f</a> &gt;</td></tr>
<tr class="separator:ad03a804ee48eb9b3cd5aaf47f7641b3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d5a81b5a74bca25157b2bf0de2c3f6d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a4d5a81b5a74bca25157b2bf0de2c3f6d">Box3d</a> = <a class="el" href="classvcl_1_1Box.html">Box</a>&lt; <a class="el" href="group__space.html#gabb47c1364fb2fe1464a54417684f011e">Point3d</a> &gt;</td></tr>
<tr class="separator:a4d5a81b5a74bca25157b2bf0de2c3f6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85b2f3d72f837560dc3dac7b128dd286"><td class="memTemplParams" colspan="2">template&lt;typename ValueType , typename ScalarType  = double, bool AllowDuplicates = true&gt; </td></tr>
<tr class="memitem:a85b2f3d72f837560dc3dac7b128dd286"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a85b2f3d72f837560dc3dac7b128dd286">HashTableGrid2</a> = <a class="el" href="classvcl_1_1HashTableGrid.html">HashTableGrid</a>&lt; <a class="el" href="namespacevcl.html#acf35775c9f8314906299b1b19f6c5f9b">RegularGrid2</a>&lt; ScalarType &gt;, ValueType, AllowDuplicates &gt;</td></tr>
<tr class="separator:a85b2f3d72f837560dc3dac7b128dd286"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4258b9247c46311b39535faa3c2cfaa7"><td class="memTemplParams" colspan="2">template&lt;typename ValueType , typename ScalarType  = double, bool AllowDuplicates = true&gt; </td></tr>
<tr class="memitem:a4258b9247c46311b39535faa3c2cfaa7"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a4258b9247c46311b39535faa3c2cfaa7">HashTableGrid3</a> = <a class="el" href="classvcl_1_1HashTableGrid.html">HashTableGrid</a>&lt; <a class="el" href="namespacevcl.html#a8d7cc878c7f7ccb25c576ebf7ad2df5b">RegularGrid3</a>&lt; ScalarType &gt;, ValueType, AllowDuplicates &gt;</td></tr>
<tr class="separator:a4258b9247c46311b39535faa3c2cfaa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf35775c9f8314906299b1b19f6c5f9b"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:acf35775c9f8314906299b1b19f6c5f9b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#acf35775c9f8314906299b1b19f6c5f9b">RegularGrid2</a> = <a class="el" href="classvcl_1_1RegularGrid.html">RegularGrid</a>&lt; Scalar, 2 &gt;</td></tr>
<tr class="separator:acf35775c9f8314906299b1b19f6c5f9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d7cc878c7f7ccb25c576ebf7ad2df5b"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:a8d7cc878c7f7ccb25c576ebf7ad2df5b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a8d7cc878c7f7ccb25c576ebf7ad2df5b">RegularGrid3</a> = <a class="el" href="classvcl_1_1RegularGrid.html">RegularGrid</a>&lt; Scalar, 3 &gt;</td></tr>
<tr class="separator:a8d7cc878c7f7ccb25c576ebf7ad2df5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bbbace04824cfa901027d8e90d830c6"><td class="memTemplParams" colspan="2">template&lt;typename ValueType , typename ScalarType  = double&gt; </td></tr>
<tr class="memitem:a2bbbace04824cfa901027d8e90d830c6"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a2bbbace04824cfa901027d8e90d830c6">StaticGrid2</a> = <a class="el" href="classvcl_1_1StaticGrid.html">StaticGrid</a>&lt; <a class="el" href="namespacevcl.html#acf35775c9f8314906299b1b19f6c5f9b">RegularGrid2</a>&lt; ScalarType &gt;, ValueType &gt;</td></tr>
<tr class="separator:a2bbbace04824cfa901027d8e90d830c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa27c3398ca14cd8a5a7e1423d7a68cd"><td class="memTemplParams" colspan="2">template&lt;typename ValueType , typename ScalarType  = double&gt; </td></tr>
<tr class="memitem:afa27c3398ca14cd8a5a7e1423d7a68cd"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#afa27c3398ca14cd8a5a7e1423d7a68cd">StaticGrid3</a> = <a class="el" href="classvcl_1_1StaticGrid.html">StaticGrid</a>&lt; <a class="el" href="namespacevcl.html#a8d7cc878c7f7ccb25c576ebf7ad2df5b">RegularGrid3</a>&lt; ScalarType &gt;, ValueType &gt;</td></tr>
<tr class="separator:afa27c3398ca14cd8a5a7e1423d7a68cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a707bb169c4d4cafd5d84170b495721dc"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:a707bb169c4d4cafd5d84170b495721dc"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a707bb169c4d4cafd5d84170b495721dc">Matrix33</a> = Eigen::Matrix&lt; Scalar, 3, 3 &gt;</td></tr>
<tr class="separator:a707bb169c4d4cafd5d84170b495721dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2e70d03403788ee68a3f150a70d8039"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#aa2e70d03403788ee68a3f150a70d8039">Matrix33i</a> = <a class="el" href="namespacevcl.html#a707bb169c4d4cafd5d84170b495721dc">Matrix33</a>&lt; int &gt;</td></tr>
<tr class="separator:aa2e70d03403788ee68a3f150a70d8039"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac96c7ac5d789e9dbf055e35fa5a24835"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ac96c7ac5d789e9dbf055e35fa5a24835">Matrix33f</a> = <a class="el" href="namespacevcl.html#a707bb169c4d4cafd5d84170b495721dc">Matrix33</a>&lt; float &gt;</td></tr>
<tr class="separator:ac96c7ac5d789e9dbf055e35fa5a24835"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21e274a73f9088730a856902ede6ee37"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a21e274a73f9088730a856902ede6ee37">Matrix33d</a> = <a class="el" href="namespacevcl.html#a707bb169c4d4cafd5d84170b495721dc">Matrix33</a>&lt; double &gt;</td></tr>
<tr class="separator:a21e274a73f9088730a856902ede6ee37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad82a126b390f21b2e9658c73e7a795ee"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:ad82a126b390f21b2e9658c73e7a795ee"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ad82a126b390f21b2e9658c73e7a795ee">Matrix44</a> = Eigen::Matrix&lt; Scalar, 4, 4 &gt;</td></tr>
<tr class="separator:ad82a126b390f21b2e9658c73e7a795ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af09e528e12eb6fb1fc6e596b46da8beb"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#af09e528e12eb6fb1fc6e596b46da8beb">Matrix44i</a> = <a class="el" href="namespacevcl.html#ad82a126b390f21b2e9658c73e7a795ee">Matrix44</a>&lt; int &gt;</td></tr>
<tr class="separator:af09e528e12eb6fb1fc6e596b46da8beb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6891233f7166ae9569a840d151cfe140"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a6891233f7166ae9569a840d151cfe140">Matrix44f</a> = <a class="el" href="namespacevcl.html#ad82a126b390f21b2e9658c73e7a795ee">Matrix44</a>&lt; float &gt;</td></tr>
<tr class="separator:a6891233f7166ae9569a840d151cfe140"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c9537d456b6db5dc5f2216dfc8bccdc"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a0c9537d456b6db5dc5f2216dfc8bccdc">Matrix44d</a> = <a class="el" href="namespacevcl.html#ad82a126b390f21b2e9658c73e7a795ee">Matrix44</a>&lt; double &gt;</td></tr>
<tr class="separator:a0c9537d456b6db5dc5f2216dfc8bccdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fa66e0f1a04578cf69387027e898c8d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a6fa66e0f1a04578cf69387027e898c8d">Planef</a> = <a class="el" href="classvcl_1_1Plane.html">Plane</a>&lt; float &gt;</td></tr>
<tr class="separator:a6fa66e0f1a04578cf69387027e898c8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08ef90973b043cbb709bec85607f8313"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a08ef90973b043cbb709bec85607f8313">Planed</a> = <a class="el" href="classvcl_1_1Plane.html">Plane</a>&lt; double &gt;</td></tr>
<tr class="separator:a08ef90973b043cbb709bec85607f8313"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d15a5d1bc87330938ae9b8a55373334"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:ga6d15a5d1bc87330938ae9b8a55373334"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__space.html#ga6d15a5d1bc87330938ae9b8a55373334">Point2</a> = <a class="el" href="classvcl_1_1Point.html">Point</a>&lt; Scalar, 2 &gt;</td></tr>
<tr class="memdesc:ga6d15a5d1bc87330938ae9b8a55373334"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience alias for a 2-dimensional <a class="el" href="classvcl_1_1Point.html" title="The Point class represents an N-dimensional point containing N scalar values.">Point</a>.  <br /></td></tr>
<tr class="separator:ga6d15a5d1bc87330938ae9b8a55373334"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga94bdb300286f9b4bf31987102e011f8d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__space.html#ga94bdb300286f9b4bf31987102e011f8d">Point2i</a> = <a class="el" href="group__space.html#ga6d15a5d1bc87330938ae9b8a55373334">Point2</a>&lt; int &gt;</td></tr>
<tr class="memdesc:ga94bdb300286f9b4bf31987102e011f8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience alias for a 2-dimensional <a class="el" href="classvcl_1_1Point.html" title="The Point class represents an N-dimensional point containing N scalar values.">Point</a> with integer components.  <br /></td></tr>
<tr class="separator:ga94bdb300286f9b4bf31987102e011f8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac9560ad588438ce539ec3fdc5658746a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__space.html#gac9560ad588438ce539ec3fdc5658746a">Point2f</a> = <a class="el" href="group__space.html#ga6d15a5d1bc87330938ae9b8a55373334">Point2</a>&lt; float &gt;</td></tr>
<tr class="memdesc:gac9560ad588438ce539ec3fdc5658746a"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience alias for a 2-dimensional <a class="el" href="classvcl_1_1Point.html" title="The Point class represents an N-dimensional point containing N scalar values.">Point</a> with floating-point components.  <br /></td></tr>
<tr class="separator:gac9560ad588438ce539ec3fdc5658746a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b02e85ff4d51fe7d689f8dd0e87ecd5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__space.html#ga4b02e85ff4d51fe7d689f8dd0e87ecd5">Point2d</a> = <a class="el" href="group__space.html#ga6d15a5d1bc87330938ae9b8a55373334">Point2</a>&lt; double &gt;</td></tr>
<tr class="memdesc:ga4b02e85ff4d51fe7d689f8dd0e87ecd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience alias for a 2-dimensional <a class="el" href="classvcl_1_1Point.html" title="The Point class represents an N-dimensional point containing N scalar values.">Point</a> with double-precision floating-point components.  <br /></td></tr>
<tr class="separator:ga4b02e85ff4d51fe7d689f8dd0e87ecd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga13f2718b0763def563b8bd9f65982833"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:ga13f2718b0763def563b8bd9f65982833"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__space.html#ga13f2718b0763def563b8bd9f65982833">Point3</a> = <a class="el" href="classvcl_1_1Point.html">Point</a>&lt; Scalar, 3 &gt;</td></tr>
<tr class="memdesc:ga13f2718b0763def563b8bd9f65982833"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience alias for a 3-dimensional <a class="el" href="classvcl_1_1Point.html" title="The Point class represents an N-dimensional point containing N scalar values.">Point</a>.  <br /></td></tr>
<tr class="separator:ga13f2718b0763def563b8bd9f65982833"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga54b0dffe79fabd0458fc78332c91e73a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__space.html#ga54b0dffe79fabd0458fc78332c91e73a">Point3i</a> = <a class="el" href="group__space.html#ga13f2718b0763def563b8bd9f65982833">Point3</a>&lt; int &gt;</td></tr>
<tr class="memdesc:ga54b0dffe79fabd0458fc78332c91e73a"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience alias for a 3-dimensional <a class="el" href="classvcl_1_1Point.html" title="The Point class represents an N-dimensional point containing N scalar values.">Point</a> with integer components.  <br /></td></tr>
<tr class="separator:ga54b0dffe79fabd0458fc78332c91e73a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae19b0e9639a4f90c91e46910ee66f54c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__space.html#gae19b0e9639a4f90c91e46910ee66f54c">Point3f</a> = <a class="el" href="group__space.html#ga13f2718b0763def563b8bd9f65982833">Point3</a>&lt; float &gt;</td></tr>
<tr class="memdesc:gae19b0e9639a4f90c91e46910ee66f54c"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience alias for a 3-dimensional <a class="el" href="classvcl_1_1Point.html" title="The Point class represents an N-dimensional point containing N scalar values.">Point</a> with floating-point components.  <br /></td></tr>
<tr class="separator:gae19b0e9639a4f90c91e46910ee66f54c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb47c1364fb2fe1464a54417684f011e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__space.html#gabb47c1364fb2fe1464a54417684f011e">Point3d</a> = <a class="el" href="group__space.html#ga13f2718b0763def563b8bd9f65982833">Point3</a>&lt; double &gt;</td></tr>
<tr class="memdesc:gabb47c1364fb2fe1464a54417684f011e"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience alias for a 3-dimensional <a class="el" href="classvcl_1_1Point.html" title="The Point class represents an N-dimensional point containing N scalar values.">Point</a> with double-precision floating-point components.  <br /></td></tr>
<tr class="separator:gabb47c1364fb2fe1464a54417684f011e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga13715e1b62b4c051146f46d84e04afbc"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:ga13715e1b62b4c051146f46d84e04afbc"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__space.html#ga13715e1b62b4c051146f46d84e04afbc">Point4</a> = <a class="el" href="classvcl_1_1Point.html">Point</a>&lt; Scalar, 4 &gt;</td></tr>
<tr class="memdesc:ga13715e1b62b4c051146f46d84e04afbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience alias for a 4-dimensional <a class="el" href="classvcl_1_1Point.html" title="The Point class represents an N-dimensional point containing N scalar values.">Point</a>.  <br /></td></tr>
<tr class="separator:ga13715e1b62b4c051146f46d84e04afbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac86981d787ccd11247f7774e3be3c7b2"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__space.html#gac86981d787ccd11247f7774e3be3c7b2">Point4i</a> = <a class="el" href="group__space.html#ga13715e1b62b4c051146f46d84e04afbc">Point4</a>&lt; int &gt;</td></tr>
<tr class="memdesc:gac86981d787ccd11247f7774e3be3c7b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience alias for a 4-dimensional <a class="el" href="classvcl_1_1Point.html" title="The Point class represents an N-dimensional point containing N scalar values.">Point</a> with integer components.  <br /></td></tr>
<tr class="separator:gac86981d787ccd11247f7774e3be3c7b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga876dce2d8f1042f58d6ee413cd66b2e1"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__space.html#ga876dce2d8f1042f58d6ee413cd66b2e1">Point4f</a> = <a class="el" href="group__space.html#ga13715e1b62b4c051146f46d84e04afbc">Point4</a>&lt; float &gt;</td></tr>
<tr class="memdesc:ga876dce2d8f1042f58d6ee413cd66b2e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience alias for a 4-dimensional <a class="el" href="classvcl_1_1Point.html" title="The Point class represents an N-dimensional point containing N scalar values.">Point</a> with floating-point components.  <br /></td></tr>
<tr class="separator:ga876dce2d8f1042f58d6ee413cd66b2e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga648562f0e0989c853d13b8b0338f3646"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__space.html#ga648562f0e0989c853d13b8b0338f3646">Point4d</a> = <a class="el" href="group__space.html#ga13715e1b62b4c051146f46d84e04afbc">Point4</a>&lt; double &gt;</td></tr>
<tr class="memdesc:ga648562f0e0989c853d13b8b0338f3646"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience alias for a 4-dimensional <a class="el" href="classvcl_1_1Point.html" title="The Point class represents an N-dimensional point containing N scalar values.">Point</a> with double-precision floating-point components.  <br /></td></tr>
<tr class="separator:ga648562f0e0989c853d13b8b0338f3646"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a924ac7eb7740e67b7701c82f079ca13b"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:a924ac7eb7740e67b7701c82f079ca13b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a924ac7eb7740e67b7701c82f079ca13b">Polygon2</a> = <a class="el" href="classvcl_1_1Polygon.html">Polygon</a>&lt; <a class="el" href="group__space.html#ga6d15a5d1bc87330938ae9b8a55373334">Point2</a>&lt; Scalar &gt; &gt;</td></tr>
<tr class="separator:a924ac7eb7740e67b7701c82f079ca13b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d13400e95eb6871c2e4f6169ef08c23"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a2d13400e95eb6871c2e4f6169ef08c23">Polygon2f</a> = <a class="el" href="classvcl_1_1Polygon.html">Polygon</a>&lt; <a class="el" href="group__space.html#gac9560ad588438ce539ec3fdc5658746a">Point2f</a> &gt;</td></tr>
<tr class="separator:a2d13400e95eb6871c2e4f6169ef08c23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a386fd968f85ff551b4d58e109c21db9a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a386fd968f85ff551b4d58e109c21db9a">Polygon2d</a> = <a class="el" href="classvcl_1_1Polygon.html">Polygon</a>&lt; <a class="el" href="group__space.html#ga4b02e85ff4d51fe7d689f8dd0e87ecd5">Point2d</a> &gt;</td></tr>
<tr class="separator:a386fd968f85ff551b4d58e109c21db9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac04b9a59a6c30f22d15b0d1932e60457"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:ac04b9a59a6c30f22d15b0d1932e60457"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ac04b9a59a6c30f22d15b0d1932e60457">Polygon3</a> = <a class="el" href="classvcl_1_1Polygon.html">Polygon</a>&lt; <a class="el" href="group__space.html#ga13f2718b0763def563b8bd9f65982833">Point3</a>&lt; Scalar &gt; &gt;</td></tr>
<tr class="separator:ac04b9a59a6c30f22d15b0d1932e60457"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a359353bfe1b3e56f12a750b2de4abc"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a4a359353bfe1b3e56f12a750b2de4abc">Polygon3f</a> = <a class="el" href="classvcl_1_1Polygon.html">Polygon</a>&lt; <a class="el" href="group__space.html#gae19b0e9639a4f90c91e46910ee66f54c">Point3f</a> &gt;</td></tr>
<tr class="separator:a4a359353bfe1b3e56f12a750b2de4abc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac010b9e655ca9ca0c32f8c61b1eb56a2"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ac010b9e655ca9ca0c32f8c61b1eb56a2">Polygon3d</a> = <a class="el" href="classvcl_1_1Polygon.html">Polygon</a>&lt; <a class="el" href="group__space.html#gabb47c1364fb2fe1464a54417684f011e">Point3d</a> &gt;</td></tr>
<tr class="separator:ac010b9e655ca9ca0c32f8c61b1eb56a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cb93e7b8a1ccd33f76ba2d53ef9ecfa"><td class="memTemplParams" colspan="2">template&lt;VertexConcept VertexType&gt; </td></tr>
<tr class="memitem:a2cb93e7b8a1ccd33f76ba2d53ef9ecfa"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a2cb93e7b8a1ccd33f76ba2d53ef9ecfa">VertexSampler</a> = internal::VertexSampler&lt; VertexType, false &gt;</td></tr>
<tr class="separator:a2cb93e7b8a1ccd33f76ba2d53ef9ecfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af12c15595ec95998920b3ded3c1a8dbf"><td class="memTemplParams" colspan="2">template&lt;VertexConcept VertexType&gt; </td></tr>
<tr class="memitem:af12c15595ec95998920b3ded3c1a8dbf"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#af12c15595ec95998920b3ded3c1a8dbf">ConstVertexSampler</a> = internal::VertexSampler&lt; VertexType, true &gt;</td></tr>
<tr class="separator:af12c15595ec95998920b3ded3c1a8dbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8c7ce5479499796837976d3247e4df8"><td class="memTemplParams" colspan="2">template&lt;typename S &gt; </td></tr>
<tr class="memitem:af8c7ce5479499796837976d3247e4df8"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#af8c7ce5479499796837976d3247e4df8">Segment2</a> = <a class="el" href="classvcl_1_1Segment.html">Segment</a>&lt; <a class="el" href="group__space.html#ga6d15a5d1bc87330938ae9b8a55373334">Point2</a>&lt; S &gt; &gt;</td></tr>
<tr class="separator:af8c7ce5479499796837976d3247e4df8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ca08e736f7887a86fa4fc2dd396cdc5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a9ca08e736f7887a86fa4fc2dd396cdc5">Segment2i</a> = <a class="el" href="classvcl_1_1Segment.html">Segment</a>&lt; <a class="el" href="group__space.html#ga94bdb300286f9b4bf31987102e011f8d">Point2i</a> &gt;</td></tr>
<tr class="separator:a9ca08e736f7887a86fa4fc2dd396cdc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83dc041e1243c07111706a89433af7a9"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a83dc041e1243c07111706a89433af7a9">Segment2f</a> = <a class="el" href="classvcl_1_1Segment.html">Segment</a>&lt; <a class="el" href="group__space.html#gac9560ad588438ce539ec3fdc5658746a">Point2f</a> &gt;</td></tr>
<tr class="separator:a83dc041e1243c07111706a89433af7a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5da8472ea5b5275ab7109e52d50af04"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ae5da8472ea5b5275ab7109e52d50af04">Segment2d</a> = <a class="el" href="classvcl_1_1Segment.html">Segment</a>&lt; <a class="el" href="group__space.html#ga4b02e85ff4d51fe7d689f8dd0e87ecd5">Point2d</a> &gt;</td></tr>
<tr class="separator:ae5da8472ea5b5275ab7109e52d50af04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc9c518fdcc207d621776ebeeedc0db5"><td class="memTemplParams" colspan="2">template&lt;typename S &gt; </td></tr>
<tr class="memitem:afc9c518fdcc207d621776ebeeedc0db5"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#afc9c518fdcc207d621776ebeeedc0db5">Segment3</a> = <a class="el" href="classvcl_1_1Segment.html">Segment</a>&lt; <a class="el" href="group__space.html#ga13f2718b0763def563b8bd9f65982833">Point3</a>&lt; S &gt; &gt;</td></tr>
<tr class="separator:afc9c518fdcc207d621776ebeeedc0db5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0694142b42086cf347becff6f0db0c9c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a0694142b42086cf347becff6f0db0c9c">Segment3i</a> = <a class="el" href="classvcl_1_1Segment.html">Segment</a>&lt; <a class="el" href="group__space.html#ga54b0dffe79fabd0458fc78332c91e73a">Point3i</a> &gt;</td></tr>
<tr class="separator:a0694142b42086cf347becff6f0db0c9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01b4f12a5cd0b2470b2abcd9890f1de1"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a01b4f12a5cd0b2470b2abcd9890f1de1">Segment3f</a> = <a class="el" href="classvcl_1_1Segment.html">Segment</a>&lt; <a class="el" href="group__space.html#gae19b0e9639a4f90c91e46910ee66f54c">Point3f</a> &gt;</td></tr>
<tr class="separator:a01b4f12a5cd0b2470b2abcd9890f1de1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77d6ff7d119b08bd6bc8d5e84b9fe2ec"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a77d6ff7d119b08bd6bc8d5e84b9fe2ec">Segment3d</a> = <a class="el" href="classvcl_1_1Segment.html">Segment</a>&lt; <a class="el" href="group__space.html#gabb47c1364fb2fe1464a54417684f011e">Point3d</a> &gt;</td></tr>
<tr class="separator:a77d6ff7d119b08bd6bc8d5e84b9fe2ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a918b0af3e76ff4b82da382ddfab126d0"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a918b0af3e76ff4b82da382ddfab126d0">Spheref</a> = <a class="el" href="classvcl_1_1Sphere.html">Sphere</a>&lt; float &gt;</td></tr>
<tr class="separator:a918b0af3e76ff4b82da382ddfab126d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a125a3b42c101ab958048c730060aa8c8"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a125a3b42c101ab958048c730060aa8c8">Sphered</a> = <a class="el" href="classvcl_1_1Sphere.html">Sphere</a>&lt; double &gt;</td></tr>
<tr class="separator:a125a3b42c101ab958048c730060aa8c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a917984925513fc8634c94e269ee0cf82"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a917984925513fc8634c94e269ee0cf82">TexCoordi</a> = <a class="el" href="classvcl_1_1TexCoord.html">TexCoord</a>&lt; int &gt;</td></tr>
<tr class="separator:a917984925513fc8634c94e269ee0cf82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ccd8e32ef2f6bf0decb43463f41fb2b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a6ccd8e32ef2f6bf0decb43463f41fb2b">TexCoordf</a> = <a class="el" href="classvcl_1_1TexCoord.html">TexCoord</a>&lt; float &gt;</td></tr>
<tr class="separator:a6ccd8e32ef2f6bf0decb43463f41fb2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec42e251f09249cda2fe0463b81c0f79"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#aec42e251f09249cda2fe0463b81c0f79">TexCoordd</a> = <a class="el" href="classvcl_1_1TexCoord.html">TexCoord</a>&lt; double &gt;</td></tr>
<tr class="separator:aec42e251f09249cda2fe0463b81c0f79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac0ef38a541827b51057bfae9e8c5039"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:aac0ef38a541827b51057bfae9e8c5039"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#aac0ef38a541827b51057bfae9e8c5039">Triangle2</a> = <a class="el" href="classvcl_1_1Triangle.html">Triangle</a>&lt; <a class="el" href="group__space.html#ga6d15a5d1bc87330938ae9b8a55373334">Point2</a>&lt; Scalar &gt; &gt;</td></tr>
<tr class="separator:aac0ef38a541827b51057bfae9e8c5039"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1f6b217d733de32db193f0e751ece25"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ad1f6b217d733de32db193f0e751ece25">Triangle2f</a> = <a class="el" href="classvcl_1_1Triangle.html">Triangle</a>&lt; <a class="el" href="group__space.html#gac9560ad588438ce539ec3fdc5658746a">Point2f</a> &gt;</td></tr>
<tr class="separator:ad1f6b217d733de32db193f0e751ece25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e9344ae874797a2a653deab133d870f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a8e9344ae874797a2a653deab133d870f">Triangle2d</a> = <a class="el" href="classvcl_1_1Triangle.html">Triangle</a>&lt; <a class="el" href="group__space.html#ga4b02e85ff4d51fe7d689f8dd0e87ecd5">Point2d</a> &gt;</td></tr>
<tr class="separator:a8e9344ae874797a2a653deab133d870f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae03921c36e8b060269d9ff90b068db39"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:ae03921c36e8b060269d9ff90b068db39"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ae03921c36e8b060269d9ff90b068db39">Triangle3</a> = <a class="el" href="classvcl_1_1Triangle.html">Triangle</a>&lt; <a class="el" href="group__space.html#ga13f2718b0763def563b8bd9f65982833">Point3</a>&lt; Scalar &gt; &gt;</td></tr>
<tr class="separator:ae03921c36e8b060269d9ff90b068db39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa2a67863f5edd83d508344306bd7bb3"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#afa2a67863f5edd83d508344306bd7bb3">Triangle3f</a> = <a class="el" href="classvcl_1_1Triangle.html">Triangle</a>&lt; <a class="el" href="group__space.html#gae19b0e9639a4f90c91e46910ee66f54c">Point3f</a> &gt;</td></tr>
<tr class="separator:afa2a67863f5edd83d508344306bd7bb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02db1e7fb252318c4435c8ca9944401e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a02db1e7fb252318c4435c8ca9944401e">Triangle3d</a> = <a class="el" href="classvcl_1_1Triangle.html">Triangle</a>&lt; <a class="el" href="group__space.html#gabb47c1364fb2fe1464a54417684f011e">Point3d</a> &gt;</td></tr>
<tr class="separator:a02db1e7fb252318c4435c8ca9944401e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92c93a12005e031d04c92971247414ef"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:a92c93a12005e031d04c92971247414ef"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a92c93a12005e031d04c92971247414ef">TriangleWrapper2</a> = <a class="el" href="classvcl_1_1TriangleWrapper.html">TriangleWrapper</a>&lt; <a class="el" href="group__space.html#ga6d15a5d1bc87330938ae9b8a55373334">Point2</a>&lt; Scalar &gt; &gt;</td></tr>
<tr class="separator:a92c93a12005e031d04c92971247414ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ff16ee6b33f9bdd47405cb91f29e2d0"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a5ff16ee6b33f9bdd47405cb91f29e2d0">TriangleWrapper2f</a> = <a class="el" href="classvcl_1_1TriangleWrapper.html">TriangleWrapper</a>&lt; <a class="el" href="group__space.html#gac9560ad588438ce539ec3fdc5658746a">Point2f</a> &gt;</td></tr>
<tr class="separator:a5ff16ee6b33f9bdd47405cb91f29e2d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27931fc2ea467c03c1019dc025d218e5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a27931fc2ea467c03c1019dc025d218e5">TriangleWrapper2d</a> = <a class="el" href="classvcl_1_1TriangleWrapper.html">TriangleWrapper</a>&lt; <a class="el" href="group__space.html#ga4b02e85ff4d51fe7d689f8dd0e87ecd5">Point2d</a> &gt;</td></tr>
<tr class="separator:a27931fc2ea467c03c1019dc025d218e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a439efbe438907a52943d563d8a12daab"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:a439efbe438907a52943d563d8a12daab"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a439efbe438907a52943d563d8a12daab">TriangleWrapper3</a> = <a class="el" href="classvcl_1_1TriangleWrapper.html">TriangleWrapper</a>&lt; <a class="el" href="group__space.html#ga13f2718b0763def563b8bd9f65982833">Point3</a>&lt; Scalar &gt; &gt;</td></tr>
<tr class="separator:a439efbe438907a52943d563d8a12daab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a295b4c2f1ffcf361e32166b44a5a4476"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a295b4c2f1ffcf361e32166b44a5a4476">TriangleWrapper3f</a> = <a class="el" href="classvcl_1_1TriangleWrapper.html">TriangleWrapper</a>&lt; <a class="el" href="group__space.html#gae19b0e9639a4f90c91e46910ee66f54c">Point3f</a> &gt;</td></tr>
<tr class="separator:a295b4c2f1ffcf361e32166b44a5a4476"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace2761031333634f83908ed3d4e5fb19"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ace2761031333634f83908ed3d4e5fb19">TriangleWrapper3d</a> = <a class="el" href="classvcl_1_1TriangleWrapper.html">TriangleWrapper</a>&lt; <a class="el" href="group__space.html#gabb47c1364fb2fe1464a54417684f011e">Point3d</a> &gt;</td></tr>
<tr class="separator:ace2761031333634f83908ed3d4e5fb19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca4b0f0c23a3bd7ad471022123a5a0d8"><td class="memTemplParams" colspan="2">template&lt;typename derived , template&lt; typename... &gt; class base&gt; </td></tr>
<tr class="memitem:aca4b0f0c23a3bd7ad471022123a5a0d8"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#aca4b0f0c23a3bd7ad471022123a5a0d8">IsDerivedFromTemplateSpecialization</a> = std::invoke_result&lt; internal::IsDerivedFromImplementation&lt; base &gt;, typename std::remove_cv&lt; derived &gt;::type * &gt;::type</td></tr>
<tr class="separator:aca4b0f0c23a3bd7ad471022123a5a0d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ec2f45ee6feff2a4aff0f15d6b0b0b0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2ec2f45ee6feff2a4aff0f15d6b0b0b0"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a2ec2f45ee6feff2a4aff0f15d6b0b0b0">RemoveCVRefAndPointer</a> = typename std::remove_cvref_t&lt; std::remove_pointer_t&lt; T &gt; &gt;</td></tr>
<tr class="separator:a2ec2f45ee6feff2a4aff0f15d6b0b0b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a8e5224d2d66eae96da5ec5f8bd7eb5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8a8e5224d2d66eae96da5ec5f8bd7eb5"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a8a8e5224d2d66eae96da5ec5f8bd7eb5">RemoveConstFromPointer</a> = std::conditional_t&lt; std::is_pointer_v&lt; T &gt;, std::add_pointer_t&lt; typename std::remove_cv_t&lt; typename std::remove_pointer_t&lt; T &gt; &gt; &gt;, T &gt;</td></tr>
<tr class="separator:a8a8e5224d2d66eae96da5ec5f8bd7eb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a5a4e8376b2d47797f9167f2a8dd6fb0e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a5a4e8376b2d47797f9167f2a8dd6fb0e">HausdorffSamplingMethod</a> { <a class="el" href="namespacevcl.html#a5a4e8376b2d47797f9167f2a8dd6fb0ea33aad0431cadce18cad82201cb732f49">HAUSDORFF_VERTEX_UNIFORM</a> = 0
, <a class="el" href="namespacevcl.html#a5a4e8376b2d47797f9167f2a8dd6fb0eac8770691ceb41b51c7ab63b70f1da9c6">HAUSDORFF_EDGE_UNIFORM</a>
, <a class="el" href="namespacevcl.html#a5a4e8376b2d47797f9167f2a8dd6fb0eaf9d0153b4af81b71be3972e5a9e3307a">HAUSDORFF_MONTECARLO</a>
 }</td></tr>
<tr class="separator:a5a4e8376b2d47797f9167f2a8dd6fb0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaca879a6bfd47ff8429d6b2f6cfa9440"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#aaca879a6bfd47ff8429d6b2f6cfa9440">VCLibPrincipalCurvatureAlgorithm</a> { <a class="el" href="namespacevcl.html#aaca879a6bfd47ff8429d6b2f6cfa9440a16e818963316b0b43fcbdec6d75f25ed">VCL_PRINCIPAL_CURVATURE_TAUBIN95</a>
, <a class="el" href="namespacevcl.html#aaca879a6bfd47ff8429d6b2f6cfa9440a2c812dad0f96c382657b60bb2d2f8180">VCL_PRINCIPAL_CURVATURE_PCA</a>
 }</td></tr>
<tr class="separator:aaca879a6bfd47ff8429d6b2f6cfa9440"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f1474ce703c6b063677f747fccaffd6"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a3f1474ce703c6b063677f747fccaffd6">ComponentIDEnum</a> : uint { <br />
&#160;&#160;<a class="el" href="namespacevcl.html#a3f1474ce703c6b063677f747fccaffd6a96af186d25705f291379814fe1f2ef8e">BIT_FLAGS</a> = 0
, <a class="el" href="namespacevcl.html#a3f1474ce703c6b063677f747fccaffd6a2518c9b8b4cfd9843ffd5399a2e6f7ad">COORDINATE</a>
, <a class="el" href="namespacevcl.html#a3f1474ce703c6b063677f747fccaffd6a391cebfb461095102db45aca2deac4b1">NORMAL</a>
, <a class="el" href="namespacevcl.html#a3f1474ce703c6b063677f747fccaffd6af20ccd0cc636dcdc7ddfdc951bbcff12">COLOR</a>
, <br />
&#160;&#160;<a class="el" href="namespacevcl.html#a3f1474ce703c6b063677f747fccaffd6a3ae1b3b0757067aabc1c3c8464e6c3fa">QUALITY</a>
, <a class="el" href="namespacevcl.html#a3f1474ce703c6b063677f747fccaffd6ad37ecc06b487f1e4b2c4dec7091029a2">MARK</a>
, <a class="el" href="namespacevcl.html#a3f1474ce703c6b063677f747fccaffd6afb61ac208cf6f113d02518e9d2db513c">PRINCIPAL_CURVATURE</a>
, <a class="el" href="namespacevcl.html#a3f1474ce703c6b063677f747fccaffd6a301ae6d835b1530434994e44cc5beebc">TEX_COORD</a>
, <br />
&#160;&#160;<a class="el" href="namespacevcl.html#a3f1474ce703c6b063677f747fccaffd6a848ff528789e6d6d1590fbe406f6e7ca">VERTEX_PTRS</a>
, <a class="el" href="namespacevcl.html#a3f1474ce703c6b063677f747fccaffd6ae8d3db0b18558b89d3fad8cfbbf3baf0">ADJACENT_EDGES</a>
, <a class="el" href="namespacevcl.html#a3f1474ce703c6b063677f747fccaffd6a66fc76888ade90ce07ebb705d0b2af9c">ADJACENT_FACES</a>
, <a class="el" href="namespacevcl.html#a3f1474ce703c6b063677f747fccaffd6a05010a40c6adc052d230f646106fdc3c">ADJACENT_VERTICES</a>
, <br />
&#160;&#160;<a class="el" href="namespacevcl.html#a3f1474ce703c6b063677f747fccaffd6afdd8a9baf552cee157a83240111b5317">WEDGE_COLORS</a>
, <a class="el" href="namespacevcl.html#a3f1474ce703c6b063677f747fccaffd6a9ca2b21f4e6c633fd482276d1979b497">WEDGE_TEX_COORDS</a>
, <a class="el" href="namespacevcl.html#a3f1474ce703c6b063677f747fccaffd6a4388f6baca6989c69c0bacf41a28bb37">BOUNDING_BOX</a>
, <a class="el" href="namespacevcl.html#a3f1474ce703c6b063677f747fccaffd6aaa06362739c3118aa022cd54160245f0">NAME</a>
, <br />
&#160;&#160;<a class="el" href="namespacevcl.html#a3f1474ce703c6b063677f747fccaffd6a242ce2627ed5591d7913c3485b5e0f41">TEXTURE_PATHS</a>
, <a class="el" href="namespacevcl.html#a3f1474ce703c6b063677f747fccaffd6aba543e5ee5048450527106b123686aa8">TRANSFORM_MATRIX</a>
, <a class="el" href="namespacevcl.html#a3f1474ce703c6b063677f747fccaffd6a14a144ed134908cae680884da549edfa">CUSTOM_COMPONENTS</a>
<br />
 }</td></tr>
<tr class="separator:a3f1474ce703c6b063677f747fccaffd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae046f7dd555ae870338041167e1fcb72"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ae046f7dd555ae870338041167e1fcb72">ElementIDEnum</a> : uint { <a class="el" href="namespacevcl.html#ae046f7dd555ae870338041167e1fcb72a2b976bb23bc172fe0c729ce8f367b76e">VERTEX</a> = 0
, <a class="el" href="namespacevcl.html#ae046f7dd555ae870338041167e1fcb72a0deacef785932de145d594f20e312b58">FACE</a>
, <a class="el" href="namespacevcl.html#ae046f7dd555ae870338041167e1fcb72a277eb4b09247da79fe02b8a334452e67">EDGE</a>
 }</td></tr>
<tr class="separator:ae046f7dd555ae870338041167e1fcb72"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga1ad883eeb58e2a302d15ce6ba179752f"><td class="memTemplParams" colspan="2">template&lt;PointConcept PointType&gt; </td></tr>
<tr class="memitem:ga1ad883eeb58e2a302d15ce6ba179752f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bounding__box.html#ga1ad883eeb58e2a302d15ce6ba179752f">boundingBox</a> (const PointType &amp;p)</td></tr>
<tr class="memdesc:ga1ad883eeb58e2a302d15ce6ba179752f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the bounding box of a single point.  <br /></td></tr>
<tr class="separator:ga1ad883eeb58e2a302d15ce6ba179752f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga776dc863a78918d5a0f104907ab8a26f"><td class="memTemplParams" colspan="2">template&lt;SegmentConcept SegmentType&gt; </td></tr>
<tr class="memitem:ga776dc863a78918d5a0f104907ab8a26f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bounding__box.html#ga776dc863a78918d5a0f104907ab8a26f">boundingBox</a> (const SegmentType &amp;s)</td></tr>
<tr class="memdesc:ga776dc863a78918d5a0f104907ab8a26f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the bounding box of a line segment.  <br /></td></tr>
<tr class="separator:ga776dc863a78918d5a0f104907ab8a26f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab8f4fd4f0f5ffcf56b82e44e7bb6a1dd"><td class="memTemplParams" colspan="2">template&lt;SphereConcept SphereType&gt; </td></tr>
<tr class="memitem:gab8f4fd4f0f5ffcf56b82e44e7bb6a1dd"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bounding__box.html#gab8f4fd4f0f5ffcf56b82e44e7bb6a1dd">boundingBox</a> (const SphereType &amp;s)</td></tr>
<tr class="memdesc:gab8f4fd4f0f5ffcf56b82e44e7bb6a1dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the bounding box of a sphere.  <br /></td></tr>
<tr class="separator:gab8f4fd4f0f5ffcf56b82e44e7bb6a1dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2aa52bf969238c1f809e218722e63ccf"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga2aa52bf969238c1f809e218722e63ccf"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bounding__box.html#ga2aa52bf969238c1f809e218722e63ccf">boundingBox</a> (const MeshType &amp;m)</td></tr>
<tr class="memdesc:ga2aa52bf969238c1f809e218722e63ccf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the bounding box of a mesh.  <br /></td></tr>
<tr class="separator:ga2aa52bf969238c1f809e218722e63ccf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5394cef99570de3bb2538e6c4dae69f7"><td class="memTemplParams" colspan="2">template&lt;VertexConcept VertexType&gt; </td></tr>
<tr class="memitem:ga5394cef99570de3bb2538e6c4dae69f7"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bounding__box.html#ga5394cef99570de3bb2538e6c4dae69f7">boundingBox</a> (const VertexType &amp;v)</td></tr>
<tr class="memdesc:ga5394cef99570de3bb2538e6c4dae69f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the bounding box of a vertex.  <br /></td></tr>
<tr class="separator:ga5394cef99570de3bb2538e6c4dae69f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga65283494a83b003698a6f37d3157384a"><td class="memTemplParams" colspan="2">template&lt;VertexConcept VertexType&gt; </td></tr>
<tr class="memitem:ga65283494a83b003698a6f37d3157384a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bounding__box.html#ga65283494a83b003698a6f37d3157384a">boundingBox</a> (const VertexType *v)</td></tr>
<tr class="memdesc:ga65283494a83b003698a6f37d3157384a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the bounding box of a vertex pointer.  <br /></td></tr>
<tr class="separator:ga65283494a83b003698a6f37d3157384a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf568c42e98a48937632002951ba1a0c7"><td class="memTemplParams" colspan="2">template&lt;FaceConcept FaceType&gt; </td></tr>
<tr class="memitem:gaf568c42e98a48937632002951ba1a0c7"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bounding__box.html#gaf568c42e98a48937632002951ba1a0c7">boundingBox</a> (const FaceType &amp;f)</td></tr>
<tr class="memdesc:gaf568c42e98a48937632002951ba1a0c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the bounding box of a face.  <br /></td></tr>
<tr class="separator:gaf568c42e98a48937632002951ba1a0c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafcd15ef8e31e650a8e3714feb5c6efcc"><td class="memTemplParams" colspan="2">template&lt;FaceConcept FaceType&gt; </td></tr>
<tr class="memitem:gafcd15ef8e31e650a8e3714feb5c6efcc"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bounding__box.html#gafcd15ef8e31e650a8e3714feb5c6efcc">boundingBox</a> (const FaceType *f)</td></tr>
<tr class="memdesc:gafcd15ef8e31e650a8e3714feb5c6efcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the bounding box of a face pointer.  <br /></td></tr>
<tr class="separator:gafcd15ef8e31e650a8e3714feb5c6efcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3364ecfcc22e860e202e0c4edc2bbc79"><td class="memTemplParams" colspan="2">template&lt;EdgeConcept EdgeType&gt; </td></tr>
<tr class="memitem:ga3364ecfcc22e860e202e0c4edc2bbc79"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bounding__box.html#ga3364ecfcc22e860e202e0c4edc2bbc79">boundingBox</a> (const EdgeType &amp;e)</td></tr>
<tr class="memdesc:ga3364ecfcc22e860e202e0c4edc2bbc79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the bounding box of an edge.  <br /></td></tr>
<tr class="separator:ga3364ecfcc22e860e202e0c4edc2bbc79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac83361d6c2d4182da008a6e198fe4465"><td class="memTemplParams" colspan="2">template&lt;EdgeConcept EdgeType&gt; </td></tr>
<tr class="memitem:gac83361d6c2d4182da008a6e198fe4465"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bounding__box.html#gac83361d6c2d4182da008a6e198fe4465">boundingBox</a> (const EdgeType *e)</td></tr>
<tr class="memdesc:gac83361d6c2d4182da008a6e198fe4465"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the bounding box of an edge pointer.  <br /></td></tr>
<tr class="separator:gac83361d6c2d4182da008a6e198fe4465"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c874831bf64431e53535e966bccb9e9"><td class="memTemplParams" colspan="2">template&lt;IteratorConcept Iterator&gt; </td></tr>
<tr class="memitem:ga6c874831bf64431e53535e966bccb9e9"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bounding__box.html#ga6c874831bf64431e53535e966bccb9e9">boundingBox</a> (Iterator begin, Iterator end)</td></tr>
<tr class="memdesc:ga6c874831bf64431e53535e966bccb9e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the bounding box of a set of objects.  <br /></td></tr>
<tr class="separator:ga6c874831bf64431e53535e966bccb9e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga780e912fa6dbf0a2a7d0e49445f65347"><td class="memTemplParams" colspan="2">template&lt;Range Rng&gt; </td></tr>
<tr class="memitem:ga780e912fa6dbf0a2a7d0e49445f65347"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bounding__box.html#ga780e912fa6dbf0a2a7d0e49445f65347">boundingBox</a> (Rng &amp;&amp;r)</td></tr>
<tr class="memdesc:ga780e912fa6dbf0a2a7d0e49445f65347"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the bounding box of a range of objects.  <br /></td></tr>
<tr class="separator:ga780e912fa6dbf0a2a7d0e49445f65347"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed545a1f18ff8b6c2ee273c0d44c9b9f"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:gaed545a1f18ff8b6c2ee273c0d44c9b9f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__clean.html#gaed545a1f18ff8b6c2ee273c0d44c9b9f">numberUnreferencedVertices</a> (const MeshType &amp;m)</td></tr>
<tr class="memdesc:gaed545a1f18ff8b6c2ee273c0d44c9b9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of non-deleted unreferenced vertices of the mesh.  <br /></td></tr>
<tr class="separator:gaed545a1f18ff8b6c2ee273c0d44c9b9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25c5d478a258364fa7a8215e7ffbb7d2"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga25c5d478a258364fa7a8215e7ffbb7d2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__clean.html#ga25c5d478a258364fa7a8215e7ffbb7d2">removeUnreferencedVertices</a> (MeshType &amp;m)</td></tr>
<tr class="memdesc:ga25c5d478a258364fa7a8215e7ffbb7d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marks as deleted all the non-deleted unreferenced vertices of the mesh.  <br /></td></tr>
<tr class="separator:ga25c5d478a258364fa7a8215e7ffbb7d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabce801a437aa06438837271fde16cb5a"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:gabce801a437aa06438837271fde16cb5a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__clean.html#gabce801a437aa06438837271fde16cb5a">removeDuplicatedVertices</a> (MeshType &amp;m)</td></tr>
<tr class="memdesc:gabce801a437aa06438837271fde16cb5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marks as deleted the duplicate vertices of the mesh, by looking only at their spatial positions.  <br /></td></tr>
<tr class="separator:gabce801a437aa06438837271fde16cb5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e771a075c5db04274b407af212d2c2b"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga6e771a075c5db04274b407af212d2c2b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__clean.html#ga6e771a075c5db04274b407af212d2c2b">removeDuplicatedFaces</a> (MeshType &amp;m)</td></tr>
<tr class="memdesc:ga6e771a075c5db04274b407af212d2c2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all duplicate faces of the mesh by looking only at their vertex references.  <br /></td></tr>
<tr class="separator:ga6e771a075c5db04274b407af212d2c2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga351485ba1c87c7bd1193917323921ba7"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga351485ba1c87c7bd1193917323921ba7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__clean.html#ga351485ba1c87c7bd1193917323921ba7">removeDegeneratedVertices</a> (MeshType &amp;m, bool deleteAlsoFaces)</td></tr>
<tr class="memdesc:ga351485ba1c87c7bd1193917323921ba7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all vertices that have coordinates with invalid floating point values (NaN or inf).  <br /></td></tr>
<tr class="separator:ga351485ba1c87c7bd1193917323921ba7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3561ea390b2dfc6fec49d12543ea60e7"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga3561ea390b2dfc6fec49d12543ea60e7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__clean.html#ga3561ea390b2dfc6fec49d12543ea60e7">removeDegenerateFaces</a> (MeshType &amp;m)</td></tr>
<tr class="memdesc:ga3561ea390b2dfc6fec49d12543ea60e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all degenerate faces from the input mesh.  <br /></td></tr>
<tr class="separator:ga3561ea390b2dfc6fec49d12543ea60e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd1e4943610b0e15397196d5fc73b0da"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:gabd1e4943610b0e15397196d5fc73b0da"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__clean.html#gabd1e4943610b0e15397196d5fc73b0da">numberNonManifoldVertices</a> (const MeshType &amp;m)</td></tr>
<tr class="memdesc:gabd1e4943610b0e15397196d5fc73b0da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counts the number of non-manifold vertices in the input mesh.  <br /></td></tr>
<tr class="separator:gabd1e4943610b0e15397196d5fc73b0da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae4c34d80af91ce6339f86c6de2c702cd"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:gae4c34d80af91ce6339f86c6de2c702cd"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__clean.html#gae4c34d80af91ce6339f86c6de2c702cd">isWaterTight</a> (const MeshType &amp;m)</td></tr>
<tr class="memdesc:gae4c34d80af91ce6339f86c6de2c702cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the input mesh is water tight.  <br /></td></tr>
<tr class="separator:gae4c34d80af91ce6339f86c6de2c702cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c6de124adcaf9fb747b9c490667f093"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; <br />
requires <a class="el" href="conceptvcl_1_1HasPerFaceAdjacentFaces.html">vcl::HasPerFaceAdjacentFaces</a>&lt;MeshType&gt;</td></tr>
<tr class="memitem:ga4c6de124adcaf9fb747b9c490667f093"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__clean.html#ga4c6de124adcaf9fb747b9c490667f093">numberHoles</a> (const MeshType &amp;m)</td></tr>
<tr class="memdesc:ga4c6de124adcaf9fb747b9c490667f093"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counts the number of holes in the input mesh.  <br /></td></tr>
<tr class="separator:ga4c6de124adcaf9fb747b9c490667f093"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga774f9a47e9cef107d59b97d0434177f7"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; <br />
requires <a class="el" href="conceptvcl_1_1HasPerFaceAdjacentFaces.html">vcl::HasPerFaceAdjacentFaces</a>&lt;MeshType&gt;</td></tr>
<tr class="memitem:ga774f9a47e9cef107d59b97d0434177f7"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::set&lt; <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__clean.html#ga774f9a47e9cef107d59b97d0434177f7">connectedComponents</a> (const MeshType &amp;m)</td></tr>
<tr class="memdesc:ga774f9a47e9cef107d59b97d0434177f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the connected components of the input mesh based on its topology.  <br /></td></tr>
<tr class="separator:ga774f9a47e9cef107d59b97d0434177f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf8a059b21f1238f6e531191f40685670"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:gaf8a059b21f1238f6e531191f40685670"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__clean.html#gaf8a059b21f1238f6e531191f40685670">numberConnectedComponents</a> (const MeshType &amp;m)</td></tr>
<tr class="memdesc:gaf8a059b21f1238f6e531191f40685670"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the number of connected components of the input mesh based on its topology.  <br /></td></tr>
<tr class="separator:gaf8a059b21f1238f6e531191f40685670"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed05ee87778462738625d7c0f6ac38e6"><td class="memTemplParams" colspan="2">template&lt;PolygonMeshConcept MeshType, LoggerConcept LogType = NullLogger&gt; </td></tr>
<tr class="memitem:gaed05ee87778462738625d7c0f6ac38e6"><td class="memTemplItemLeft" align="right" valign="top">MeshType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__create.html#gaed05ee87778462738625d7c0f6ac38e6">createDodecahedron</a> (LogType &amp;log=<a class="el" href="group__miscellaneous.html#ga3377e3c875ec245e90ac5a395105ce99">nullLogger</a>)</td></tr>
<tr class="memdesc:gaed05ee87778462738625d7c0f6ac38e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates and returns a <a class="el" href="classvcl_1_1Polygon.html">Polygon</a> <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a> containing a Dodecahedron.  <br /></td></tr>
<tr class="separator:gaed05ee87778462738625d7c0f6ac38e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad27918bc874e941633aeeb83c09ef8bc"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:gad27918bc874e941633aeeb83c09ef8bc"><td class="memTemplItemLeft" align="right" valign="top">MeshType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__create.html#gad27918bc874e941633aeeb83c09ef8bc">createHexahedron</a> ()</td></tr>
<tr class="memdesc:gad27918bc874e941633aeeb83c09ef8bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates and returns a hexahedron having as extremes the points <code>(-1, -1, -1)</code> and <code>(1, 1, 1)</code>.  <br /></td></tr>
<tr class="separator:gad27918bc874e941633aeeb83c09ef8bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga99aea140f795216e3bad1e4086ea3fe5"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType, Point3Concept CoordType&gt; </td></tr>
<tr class="memitem:ga99aea140f795216e3bad1e4086ea3fe5"><td class="memTemplItemLeft" align="right" valign="top">MeshType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__create.html#ga99aea140f795216e3bad1e4086ea3fe5">createHexahedron</a> (const CoordType &amp;<a class="el" href="namespacevcl.html#a3edcb561672a6be17e9453bd1ea446d5">min</a>, const CoordType &amp;<a class="el" href="namespacevcl.html#a69cc63a5ad2974d082145ed1dee7846b">max</a>)</td></tr>
<tr class="memdesc:ga99aea140f795216e3bad1e4086ea3fe5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates and returns a Hexahedron having as extremes points min and max given as arguments.  <br /></td></tr>
<tr class="separator:ga99aea140f795216e3bad1e4086ea3fe5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7383cbe54f93fa408ebd2f3e6f66ae21"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType, Point3Concept CoordType&gt; </td></tr>
<tr class="memitem:ga7383cbe54f93fa408ebd2f3e6f66ae21"><td class="memTemplItemLeft" align="right" valign="top">MeshType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__create.html#ga7383cbe54f93fa408ebd2f3e6f66ae21">createCube</a> (const CoordType &amp;<a class="el" href="namespacevcl.html#a3edcb561672a6be17e9453bd1ea446d5">min</a>, double edgeLength)</td></tr>
<tr class="memdesc:ga7383cbe54f93fa408ebd2f3e6f66ae21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates and returns a Cube having <code>min</code> as minimum extreme and the given edge length.  <br /></td></tr>
<tr class="separator:ga7383cbe54f93fa408ebd2f3e6f66ae21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6cf9b8ea5cd197d17f2a1bcf68c89050"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga6cf9b8ea5cd197d17f2a1bcf68c89050"><td class="memTemplItemLeft" align="right" valign="top">MeshType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__create.html#ga6cf9b8ea5cd197d17f2a1bcf68c89050">createIcosahedron</a> (bool normalizeVertices=false)</td></tr>
<tr class="memdesc:ga6cf9b8ea5cd197d17f2a1bcf68c89050"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates and returns an icosahedron mesh.  <br /></td></tr>
<tr class="separator:ga6cf9b8ea5cd197d17f2a1bcf68c89050"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga178428edf0329a0ed798ccc4b9a6feae"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga178428edf0329a0ed798ccc4b9a6feae"><td class="memTemplItemLeft" align="right" valign="top">MeshType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__create.html#ga178428edf0329a0ed798ccc4b9a6feae">createSphereUV</a> (const SphereConcept auto &amp;sp, <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> parallels, <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> meridians)</td></tr>
<tr class="memdesc:ga178428edf0329a0ed798ccc4b9a6feae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates and returns a sphere mesh using the UV mode, starting from a sphere object.  <br /></td></tr>
<tr class="separator:ga178428edf0329a0ed798ccc4b9a6feae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad6f54ee450c902f94c4185193d7bfed0"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:gad6f54ee450c902f94c4185193d7bfed0"><td class="memTemplItemLeft" align="right" valign="top">MeshType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__create.html#gad6f54ee450c902f94c4185193d7bfed0">createSphereNormalizedCube</a> (const SphereConcept auto &amp;sp, <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> divisions)</td></tr>
<tr class="memdesc:gad6f54ee450c902f94c4185193d7bfed0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates and returns a sphere mesh using the normalized cube mode, starting from a sphere object.  <br /></td></tr>
<tr class="separator:gad6f54ee450c902f94c4185193d7bfed0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga964925e1a22e75db7dea160f6ca9b9bd"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga964925e1a22e75db7dea160f6ca9b9bd"><td class="memTemplItemLeft" align="right" valign="top">MeshType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__create.html#ga964925e1a22e75db7dea160f6ca9b9bd">createSphereSpherifiedCube</a> (const SphereConcept auto &amp;sp, <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> divisions)</td></tr>
<tr class="memdesc:ga964925e1a22e75db7dea160f6ca9b9bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates and returns a sphere mesh using the spherified cube mode, starting from a sphere object.  <br /></td></tr>
<tr class="separator:ga964925e1a22e75db7dea160f6ca9b9bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4fa15f02159bbc4db0b84ffa8978b154"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga4fa15f02159bbc4db0b84ffa8978b154"><td class="memTemplItemLeft" align="right" valign="top">MeshType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__create.html#ga4fa15f02159bbc4db0b84ffa8978b154">createSphereIcosahedron</a> (const SphereConcept auto &amp;sp, <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> divisions)</td></tr>
<tr class="memdesc:ga4fa15f02159bbc4db0b84ffa8978b154"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates and returns a sphere mesh using the icosahedron mode, starting from a sphere object.  <br /></td></tr>
<tr class="separator:ga4fa15f02159bbc4db0b84ffa8978b154"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabff9f22d5dbda0bd9f591e893b80b4ce"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:gabff9f22d5dbda0bd9f591e893b80b4ce"><td class="memTemplItemLeft" align="right" valign="top">MeshType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__create.html#gabff9f22d5dbda0bd9f591e893b80b4ce">createSphere</a> (const SphereConcept auto &amp;sp, const <a class="el" href="structvcl_1_1CreateSphereArgs.html">CreateSphereArgs</a> &amp;args=<a class="el" href="structvcl_1_1CreateSphereArgs.html">CreateSphereArgs</a>())</td></tr>
<tr class="memdesc:gabff9f22d5dbda0bd9f591e893b80b4ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="classvcl_1_1Sphere.html">Sphere</a> <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a> starting from a sphere object, using the generation method given in the argument <code>args.mode</code> (see <a href="https://github.com/caosdoar/spheres">https://github.com/caosdoar/spheres</a> for more details).  <br /></td></tr>
<tr class="separator:gabff9f22d5dbda0bd9f591e893b80b4ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga455a7abda2f207c424dd5946c30c48c6"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga455a7abda2f207c424dd5946c30c48c6"><td class="memTemplItemLeft" align="right" valign="top">MeshType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__create.html#ga455a7abda2f207c424dd5946c30c48c6">createSphere</a> ()</td></tr>
<tr class="memdesc:ga455a7abda2f207c424dd5946c30c48c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="classvcl_1_1Sphere.html">Sphere</a> <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a> using the UV mode (<a href="https://github.com/caosdoar/spheres">https://github.com/caosdoar/spheres</a>), centered in (0, 0, 0), having radius 1, with 10 parallels and 20 meridias.  <br /></td></tr>
<tr class="separator:ga455a7abda2f207c424dd5946c30c48c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d38a6ecac2b2ab64dd11d53d78e98ca"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga3d38a6ecac2b2ab64dd11d53d78e98ca"><td class="memTemplItemLeft" align="right" valign="top">MeshType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__create.html#ga3d38a6ecac2b2ab64dd11d53d78e98ca">createTetrahedron</a> ()</td></tr>
<tr class="memdesc:ga3d38a6ecac2b2ab64dd11d53d78e98ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a simple tetrahedron mesh with the following point coordinates:  <br /></td></tr>
<tr class="separator:ga3d38a6ecac2b2ab64dd11d53d78e98ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c70a856983dfae4697e3521825dce90"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType, Point3Concept CoordType&gt; </td></tr>
<tr class="memitem:ga7c70a856983dfae4697e3521825dce90"><td class="memTemplItemLeft" align="right" valign="top">MeshType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__create.html#ga7c70a856983dfae4697e3521825dce90">createTetrahedron</a> (const CoordType &amp;p0, const CoordType &amp;p1, const CoordType &amp;p2, const CoordType &amp;p3)</td></tr>
<tr class="memdesc:ga7c70a856983dfae4697e3521825dce90"><td class="mdescLeft">&#160;</td><td class="mdescRight">createTetrahedron createTetrahedron creates a simple tetrahedron mesh with the given points. The function assumes that the points p0, p1 and p2 are in counterclockwise order, and does not perform any sanity check about the validity of the points.  <br /></td></tr>
<tr class="separator:ga7c70a856983dfae4697e3521825dce90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9abd2d46a87cb3d18987a37e11ed6ccc"><td class="memTemplParams" colspan="2">template&lt;Point3Concept PointType, FaceConcept FaceType, typename ScalarType &gt; </td></tr>
<tr class="memitem:a9abd2d46a87cb3d18987a37e11ed6ccc"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a9abd2d46a87cb3d18987a37e11ed6ccc">pointFaceDistance</a> (const PointType &amp;p, const FaceType &amp;f, ScalarType maxDist, PointType &amp;closest, bool signedDist=false)</td></tr>
<tr class="memdesc:a9abd2d46a87cb3d18987a37e11ed6ccc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the distance between a 3D point and a 3D triangle face.  <br /></td></tr>
<tr class="separator:a9abd2d46a87cb3d18987a37e11ed6ccc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a294ad7cda738cd64d09b432874830c"><td class="memTemplParams" colspan="2">template&lt;Point3Concept PointType, FaceConcept FaceType, typename ScalarType &gt; </td></tr>
<tr class="memitem:a3a294ad7cda738cd64d09b432874830c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a3a294ad7cda738cd64d09b432874830c">pointFaceDistance</a> (const PointType &amp;p, const FaceType &amp;f, ScalarType maxDist, bool signedDist=false)</td></tr>
<tr class="separator:a3a294ad7cda738cd64d09b432874830c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02f5dd6bd231e193440d954eee9d3aef"><td class="memTemplParams" colspan="2">template&lt;Point3Concept PointType, FaceConcept FaceType&gt; </td></tr>
<tr class="memitem:a02f5dd6bd231e193440d954eee9d3aef"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a02f5dd6bd231e193440d954eee9d3aef">pointFaceDistance</a> (const PointType &amp;p, const FaceType &amp;f, PointType &amp;closest, bool signedDist=false)</td></tr>
<tr class="separator:a02f5dd6bd231e193440d954eee9d3aef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8efd5f55775e66de7f1f69b35bd1561a"><td class="memTemplParams" colspan="2">template&lt;Point3Concept PointType, FaceConcept FaceType&gt; </td></tr>
<tr class="memitem:a8efd5f55775e66de7f1f69b35bd1561a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a8efd5f55775e66de7f1f69b35bd1561a">pointFaceDistance</a> (const PointType &amp;p, const FaceType &amp;f, bool signedDist=false)</td></tr>
<tr class="memdesc:a8efd5f55775e66de7f1f69b35bd1561a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the distance between a 3D point and a 3D triangle face.  <br /></td></tr>
<tr class="separator:a8efd5f55775e66de7f1f69b35bd1561a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga63f7958bed5f73548d28f436c7eb7b35"><td class="memTemplParams" colspan="2">template&lt;typename Obj1 , typename Obj2 &gt; </td></tr>
<tr class="memitem:ga63f7958bed5f73548d28f436c7eb7b35"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__distance.html#ga63f7958bed5f73548d28f436c7eb7b35">distFunction</a> ()</td></tr>
<tr class="memdesc:ga63f7958bed5f73548d28f436c7eb7b35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a proper dist function between a Obj1 object and an Obj2 object.  <br /></td></tr>
<tr class="separator:ga63f7958bed5f73548d28f436c7eb7b35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b9b1898fbdb7ba13f1e1adaf832ba4d"><td class="memTemplParams" colspan="2">template&lt;typename Obj1 , typename Obj2 , typename ScalarType  = double&gt; </td></tr>
<tr class="memitem:ga1b9b1898fbdb7ba13f1e1adaf832ba4d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__distance.html#ga1b9b1898fbdb7ba13f1e1adaf832ba4d">boundedDistFunction</a> ()</td></tr>
<tr class="memdesc:ga1b9b1898fbdb7ba13f1e1adaf832ba4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a proper dist function between a Obj1 object and an Obj2 object.  <br /></td></tr>
<tr class="separator:ga1b9b1898fbdb7ba13f1e1adaf832ba4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9082710ebf39cdd11a256086220d007a"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType1, MeshConcept MeshType2, LoggerConcept LogType = NullLogger&gt; </td></tr>
<tr class="memitem:a9082710ebf39cdd11a256086220d007a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structvcl_1_1HausdorffDistResult.html">HausdorffDistResult</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a9082710ebf39cdd11a256086220d007a">hausdorffDistance</a> (const MeshType1 &amp;m1, const MeshType2 &amp;m2, LogType &amp;log=<a class="el" href="group__miscellaneous.html#ga3377e3c875ec245e90ac5a395105ce99">nullLogger</a>, <a class="el" href="namespacevcl.html#a5a4e8376b2d47797f9167f2a8dd6fb0e">HausdorffSamplingMethod</a> sampMethod=<a class="el" href="namespacevcl.html#a5a4e8376b2d47797f9167f2a8dd6fb0ea33aad0431cadce18cad82201cb732f49">HAUSDORFF_VERTEX_UNIFORM</a>, <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> nSamples=0, bool deterministic=false)</td></tr>
<tr class="separator:a9082710ebf39cdd11a256086220d007a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1826187003e1e307765b32879a69b748"><td class="memTemplParams" colspan="2">template&lt;Point3Concept PointType, PlaneConcept PlaneType&gt; </td></tr>
<tr class="memitem:a1826187003e1e307765b32879a69b748"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a1826187003e1e307765b32879a69b748">pointPlaneDistance</a> (const PointType &amp;p, const PlaneType &amp;plane, bool signedDist=false)</td></tr>
<tr class="separator:a1826187003e1e307765b32879a69b748"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d8430571d9a6027e6d7e3bac4816b95"><td class="memTemplParams" colspan="2">template&lt;PointConcept PointType, SegmentConcept SegmentType&gt; <br />
requires (PointType::DIM == SegmentType::DIM)</td></tr>
<tr class="memitem:a1d8430571d9a6027e6d7e3bac4816b95"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a1d8430571d9a6027e6d7e3bac4816b95">pointSegmentDistance</a> (const PointType &amp;p, const SegmentType &amp;s, PointType &amp;closest)</td></tr>
<tr class="separator:a1d8430571d9a6027e6d7e3bac4816b95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e95f3d99f53e335c7e17af14b42f991"><td class="memTemplParams" colspan="2">template&lt;PointConcept PointType, SegmentConcept SegmentType&gt; <br />
requires (PointType::DIM == SegmentType::DIM)</td></tr>
<tr class="memitem:a7e95f3d99f53e335c7e17af14b42f991"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a7e95f3d99f53e335c7e17af14b42f991">pointSegmentDistance</a> (const PointType &amp;p, const SegmentType &amp;s)</td></tr>
<tr class="separator:a7e95f3d99f53e335c7e17af14b42f991"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59d8e830fa317191e2d02ff5cafc7149"><td class="memTemplParams" colspan="2">template&lt;MatrixConcept Matrix, EdgeMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a59d8e830fa317191e2d02ff5cafc7149"><td class="memTemplItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a59d8e830fa317191e2d02ff5cafc7149">edgeMatrix</a> (const MeshType &amp;mesh)</td></tr>
<tr class="memdesc:a59d8e830fa317191e2d02ff5cafc7149"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a #V*3 Matrix of scalars containing the coordinates of the vertices of a <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>. The function is templated on the Matrix itself.  <br /></td></tr>
<tr class="separator:a59d8e830fa317191e2d02ff5cafc7149"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0aeda48720e2d34688e56a6ab79b7600"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> ELEM_ID, MatrixConcept Matrix, MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a0aeda48720e2d34688e56a6ab79b7600"><td class="memTemplItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a0aeda48720e2d34688e56a6ab79b7600">elementNormalsMatrix</a> (const MeshType &amp;mesh)</td></tr>
<tr class="memdesc:a0aeda48720e2d34688e56a6ab79b7600"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a #E <a class="el" href="classvcl_1_1Vector.html" title="The Vector class is a generic container of objects of type T, that could have fixed or dynamic size,...">Vector</a> of booleans (or integers) containing the selection status of the elements identified by <code>ELEM_ID</code> of a <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>. The function is templated on the <a class="el" href="classvcl_1_1Vector.html" title="The Vector class is a generic container of objects of type T, that could have fixed or dynamic size,...">Vector</a> itself.  <br /></td></tr>
<tr class="separator:a0aeda48720e2d34688e56a6ab79b7600"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed0e167ce00c4dd8cf2b6400ceb24da3"><td class="memTemplParams" colspan="2">template&lt;MatrixConcept Matrix, MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:aed0e167ce00c4dd8cf2b6400ceb24da3"><td class="memTemplItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#aed0e167ce00c4dd8cf2b6400ceb24da3">vertexNormalsMatrix</a> (const MeshType &amp;mesh)</td></tr>
<tr class="memdesc:aed0e167ce00c4dd8cf2b6400ceb24da3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a #V*3 Matrix of scalars containing the normals of the vertices of a <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>. The function is templated on the Matrix itself.  <br /></td></tr>
<tr class="separator:aed0e167ce00c4dd8cf2b6400ceb24da3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bc50612a1185ec7d1add143f93eb0ec"><td class="memTemplParams" colspan="2">template&lt;MatrixConcept Matrix, FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a6bc50612a1185ec7d1add143f93eb0ec"><td class="memTemplItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a6bc50612a1185ec7d1add143f93eb0ec">faceNormalsMatrix</a> (const MeshType &amp;mesh)</td></tr>
<tr class="memdesc:a6bc50612a1185ec7d1add143f93eb0ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a #F*3 Matrix of scalars containing the normals of the faces of a <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>. The function is templated on the Matrix itself.  <br /></td></tr>
<tr class="separator:a6bc50612a1185ec7d1add143f93eb0ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add776c0c02e7ef2d7657fce701c437e7"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> ELEM_ID, MatrixConcept Matrix, MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:add776c0c02e7ef2d7657fce701c437e7"><td class="memTemplItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#add776c0c02e7ef2d7657fce701c437e7">elementColorsMatrix</a> (const MeshType &amp;mesh)</td></tr>
<tr class="memdesc:add776c0c02e7ef2d7657fce701c437e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a #E*4 Matrix of integers containing the colors of the elements identified by <code>ELEM_ID</code> of a <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>. The function is templated on the Matrix itself.  <br /></td></tr>
<tr class="separator:add776c0c02e7ef2d7657fce701c437e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01810ffdfe2df3aa87e9de9c783a32a6"><td class="memTemplParams" colspan="2">template&lt;MatrixConcept Matrix, MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a01810ffdfe2df3aa87e9de9c783a32a6"><td class="memTemplItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a01810ffdfe2df3aa87e9de9c783a32a6">vertexColorsMatrix</a> (const MeshType &amp;mesh)</td></tr>
<tr class="memdesc:a01810ffdfe2df3aa87e9de9c783a32a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a #V*4 Matrix of integers containing the colors of the vertices of a <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>. The function is templated on the Matrix itself.  <br /></td></tr>
<tr class="separator:a01810ffdfe2df3aa87e9de9c783a32a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a480cf1413039e05d9065485c52076ce9"><td class="memTemplParams" colspan="2">template&lt;MatrixConcept Matrix, FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a480cf1413039e05d9065485c52076ce9"><td class="memTemplItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a480cf1413039e05d9065485c52076ce9">faceColorsMatrix</a> (const MeshType &amp;mesh)</td></tr>
<tr class="memdesc:a480cf1413039e05d9065485c52076ce9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a #F*4 Matrix of integers containing the colors of the faces of a <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>. The function is templated on the Matrix itself.  <br /></td></tr>
<tr class="separator:a480cf1413039e05d9065485c52076ce9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e07fcb626e0c670f8f92e930d0b2c46"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> ELEM_ID, typename Vect , MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a8e07fcb626e0c670f8f92e930d0b2c46"><td class="memTemplItemLeft" align="right" valign="top">Vect&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a8e07fcb626e0c670f8f92e930d0b2c46">elementQualityVector</a> (const MeshType &amp;mesh)</td></tr>
<tr class="memdesc:a8e07fcb626e0c670f8f92e930d0b2c46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a #E <a class="el" href="classvcl_1_1Vector.html" title="The Vector class is a generic container of objects of type T, that could have fixed or dynamic size,...">Vector</a> of scalars containing the quality of the elements identified by <code>ELEM_ID</code> of a <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>. The function is templated on the <a class="el" href="classvcl_1_1Vector.html" title="The Vector class is a generic container of objects of type T, that could have fixed or dynamic size,...">Vector</a> itself.  <br /></td></tr>
<tr class="separator:a8e07fcb626e0c670f8f92e930d0b2c46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04201da836f3c6bc6eb9444319f7b492"><td class="memTemplParams" colspan="2">template&lt;typename Vect , MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a04201da836f3c6bc6eb9444319f7b492"><td class="memTemplItemLeft" align="right" valign="top">Vect&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a04201da836f3c6bc6eb9444319f7b492">vertexQualityVector</a> (const MeshType &amp;mesh)</td></tr>
<tr class="memdesc:a04201da836f3c6bc6eb9444319f7b492"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a #V <a class="el" href="classvcl_1_1Vector.html" title="The Vector class is a generic container of objects of type T, that could have fixed or dynamic size,...">Vector</a> of scalars containing the quality of the vertices of a <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>. The function is templated on the <a class="el" href="classvcl_1_1Vector.html" title="The Vector class is a generic container of objects of type T, that could have fixed or dynamic size,...">Vector</a> itself.  <br /></td></tr>
<tr class="separator:a04201da836f3c6bc6eb9444319f7b492"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7afddefac9fc869e5cb82367856f19e9"><td class="memTemplParams" colspan="2">template&lt;typename Vect , FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a7afddefac9fc869e5cb82367856f19e9"><td class="memTemplItemLeft" align="right" valign="top">Vect&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a7afddefac9fc869e5cb82367856f19e9">faceQualityVector</a> (const MeshType &amp;mesh)</td></tr>
<tr class="memdesc:a7afddefac9fc869e5cb82367856f19e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a #F <a class="el" href="classvcl_1_1Vector.html" title="The Vector class is a generic container of objects of type T, that could have fixed or dynamic size,...">Vector</a> of scalars containing the quality of the faces of a <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>. The function is templated on the <a class="el" href="classvcl_1_1Vector.html" title="The Vector class is a generic container of objects of type T, that could have fixed or dynamic size,...">Vector</a> itself.  <br /></td></tr>
<tr class="separator:a7afddefac9fc869e5cb82367856f19e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c4c7b512ed2781bd919b794fe63c1eb"><td class="memTemplParams" colspan="2">template&lt;MeshConcept InMeshType, MeshConcept OutMeshType = InMeshType&gt; </td></tr>
<tr class="memitem:a1c4c7b512ed2781bd919b794fe63c1eb"><td class="memTemplItemLeft" align="right" valign="top">OutMeshType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a1c4c7b512ed2781bd919b794fe63c1eb">perVertexMeshFilter</a> (const InMeshType &amp;m, std::function&lt; bool(const typename InMeshType::VertexType &amp;)&gt; &amp;&amp;vertexFilter, bool saveBirthIndicesInCustomComponent=true)</td></tr>
<tr class="memdesc:a1c4c7b512ed2781bd919b794fe63c1eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates and returns a new mesh that is composed of the vertices of the input mesh <code>m</code> filtered using the <code>vertexFilter</code> function.  <br /></td></tr>
<tr class="separator:a1c4c7b512ed2781bd919b794fe63c1eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d3830ce96c420a6f11c93650c709fa6"><td class="memTemplParams" colspan="2">template&lt;MeshConcept InMeshType, MeshConcept OutMeshType = InMeshType&gt; </td></tr>
<tr class="memitem:a8d3830ce96c420a6f11c93650c709fa6"><td class="memTemplItemLeft" align="right" valign="top">OutMeshType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a8d3830ce96c420a6f11c93650c709fa6">perVertexMeshFilter</a> (const InMeshType &amp;m, Range auto &amp;&amp;vertexFilterRng, bool saveBirthIndicesInCustomComponent=true)</td></tr>
<tr class="memdesc:a8d3830ce96c420a6f11c93650c709fa6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates and returns a new mesh that is composed of the vertices of the input mesh <code>m</code> filtered using the <code>vertexFilterRng</code> range.  <br /></td></tr>
<tr class="separator:a8d3830ce96c420a6f11c93650c709fa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72f6132dc1f37d4790e34ef4e42e6d15"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept InMeshType, FaceMeshConcept OutMeshType = InMeshType&gt; </td></tr>
<tr class="memitem:a72f6132dc1f37d4790e34ef4e42e6d15"><td class="memTemplItemLeft" align="right" valign="top">OutMeshType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a72f6132dc1f37d4790e34ef4e42e6d15">perFaceMeshFilter</a> (const InMeshType &amp;m, std::function&lt; bool(const typename InMeshType::FaceType &amp;)&gt; &amp;&amp;faceFilter, bool saveBirthIndicesInCustomComponent=true)</td></tr>
<tr class="memdesc:a72f6132dc1f37d4790e34ef4e42e6d15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates and returns a new mesh that is composed of the faces of the input mesh <code>m</code> filtered using the <code>faceFilter</code> function. Only vertices belonging to the imported faces will be imported in the output mesh.  <br /></td></tr>
<tr class="separator:a72f6132dc1f37d4790e34ef4e42e6d15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace4273fd5df9842c19d335bcab94d287"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept InMeshType, FaceMeshConcept OutMeshType = InMeshType&gt; </td></tr>
<tr class="memitem:ace4273fd5df9842c19d335bcab94d287"><td class="memTemplItemLeft" align="right" valign="top">OutMeshType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ace4273fd5df9842c19d335bcab94d287">perFaceMeshFilter</a> (const InMeshType &amp;m, Range auto &amp;&amp;faceFilterRng, bool saveBirthIndicesInCustomComponent=true)</td></tr>
<tr class="memdesc:ace4273fd5df9842c19d335bcab94d287"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates and returns a new mesh that is composed of the faces of the input mesh <code>m</code> filtered using the <code>faceFilterRng</code> range. Only vertices belonging to the imported faces will be imported in the output mesh.  <br /></td></tr>
<tr class="separator:ace4273fd5df9842c19d335bcab94d287"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbf2dd04b5f4477ba07ab217dd603d14"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:abbf2dd04b5f4477ba07ab217dd603d14"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Plane.html">Plane</a>&lt; Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#abbf2dd04b5f4477ba07ab217dd603d14">fitPlaneToPointCloud</a> (const std::vector&lt; <a class="el" href="group__space.html#ga13f2718b0763def563b8bd9f65982833">Point3</a>&lt; Scalar &gt; &gt; &amp;pointVec)</td></tr>
<tr class="memdesc:abbf2dd04b5f4477ba07ab217dd603d14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the plane best fitting a set of points The algorithm used is the classical Covariance matrix eigenvector approach.  <br /></td></tr>
<tr class="separator:abbf2dd04b5f4477ba07ab217dd603d14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8d724d35f1e65a0966e980fc544364f"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:af8d724d35f1e65a0966e980fc544364f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Plane.html">Plane</a>&lt; Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#af8d724d35f1e65a0966e980fc544364f">fitPlaneToWeightedPointCloud</a> (const std::vector&lt; <a class="el" href="group__space.html#ga13f2718b0763def563b8bd9f65982833">Point3</a>&lt; Scalar &gt; &gt; &amp;pointVec)</td></tr>
<tr class="memdesc:af8d724d35f1e65a0966e980fc544364f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the plane best fitting a wighted set of points The algorithm used is the wighted Covariance matrix eigenvector approach.  <br /></td></tr>
<tr class="separator:af8d724d35f1e65a0966e980fc544364f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa433f6d104a81e917270cca3d9ed26ed"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType, MatrixConcept VMatrix, MatrixConcept VNMatrix = Eigen::MatrixX3d&gt; </td></tr>
<tr class="memitem:aa433f6d104a81e917270cca3d9ed26ed"><td class="memTemplItemLeft" align="right" valign="top">MeshType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#aa433f6d104a81e917270cca3d9ed26ed">pointCloudMeshFromMatrices</a> (const VMatrix &amp;vertices, const VNMatrix &amp;vertexNormals=VNMatrix())</td></tr>
<tr class="memdesc:aa433f6d104a81e917270cca3d9ed26ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates and returns a new point cloud mesh from the input vertex matrix and the other matrices that are given as arguments.  <br /></td></tr>
<tr class="separator:aa433f6d104a81e917270cca3d9ed26ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae60ae8879b69a995723ada3f73422606"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType, MatrixConcept VMatrix, MatrixConcept FMatrix = Eigen::MatrixX3i, MatrixConcept VNMatrix = Eigen::MatrixX3d, MatrixConcept FNMatrix = Eigen::MatrixX3d&gt; </td></tr>
<tr class="memitem:ae60ae8879b69a995723ada3f73422606"><td class="memTemplItemLeft" align="right" valign="top">MeshType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ae60ae8879b69a995723ada3f73422606">meshFromMatrices</a> (const VMatrix &amp;vertices, const FMatrix &amp;faces=FMatrix(), const VNMatrix &amp;vertexNormals=VNMatrix(), const FNMatrix &amp;faceNormals=FNMatrix())</td></tr>
<tr class="memdesc:ae60ae8879b69a995723ada3f73422606"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates and returns a new mesh from the input vertex and face (if any) matrices, and the other matrices that are given as arguments.  <br /></td></tr>
<tr class="separator:ae60ae8879b69a995723ada3f73422606"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af39dbdcb3c98584459fdb4b3e87e3332"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType, MatrixConcept VMatrix, MatrixConcept FMatrix = Eigen::MatrixX3i, MatrixConcept EMatrix = Eigen::MatrixX2i, MatrixConcept VNMatrix = Eigen::MatrixX3d, MatrixConcept FNMatrix = Eigen::MatrixX3d&gt; </td></tr>
<tr class="memitem:af39dbdcb3c98584459fdb4b3e87e3332"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#af39dbdcb3c98584459fdb4b3e87e3332">importMeshFromMatrices</a> (MeshType &amp;mesh, const VMatrix &amp;vertices, const FMatrix &amp;faces=FMatrix(), const EMatrix &amp;edges=EMatrix(), const VNMatrix &amp;vertexNormals=VNMatrix(), const FNMatrix &amp;faceNormals=FNMatrix())</td></tr>
<tr class="memdesc:af39dbdcb3c98584459fdb4b3e87e3332"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the given input <code>mesh</code> from the input vertex matrix, and the other matrices that are given as arguments.  <br /></td></tr>
<tr class="separator:af39dbdcb3c98584459fdb4b3e87e3332"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02ca8fdd4a9b050d0f0ac4d5e1c13bde"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType, MatrixConcept VMatrix&gt; </td></tr>
<tr class="memitem:a02ca8fdd4a9b050d0f0ac4d5e1c13bde"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a02ca8fdd4a9b050d0f0ac4d5e1c13bde">importVerticesFromMatrix</a> (MeshType &amp;mesh, const VMatrix &amp;vertices, bool clearBeforeSet=true)</td></tr>
<tr class="memdesc:a02ca8fdd4a9b050d0f0ac4d5e1c13bde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the vertices of the given input <code>mesh</code> from the input vertex matrix.  <br /></td></tr>
<tr class="separator:a02ca8fdd4a9b050d0f0ac4d5e1c13bde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41c8a076bfadd5ab22ebd08eab05237d"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType, MatrixConcept FMatrix&gt; </td></tr>
<tr class="memitem:a41c8a076bfadd5ab22ebd08eab05237d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a41c8a076bfadd5ab22ebd08eab05237d">importFacesFromMatrix</a> (MeshType &amp;mesh, const FMatrix &amp;faces, bool clearBeforeSet=true)</td></tr>
<tr class="separator:a41c8a076bfadd5ab22ebd08eab05237d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd8cc56f370e2fca77dc3da2a248d1f5"><td class="memTemplParams" colspan="2">template&lt;EdgeMeshConcept MeshType, MatrixConcept EMatrix&gt; </td></tr>
<tr class="memitem:abd8cc56f370e2fca77dc3da2a248d1f5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#abd8cc56f370e2fca77dc3da2a248d1f5">importEdgesFromMatrix</a> (MeshType &amp;mesh, const EMatrix &amp;edges, bool clearBeforeSet=true)</td></tr>
<tr class="separator:abd8cc56f370e2fca77dc3da2a248d1f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a255e7edcea02d432b2aa8a1c46dae3e5"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType, MatrixConcept VNMatrix&gt; </td></tr>
<tr class="memitem:a255e7edcea02d432b2aa8a1c46dae3e5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a255e7edcea02d432b2aa8a1c46dae3e5">importVertexNormalsFromMatrix</a> (MeshType &amp;mesh, const VNMatrix &amp;vertexNormals)</td></tr>
<tr class="separator:a255e7edcea02d432b2aa8a1c46dae3e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab91626832747d82bfe051ffc6a9d8619"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType, MatrixConcept FNMatrix&gt; </td></tr>
<tr class="memitem:ab91626832747d82bfe051ffc6a9d8619"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ab91626832747d82bfe051ffc6a9d8619">importFaceNormalsFromMatrix</a> (MeshType &amp;mesh, const FNMatrix &amp;faceNormals)</td></tr>
<tr class="separator:ab91626832747d82bfe051ffc6a9d8619"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0b73844d3c33491eb38e6e34017eb98"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType, MatrixConcept VCMatrix&gt; </td></tr>
<tr class="memitem:ac0b73844d3c33491eb38e6e34017eb98"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ac0b73844d3c33491eb38e6e34017eb98">importVertexColorsFromMatrix</a> (MeshType &amp;mesh, const VCMatrix &amp;vertexColors)</td></tr>
<tr class="separator:ac0b73844d3c33491eb38e6e34017eb98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a909af3aba8fff954b61d9c98f7470eab"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType, MatrixConcept FCMatrix&gt; </td></tr>
<tr class="memitem:a909af3aba8fff954b61d9c98f7470eab"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a909af3aba8fff954b61d9c98f7470eab">importFaceColorsFromMatrix</a> (MeshType &amp;mesh, const FCMatrix &amp;faceColors)</td></tr>
<tr class="separator:a909af3aba8fff954b61d9c98f7470eab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bdac4366b8757c10172f6e1ad61976d"><td class="memTemplParams" colspan="2">template&lt;EdgeMeshConcept MeshType, MatrixConcept ECMatrix&gt; </td></tr>
<tr class="memitem:a9bdac4366b8757c10172f6e1ad61976d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a9bdac4366b8757c10172f6e1ad61976d">importEdgeColorsFromMatrix</a> (MeshType &amp;mesh, const ECMatrix &amp;edgeColors)</td></tr>
<tr class="separator:a9bdac4366b8757c10172f6e1ad61976d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb99398069d243b6bb7b09e55a279792"><td class="memTemplParams" colspan="2">template&lt;FaceConcept FaceType, PointConcept PointType&gt; </td></tr>
<tr class="memitem:abb99398069d243b6bb7b09e55a279792"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#abb99398069d243b6bb7b09e55a279792">faceBoxIntersect</a> (const FaceType &amp;f, const <a class="el" href="classvcl_1_1Box.html">Box</a>&lt; PointType &gt; &amp;box)</td></tr>
<tr class="separator:abb99398069d243b6bb7b09e55a279792"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cec6eee8e30eefd8783a997a48127fa"><td class="memTemplParams" colspan="2">template&lt;FaceConcept FaceType, PointConcept PointType, typename SScalar &gt; </td></tr>
<tr class="memitem:a0cec6eee8e30eefd8783a997a48127fa"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a0cec6eee8e30eefd8783a997a48127fa">faceSphereItersect</a> (const FaceType &amp;f, const <a class="el" href="classvcl_1_1Sphere.html">Sphere</a>&lt; SScalar &gt; &amp;sphere, PointType &amp;witness, std::pair&lt; SScalar, SScalar &gt; &amp;res)</td></tr>
<tr class="memdesc:a0cec6eee8e30eefd8783a997a48127fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the intersection between a sphere and a face, that may be also polygonal.  <br /></td></tr>
<tr class="separator:a0cec6eee8e30eefd8783a997a48127fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a74b10bc09834d0a2d787336a5f7823"><td class="memTemplParams" colspan="2">template&lt;FaceConcept FaceType, typename SScalar &gt; </td></tr>
<tr class="memitem:a9a74b10bc09834d0a2d787336a5f7823"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a9a74b10bc09834d0a2d787336a5f7823">faceSphereItersect</a> (const FaceType &amp;f, const <a class="el" href="classvcl_1_1Sphere.html">Sphere</a>&lt; SScalar &gt; &amp;sphere)</td></tr>
<tr class="memdesc:a9a74b10bc09834d0a2d787336a5f7823"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the intersection between a sphere and a face, that may be also polygonal.  <br /></td></tr>
<tr class="separator:a9a74b10bc09834d0a2d787336a5f7823"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga70dad48ffd4a840c11d422b0c3121393"><td class="memTemplParams" colspan="2">template&lt;typename Obj1 , typename Obj2 &gt; </td></tr>
<tr class="memitem:ga70dad48ffd4a840c11d422b0c3121393"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__intersection.html#ga70dad48ffd4a840c11d422b0c3121393">intersectFunction</a> ()</td></tr>
<tr class="memdesc:ga70dad48ffd4a840c11d422b0c3121393"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a proper intersect function between a Obj1 object and an Obj2 object.  <br /></td></tr>
<tr class="separator:ga70dad48ffd4a840c11d422b0c3121393"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adac28fe9c51f808b6120eb2d9387484b"><td class="memTemplParams" colspan="2">template&lt;EdgeMeshConcept EdgeMesh, FaceMeshConcept MeshType, PlaneConcept PlaneType&gt; </td></tr>
<tr class="memitem:adac28fe9c51f808b6120eb2d9387484b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacevcl.html#aadd5d4f0adc881097d2c62b003a449cc">EdgeMesh</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#adac28fe9c51f808b6120eb2d9387484b">meshPlaneIntersection</a> (const MeshType &amp;m, const PlaneType &amp;pl)</td></tr>
<tr class="memdesc:adac28fe9c51f808b6120eb2d9387484b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes a mesh and a plane as inputs and computes the intersection between the mesh and the plane. It creates a new EdgeMesh to represent the intersection edges.  <br /></td></tr>
<tr class="separator:adac28fe9c51f808b6120eb2d9387484b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e4c155f781f7c3e6fca2b922398fb82"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType, typename SScalar &gt; </td></tr>
<tr class="memitem:a1e4c155f781f7c3e6fca2b922398fb82"><td class="memTemplItemLeft" align="right" valign="top">MeshType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a1e4c155f781f7c3e6fca2b922398fb82">meshSphereIntersection</a> (const MeshType &amp;m, const <a class="el" href="classvcl_1_1Sphere.html">vcl::Sphere</a>&lt; SScalar &gt; &amp;sphere, double tol)</td></tr>
<tr class="memdesc:a1e4c155f781f7c3e6fca2b922398fb82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the intersection between a mesh and a ball.  <br /></td></tr>
<tr class="separator:a1e4c155f781f7c3e6fca2b922398fb82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5da120ef4b6039bf54902d14cb8b7519"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType, typename SScalar &gt; </td></tr>
<tr class="memitem:a5da120ef4b6039bf54902d14cb8b7519"><td class="memTemplItemLeft" align="right" valign="top">MeshType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a5da120ef4b6039bf54902d14cb8b7519">meshSphereIntersection</a> (const MeshType &amp;m, const <a class="el" href="classvcl_1_1Sphere.html">vcl::Sphere</a>&lt; SScalar &gt; &amp;sphere)</td></tr>
<tr class="memdesc:a5da120ef4b6039bf54902d14cb8b7519"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as meshSphereIntersection(MeshType, Sphere, double);.  <br /></td></tr>
<tr class="separator:a5da120ef4b6039bf54902d14cb8b7519"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27474522dfcc3be4ce96d6a8b44fcc09"><td class="memTemplParams" colspan="2">template&lt;PlaneConcept PlaneType, Box3Concept BoxType&gt; </td></tr>
<tr class="memitem:a27474522dfcc3be4ce96d6a8b44fcc09"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a27474522dfcc3be4ce96d6a8b44fcc09">planeBoxIntersect</a> (const PlaneType &amp;p, const BoxType &amp;box)</td></tr>
<tr class="memdesc:a27474522dfcc3be4ce96d6a8b44fcc09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a plane intersects with a box.  <br /></td></tr>
<tr class="separator:a27474522dfcc3be4ce96d6a8b44fcc09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a095d688d385405cbf305d7f501f672a6"><td class="memTemplParams" colspan="2">template&lt;PlaneConcept PlaneType, Segment3Concept SegmentType&gt; </td></tr>
<tr class="memitem:a095d688d385405cbf305d7f501f672a6"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a095d688d385405cbf305d7f501f672a6">planeSegmentIntersect</a> (const PlaneType &amp;p, const SegmentType &amp;s, typename SegmentType::PointType &amp;intersection)</td></tr>
<tr class="memdesc:a095d688d385405cbf305d7f501f672a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function computes the intersection between a plane and a 3D segment. If the intersection exists, it returns true and stores the intersection point in the output parameter intersection, otherwise, it returns false.  <br /></td></tr>
<tr class="separator:a095d688d385405cbf305d7f501f672a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5603e96ba08d11993828c0e47f2657b2"><td class="memTemplParams" colspan="2">template&lt;PlaneConcept PlaneType, Segment3Concept SegmentType&gt; </td></tr>
<tr class="memitem:a5603e96ba08d11993828c0e47f2657b2"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a5603e96ba08d11993828c0e47f2657b2">planeSegmentIntersect</a> (const PlaneType &amp;p, const SegmentType &amp;s)</td></tr>
<tr class="memdesc:a5603e96ba08d11993828c0e47f2657b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function computes the intersection between a plane and a 3D segment. If the intersection exists, it returns true, otherwise, it returns false.  <br /></td></tr>
<tr class="separator:a5603e96ba08d11993828c0e47f2657b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9349b9ea771a0058a9cb4a57eedd624b"><td class="memTemplParams" colspan="2">template&lt;SphereConcept SphereType, Box3Concept BoxType&gt; </td></tr>
<tr class="memitem:a9349b9ea771a0058a9cb4a57eedd624b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a9349b9ea771a0058a9cb4a57eedd624b">sphereBoxIntersect</a> (const SphereType &amp;s, const BoxType &amp;box)</td></tr>
<tr class="separator:a9349b9ea771a0058a9cb4a57eedd624b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab78be5dc0d03ed32cde7a2262b506c74"><td class="memTemplParams" colspan="2">template&lt;ConstTriangle2Concept TriangleType, Point2Concept PointType&gt; </td></tr>
<tr class="memitem:ab78be5dc0d03ed32cde7a2262b506c74"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ab78be5dc0d03ed32cde7a2262b506c74">trianglePointIntersect</a> (const TriangleType &amp;tr, const PointType &amp;p)</td></tr>
<tr class="separator:ab78be5dc0d03ed32cde7a2262b506c74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b3c4b3e9c618082e4fbd063afafccb4"><td class="memTemplParams" colspan="2">template&lt;ConstTriangle3Concept TriangleType, Box3Concept BoxType&gt; </td></tr>
<tr class="memitem:a9b3c4b3e9c618082e4fbd063afafccb4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a9b3c4b3e9c618082e4fbd063afafccb4">triangleBoxIntersect</a> (const TriangleType &amp;t, const BoxType &amp;box)</td></tr>
<tr class="memdesc:a9b3c4b3e9c618082e4fbd063afafccb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a triangle intersects with a box. <a href="https://gist.github.com/jflipts/fc68d4eeacfcc04fbdb2bf38e0911850">https://gist.github.com/jflipts/fc68d4eeacfcc04fbdb2bf38e0911850</a>.  <br /></td></tr>
<tr class="separator:a9b3c4b3e9c618082e4fbd063afafccb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afef4c14e85563ae0db11815309e9a5cc"><td class="memTemplParams" colspan="2">template&lt;ConstTriangle3Concept TriangleType, SphereConcept SphereType, Point3Concept PointType, typename ScalarType &gt; </td></tr>
<tr class="memitem:afef4c14e85563ae0db11815309e9a5cc"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#afef4c14e85563ae0db11815309e9a5cc">triangleSphereItersect</a> (const TriangleType &amp;t, const SphereType &amp;sphere, PointType &amp;witness, std::pair&lt; ScalarType, ScalarType &gt; &amp;res)</td></tr>
<tr class="memdesc:afef4c14e85563ae0db11815309e9a5cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the intersection between a sphere and a triangle.  <br /></td></tr>
<tr class="separator:afef4c14e85563ae0db11815309e9a5cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af510b267910115525d77a6b4539ca3cd"><td class="memTemplParams" colspan="2">template&lt;ConstTriangle3Concept TriangleType, SphereConcept SphereType&gt; </td></tr>
<tr class="memitem:af510b267910115525d77a6b4539ca3cd"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#af510b267910115525d77a6b4539ca3cd">triangleSphereItersect</a> (const TriangleType &amp;t, const SphereType &amp;sphere)</td></tr>
<tr class="memdesc:af510b267910115525d77a6b4539ca3cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the intersection between a sphere and a triangle.  <br /></td></tr>
<tr class="separator:af510b267910115525d77a6b4539ca3cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6bad1ad4846f6650d8e1cf03053ffaca"><td class="memTemplParams" colspan="2">template&lt;SamplerConcept SamplerType, MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga6bad1ad4846f6650d8e1cf03053ffaca"><td class="memTemplItemLeft" align="right" valign="top">SamplerType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__point__sampling.html#ga6bad1ad4846f6650d8e1cf03053ffaca">allVerticesPointSampling</a> (const MeshType &amp;m, std::vector&lt; <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> &gt; &amp;birthVertices, bool onlySelected=false)</td></tr>
<tr class="memdesc:ga6bad1ad4846f6650d8e1cf03053ffaca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a Sampler object that contains all the vertices contained in the given mesh.  <br /></td></tr>
<tr class="separator:ga6bad1ad4846f6650d8e1cf03053ffaca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0574891fa5b4831a4e707432860bebd4"><td class="memTemplParams" colspan="2">template&lt;SamplerConcept SamplerType, MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga0574891fa5b4831a4e707432860bebd4"><td class="memTemplItemLeft" align="right" valign="top">SamplerType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__point__sampling.html#ga0574891fa5b4831a4e707432860bebd4">allVerticesPointSampling</a> (const MeshType &amp;m, bool onlySelected=false)</td></tr>
<tr class="memdesc:ga0574891fa5b4831a4e707432860bebd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a Sampler object that contains all the vertices contained in the given mesh.  <br /></td></tr>
<tr class="separator:ga0574891fa5b4831a4e707432860bebd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga14a5fe047802f08870b0d9c8e2c6d6b0"><td class="memTemplParams" colspan="2">template&lt;SamplerConcept SamplerType, FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga14a5fe047802f08870b0d9c8e2c6d6b0"><td class="memTemplItemLeft" align="right" valign="top">SamplerType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__point__sampling.html#ga14a5fe047802f08870b0d9c8e2c6d6b0">allFacesPointSampling</a> (const MeshType &amp;m, std::vector&lt; <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> &gt; &amp;birthFaces, bool onlySelected=false)</td></tr>
<tr class="memdesc:ga14a5fe047802f08870b0d9c8e2c6d6b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a SamplerType object that contains all the faces contained in the given mesh.  <br /></td></tr>
<tr class="separator:ga14a5fe047802f08870b0d9c8e2c6d6b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ed68aa0237831920672882dea64fc83"><td class="memTemplParams" colspan="2">template&lt;SamplerConcept SamplerType, FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga6ed68aa0237831920672882dea64fc83"><td class="memTemplItemLeft" align="right" valign="top">SamplerType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__point__sampling.html#ga6ed68aa0237831920672882dea64fc83">allFacesPointSampling</a> (const MeshType &amp;m, bool onlySelected=false)</td></tr>
<tr class="memdesc:ga6ed68aa0237831920672882dea64fc83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a SamplerType object that contains all the faces contained in the given mesh.  <br /></td></tr>
<tr class="separator:ga6ed68aa0237831920672882dea64fc83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e63011af761c14b63e738ffc562bfa4"><td class="memTemplParams" colspan="2">template&lt;SamplerConcept SamplerType, MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga6e63011af761c14b63e738ffc562bfa4"><td class="memTemplItemLeft" align="right" valign="top">SamplerType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__point__sampling.html#ga6e63011af761c14b63e738ffc562bfa4">vertexUniformPointSampling</a> (const MeshType &amp;m, <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> nSamples, std::vector&lt; <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> &gt; &amp;birthVertices, bool onlySelected=false, bool deterministic=false)</td></tr>
<tr class="memdesc:ga6e63011af761c14b63e738ffc562bfa4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a SamplerType object that contains the given number of samples taken from the vertices of the given mesh. Each vertex has the same probability of being chosen. If onlySelected is true, only the selected vertices are sampled. The indices of the sampled vertices in the mesh are stored in the birthVertices vector.  <br /></td></tr>
<tr class="separator:ga6e63011af761c14b63e738ffc562bfa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5bb3ffc00ab21f608405f5d5cb45837e"><td class="memTemplParams" colspan="2">template&lt;SamplerConcept SamplerType, MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga5bb3ffc00ab21f608405f5d5cb45837e"><td class="memTemplItemLeft" align="right" valign="top">SamplerType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__point__sampling.html#ga5bb3ffc00ab21f608405f5d5cb45837e">vertexUniformPointSampling</a> (const MeshType &amp;m, <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> nSamples, bool onlySelected=false, bool deterministic=false)</td></tr>
<tr class="memdesc:ga5bb3ffc00ab21f608405f5d5cb45837e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a SamplerType object that contains the given number of samples taken from the vertices of the given mesh. Each vertex has the same probability of being chosen. If onlySelected is true, only the selected vertices are sampled.  <br /></td></tr>
<tr class="separator:ga5bb3ffc00ab21f608405f5d5cb45837e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga94e128e7ea93dd40b0b1084c40f0786f"><td class="memTemplParams" colspan="2">template&lt;SamplerConcept SamplerType, FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga94e128e7ea93dd40b0b1084c40f0786f"><td class="memTemplItemLeft" align="right" valign="top">SamplerType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__point__sampling.html#ga94e128e7ea93dd40b0b1084c40f0786f">faceUniformPointSampling</a> (const MeshType &amp;m, <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> nSamples, std::vector&lt; <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> &gt; &amp;birthFaces, bool onlySelected=false, bool deterministic=false)</td></tr>
<tr class="memdesc:ga94e128e7ea93dd40b0b1084c40f0786f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a SamplerType object that contains the given number of samples taken from the faces of the given mesh. Each face has the same probability of being chosen. If onlySelected is true, only the selected faces are sampled. The indices of the sampled faces in the mesh are stored in the birthFaces vector.  <br /></td></tr>
<tr class="separator:ga94e128e7ea93dd40b0b1084c40f0786f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9bb8d0edffb2b4d75fa1ac1d8b9fece2"><td class="memTemplParams" colspan="2">template&lt;SamplerConcept SamplerType, FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga9bb8d0edffb2b4d75fa1ac1d8b9fece2"><td class="memTemplItemLeft" align="right" valign="top">SamplerType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__point__sampling.html#ga9bb8d0edffb2b4d75fa1ac1d8b9fece2">faceUniformPointSampling</a> (const MeshType &amp;m, <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> nSamples, bool onlySelected=false, bool deterministic=false)</td></tr>
<tr class="memdesc:ga9bb8d0edffb2b4d75fa1ac1d8b9fece2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a SamplerType object that contains the given number of samples taken from the faces of the given mesh. Each face has the same probability of being chosen. If onlySelected is true, only the selected faces are sampled.  <br /></td></tr>
<tr class="separator:ga9bb8d0edffb2b4d75fa1ac1d8b9fece2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5cfe308da197164da340267bc3a3756f"><td class="memTemplParams" colspan="2">template&lt;SamplerConcept SamplerType, MeshConcept MeshType, typename ScalarType &gt; </td></tr>
<tr class="memitem:ga5cfe308da197164da340267bc3a3756f"><td class="memTemplItemLeft" align="right" valign="top">SamplerType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__point__sampling.html#ga5cfe308da197164da340267bc3a3756f">vertexWeightedPointSampling</a> (const MeshType &amp;m, const std::vector&lt; ScalarType &gt; &amp;weights, <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> nSamples, std::vector&lt; <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> &gt; &amp;birthVertices, bool deterministic=false)</td></tr>
<tr class="memdesc:ga5cfe308da197164da340267bc3a3756f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Samples the vertices in a weighted way, using the per vertex weights given as input. Each vertex has a probability of being chosen that is proportional to its weight. If onlySelected is true, only the selected vertices are sampled. The indices of the sampled vertices in the mesh are stored in the birthVertices vector.  <br /></td></tr>
<tr class="separator:ga5cfe308da197164da340267bc3a3756f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c655840001a3b184e1e77f1dd5c1c24"><td class="memTemplParams" colspan="2">template&lt;SamplerConcept SamplerType, MeshConcept MeshType, typename ScalarType &gt; </td></tr>
<tr class="memitem:ga5c655840001a3b184e1e77f1dd5c1c24"><td class="memTemplItemLeft" align="right" valign="top">SamplerType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__point__sampling.html#ga5c655840001a3b184e1e77f1dd5c1c24">vertexWeightedPointSampling</a> (const MeshType &amp;m, const std::vector&lt; ScalarType &gt; &amp;weights, <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> nSamples, bool deterministic=false)</td></tr>
<tr class="memdesc:ga5c655840001a3b184e1e77f1dd5c1c24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Samples the vertices in a weighted way, using the per vertex weights given as input. Each vertex has a probability of being chosen that is proportional to its weight. If onlySelected is true, only the selected vertices are sampled.  <br /></td></tr>
<tr class="separator:ga5c655840001a3b184e1e77f1dd5c1c24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45797a5529565501b0217b75b996cc8d"><td class="memTemplParams" colspan="2">template&lt;SamplerConcept SamplerType, FaceMeshConcept MeshType, typename ScalarType &gt; </td></tr>
<tr class="memitem:ga45797a5529565501b0217b75b996cc8d"><td class="memTemplItemLeft" align="right" valign="top">SamplerType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__point__sampling.html#ga45797a5529565501b0217b75b996cc8d">faceWeightedPointSampling</a> (const MeshType &amp;m, const std::vector&lt; ScalarType &gt; &amp;weights, <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> nSamples, std::vector&lt; <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> &gt; &amp;birthFaces, bool deterministic=false)</td></tr>
<tr class="memdesc:ga45797a5529565501b0217b75b996cc8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a SamplerType object that contains the given number of samples taken from the faces of the given mesh. Each face has the same probability of being chosen. If onlySelected is true, only the selected faces are sampled. The indices of the sampled faces in the mesh are stored in the birthFaces vector.  <br /></td></tr>
<tr class="separator:ga45797a5529565501b0217b75b996cc8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b80c4e54addd57077b19b3be88e46df"><td class="memTemplParams" colspan="2">template&lt;SamplerConcept SamplerType, FaceMeshConcept MeshType, typename ScalarType &gt; </td></tr>
<tr class="memitem:ga7b80c4e54addd57077b19b3be88e46df"><td class="memTemplItemLeft" align="right" valign="top">SamplerType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__point__sampling.html#ga7b80c4e54addd57077b19b3be88e46df">faceWeightedPointSampling</a> (const MeshType &amp;m, const std::vector&lt; ScalarType &gt; &amp;weights, <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> nSamples, bool deterministic=false)</td></tr>
<tr class="memdesc:ga7b80c4e54addd57077b19b3be88e46df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a SamplerType object that contains the given number of samples taken from the faces of the given mesh. Each face has the same probability of being chosen. If onlySelected is true, only the selected faces are sampled.  <br /></td></tr>
<tr class="separator:ga7b80c4e54addd57077b19b3be88e46df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga06a1f194581098995159c29d970f09fa"><td class="memTemplParams" colspan="2">template&lt;SamplerConcept SamplerType, MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga06a1f194581098995159c29d970f09fa"><td class="memTemplItemLeft" align="right" valign="top">SamplerType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__point__sampling.html#ga06a1f194581098995159c29d970f09fa">vertexQualityWeightedPointSampling</a> (const MeshType &amp;m, <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> nSamples, bool deterministic=false)</td></tr>
<tr class="memdesc:ga06a1f194581098995159c29d970f09fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Samples the vertices in a weighted way, using the per vertex Quality component. Each vertex has a probability of being chosen that is proportional to its quality value.  <br /></td></tr>
<tr class="separator:ga06a1f194581098995159c29d970f09fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca1e65bf9e52ec03df48208bc727a90b"><td class="memTemplParams" colspan="2">template&lt;SamplerConcept SamplerType, FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:gaca1e65bf9e52ec03df48208bc727a90b"><td class="memTemplItemLeft" align="right" valign="top">SamplerType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__point__sampling.html#gaca1e65bf9e52ec03df48208bc727a90b">faceQualityWeightedPointSampling</a> (const MeshType &amp;m, <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> nSamples, bool deterministic=false)</td></tr>
<tr class="memdesc:gaca1e65bf9e52ec03df48208bc727a90b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Samples the faces in a weighted way, using the per face Quality component. Each face has a probability of being chosen that is proportional to its quality value.  <br /></td></tr>
<tr class="separator:gaca1e65bf9e52ec03df48208bc727a90b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga61de0fbca61ca1cf5d4afd01204bae90"><td class="memTemplParams" colspan="2">template&lt;SamplerConcept SamplerType, FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga61de0fbca61ca1cf5d4afd01204bae90"><td class="memTemplItemLeft" align="right" valign="top">SamplerType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__point__sampling.html#ga61de0fbca61ca1cf5d4afd01204bae90">vertexAreaWeightedPointSampling</a> (const MeshType &amp;m, <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> nSamples, bool deterministic=false)</td></tr>
<tr class="memdesc:ga61de0fbca61ca1cf5d4afd01204bae90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Samples the vertices in a weighted way, using the area. Each vertex has a probability of being chosen that is proportional to the average area of its adjacent faces.  <br /></td></tr>
<tr class="separator:ga61de0fbca61ca1cf5d4afd01204bae90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga865ca2d8750dd3ec5543dc2bfc3d00d3"><td class="memTemplParams" colspan="2">template&lt;SamplerConcept SamplerType, FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga865ca2d8750dd3ec5543dc2bfc3d00d3"><td class="memTemplItemLeft" align="right" valign="top">SamplerType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__point__sampling.html#ga865ca2d8750dd3ec5543dc2bfc3d00d3">faceAreaWeightedPointSampling</a> (const MeshType &amp;m, <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> nSamples, bool deterministic=false)</td></tr>
<tr class="memdesc:ga865ca2d8750dd3ec5543dc2bfc3d00d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Samples the faces in a weighted way, using the per face area. Each face has a probability of being chosen that is proportional to its area.  <br /></td></tr>
<tr class="separator:ga865ca2d8750dd3ec5543dc2bfc3d00d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d709e7d573815c0e5ebd934904de746"><td class="memTemplParams" colspan="2">template&lt;SamplerConcept SamplerType, FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga3d709e7d573815c0e5ebd934904de746"><td class="memTemplItemLeft" align="right" valign="top">SamplerType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__point__sampling.html#ga3d709e7d573815c0e5ebd934904de746">montecarloPointSampling</a> (const MeshType &amp;m, <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> nSamples, std::vector&lt; <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> &gt; &amp;birthFaces, bool deterministic=false)</td></tr>
<tr class="memdesc:ga3d709e7d573815c0e5ebd934904de746"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a montecarlo distribution with an exact number of samples. It works by generating a sequence of consecutive segments proportional to the face areas and actually shooting sample over this line. The indices of the sampled faces in the mesh are stored in the birthFaces vector.  <br /></td></tr>
<tr class="separator:ga3d709e7d573815c0e5ebd934904de746"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d65adc0bca9ee054f7491f14f43b0ec"><td class="memTemplParams" colspan="2">template&lt;SamplerConcept SamplerType, FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga1d65adc0bca9ee054f7491f14f43b0ec"><td class="memTemplItemLeft" align="right" valign="top">SamplerType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__point__sampling.html#ga1d65adc0bca9ee054f7491f14f43b0ec">montecarloPointSampling</a> (const MeshType &amp;m, <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> nSamples, bool deterministic=false)</td></tr>
<tr class="memdesc:ga1d65adc0bca9ee054f7491f14f43b0ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a montecarlo distribution with an exact number of samples. It works by generating a sequence of consecutive segments proportional to the face areas and actually shooting sample over this line.  <br /></td></tr>
<tr class="separator:ga1d65adc0bca9ee054f7491f14f43b0ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cc79547db9d6b6a15264fc004fec4dc"><td class="memTemplParams" colspan="2">template&lt;SamplerConcept SamplerType, FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a6cc79547db9d6b6a15264fc004fec4dc"><td class="memTemplItemLeft" align="right" valign="top">SamplerType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a6cc79547db9d6b6a15264fc004fec4dc">stratifiedMontecarloPointSampling</a> (const MeshType &amp;m, <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> nSamples, bool deterministic=false)</td></tr>
<tr class="separator:a6cc79547db9d6b6a15264fc004fec4dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8dfa9b78c674bc57e4a7400f723590bc"><td class="memTemplParams" colspan="2">template&lt;SamplerConcept SamplerType, FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga8dfa9b78c674bc57e4a7400f723590bc"><td class="memTemplItemLeft" align="right" valign="top">SamplerType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__point__sampling.html#ga8dfa9b78c674bc57e4a7400f723590bc">montecarloPoissonPointSampling</a> (const MeshType &amp;m, <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> nSamples, bool deterministic=false)</td></tr>
<tr class="memdesc:ga8dfa9b78c674bc57e4a7400f723590bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function compute montecarlo distribution with an approximate number of samples exploiting the poisson distribution approximation of the binomial distribution.  <br /></td></tr>
<tr class="separator:ga8dfa9b78c674bc57e4a7400f723590bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29eebb11ad214c9832b49f81417aae34"><td class="memTemplParams" colspan="2">template&lt;SamplerConcept SamplerType, FaceMeshConcept MeshType, typename ScalarType &gt; </td></tr>
<tr class="memitem:a29eebb11ad214c9832b49f81417aae34"><td class="memTemplItemLeft" align="right" valign="top">SamplerType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a29eebb11ad214c9832b49f81417aae34">vertexWeightedMontecarloPointSampling</a> (const MeshType &amp;m, const std::vector&lt; ScalarType &gt; &amp;weights, <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> nSamples, double variance, bool deterministic=false)</td></tr>
<tr class="separator:a29eebb11ad214c9832b49f81417aae34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6617580fead9a30c7c8db2e236e2a7a"><td class="memTemplParams" colspan="2">template&lt;SamplerConcept SamplerType, FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ac6617580fead9a30c7c8db2e236e2a7a"><td class="memTemplItemLeft" align="right" valign="top">SamplerType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ac6617580fead9a30c7c8db2e236e2a7a">vertexQualityWeightedMontecarloPointSampling</a> (const MeshType &amp;m, <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> nSamples, double variance, bool deterministic=false)</td></tr>
<tr class="separator:ac6617580fead9a30c7c8db2e236e2a7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a350d3edc324e0bef955a2c2ef8e20859"><td class="memTemplParams" colspan="2">template&lt;FaceConcept FaceType&gt; </td></tr>
<tr class="memitem:a350d3edc324e0bef955a2c2ef8e20859"><td class="memTemplItemLeft" align="right" valign="top">FaceType::VertexType::CoordType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a350d3edc324e0bef955a2c2ef8e20859">faceNormal</a> (const FaceType &amp;f)</td></tr>
<tr class="memdesc:a350d3edc324e0bef955a2c2ef8e20859"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the normal of a face, without modifying the face. Works both for triangle and polygonal faces, and it is optimized in case of triangle faces.  <br /></td></tr>
<tr class="separator:a350d3edc324e0bef955a2c2ef8e20859"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53b4f63db0979e578ebfa4b9e8b41f8a"><td class="memTemplParams" colspan="2">template&lt;FaceConcept FaceType&gt; </td></tr>
<tr class="memitem:a53b4f63db0979e578ebfa4b9e8b41f8a"><td class="memTemplItemLeft" align="right" valign="top">FaceType::VertexType::CoordType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a53b4f63db0979e578ebfa4b9e8b41f8a">faceBarycenter</a> (const FaceType &amp;f)</td></tr>
<tr class="memdesc:a53b4f63db0979e578ebfa4b9e8b41f8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the barycenter of a face. Works both for triangle and polygonal faces, and it is optimized in case of triangle faces.  <br /></td></tr>
<tr class="separator:a53b4f63db0979e578ebfa4b9e8b41f8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fc3b9cae851d7a729f40dc2f4ebe824"><td class="memTemplParams" colspan="2">template&lt;FaceConcept FaceType&gt; </td></tr>
<tr class="memitem:a9fc3b9cae851d7a729f40dc2f4ebe824"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a9fc3b9cae851d7a729f40dc2f4ebe824">faceArea</a> (const FaceType &amp;f)</td></tr>
<tr class="memdesc:a9fc3b9cae851d7a729f40dc2f4ebe824"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the area of a face. Works both for triangle and polygonal faces, and it is optimized in case of triangle faces.  <br /></td></tr>
<tr class="separator:a9fc3b9cae851d7a729f40dc2f4ebe824"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dccfede16e36e5ded5213fb13643943"><td class="memTemplParams" colspan="2">template&lt;FaceConcept FaceType&gt; </td></tr>
<tr class="memitem:a1dccfede16e36e5ded5213fb13643943"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a1dccfede16e36e5ded5213fb13643943">facePerimeter</a> (const FaceType &amp;f)</td></tr>
<tr class="memdesc:a1dccfede16e36e5ded5213fb13643943"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the perimeter of a face. Works both for triangle and polygonal faces, and it is optimized in case of triangle faces.  <br /></td></tr>
<tr class="separator:a1dccfede16e36e5ded5213fb13643943"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12529598a32a7b21eac27744b3578600"><td class="memTemplParams" colspan="2">template&lt;FaceConcept FaceType&gt; </td></tr>
<tr class="memitem:a12529598a32a7b21eac27744b3578600"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a12529598a32a7b21eac27744b3578600">faceAngleOnVertexRad</a> (const FaceType &amp;f, <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> vi)</td></tr>
<tr class="memdesc:a12529598a32a7b21eac27744b3578600"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the internal angle (in radians) of the vi-th vertex of the face.  <br /></td></tr>
<tr class="separator:a12529598a32a7b21eac27744b3578600"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2177afd92cfc4dbe6468aa05892b016f"><td class="memTemplParams" colspan="2">template&lt;FaceConcept FaceType&gt; <br />
requires comp::HasAdjacentFaces&lt;FaceType&gt;</td></tr>
<tr class="memitem:a2177afd92cfc4dbe6468aa05892b016f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a2177afd92cfc4dbe6468aa05892b016f">faceDihedralAngleOnEdge</a> (const FaceType &amp;f, <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> e)</td></tr>
<tr class="memdesc:a2177afd92cfc4dbe6468aa05892b016f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the signed dihedral angle between the normals of the given face and its adjacent face on the edge <code>e</code>.  <br /></td></tr>
<tr class="separator:a2177afd92cfc4dbe6468aa05892b016f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25a86f4bcf104c60099849828d71e06f"><td class="memTemplParams" colspan="2">template&lt;FaceConcept FaceType&gt; <br />
requires comp::HasAdjacentFaces&lt;FaceType&gt;</td></tr>
<tr class="memitem:a25a86f4bcf104c60099849828d71e06f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a25a86f4bcf104c60099849828d71e06f">isFaceManifoldOnEdge</a> (const FaceType &amp;f, <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> edge)</td></tr>
<tr class="memdesc:a25a86f4bcf104c60099849828d71e06f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if an edge in the given face is manifold.  <br /></td></tr>
<tr class="separator:a25a86f4bcf104c60099849828d71e06f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af888cb13421f6fb92d776927f302518b"><td class="memTemplParams" colspan="2">template&lt;FaceConcept FaceType&gt; <br />
requires comp::HasAdjacentFaces&lt;FaceType&gt;</td></tr>
<tr class="memitem:af888cb13421f6fb92d776927f302518b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#af888cb13421f6fb92d776927f302518b">isFaceEdgeOnBorder</a> (const FaceType &amp;f, <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> edge)</td></tr>
<tr class="memdesc:af888cb13421f6fb92d776927f302518b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if an edge in the given face is on the border.  <br /></td></tr>
<tr class="separator:af888cb13421f6fb92d776927f302518b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47188a6c411a5a4fbd8542d5ce1525aa"><td class="memTemplParams" colspan="2">template&lt;FaceConcept FaceType&gt; <br />
requires comp::HasAdjacentFaces&lt;FaceType&gt;</td></tr>
<tr class="memitem:a47188a6c411a5a4fbd8542d5ce1525aa"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a47188a6c411a5a4fbd8542d5ce1525aa">checkFlipEdge</a> (const FaceType &amp;f, <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> edge)</td></tr>
<tr class="memdesc:a47188a6c411a5a4fbd8542d5ce1525aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a boolean value indicating whether the edge flip operation is allowed or not.  <br /></td></tr>
<tr class="separator:a47188a6c411a5a4fbd8542d5ce1525aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77bd6f212cc6ca4ad37ce181c2ba6d1b"><td class="memTemplParams" colspan="2">template&lt;FaceConcept FaceType&gt; <br />
requires comp::HasAdjacentFaces&lt;FaceType&gt;</td></tr>
<tr class="memitem:a77bd6f212cc6ca4ad37ce181c2ba6d1b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a77bd6f212cc6ca4ad37ce181c2ba6d1b">edgeAdjacentFacesNumber</a> (const FaceType &amp;f, <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> edge)</td></tr>
<tr class="memdesc:a77bd6f212cc6ca4ad37ce181c2ba6d1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of adjacent faces to the given edge of the face f.  <br /></td></tr>
<tr class="separator:a77bd6f212cc6ca4ad37ce181c2ba6d1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a711865422c63688724ec6328b4e7c4cd"><td class="memTemplParams" colspan="2">template&lt;FaceConcept FaceType&gt; <br />
requires comp::HasAdjacentFaces&lt;FaceType&gt;</td></tr>
<tr class="memitem:a711865422c63688724ec6328b4e7c4cd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a711865422c63688724ec6328b4e7c4cd">faceEdgesOnBorderNumber</a> (const FaceType &amp;f)</td></tr>
<tr class="memdesc:a711865422c63688724ec6328b4e7c4cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of edges that are on border (no adjacent faces) on the given face.  <br /></td></tr>
<tr class="separator:a711865422c63688724ec6328b4e7c4cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3109cc4c0e2128888f2a3fa6ae27a98f"><td class="memTemplParams" colspan="2">template&lt;FaceConcept FaceType&gt; <br />
requires comp::HasAdjacentFaces&lt;FaceType&gt;</td></tr>
<tr class="memitem:a3109cc4c0e2128888f2a3fa6ae27a98f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a3109cc4c0e2128888f2a3fa6ae27a98f">detachAdjacentFacesOnEdge</a> (FaceType &amp;f, <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> edge)</td></tr>
<tr class="memdesc:a3109cc4c0e2128888f2a3fa6ae27a98f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detaches the face <code>f</code> on the given edge, which consists on updating adjacent faces such that any face that was linking the face <code>f</code> won't link it anymore. It manages also non-manifold edges.  <br /></td></tr>
<tr class="separator:a3109cc4c0e2128888f2a3fa6ae27a98f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af67d9147410404febe19163fb506397d"><td class="memTemplParams" colspan="2">template&lt;FaceConcept FaceType&gt; <br />
requires comp::HasAdjacentFaces&lt;FaceType&gt;</td></tr>
<tr class="memitem:af67d9147410404febe19163fb506397d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#af67d9147410404febe19163fb506397d">detachFace</a> (FaceType &amp;f)</td></tr>
<tr class="memdesc:af67d9147410404febe19163fb506397d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detaches the given face from all its adjacent vertices and adjacent faces.  <br /></td></tr>
<tr class="separator:af67d9147410404febe19163fb506397d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3983ab4b434d669a765240b81daa236e"><td class="memTemplParams" colspan="2">template&lt;FaceConcept Face&gt; </td></tr>
<tr class="memitem:a3983ab4b434d669a765240b81daa236e"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a3983ab4b434d669a765240b81daa236e">earCut</a> (const <a class="el" href="classvcl_1_1Face.html">Face</a> &amp;polygon)</td></tr>
<tr class="memdesc:a3983ab4b434d669a765240b81daa236e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the earcut algorithm of a 3D <em>planar</em> polygon, that returns a triangulation of the polygon.  <br /></td></tr>
<tr class="separator:a3983ab4b434d669a765240b81daa236e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab5bd336ab6b6a6138f89ffbb56ef3b5"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType, FaceConcept FaceType&gt; </td></tr>
<tr class="memitem:aab5bd336ab6b6a6138f89ffbb56ef3b5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#aab5bd336ab6b6a6138f89ffbb56ef3b5">addTriangleFacesFromPolygon</a> (MeshType &amp;m, FaceType &amp;f, const std::vector&lt; <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> &gt; &amp;polygon)</td></tr>
<tr class="memdesc:aab5bd336ab6b6a6138f89ffbb56ef3b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a vector of indices of vertices in a mesh representing a polyon, this function adds N triangular faces to the mesh, that are the triangulation of the input polygon. <a class="el" href="classvcl_1_1Triangle.html">Triangle</a> edges that are internal in the polygon are marked as faux.  <br /></td></tr>
<tr class="separator:aab5bd336ab6b6a6138f89ffbb56ef3b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acad48a316f6b47d2ce4fa978be50a97e"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:acad48a316f6b47d2ce4fa978be50a97e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#acad48a316f6b47d2ce4fa978be50a97e">addTriangleFacesFromPolygon</a> (MeshType &amp;m, const std::vector&lt; <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> &gt; &amp;polygon)</td></tr>
<tr class="memdesc:acad48a316f6b47d2ce4fa978be50a97e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a vector of indices of vertices in a mesh representing a polyon, this function adds N triangular faces to the mesh, that are the triangulation of the input polygon. <a class="el" href="classvcl_1_1Triangle.html">Triangle</a> edges that are internal in the polygon are marked as faux. This function returns the index of the first added triangle.  <br /></td></tr>
<tr class="separator:acad48a316f6b47d2ce4fa978be50a97e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d6bf09841cfbbaaa328de2d552fc090"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a1d6bf09841cfbbaaa328de2d552fc090"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; typename MeshType::VertexType * &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a1d6bf09841cfbbaaa328de2d552fc090">fillAndShuffleVertexPointerVector</a> (MeshType &amp;m, bool deterministic=false)</td></tr>
<tr class="separator:a1d6bf09841cfbbaaa328de2d552fc090"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa78e0576d6ad4f8e4af89367f38dabe5"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:aa78e0576d6ad4f8e4af89367f38dabe5"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; const typename MeshType::VertexType * &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#aa78e0576d6ad4f8e4af89367f38dabe5">fillAndShuffleVertexPointerVector</a> (const MeshType &amp;m, bool deterministic=false)</td></tr>
<tr class="separator:aa78e0576d6ad4f8e4af89367f38dabe5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9667638a4f4f3faea6994a61ce7119e"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ac9667638a4f4f3faea6994a61ce7119e"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ac9667638a4f4f3faea6994a61ce7119e">fillAndShuffleVertexIndexVector</a> (const MeshType &amp;m, bool deterministic=false)</td></tr>
<tr class="separator:ac9667638a4f4f3faea6994a61ce7119e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad656a119fe2eb1573d28a28e6576d41d"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ad656a119fe2eb1573d28a28e6576d41d"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; typename MeshType::FaceType * &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ad656a119fe2eb1573d28a28e6576d41d">fillAndShuffleFacePointerVector</a> (MeshType &amp;m, bool deterministic=false)</td></tr>
<tr class="separator:ad656a119fe2eb1573d28a28e6576d41d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9b1a38c4fad92ad74bbc461e64f1c08"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ab9b1a38c4fad92ad74bbc461e64f1c08"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; const typename MeshType::FaceType * &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ab9b1a38c4fad92ad74bbc461e64f1c08">fillAndShuffleFacePointerVector</a> (const MeshType &amp;m, bool deterministic=false)</td></tr>
<tr class="separator:ab9b1a38c4fad92ad74bbc461e64f1c08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae41a0dea61c2ea301966406de57ae461"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ae41a0dea61c2ea301966406de57ae461"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ae41a0dea61c2ea301966406de57ae461">fillAndShuffleFaceIndexVector</a> (const MeshType &amp;m, bool deterministic=false)</td></tr>
<tr class="separator:ae41a0dea61c2ea301966406de57ae461"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6effb8d19dc6c62592f8f2cfff8a6854"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a6effb8d19dc6c62592f8f2cfff8a6854"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a6effb8d19dc6c62592f8f2cfff8a6854">laplacianSmoothing</a> (MeshType &amp;m, <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> step, bool smoothSelected=false, bool cotangentWeight=false)</td></tr>
<tr class="memdesc:a6effb8d19dc6c62592f8f2cfff8a6854"><td class="mdescLeft">&#160;</td><td class="mdescRight">vertexCoordLaplacianSmoothing the classical Laplacian smoothing. Each vertex is moved onto the average of the adjacent vertices.  <br /></td></tr>
<tr class="separator:a6effb8d19dc6c62592f8f2cfff8a6854"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d1a7878d6acec093a915b11413984aa"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a7d1a7878d6acec093a915b11413984aa"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a7d1a7878d6acec093a915b11413984aa">taubinSmoothing</a> (MeshType &amp;m, <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> step, float lambda, float mu, bool smoothSelected=false)</td></tr>
<tr class="separator:a7d1a7878d6acec093a915b11413984aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a2005cb82322d607914a2e2dcd63e66"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a9a2005cb82322d607914a2e2dcd63e66"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a9a2005cb82322d607914a2e2dcd63e66">smoothPerVertexNormalsPointCloud</a> (MeshType &amp;m, <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> neighborNum, <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> iterNum)</td></tr>
<tr class="memdesc:a9a2005cb82322d607914a2e2dcd63e66"><td class="mdescLeft">&#160;</td><td class="mdescRight">smoothPerVertexNormalsPointCloud  <br /></td></tr>
<tr class="separator:a9a2005cb82322d607914a2e2dcd63e66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33f84f8e28d1adf77369c920bb0e46b5"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType, PointConcept PointType&gt; </td></tr>
<tr class="memitem:a33f84f8e28d1adf77369c920bb0e46b5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a33f84f8e28d1adf77369c920bb0e46b5">smoothPerVertexNormalsPointCloud</a> (MeshType &amp;m, const <a class="el" href="classvcl_1_1KDTree.html">KDTree</a>&lt; PointType &gt; &amp;tree, <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> neighborNum, <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> iterNum)</td></tr>
<tr class="memdesc:a33f84f8e28d1adf77369c920bb0e46b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">smoothPerVertexNormalsPointCloud  <br /></td></tr>
<tr class="separator:a33f84f8e28d1adf77369c920bb0e46b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ff4adce6cdd2cc82aec090338c4ccfe"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a8ff4adce6cdd2cc82aec090338c4ccfe"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classvcl_1_1MeshEdgeUtil.html">MeshEdgeUtil</a>&lt; MeshType &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a8ff4adce6cdd2cc82aec090338c4ccfe">fillAndSortMeshEdgeUtilVector</a> (MeshType &amp;m, bool includeFauxEdges=true)</td></tr>
<tr class="separator:a8ff4adce6cdd2cc82aec090338c4ccfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66a5b3121ca08d3686ae7637a9e30cf7"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a66a5b3121ca08d3686ae7637a9e30cf7"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classvcl_1_1ConstMeshEdgeUtil.html">ConstMeshEdgeUtil</a>&lt; MeshType &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a66a5b3121ca08d3686ae7637a9e30cf7">fillAndSortMeshEdgeUtilVector</a> (const MeshType &amp;m, bool includeFauxEdges=true)</td></tr>
<tr class="separator:a66a5b3121ca08d3686ae7637a9e30cf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66e2e1e0ec5d91e9def735ecf4f84b0e"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a66e2e1e0ec5d91e9def735ecf4f84b0e"><td class="memTemplItemLeft" align="right" valign="top">MeshType::VertexType::CoordType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a66e2e1e0ec5d91e9def735ecf4f84b0e">barycenter</a> (const MeshType &amp;m)</td></tr>
<tr class="memdesc:a66e2e1e0ec5d91e9def735ecf4f84b0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the barycenter of the mesh, that is the simple average of all the vertex coordintes of the mesh.  <br /></td></tr>
<tr class="separator:a66e2e1e0ec5d91e9def735ecf4f84b0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63bff22265d64d974b4fe4267b6dbac0"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a63bff22265d64d974b4fe4267b6dbac0"><td class="memTemplItemLeft" align="right" valign="top">MeshType::VertexType::CoordType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a63bff22265d64d974b4fe4267b6dbac0">scalarWeightedBarycenter</a> (const MeshType &amp;m)</td></tr>
<tr class="memdesc:a63bff22265d64d974b4fe4267b6dbac0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the barycenter of the mesh weighted on the per vertex quality values.  <br /></td></tr>
<tr class="separator:a63bff22265d64d974b4fe4267b6dbac0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecc52dfd02e09e49a5dd1612183a2cb8"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:aecc52dfd02e09e49a5dd1612183a2cb8"><td class="memTemplItemLeft" align="right" valign="top">MeshType::VertexType::CoordType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#aecc52dfd02e09e49a5dd1612183a2cb8">shellBarycenter</a> (const MeshType &amp;m)</td></tr>
<tr class="memdesc:aecc52dfd02e09e49a5dd1612183a2cb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the barycenter of the surface thin-shell. E.g. it assume a 'empty' model where all the mass is located on the surface and compute the barycenter of that thinshell. Works for any polygonal model (no problem with open, nonmanifold selfintersecting models). Useful for computing the barycenter of 2D planar figures.  <br /></td></tr>
<tr class="separator:aecc52dfd02e09e49a5dd1612183a2cb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a3eb7aeb0da02be51ca136620616b43"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a9a3eb7aeb0da02be51ca136620616b43"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a9a3eb7aeb0da02be51ca136620616b43">volume</a> (const MeshType &amp;m)</td></tr>
<tr class="memdesc:a9a3eb7aeb0da02be51ca136620616b43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the volume of a closed surface <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>. Returned value is meaningful only if the input mesh is watertight.  <br /></td></tr>
<tr class="separator:a9a3eb7aeb0da02be51ca136620616b43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dfa8d4e30b457c12c3e5e21b4fc123a"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a5dfa8d4e30b457c12c3e5e21b4fc123a"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a5dfa8d4e30b457c12c3e5e21b4fc123a">surfaceArea</a> (const MeshType &amp;m)</td></tr>
<tr class="memdesc:a5dfa8d4e30b457c12c3e5e21b4fc123a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the surface area of the given <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>, that is the sum of the areas of each face of the mesh.  <br /></td></tr>
<tr class="separator:a5dfa8d4e30b457c12c3e5e21b4fc123a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86c0811cfbc37a3b319d57902e81e949"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a86c0811cfbc37a3b319d57902e81e949"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a86c0811cfbc37a3b319d57902e81e949">borderLength</a> (const MeshType &amp;m)</td></tr>
<tr class="memdesc:a86c0811cfbc37a3b319d57902e81e949"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the border length of the given <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>, that is the sum of the length of the edges that are on border in the given mesh.  <br /></td></tr>
<tr class="separator:a86c0811cfbc37a3b319d57902e81e949"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9fd633374c0d8ab86df9e354a9a0fb5"><td class="memTemplParams" colspan="2">template&lt;PointConcept PointType&gt; </td></tr>
<tr class="memitem:af9fd633374c0d8ab86df9e354a9a0fb5"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#af9fd633374c0d8ab86df9e354a9a0fb5">covarianceMatrixOfPointCloud</a> (const std::vector&lt; PointType &gt; &amp;pointVec)</td></tr>
<tr class="memdesc:af9fd633374c0d8ab86df9e354a9a0fb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the covariance matrix of a set of points.  <br /></td></tr>
<tr class="separator:af9fd633374c0d8ab86df9e354a9a0fb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46a67e9dd1e0a9805f812c10328caaa2"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a46a67e9dd1e0a9805f812c10328caaa2"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a46a67e9dd1e0a9805f812c10328caaa2">covarianceMatrixOfPointCloud</a> (const MeshType &amp;m)</td></tr>
<tr class="memdesc:a46a67e9dd1e0a9805f812c10328caaa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the covariance matrix of a <a class="el" href="classvcl_1_1Point.html" title="The Point class represents an N-dimensional point containing N scalar values.">Point</a> Cloud <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>.  <br /></td></tr>
<tr class="separator:a46a67e9dd1e0a9805f812c10328caaa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe0d3154bb94af5fb7d34bd186eba0b3"><td class="memTemplParams" colspan="2">template&lt;PointConcept PointType&gt; </td></tr>
<tr class="memitem:abe0d3154bb94af5fb7d34bd186eba0b3"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#abe0d3154bb94af5fb7d34bd186eba0b3">weightedCovarianceMatrixOfPointCloud</a> (const std::vector&lt; PointType &gt; &amp;pointVec, const std::vector&lt; typename PointType::ScalarType &gt; &amp;weights)</td></tr>
<tr class="memdesc:abe0d3154bb94af5fb7d34bd186eba0b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the weighted covariance matrix of a set of points.  <br /></td></tr>
<tr class="separator:abe0d3154bb94af5fb7d34bd186eba0b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49e57acf0c1cb51e98f7a176051d99ee"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a49e57acf0c1cb51e98f7a176051d99ee"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a49e57acf0c1cb51e98f7a176051d99ee">covarianceMatrixOfMesh</a> (const MeshType &amp;m)</td></tr>
<tr class="memdesc:a49e57acf0c1cb51e98f7a176051d99ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute covariance matrix of a mesh, i.e. the integral int_{m} { (x-b)(x-b)^T }dx where b is the barycenter and x spans over the mesh m.  <br /></td></tr>
<tr class="separator:a49e57acf0c1cb51e98f7a176051d99ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a598979803f34d74d1c4c9d4599d01eb8"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType, typename ScalarType &gt; </td></tr>
<tr class="memitem:a598979803f34d74d1c4c9d4599d01eb8"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; ScalarType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a598979803f34d74d1c4c9d4599d01eb8">vertexRadiusFromWeights</a> (const MeshType &amp;m, const std::vector&lt; ScalarType &gt; &amp;weights, double diskRadius, double radiusVariance, bool invert=false)</td></tr>
<tr class="memdesc:a598979803f34d74d1c4c9d4599d01eb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">When performing an adptive pruning for each sample we expect a varying radius to be removed. The radius is a PerVertex attribute that we compute from the current per vertex weights given as argument. The expected radius of the sample is computed so that it linearly maps the quality between diskradius and diskradius*variance.  <br /></td></tr>
<tr class="separator:a598979803f34d74d1c4c9d4599d01eb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2972300f527bd1cce6182dde8b76c41"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ae2972300f527bd1cce6182dde8b76c41"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ae2972300f527bd1cce6182dde8b76c41">vertexQualityMinMax</a> (const MeshType &amp;m)</td></tr>
<tr class="memdesc:ae2972300f527bd1cce6182dde8b76c41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pair containing the min and the maximum vertex quality.  <br /></td></tr>
<tr class="separator:ae2972300f527bd1cce6182dde8b76c41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42145b026908d9eafadd429eba4fa0be"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a42145b026908d9eafadd429eba4fa0be"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a42145b026908d9eafadd429eba4fa0be">faceQualityMinMax</a> (const MeshType &amp;m)</td></tr>
<tr class="memdesc:a42145b026908d9eafadd429eba4fa0be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pair containing the min and the maximum face quality.  <br /></td></tr>
<tr class="separator:a42145b026908d9eafadd429eba4fa0be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ed4ecc783b58f5327f0a6b68c071727"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a9ed4ecc783b58f5327f0a6b68c071727"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a9ed4ecc783b58f5327f0a6b68c071727">vertexQualityAverage</a> (const MeshType &amp;m)</td></tr>
<tr class="memdesc:a9ed4ecc783b58f5327f0a6b68c071727"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a scalar that is the average of the vertex quality.  <br /></td></tr>
<tr class="separator:a9ed4ecc783b58f5327f0a6b68c071727"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cdee5764b3aa8dbc91ff6a114e9bfc1"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a4cdee5764b3aa8dbc91ff6a114e9bfc1"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a4cdee5764b3aa8dbc91ff6a114e9bfc1">faceQualityAverage</a> (const MeshType &amp;m)</td></tr>
<tr class="memdesc:a4cdee5764b3aa8dbc91ff6a114e9bfc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a scalar that is the average of the face quality.  <br /></td></tr>
<tr class="separator:a4cdee5764b3aa8dbc91ff6a114e9bfc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8a8d81401816c73db39eeae352e95bc"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:aa8a8d81401816c73db39eeae352e95bc"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; typename MeshType::VertexType::QualityType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#aa8a8d81401816c73db39eeae352e95bc">vertexRadiusFromQuality</a> (const MeshType &amp;m, double diskRadius, double radiusVariance, bool invert=false)</td></tr>
<tr class="memdesc:aa8a8d81401816c73db39eeae352e95bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">When performing an adptive pruning for each sample we expect a varying radius to be removed. The radius is a PerVertex attribute that we compute from the current per vertex quality component. The expected radius of the sample is computed so that it linearly maps the quality between diskradius and diskradius*variance.  <br /></td></tr>
<tr class="separator:aa8a8d81401816c73db39eeae352e95bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cbfad9340b842c1bf68c7faf4ff9dc7"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType, typename HScalar  = double&gt; </td></tr>
<tr class="memitem:a7cbfad9340b842c1bf68c7faf4ff9dc7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Histogram.html">Histogram</a>&lt; HScalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a7cbfad9340b842c1bf68c7faf4ff9dc7">vertexQualityHistogram</a> (const MeshType &amp;m, bool selectionOnly=false, <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> histSize=10000)</td></tr>
<tr class="separator:a7cbfad9340b842c1bf68c7faf4ff9dc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af44349f8534585f6e0cef128edb98ca0"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType, typename HScalar  = double&gt; </td></tr>
<tr class="memitem:af44349f8534585f6e0cef128edb98ca0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Histogram.html">Histogram</a>&lt; HScalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#af44349f8534585f6e0cef128edb98ca0">faceQualityHistogram</a> (const MeshType &amp;m, bool selectionOnly=false, <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> histSize=10000)</td></tr>
<tr class="separator:af44349f8534585f6e0cef128edb98ca0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ebad55b87f91b27b05663d9ce7ad406"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a7ebad55b87f91b27b05663d9ce7ad406"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a7ebad55b87f91b27b05663d9ce7ad406">vertexSelectionNumber</a> (const MeshType &amp;m)</td></tr>
<tr class="separator:a7ebad55b87f91b27b05663d9ce7ad406"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5585995167e0f9338ebb153314c0067b"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a5585995167e0f9338ebb153314c0067b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a5585995167e0f9338ebb153314c0067b">faceSelectionNumber</a> (const MeshType &amp;m)</td></tr>
<tr class="separator:a5585995167e0f9338ebb153314c0067b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ecd18a495232ac86d4c81913a1ad3f7"><td class="memTemplParams" colspan="2">template&lt;HasBoundingBox MeshType&gt; </td></tr>
<tr class="memitem:ga8ecd18a495232ac86d4c81913a1ad3f7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__update.html#ga8ecd18a495232ac86d4c81913a1ad3f7">updateBoundingBox</a> (MeshType &amp;m)</td></tr>
<tr class="memdesc:ga8ecd18a495232ac86d4c81913a1ad3f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the bounding box of the mesh.  <br /></td></tr>
<tr class="separator:ga8ecd18a495232ac86d4c81913a1ad3f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga38b37b1e8291340239554140dd07bcf2"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga38b37b1e8291340239554140dd07bcf2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__update.html#ga38b37b1e8291340239554140dd07bcf2">setPerVertexColor</a> (MeshType &amp;m, <a class="el" href="classvcl_1_1Color.html">vcl::Color</a> c=<a class="el" href="classvcl_1_1Color.html#afab49834d923b1e26589efe2eef9a135a933a633d2d20cec2e05a97a403dcd1d4">vcl::Color::White</a>, bool onlySelected=false)</td></tr>
<tr class="memdesc:ga38b37b1e8291340239554140dd07bcf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the color of the vertices. If the <code>onlySelected</code> flag is set to <code>true</code>, only the color of the selected vertices will be set. Otherwise, all the vertices will have the same color.  <br /></td></tr>
<tr class="separator:ga38b37b1e8291340239554140dd07bcf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd40b9510ebcbbc885f2b251eff19c85"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:gafd40b9510ebcbbc885f2b251eff19c85"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__update.html#gafd40b9510ebcbbc885f2b251eff19c85">setPerFaceColor</a> (MeshType &amp;m, <a class="el" href="classvcl_1_1Color.html">vcl::Color</a> c=<a class="el" href="classvcl_1_1Color.html#afab49834d923b1e26589efe2eef9a135a933a633d2d20cec2e05a97a403dcd1d4">vcl::Color::White</a>, bool onlySelected=false)</td></tr>
<tr class="memdesc:gafd40b9510ebcbbc885f2b251eff19c85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the color of the faces. If the <code>onlySelected</code> flag is set to <code>true</code>, only the color of the selected faces will be set. Otherwise, all the faces will have the same color.  <br /></td></tr>
<tr class="separator:gafd40b9510ebcbbc885f2b251eff19c85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa7a7bdb880ed18451dbad7b220ad708"><td class="memTemplParams" colspan="2">template&lt;HasColor MeshType&gt; </td></tr>
<tr class="memitem:gafa7a7bdb880ed18451dbad7b220ad708"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__update.html#gafa7a7bdb880ed18451dbad7b220ad708">setMeshColor</a> (MeshType &amp;m, <a class="el" href="classvcl_1_1Color.html">vcl::Color</a> c=<a class="el" href="classvcl_1_1Color.html#afab49834d923b1e26589efe2eef9a135a933a633d2d20cec2e05a97a403dcd1d4">vcl::Color::White</a>)</td></tr>
<tr class="memdesc:gafa7a7bdb880ed18451dbad7b220ad708"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the color component of a mesh.  <br /></td></tr>
<tr class="separator:gafa7a7bdb880ed18451dbad7b220ad708"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga003227edc01710ea2a42c6e326b34698"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga003227edc01710ea2a42c6e326b34698"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__update.html#ga003227edc01710ea2a42c6e326b34698">setPerVertexColorFromFaceColor</a> (MeshType &amp;m)</td></tr>
<tr class="memdesc:ga003227edc01710ea2a42c6e326b34698"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the vertex colors from its incident face colors, computing a plain average of the face colors.  <br /></td></tr>
<tr class="separator:ga003227edc01710ea2a42c6e326b34698"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga698e981e0c5fd646f3401579735e7825"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga698e981e0c5fd646f3401579735e7825"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__update.html#ga698e981e0c5fd646f3401579735e7825">setPerFaceColorFromVertexColor</a> (MeshType &amp;m)</td></tr>
<tr class="memdesc:ga698e981e0c5fd646f3401579735e7825"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the face colors from its incident vertex colors, computing a plain average of the vertex colors.  <br /></td></tr>
<tr class="separator:ga698e981e0c5fd646f3401579735e7825"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga213cbe42a2c49bda6686e5dee548941f"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga213cbe42a2c49bda6686e5dee548941f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__update.html#ga213cbe42a2c49bda6686e5dee548941f">setPerVertexColorFromQuality</a> (MeshType &amp;m, <a class="el" href="classvcl_1_1Color.html#a32ace7bd7fccf742b39f6cd83042a10f">vcl::Color::ColorMap</a> colorMap=<a class="el" href="classvcl_1_1Color.html#a32ace7bd7fccf742b39f6cd83042a10fab41395ae78ccecdb7c2a311a4bb25130">vcl::Color::RedBlue</a>, typename MeshType::VertexType::QualityType minQuality=0, typename MeshType::VertexType::QualityType maxQuality=0)</td></tr>
<tr class="memdesc:ga213cbe42a2c49bda6686e5dee548941f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the vertex colors from the quality values by computing a shading in the given color map (default is Red to Blue color map), in the given interval [minQuality, maxQuality].  <br /></td></tr>
<tr class="separator:ga213cbe42a2c49bda6686e5dee548941f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad1237f614680030ae7d2bdc13b2877b6"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:gad1237f614680030ae7d2bdc13b2877b6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__update.html#gad1237f614680030ae7d2bdc13b2877b6">setPerFaceColorFromQuality</a> (MeshType &amp;m, <a class="el" href="classvcl_1_1Color.html#a32ace7bd7fccf742b39f6cd83042a10f">vcl::Color::ColorMap</a> colorMap=<a class="el" href="classvcl_1_1Color.html#a32ace7bd7fccf742b39f6cd83042a10fab41395ae78ccecdb7c2a311a4bb25130">vcl::Color::RedBlue</a>, typename MeshType::FaceType::QualityType minQuality=0, typename MeshType::FaceType::QualityType maxQuality=0)</td></tr>
<tr class="memdesc:gad1237f614680030ae7d2bdc13b2877b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the face colors from the quality values by computing a shading in the given color map (default is Red to Blue color map), in the given interval [minQuality, maxQuality].  <br /></td></tr>
<tr class="separator:gad1237f614680030ae7d2bdc13b2877b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb208445ca45b8758d9522c420694f38"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:gadb208445ca45b8758d9522c420694f38"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__update.html#gadb208445ca45b8758d9522c420694f38">setPerVertexColorFromFaceBorderFlag</a> (MeshType &amp;m, <a class="el" href="classvcl_1_1Color.html">Color</a> borderColor=<a class="el" href="classvcl_1_1Color.html#afab49834d923b1e26589efe2eef9a135af54d29d341201c1ef87b86671a29b28e">vcl::Color::Blue</a>, <a class="el" href="classvcl_1_1Color.html">Color</a> internalColor=<a class="el" href="classvcl_1_1Color.html#afab49834d923b1e26589efe2eef9a135a933a633d2d20cec2e05a97a403dcd1d4">vcl::Color::White</a>, <a class="el" href="classvcl_1_1Color.html">Color</a> mixColor=<a class="el" href="classvcl_1_1Color.html#afab49834d923b1e26589efe2eef9a135aa70f19981682325e9f47020f45097ab3">vcl::Color::Cyan</a>)</td></tr>
<tr class="memdesc:gadb208445ca45b8758d9522c420694f38"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classvcl_1_1Color.html" title="The Color class represents a RGBA color.">Color</a> the vertices of the mesh that are on border, using the border flags of the faces.  <br /></td></tr>
<tr class="separator:gadb208445ca45b8758d9522c420694f38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaefda81ff00c7e8d3b5ff19c9e90c03bf"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:gaefda81ff00c7e8d3b5ff19c9e90c03bf"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__update.html#gaefda81ff00c7e8d3b5ff19c9e90c03bf">setPerFaceColorFromConnectedComponents</a> (MeshType &amp;m, const std::vector&lt; std::set&lt; <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> &gt; &gt; &amp;<a class="el" href="group__clean.html#ga774f9a47e9cef107d59b97d0434177f7">connectedComponents</a>)</td></tr>
<tr class="memdesc:gaefda81ff00c7e8d3b5ff19c9e90c03bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an already computed vector of sets of connected components (see vcl::connectedComponents(m) in <code><a class="el" href="clean_8h.html">vclib/algorithms/clean.h</a></code>), sets face colors according from connected components of the mesh. Each connected component will have a different per face color.  <br /></td></tr>
<tr class="separator:gaefda81ff00c7e8d3b5ff19c9e90c03bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga39a8c9027a5e7c936518969bda799f71"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga39a8c9027a5e7c936518969bda799f71"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__update.html#ga39a8c9027a5e7c936518969bda799f71">setPerFaceColorFromConnectedComponents</a> (MeshType &amp;m)</td></tr>
<tr class="memdesc:ga39a8c9027a5e7c936518969bda799f71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets face colors according from connected components of the mesh. Each connected component will have a different per face color. Since this function will need to compute connected components of the mesh, also per <a class="el" href="classvcl_1_1Face.html" title="The Face class represents an Face element of the vcl::Mesh class.">Face</a> AdjacentFaces component is required.  <br /></td></tr>
<tr class="separator:ga39a8c9027a5e7c936518969bda799f71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga318a121ea66deb73b4d95ca0ec311290"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga318a121ea66deb73b4d95ca0ec311290"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__update.html#ga318a121ea66deb73b4d95ca0ec311290">setPerFaceColorScattering</a> (MeshType &amp;m, <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> nColors=50, bool checkFauxEdges=true)</td></tr>
<tr class="memdesc:ga318a121ea66deb73b4d95ca0ec311290"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function colors each face of the mesh using a given number of scattering colors (default number is 50). By default, colors uniformely adjacent faces having faux edges in common. This check is made only if the option <code>checkFauxEdges</code> is set to true, and if the per <a class="el" href="classvcl_1_1Face.html" title="The Face class represents an Face element of the vcl::Mesh class.">Face</a> AdjacentFaces component is available in the mesh.  <br /></td></tr>
<tr class="separator:ga318a121ea66deb73b4d95ca0ec311290"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga37b2b7fbbfce106c039cb86ad7994335"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType, PointConcept PointType&gt; </td></tr>
<tr class="memitem:ga37b2b7fbbfce106c039cb86ad7994335"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__update.html#ga37b2b7fbbfce106c039cb86ad7994335">setPerVertexColorPerlinNoise</a> (MeshType &amp;m, PointType period, PointType offset=PointType(0, 0, 0), bool onSelected=false)</td></tr>
<tr class="memdesc:ga37b2b7fbbfce106c039cb86ad7994335"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the vertex color according to a perlin noise computed on the vertex coordinates.  <br /></td></tr>
<tr class="separator:ga37b2b7fbbfce106c039cb86ad7994335"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga48d79f5a79d36e16d20272ccdb3f56e5"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType, PointConcept PointType&gt; </td></tr>
<tr class="memitem:ga48d79f5a79d36e16d20272ccdb3f56e5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__update.html#ga48d79f5a79d36e16d20272ccdb3f56e5">setPerVertexPerlinColor</a> (MeshType &amp;m, double period, PointType offset=PointType(0, 0, 0), <a class="el" href="classvcl_1_1Color.html">Color</a> color1=<a class="el" href="classvcl_1_1Color.html#afab49834d923b1e26589efe2eef9a135a5777c5f96e2970090b99598c215292f7">Color::Black</a>, <a class="el" href="classvcl_1_1Color.html">Color</a> color2=<a class="el" href="classvcl_1_1Color.html#afab49834d923b1e26589efe2eef9a135a933a633d2d20cec2e05a97a403dcd1d4">Color::White</a>, bool onSelected=false)</td></tr>
<tr class="memdesc:ga48d79f5a79d36e16d20272ccdb3f56e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple Perlin color mixing. <code>color1</code> and <code>color2</code> are mixed according the perlin noise function, with <code>period</code> and <code>offset</code>.  <br /></td></tr>
<tr class="separator:ga48d79f5a79d36e16d20272ccdb3f56e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0953cccb4f94dded63edb630530e2197"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType, LoggerConcept LogType = NullLogger&gt; </td></tr>
<tr class="memitem:a0953cccb4f94dded63edb630530e2197"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a0953cccb4f94dded63edb630530e2197">updatePrincipalCurvatureTaubin95</a> (MeshType &amp;m, LogType &amp;log)</td></tr>
<tr class="separator:a0953cccb4f94dded63edb630530e2197"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac053ed0caa29edc306e54201f0bf6123"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType, LoggerConcept LogType = NullLogger&gt; </td></tr>
<tr class="memitem:ac053ed0caa29edc306e54201f0bf6123"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ac053ed0caa29edc306e54201f0bf6123">updatePrincipalCurvaturePCA</a> (MeshType &amp;m, typename MeshType::VertexType::CoordType::ScalarType radius, bool montecarloSampling=true, LogType &amp;log=<a class="el" href="group__miscellaneous.html#ga3377e3c875ec245e90ac5a395105ce99">nullLogger</a>)</td></tr>
<tr class="memdesc:ac053ed0caa29edc306e54201f0bf6123"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the Principal Curvature meseaure as described in the paper: Robust principal curvatures on Multiple Scales, Yong-Liang Yang, Yu-Kun Lai, Shi-Min Hu Helmut Pottmann SGP 2004. If montecarloSampling==true the covariance is computed by montecarlo sampling on the mesh (faster); If montecarloSampling==false the covariance is computed by (analytic)integration over the surface (slower).  <br /></td></tr>
<tr class="separator:ac053ed0caa29edc306e54201f0bf6123"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c1237fab955f1bf4329842c6d3ed51a"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType, LoggerConcept LogType = NullLogger&gt; </td></tr>
<tr class="memitem:a3c1237fab955f1bf4329842c6d3ed51a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a3c1237fab955f1bf4329842c6d3ed51a">updatePrincipalCurvature</a> (MeshType &amp;m, LogType &amp;log=<a class="el" href="group__miscellaneous.html#ga3377e3c875ec245e90ac5a395105ce99">nullLogger</a>)</td></tr>
<tr class="separator:a3c1237fab955f1bf4329842c6d3ed51a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b3ad75679b446aabe75e8f1701bce67"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType, LoggerConcept LogType = NullLogger&gt; </td></tr>
<tr class="memitem:a8b3ad75679b446aabe75e8f1701bce67"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a8b3ad75679b446aabe75e8f1701bce67">updatePrincipalCurvature</a> (MeshType &amp;m, <a class="el" href="namespacevcl.html#aaca879a6bfd47ff8429d6b2f6cfa9440">VCLibPrincipalCurvatureAlgorithm</a> alg=<a class="el" href="namespacevcl.html#aaca879a6bfd47ff8429d6b2f6cfa9440a16e818963316b0b43fcbdec6d75f25ed">VCL_PRINCIPAL_CURVATURE_TAUBIN95</a>, LogType &amp;log=<a class="el" href="group__miscellaneous.html#ga3377e3c875ec245e90ac5a395105ce99">nullLogger</a>)</td></tr>
<tr class="separator:a8b3ad75679b446aabe75e8f1701bce67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a359b253b8af6d1ae3ac24625e8ac7a56"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a359b253b8af6d1ae3ac24625e8ac7a56"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a359b253b8af6d1ae3ac24625e8ac7a56">updateBorder</a> (MeshType &amp;m)</td></tr>
<tr class="memdesc:a359b253b8af6d1ae3ac24625e8ac7a56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes per-face border flags without requiring any kind of topology info.  <br /></td></tr>
<tr class="separator:a359b253b8af6d1ae3ac24625e8ac7a56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3ccefcbb94fc15319e388a1183f3925"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ae3ccefcbb94fc15319e388a1183f3925"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ae3ccefcbb94fc15319e388a1183f3925">normalizePerFaceNormals</a> (MeshType &amp;m)</td></tr>
<tr class="memdesc:ae3ccefcbb94fc15319e388a1183f3925"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalizes the length of the face normals.  <br /></td></tr>
<tr class="separator:ae3ccefcbb94fc15319e388a1183f3925"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dd9800cb5538e0eb47613be82daaf44"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a8dd9800cb5538e0eb47613be82daaf44"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a8dd9800cb5538e0eb47613be82daaf44">updatePerFaceNormals</a> (MeshType &amp;m, bool normalize=true)</td></tr>
<tr class="memdesc:a8dd9800cb5538e0eb47613be82daaf44"><td class="mdescLeft">&#160;</td><td class="mdescRight">updatePerFaceNormals  <br /></td></tr>
<tr class="separator:a8dd9800cb5538e0eb47613be82daaf44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6a0e2bc172c69d34a84631e824c75a4"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ad6a0e2bc172c69d34a84631e824c75a4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ad6a0e2bc172c69d34a84631e824c75a4">clearPerVertexNormals</a> (MeshType &amp;m)</td></tr>
<tr class="memdesc:ad6a0e2bc172c69d34a84631e824c75a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets to zero the normals of all the vertices of the mesh, including the unreferenced ones.  <br /></td></tr>
<tr class="separator:ad6a0e2bc172c69d34a84631e824c75a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5ad240da55effe35e495f1aad2e3507"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:aa5ad240da55effe35e495f1aad2e3507"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#aa5ad240da55effe35e495f1aad2e3507">clearPerReferencedVertexNormals</a> (MeshType &amp;m)</td></tr>
<tr class="memdesc:aa5ad240da55effe35e495f1aad2e3507"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets to zero all the normals of vertices that are referenced by at least one face, leaving unchanged all the normals of the unreferenced vertices that may be still useful.  <br /></td></tr>
<tr class="separator:aa5ad240da55effe35e495f1aad2e3507"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c7590577a9732afcd1dc3639b3965b6"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a0c7590577a9732afcd1dc3639b3965b6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a0c7590577a9732afcd1dc3639b3965b6">normalizePerVertexNormals</a> (MeshType &amp;m)</td></tr>
<tr class="memdesc:a0c7590577a9732afcd1dc3639b3965b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalizes the length of the vertex normals.  <br /></td></tr>
<tr class="separator:a0c7590577a9732afcd1dc3639b3965b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea3bc3d2b03bb9e985c9977023b0fb9f"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:aea3bc3d2b03bb9e985c9977023b0fb9f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#aea3bc3d2b03bb9e985c9977023b0fb9f">updatePerVertexNormals</a> (MeshType &amp;m, bool normalize=true)</td></tr>
<tr class="memdesc:aea3bc3d2b03bb9e985c9977023b0fb9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the vertex normal as the classic area weighted average.  <br /></td></tr>
<tr class="separator:aea3bc3d2b03bb9e985c9977023b0fb9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afafcf64d1f3086a907da247132369ca2"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:afafcf64d1f3086a907da247132369ca2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#afafcf64d1f3086a907da247132369ca2">updatePerVertexNormalsFromFaceNormals</a> (MeshType &amp;m, bool normalize=true)</td></tr>
<tr class="memdesc:afafcf64d1f3086a907da247132369ca2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the vertex normal as the sum of the adjacent faces normals.  <br /></td></tr>
<tr class="separator:afafcf64d1f3086a907da247132369ca2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b7d63fc38670dac30d1dd1dadf4ef8c"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a1b7d63fc38670dac30d1dd1dadf4ef8c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a1b7d63fc38670dac30d1dd1dadf4ef8c">updatePerVertexNormalsAngleWeighted</a> (MeshType &amp;m, bool normalize=true)</td></tr>
<tr class="memdesc:a1b7d63fc38670dac30d1dd1dadf4ef8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the vertex normal as an angle weighted average.  <br /></td></tr>
<tr class="separator:a1b7d63fc38670dac30d1dd1dadf4ef8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fdde9d989eeac7117c4f2fd26f3456b"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a5fdde9d989eeac7117c4f2fd26f3456b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a5fdde9d989eeac7117c4f2fd26f3456b">updatePerVertexNormalsNelsonMaxWeighted</a> (MeshType &amp;m, bool normalize=true)</td></tr>
<tr class="memdesc:a5fdde9d989eeac7117c4f2fd26f3456b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the vertex normal using the Max et al. weighting scheme.  <br /></td></tr>
<tr class="separator:a5fdde9d989eeac7117c4f2fd26f3456b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a520f83d5e0afa947767dffe36fb77661"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType, typename MScalar &gt; </td></tr>
<tr class="memitem:a520f83d5e0afa947767dffe36fb77661"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a520f83d5e0afa947767dffe36fb77661">multiplyPerFaceNormalsByMatrix</a> (MeshType &amp;mesh, const <a class="el" href="namespacevcl.html#ad82a126b390f21b2e9658c73e7a795ee">vcl::Matrix44</a>&lt; MScalar &gt; &amp;mat, bool removeScalingFromMatrix=true)</td></tr>
<tr class="memdesc:a520f83d5e0afa947767dffe36fb77661"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies the <a class="el" href="classvcl_1_1Face.html" title="The Face class represents an Face element of the vcl::Mesh class.">Face</a> Normals by the given TRS 4x4 Matrix. By default, the scale component is removed from the matrix.  <br /></td></tr>
<tr class="separator:a520f83d5e0afa947767dffe36fb77661"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abce848dfdb8667d516f4738b3b8925a7"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType, typename MScalar &gt; </td></tr>
<tr class="memitem:abce848dfdb8667d516f4738b3b8925a7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#abce848dfdb8667d516f4738b3b8925a7">multiplyPerVertexNormalsByMatrix</a> (MeshType &amp;mesh, const <a class="el" href="namespacevcl.html#ad82a126b390f21b2e9658c73e7a795ee">vcl::Matrix44</a>&lt; MScalar &gt; &amp;mat, bool removeScalingFromMatrix=true)</td></tr>
<tr class="memdesc:abce848dfdb8667d516f4738b3b8925a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies the <a class="el" href="classvcl_1_1Vertex.html" title="The Vertex class represents an Vertex element of the vcl::Mesh class.">Vertex</a> Normals by the given TRS 4x4 Matrix. By default, the scale component is removed from the matrix.  <br /></td></tr>
<tr class="separator:abce848dfdb8667d516f4738b3b8925a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a745a7eed34f93850095b2c81f127d9f6"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a745a7eed34f93850095b2c81f127d9f6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a745a7eed34f93850095b2c81f127d9f6">setPerVertexQuality</a> (MeshType &amp;m, typename MeshType::VertexType::QualityType s)</td></tr>
<tr class="memdesc:a745a7eed34f93850095b2c81f127d9f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a constant value to all the vertex quality of the mesh.  <br /></td></tr>
<tr class="separator:a745a7eed34f93850095b2c81f127d9f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa949e95f7bfb9d8dedc0f7e15e5d3ab9"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:aa949e95f7bfb9d8dedc0f7e15e5d3ab9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#aa949e95f7bfb9d8dedc0f7e15e5d3ab9">setPerFaceQuality</a> (MeshType &amp;m, typename MeshType::FaceType::QualityType s)</td></tr>
<tr class="memdesc:aa949e95f7bfb9d8dedc0f7e15e5d3ab9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a constant value to all the face quality of the mesh.  <br /></td></tr>
<tr class="separator:aa949e95f7bfb9d8dedc0f7e15e5d3ab9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a696dc0c7e7d1e45751850aaa7a51f247"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a696dc0c7e7d1e45751850aaa7a51f247"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a696dc0c7e7d1e45751850aaa7a51f247">clampPerVertexQuality</a> (MeshType &amp;m, typename MeshType::VertexType::QualityType minS, typename MeshType::VertexType::QualityType maxS)</td></tr>
<tr class="memdesc:a696dc0c7e7d1e45751850aaa7a51f247"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clamps the vertex quality of a mesh in a given interval.  <br /></td></tr>
<tr class="separator:a696dc0c7e7d1e45751850aaa7a51f247"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a748cd8beb49f3c7a18dbd1efdcd8bf21"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a748cd8beb49f3c7a18dbd1efdcd8bf21"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a748cd8beb49f3c7a18dbd1efdcd8bf21">clampPerFaceQuality</a> (MeshType &amp;m, typename MeshType::FaceType::QualityType minS, typename MeshType::FaceType::QualityType maxS)</td></tr>
<tr class="memdesc:a748cd8beb49f3c7a18dbd1efdcd8bf21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clamps the face quality of a mesh in a given interval.  <br /></td></tr>
<tr class="separator:a748cd8beb49f3c7a18dbd1efdcd8bf21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1a6ca42d06d208218a4aa820f220696"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ad1a6ca42d06d208218a4aa820f220696"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ad1a6ca42d06d208218a4aa820f220696">normalizePerVertexQuality</a> (MeshType &amp;m, typename MeshType::VertexType::QualityType minS=0, typename MeshType::VertexType::QualityType maxS=1)</td></tr>
<tr class="memdesc:ad1a6ca42d06d208218a4aa820f220696"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalizes the vertex quality of a mesh in a given interval (default [0, 1]).  <br /></td></tr>
<tr class="separator:ad1a6ca42d06d208218a4aa820f220696"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a607cbcdaf24e6dd7cec3e23a28fb450f"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a607cbcdaf24e6dd7cec3e23a28fb450f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a607cbcdaf24e6dd7cec3e23a28fb450f">normalizePerFaceQuality</a> (MeshType &amp;m, typename MeshType::FaceType::QualityType minS=0, typename MeshType::FaceType::QualityType maxS=1)</td></tr>
<tr class="memdesc:a607cbcdaf24e6dd7cec3e23a28fb450f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalizes the face quality of a mesh in a given interval (default [0, 1]).  <br /></td></tr>
<tr class="separator:a607cbcdaf24e6dd7cec3e23a28fb450f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8b71c44c2c2e9adcc6bad8e278e7010"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:af8b71c44c2c2e9adcc6bad8e278e7010"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#af8b71c44c2c2e9adcc6bad8e278e7010">setPerVertexQualityFromVertexValence</a> (MeshType &amp;m)</td></tr>
<tr class="memdesc:af8b71c44c2c2e9adcc6bad8e278e7010"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign to the vertex quality of the mesh the valence of each vertex, that is the number of adjacent faces of the vertex.  <br /></td></tr>
<tr class="separator:af8b71c44c2c2e9adcc6bad8e278e7010"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9e9aa9515cb4086de430109e361cfde"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ab9e9aa9515cb4086de430109e361cfde"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ab9e9aa9515cb4086de430109e361cfde">setPerFaceQualityFromFaceArea</a> (MeshType &amp;m)</td></tr>
<tr class="memdesc:ab9e9aa9515cb4086de430109e361cfde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign to the face quality of the mesh the area of each face.  <br /></td></tr>
<tr class="separator:ab9e9aa9515cb4086de430109e361cfde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b31235ba7d846238e202713eaaa0495"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a2b31235ba7d846238e202713eaaa0495"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a2b31235ba7d846238e202713eaaa0495">setPerVertexQualityFromPrincipalCurvatureGaussian</a> (MeshType &amp;m)</td></tr>
<tr class="separator:a2b31235ba7d846238e202713eaaa0495"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88a3a13cc9462bac2a7e1e578cddf540"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a88a3a13cc9462bac2a7e1e578cddf540"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a88a3a13cc9462bac2a7e1e578cddf540">setPerVertexQualityFromPrincipalCurvatureMean</a> (MeshType &amp;m)</td></tr>
<tr class="separator:a88a3a13cc9462bac2a7e1e578cddf540"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88daff53e6272feb2b26432246c0f848"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a88daff53e6272feb2b26432246c0f848"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a88daff53e6272feb2b26432246c0f848">setPerVertexQualityFromPrincipalCurvatureMinValue</a> (MeshType &amp;m)</td></tr>
<tr class="separator:a88daff53e6272feb2b26432246c0f848"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b1d34773ec1878660fe407a4768b67b"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a7b1d34773ec1878660fe407a4768b67b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a7b1d34773ec1878660fe407a4768b67b">setPerVertexQualityFromPrincipalCurvatureMaxValue</a> (MeshType &amp;m)</td></tr>
<tr class="separator:a7b1d34773ec1878660fe407a4768b67b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fa908d1710912a11715aedca11ecb76"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a2fa908d1710912a11715aedca11ecb76"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a2fa908d1710912a11715aedca11ecb76">setPerVertexQualityFromPrincipalCurvatureShapeIndex</a> (MeshType &amp;m)</td></tr>
<tr class="memdesc:a2fa908d1710912a11715aedca11ecb76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the Shape Index S from the Principal Curvature, as defined by [Koenderink 1992] and stores it in the per-vertex quality.  <br /></td></tr>
<tr class="separator:a2fa908d1710912a11715aedca11ecb76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4120bcf201dd0de7e75bbd2e39a658df"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a4120bcf201dd0de7e75bbd2e39a658df"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a4120bcf201dd0de7e75bbd2e39a658df">setPerVertexQualityFromPrincipalCurvatureCurvedness</a> (MeshType &amp;m)</td></tr>
<tr class="memdesc:a4120bcf201dd0de7e75bbd2e39a658df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the Curvedness C from the Principal Curvature, as defined by [Koenderink 1992] and stores it in the per-vertex quality.  <br /></td></tr>
<tr class="separator:a4120bcf201dd0de7e75bbd2e39a658df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b0bc5dbd8005d39d14ccf664ffca33c"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a7b0bc5dbd8005d39d14ccf664ffca33c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a7b0bc5dbd8005d39d14ccf664ffca33c">clearVertexSelection</a> (MeshType &amp;m)</td></tr>
<tr class="separator:a7b0bc5dbd8005d39d14ccf664ffca33c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb5edd39f9dd2fc2220d8b08be523e29"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:abb5edd39f9dd2fc2220d8b08be523e29"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#abb5edd39f9dd2fc2220d8b08be523e29">clearFaceSelection</a> (MeshType &amp;m)</td></tr>
<tr class="separator:abb5edd39f9dd2fc2220d8b08be523e29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0416a0056c7bbd35f81e72bb9b536db0"><td class="memTemplParams" colspan="2">template&lt;EdgeMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a0416a0056c7bbd35f81e72bb9b536db0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a0416a0056c7bbd35f81e72bb9b536db0">clearEdgeSelection</a> (MeshType &amp;m)</td></tr>
<tr class="separator:a0416a0056c7bbd35f81e72bb9b536db0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaec6c356404a0bf3eb24a29e867004df"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:aaec6c356404a0bf3eb24a29e867004df"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#aaec6c356404a0bf3eb24a29e867004df">selectNonManifoldVertices</a> (MeshType &amp;m, bool clearSelectionFirst)</td></tr>
<tr class="separator:aaec6c356404a0bf3eb24a29e867004df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54e8371c2ddda188c9540ea7e7bddf78"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a54e8371c2ddda188c9540ea7e7bddf78"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a54e8371c2ddda188c9540ea7e7bddf78">clearPerVertexAdjacentFaces</a> (MeshType &amp;m)</td></tr>
<tr class="memdesc:a54e8371c2ddda188c9540ea7e7bddf78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the adjacent faces of each vertex of the mesh.  <br /></td></tr>
<tr class="separator:a54e8371c2ddda188c9540ea7e7bddf78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3ecae45cc9e58f948dc04178fd6669b"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:af3ecae45cc9e58f948dc04178fd6669b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#af3ecae45cc9e58f948dc04178fd6669b">updatePerVertexAdjacentFaces</a> (MeshType &amp;m)</td></tr>
<tr class="memdesc:af3ecae45cc9e58f948dc04178fd6669b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the adjacent faces of each vertex of the mesh.  <br /></td></tr>
<tr class="separator:af3ecae45cc9e58f948dc04178fd6669b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a312c8ca27b3e94994a1f03bc1a3d826d"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a312c8ca27b3e94994a1f03bc1a3d826d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a312c8ca27b3e94994a1f03bc1a3d826d">clearPerVertexAdjacentVertices</a> (MeshType &amp;m)</td></tr>
<tr class="memdesc:a312c8ca27b3e94994a1f03bc1a3d826d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the adjacent vertices of each vertex of the mesh.  <br /></td></tr>
<tr class="separator:a312c8ca27b3e94994a1f03bc1a3d826d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b6e8d46b2b867729d95c72ab1925df2"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a6b6e8d46b2b867729d95c72ab1925df2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a6b6e8d46b2b867729d95c72ab1925df2">updatePerVertexAdjacentVertices</a> (MeshType &amp;m)</td></tr>
<tr class="memdesc:a6b6e8d46b2b867729d95c72ab1925df2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the adjacent vertices of each vertex of the mesh.  <br /></td></tr>
<tr class="separator:a6b6e8d46b2b867729d95c72ab1925df2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec301aa1e068ae4ceeeef43761b9ee04"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:aec301aa1e068ae4ceeeef43761b9ee04"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#aec301aa1e068ae4ceeeef43761b9ee04">clearPerFaceAdjacentFaces</a> (MeshType &amp;m)</td></tr>
<tr class="memdesc:aec301aa1e068ae4ceeeef43761b9ee04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the adjacent faces of each face of the mesh.  <br /></td></tr>
<tr class="separator:aec301aa1e068ae4ceeeef43761b9ee04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3db69fc234fc8072747aabf1724f9b92"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a3db69fc234fc8072747aabf1724f9b92"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a3db69fc234fc8072747aabf1724f9b92">updatePerFaceAdjacentFaces</a> (MeshType &amp;m)</td></tr>
<tr class="memdesc:a3db69fc234fc8072747aabf1724f9b92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the per face adjacent face component.  <br /></td></tr>
<tr class="separator:a3db69fc234fc8072747aabf1724f9b92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90d821ff0dab1c3c45fdfe82ce48448f"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType, typename ScalarM &gt; </td></tr>
<tr class="memitem:a90d821ff0dab1c3c45fdfe82ce48448f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a90d821ff0dab1c3c45fdfe82ce48448f">applyTransformMatrix</a> (MeshType &amp;mesh, const <a class="el" href="namespacevcl.html#ad82a126b390f21b2e9658c73e7a795ee">Matrix44</a>&lt; ScalarM &gt; &amp;matrix, bool updateNormals=true)</td></tr>
<tr class="separator:a90d821ff0dab1c3c45fdfe82ce48448f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c4a60eeed3ddead3611508975cb6045"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType, PointConcept PointType&gt; </td></tr>
<tr class="memitem:a7c4a60eeed3ddead3611508975cb6045"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a7c4a60eeed3ddead3611508975cb6045">translate</a> (MeshType &amp;mesh, const PointType &amp;t)</td></tr>
<tr class="separator:a7c4a60eeed3ddead3611508975cb6045"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5217f309d49911db6e36a4f6d31acdaa"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType, PointConcept PointType&gt; </td></tr>
<tr class="memitem:a5217f309d49911db6e36a4f6d31acdaa"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a5217f309d49911db6e36a4f6d31acdaa">scale</a> (MeshType &amp;mesh, const PointType &amp;s)</td></tr>
<tr class="separator:a5217f309d49911db6e36a4f6d31acdaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7f4da00ff716cc6e58e2e9ade275d6a"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType, typename Scalar  = double&gt; </td></tr>
<tr class="memitem:ad7f4da00ff716cc6e58e2e9ade275d6a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ad7f4da00ff716cc6e58e2e9ade275d6a">scale</a> (MeshType &amp;mesh, const Scalar &amp;s)</td></tr>
<tr class="separator:ad7f4da00ff716cc6e58e2e9ade275d6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a516ae081ca79f1afbf5a77883613be72"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a516ae081ca79f1afbf5a77883613be72">drawPoint2</a> (const <a class="el" href="group__space.html#ga4b02e85ff4d51fe7d689f8dd0e87ecd5">Point2d</a> &amp;p, const <a class="el" href="classvcl_1_1Color.html">Color</a> &amp;c, int size=8)</td></tr>
<tr class="memdesc:a516ae081ca79f1afbf5a77883613be72"><td class="mdescLeft">&#160;</td><td class="mdescRight">drawPoint2  <br /></td></tr>
<tr class="separator:a516ae081ca79f1afbf5a77883613be72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11cf68ac82c35fc923d8406b4a8aad9e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a11cf68ac82c35fc923d8406b4a8aad9e">drawLine2</a> (const <a class="el" href="group__space.html#ga4b02e85ff4d51fe7d689f8dd0e87ecd5">Point2d</a> &amp;a, const <a class="el" href="group__space.html#ga4b02e85ff4d51fe7d689f8dd0e87ecd5">Point2d</a> &amp;b, const <a class="el" href="classvcl_1_1Color.html">Color</a> &amp;c, int width=3)</td></tr>
<tr class="memdesc:a11cf68ac82c35fc923d8406b4a8aad9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">drawLine2  <br /></td></tr>
<tr class="separator:a11cf68ac82c35fc923d8406b4a8aad9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9376bbd1e5522814ec359777aabdcf3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#af9376bbd1e5522814ec359777aabdcf3">drawTriangle2</a> (const <a class="el" href="group__space.html#ga4b02e85ff4d51fe7d689f8dd0e87ecd5">Point2d</a> &amp;p1, const <a class="el" href="group__space.html#ga4b02e85ff4d51fe7d689f8dd0e87ecd5">Point2d</a> &amp;p2, const <a class="el" href="group__space.html#ga4b02e85ff4d51fe7d689f8dd0e87ecd5">Point2d</a> &amp;p3, const <a class="el" href="classvcl_1_1Color.html">Color</a> &amp;c, int width=3, bool fill=false)</td></tr>
<tr class="separator:af9376bbd1e5522814ec359777aabdcf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f8b82d8c87385e00570c863a8976fe1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a2f8b82d8c87385e00570c863a8976fe1">drawTriangle2</a> (const std::array&lt; <a class="el" href="group__space.html#ga4b02e85ff4d51fe7d689f8dd0e87ecd5">Point2d</a>, 3 &gt; &amp;arr, const <a class="el" href="classvcl_1_1Color.html">Color</a> &amp;c, int width=3, bool fill=false)</td></tr>
<tr class="separator:a2f8b82d8c87385e00570c863a8976fe1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb8951e6b832297167e55b3bbfe366a1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#abb8951e6b832297167e55b3bbfe366a1">drawQuad2</a> (const std::array&lt; <a class="el" href="group__space.html#ga4b02e85ff4d51fe7d689f8dd0e87ecd5">Point2d</a>, 4 &gt; &amp;points, const <a class="el" href="classvcl_1_1Color.html">Color</a> &amp;c, int width=3, bool fill=false)</td></tr>
<tr class="separator:abb8951e6b832297167e55b3bbfe366a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf0a4439a6ce94a7bd97459505578043"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#aaf0a4439a6ce94a7bd97459505578043">drawQuad2</a> (const <a class="el" href="group__space.html#ga4b02e85ff4d51fe7d689f8dd0e87ecd5">Point2d</a> &amp;p1, const <a class="el" href="group__space.html#ga4b02e85ff4d51fe7d689f8dd0e87ecd5">Point2d</a> &amp;p2, const <a class="el" href="group__space.html#ga4b02e85ff4d51fe7d689f8dd0e87ecd5">Point2d</a> &amp;p3, const <a class="el" href="group__space.html#ga4b02e85ff4d51fe7d689f8dd0e87ecd5">Point2d</a> &amp;p4, const <a class="el" href="classvcl_1_1Color.html">Color</a> &amp;c, int width=3, bool fill=false)</td></tr>
<tr class="separator:aaf0a4439a6ce94a7bd97459505578043"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28c3f4bdb0bf107ad6870d3a89f522d8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a28c3f4bdb0bf107ad6870d3a89f522d8">drawPoint3</a> (const <a class="el" href="group__space.html#gabb47c1364fb2fe1464a54417684f011e">Point3d</a> &amp;p, const <a class="el" href="classvcl_1_1Color.html">Color</a> &amp;c, int size=8)</td></tr>
<tr class="memdesc:a28c3f4bdb0bf107ad6870d3a89f522d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draws a point on the plane (coord z = 0 if 3D).  <br /></td></tr>
<tr class="separator:a28c3f4bdb0bf107ad6870d3a89f522d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a323c893b90e6dc2a41ac41eb9e7691a2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a323c893b90e6dc2a41ac41eb9e7691a2">drawSphere</a> (const <a class="el" href="group__space.html#gabb47c1364fb2fe1464a54417684f011e">Point3d</a> &amp;center, float radius, const <a class="el" href="classvcl_1_1Color.html">Color</a> &amp;color, int precision=4)</td></tr>
<tr class="memdesc:a323c893b90e6dc2a41ac41eb9e7691a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draws a sphere with opengl.  <br /></td></tr>
<tr class="separator:a323c893b90e6dc2a41ac41eb9e7691a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a827383d99bab0852a41372b2cedd4f42"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a827383d99bab0852a41372b2cedd4f42">drawCylinder</a> (const <a class="el" href="group__space.html#gabb47c1364fb2fe1464a54417684f011e">Point3d</a> &amp;a, const <a class="el" href="group__space.html#gabb47c1364fb2fe1464a54417684f011e">Point3d</a> &amp;b, float top_radius, float bottom_radius, const <a class="el" href="classvcl_1_1Color.html">Color</a> &amp;color, unsigned int slices=50, unsigned int stacks=10)</td></tr>
<tr class="memdesc:a827383d99bab0852a41372b2cedd4f42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draws a cylinder with opengl. The cylinder links the two points passed as parameters.  <br /></td></tr>
<tr class="separator:a827383d99bab0852a41372b2cedd4f42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acec9c589f837b0294e6d50a9a3388b92"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#acec9c589f837b0294e6d50a9a3388b92">drawArrow3</a> (const <a class="el" href="group__space.html#gabb47c1364fb2fe1464a54417684f011e">Point3d</a> &amp;a, const <a class="el" href="group__space.html#gabb47c1364fb2fe1464a54417684f011e">Point3d</a> &amp;b, float bottom_radius, const <a class="el" href="classvcl_1_1Color.html">Color</a> &amp;color, unsigned int slices=50, unsigned int stacks=10)</td></tr>
<tr class="separator:acec9c589f837b0294e6d50a9a3388b92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b332fa5ff7656af768ec5adad56c7ef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a5b332fa5ff7656af768ec5adad56c7ef">drawLine3</a> (const <a class="el" href="group__space.html#gabb47c1364fb2fe1464a54417684f011e">Point3d</a> &amp;a, const <a class="el" href="group__space.html#gabb47c1364fb2fe1464a54417684f011e">Point3d</a> &amp;b, const <a class="el" href="classvcl_1_1Color.html">Color</a> &amp;c, int width=3)</td></tr>
<tr class="memdesc:a5b332fa5ff7656af768ec5adad56c7ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draws a line with opengl that links the two points passed as parameters.  <br /></td></tr>
<tr class="separator:a5b332fa5ff7656af768ec5adad56c7ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44f0d7c3d49978fb964728e9457b76dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a44f0d7c3d49978fb964728e9457b76dd">drawSegment3</a> (const <a class="el" href="group__space.html#gabb47c1364fb2fe1464a54417684f011e">Point3d</a> &amp;a, const <a class="el" href="group__space.html#gabb47c1364fb2fe1464a54417684f011e">Point3d</a> &amp;b, const <a class="el" href="classvcl_1_1Color.html">Color</a> &amp;c, int width=3)</td></tr>
<tr class="separator:a44f0d7c3d49978fb964728e9457b76dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d79778f20004b0238af02eea0170b06"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a3d79778f20004b0238af02eea0170b06">drawDashedLine3</a> (const <a class="el" href="group__space.html#gabb47c1364fb2fe1464a54417684f011e">Point3d</a> &amp;a, const <a class="el" href="group__space.html#gabb47c1364fb2fe1464a54417684f011e">Point3d</a> &amp;b, const <a class="el" href="classvcl_1_1Color.html">Color</a> &amp;c, int width=3)</td></tr>
<tr class="memdesc:a3d79778f20004b0238af02eea0170b06"><td class="mdescLeft">&#160;</td><td class="mdescRight">drawDashedLine  <br /></td></tr>
<tr class="separator:a3d79778f20004b0238af02eea0170b06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fe90c17e9b40d28753fa4428bbba626"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a3fe90c17e9b40d28753fa4428bbba626">drawTriangle</a> (const <a class="el" href="group__space.html#gabb47c1364fb2fe1464a54417684f011e">Point3d</a> &amp;p1, const <a class="el" href="group__space.html#gabb47c1364fb2fe1464a54417684f011e">Point3d</a> &amp;p2, const <a class="el" href="group__space.html#gabb47c1364fb2fe1464a54417684f011e">Point3d</a> &amp;p3, const <a class="el" href="classvcl_1_1Color.html">Color</a> &amp;c, int width=3, bool fill=false)</td></tr>
<tr class="separator:a3fe90c17e9b40d28753fa4428bbba626"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee24b3c24b38932469ae9ef367c7f001"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#aee24b3c24b38932469ae9ef367c7f001">drawQuad3</a> (const <a class="el" href="group__space.html#gabb47c1364fb2fe1464a54417684f011e">Point3d</a> &amp;a, const <a class="el" href="group__space.html#gabb47c1364fb2fe1464a54417684f011e">Point3d</a> &amp;b, const <a class="el" href="group__space.html#gabb47c1364fb2fe1464a54417684f011e">Point3d</a> &amp;c, const <a class="el" href="group__space.html#gabb47c1364fb2fe1464a54417684f011e">Point3d</a> &amp;d, int width=3)</td></tr>
<tr class="separator:aee24b3c24b38932469ae9ef367c7f001"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63eea0cb7f075cb1b25868a94a9755d2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a63eea0cb7f075cb1b25868a94a9755d2">drawBox3</a> (const <a class="el" href="group__space.html#gabb47c1364fb2fe1464a54417684f011e">Point3d</a> &amp;<a class="el" href="namespacevcl.html#a3edcb561672a6be17e9453bd1ea446d5">min</a>, const <a class="el" href="group__space.html#gabb47c1364fb2fe1464a54417684f011e">Point3d</a> &amp;<a class="el" href="namespacevcl.html#a69cc63a5ad2974d082145ed1dee7846b">max</a>, const <a class="el" href="classvcl_1_1Color.html">Color</a> &amp;c, int width=3)</td></tr>
<tr class="memdesc:a63eea0cb7f075cb1b25868a94a9755d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draws an axis aligned 3D box using opengl lines.  <br /></td></tr>
<tr class="separator:a63eea0cb7f075cb1b25868a94a9755d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a750ed5084363ad069179728eda8d02e4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a750ed5084363ad069179728eda8d02e4">drawBox3</a> (const <a class="el" href="group__space.html#gabb47c1364fb2fe1464a54417684f011e">Point3d</a> &amp;p0, const <a class="el" href="group__space.html#gabb47c1364fb2fe1464a54417684f011e">Point3d</a> &amp;p1, const <a class="el" href="group__space.html#gabb47c1364fb2fe1464a54417684f011e">Point3d</a> &amp;p2, const <a class="el" href="group__space.html#gabb47c1364fb2fe1464a54417684f011e">Point3d</a> &amp;p3, const <a class="el" href="group__space.html#gabb47c1364fb2fe1464a54417684f011e">Point3d</a> &amp;p4, const <a class="el" href="group__space.html#gabb47c1364fb2fe1464a54417684f011e">Point3d</a> &amp;p5, const <a class="el" href="group__space.html#gabb47c1364fb2fe1464a54417684f011e">Point3d</a> &amp;p6, const <a class="el" href="group__space.html#gabb47c1364fb2fe1464a54417684f011e">Point3d</a> &amp;p7, const <a class="el" href="classvcl_1_1Color.html">Color</a> &amp;c, int width=3)</td></tr>
<tr class="separator:a750ed5084363ad069179728eda8d02e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5ec2b87d6e4cd7c08e8cd230d1e19c6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ab5ec2b87d6e4cd7c08e8cd230d1e19c6">drawBox3</a> (const std::vector&lt; <a class="el" href="group__space.html#gabb47c1364fb2fe1464a54417684f011e">Point3d</a> &gt; &amp;p, const <a class="el" href="classvcl_1_1Color.html">Color</a> &amp;c, int width=3)</td></tr>
<tr class="memdesc:ab5ec2b87d6e4cd7c08e8cd230d1e19c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draws the box composed by the first 8 point contained on the vector passed as parameter.  <br /></td></tr>
<tr class="separator:ab5ec2b87d6e4cd7c08e8cd230d1e19c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a338dea159760ae814dc6e78425e284a1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a338dea159760ae814dc6e78425e284a1">_check_gl_error</a> (const char *file, int line)</td></tr>
<tr class="separator:a338dea159760ae814dc6e78425e284a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4af4652c16670bfb54752b13ef259554"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType, typename VCGMeshType &gt; </td></tr>
<tr class="memitem:a4af4652c16670bfb54752b13ef259554"><td class="memTemplItemLeft" align="right" valign="top">MeshType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a4af4652c16670bfb54752b13ef259554">meshFromVCGMesh</a> (const VCGMeshType &amp;vcgMesh)</td></tr>
<tr class="separator:a4af4652c16670bfb54752b13ef259554"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fbae29299b52ac6270efba384a7ee62"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType, typename VCGMeshType &gt; </td></tr>
<tr class="memitem:a9fbae29299b52ac6270efba384a7ee62"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a9fbae29299b52ac6270efba384a7ee62">importMeshFromVCGMesh</a> (MeshType &amp;mesh, const VCGMeshType &amp;vcgMesh)</td></tr>
<tr class="separator:a9fbae29299b52ac6270efba384a7ee62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae667a7fe4648184f2116cb4d9d19baea"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType, LoggerConcept LogType = NullLogger&gt; </td></tr>
<tr class="memitem:gae667a7fe4648184f2116cb4d9d19baea"><td class="memTemplItemLeft" align="right" valign="top">MeshType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__load.html#gae667a7fe4648184f2116cb4d9d19baea">load</a> (const std::string &amp;filename, LogType &amp;log=<a class="el" href="group__miscellaneous.html#ga3377e3c875ec245e90ac5a395105ce99">nullLogger</a>, bool enableOptionalComponents=true)</td></tr>
<tr class="memdesc:gae667a7fe4648184f2116cb4d9d19baea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads a mesh from a file with the given filename and stores it in the returned mesh object. Checks automatically the file format to load from the fiven filename.  <br /></td></tr>
<tr class="separator:gae667a7fe4648184f2116cb4d9d19baea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa9dbf82ebd6edc28b8a305388bc1a02"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType, LoggerConcept LogType = NullLogger&gt; </td></tr>
<tr class="memitem:gaaa9dbf82ebd6edc28b8a305388bc1a02"><td class="memTemplItemLeft" align="right" valign="top">MeshType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__load.html#gaaa9dbf82ebd6edc28b8a305388bc1a02">load</a> (const std::string &amp;filename, <a class="el" href="classvcl_1_1MeshInfo.html">MeshInfo</a> &amp;loadedInfo, LogType &amp;log=<a class="el" href="group__miscellaneous.html#ga3377e3c875ec245e90ac5a395105ce99">nullLogger</a>, bool enableOptionalComponents=true)</td></tr>
<tr class="memdesc:gaaa9dbf82ebd6edc28b8a305388bc1a02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads a mesh from a file with the given filename and stores it in the returned mesh object. Checks automatically the file format to load from the fiven filename.  <br /></td></tr>
<tr class="separator:gaaa9dbf82ebd6edc28b8a305388bc1a02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0fbd0510933b9c63dd6c46eaffc0fa08"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType, LoggerConcept LogType = NullLogger&gt; </td></tr>
<tr class="memitem:ga0fbd0510933b9c63dd6c46eaffc0fa08"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__load.html#ga0fbd0510933b9c63dd6c46eaffc0fa08">load</a> (MeshType &amp;m, const std::string &amp;filename, LogType &amp;log=<a class="el" href="group__miscellaneous.html#ga3377e3c875ec245e90ac5a395105ce99">nullLogger</a>, bool enableOptionalComponents=true)</td></tr>
<tr class="memdesc:ga0fbd0510933b9c63dd6c46eaffc0fa08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads a mesh from a file with the given filename and stores it in the given mesh object. Checks automatically the file format to load from the fiven filename.  <br /></td></tr>
<tr class="separator:ga0fbd0510933b9c63dd6c46eaffc0fa08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e824e0d155f12565bebe38c6ec42dba"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType, LoggerConcept LogType = NullLogger&gt; </td></tr>
<tr class="memitem:ga6e824e0d155f12565bebe38c6ec42dba"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__load.html#ga6e824e0d155f12565bebe38c6ec42dba">load</a> (MeshType &amp;m, const std::string &amp;filename, <a class="el" href="classvcl_1_1MeshInfo.html">MeshInfo</a> &amp;loadedInfo, LogType &amp;log=<a class="el" href="group__miscellaneous.html#ga3377e3c875ec245e90ac5a395105ce99">nullLogger</a>, bool enableOptionalComponents=true)</td></tr>
<tr class="memdesc:ga6e824e0d155f12565bebe38c6ec42dba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads a mesh from a file with the given filename and stores it in the given mesh object. Checks automatically the file format to load from the fiven filename.  <br /></td></tr>
<tr class="separator:ga6e824e0d155f12565bebe38c6ec42dba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae45340d675bbb087090142215fd76da4"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType, LoggerConcept LogType = NullLogger&gt; </td></tr>
<tr class="memitem:ae45340d675bbb087090142215fd76da4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ae45340d675bbb087090142215fd76da4">save</a> (const MeshType &amp;m, const std::string &amp;filename, LogType &amp;log=<a class="el" href="group__miscellaneous.html#ga3377e3c875ec245e90ac5a395105ce99">nullLogger</a>, bool binary=true)</td></tr>
<tr class="separator:ae45340d675bbb087090142215fd76da4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8f881fa3253b964c05b23dae03a2462"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ab8f881fa3253b964c05b23dae03a2462"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ab8f881fa3253b964c05b23dae03a2462">save</a> (const MeshType &amp;m, const std::string &amp;filename, bool binary)</td></tr>
<tr class="separator:ab8f881fa3253b964c05b23dae03a2462"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf8b67aa014b0f1d2b3b127da5daec21"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType, LoggerConcept LogType = NullLogger&gt; </td></tr>
<tr class="memitem:adf8b67aa014b0f1d2b3b127da5daec21"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#adf8b67aa014b0f1d2b3b127da5daec21">save</a> (const MeshType &amp;m, const std::string &amp;filename, const <a class="el" href="classvcl_1_1MeshInfo.html">MeshInfo</a> &amp;info, LogType &amp;log=<a class="el" href="group__miscellaneous.html#ga3377e3c875ec245e90ac5a395105ce99">nullLogger</a>, bool binary=true)</td></tr>
<tr class="separator:adf8b67aa014b0f1d2b3b127da5daec21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33948b0cb8e44bec17d4b0dfef8bd254"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:a33948b0cb8e44bec17d4b0dfef8bd254"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a33948b0cb8e44bec17d4b0dfef8bd254">isDegenerate</a> (Scalar t)</td></tr>
<tr class="separator:a33948b0cb8e44bec17d4b0dfef8bd254"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f449c33787533e7b85070de82f5d78d"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:a5f449c33787533e7b85070de82f5d78d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a5f449c33787533e7b85070de82f5d78d">epsilonCompare</a> (Scalar p1, Scalar p2, Scalar epsilon=std::numeric_limits&lt; Scalar &gt;::epsilon())</td></tr>
<tr class="separator:a5f449c33787533e7b85070de82f5d78d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53f705e848cce98dd23542a2d109e55b"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:a53f705e848cce98dd23542a2d109e55b"><td class="memTemplItemLeft" align="right" valign="top">Scalar&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a53f705e848cce98dd23542a2d109e55b">toRad</a> (const Scalar &amp;a)</td></tr>
<tr class="separator:a53f705e848cce98dd23542a2d109e55b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1578b48cbfdb04c6675ac5a3b535bb83"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:a1578b48cbfdb04c6675ac5a3b535bb83"><td class="memTemplItemLeft" align="right" valign="top">Scalar&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a1578b48cbfdb04c6675ac5a3b535bb83">toDeg</a> (const Scalar &amp;a)</td></tr>
<tr class="separator:a1578b48cbfdb04c6675ac5a3b535bb83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6613e39304926dee856b8b9770b3be5"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#aa6613e39304926dee856b8b9770b3be5">lnOfFactorial</a> (int n)</td></tr>
<tr class="memdesc:aa6613e39304926dee856b8b9770b3be5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes and caches the result of the natural logarithm of n!  <br /></td></tr>
<tr class="separator:aa6613e39304926dee856b8b9770b3be5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a438da980623645640c78105766bde287"><td class="memTemplParams" colspan="2">template&lt;Point3Concept PointType&gt; </td></tr>
<tr class="memitem:a438da980623645640c78105766bde287"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; PointType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a438da980623645640c78105766bde287">sphericalFibonacciPointSet</a> (<a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> n)</td></tr>
<tr class="memdesc:a438da980623645640c78105766bde287"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector of <code>n</code> points distributed in a unit sphere.  <br /></td></tr>
<tr class="separator:a438da980623645640c78105766bde287"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3edcb561672a6be17e9453bd1ea446d5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3edcb561672a6be17e9453bd1ea446d5"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a3edcb561672a6be17e9453bd1ea446d5">min</a> (const T &amp;el1, const T &amp;el2)</td></tr>
<tr class="separator:a3edcb561672a6be17e9453bd1ea446d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c1835cef3addd7dbae2b21a43523f3a"><td class="memTemplParams" colspan="2">template&lt;typename Head , typename... Tail&gt; <br />
requires (sizeof...(tail) &gt; 0)</td></tr>
<tr class="memitem:a9c1835cef3addd7dbae2b21a43523f3a"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a9c1835cef3addd7dbae2b21a43523f3a">min</a> (const Head &amp;head0, const Head &amp;head1, const Tail &amp;... tail)</td></tr>
<tr class="separator:a9c1835cef3addd7dbae2b21a43523f3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69cc63a5ad2974d082145ed1dee7846b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a69cc63a5ad2974d082145ed1dee7846b"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a69cc63a5ad2974d082145ed1dee7846b">max</a> (const T &amp;el1, const T &amp;el2)</td></tr>
<tr class="separator:a69cc63a5ad2974d082145ed1dee7846b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a212fbf643d263ad106507f7aa462cf46"><td class="memTemplParams" colspan="2">template&lt;typename Head , typename... Tail&gt; <br />
requires (sizeof...(tail) &gt; 0)</td></tr>
<tr class="memitem:a212fbf643d263ad106507f7aa462cf46"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a212fbf643d263ad106507f7aa462cf46">max</a> (const Head &amp;head0, const Head &amp;head1, const Tail &amp;... tail)</td></tr>
<tr class="separator:a212fbf643d263ad106507f7aa462cf46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac11460526cb6d79733a8dfe0e15614f4"><td class="memTemplParams" colspan="2">template&lt;PointConcept PointType&gt; </td></tr>
<tr class="memitem:ac11460526cb6d79733a8dfe0e15614f4"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ac11460526cb6d79733a8dfe0e15614f4">min</a> (const PointType &amp;p1, const PointType &amp;p2)</td></tr>
<tr class="separator:ac11460526cb6d79733a8dfe0e15614f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49a9bdba85989ec5842081c5c84d4fc7"><td class="memTemplParams" colspan="2">template&lt;PointConcept PointType&gt; </td></tr>
<tr class="memitem:a49a9bdba85989ec5842081c5c84d4fc7"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a49a9bdba85989ec5842081c5c84d4fc7">max</a> (const PointType &amp;p1, const PointType &amp;p2)</td></tr>
<tr class="separator:a49a9bdba85989ec5842081c5c84d4fc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc2f93864498c3b143e13c1b0009bdc4"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#afc2f93864498c3b143e13c1b0009bdc4">perlinNoise</a> (double x, double y, double z)</td></tr>
<tr class="memdesc:afc2f93864498c3b143e13c1b0009bdc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">3D Perlin noise, returns a value in the [-1,1] range with period 255  <br /></td></tr>
<tr class="separator:afc2f93864498c3b143e13c1b0009bdc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cc1884dbb897a34716178c7b06e7bb2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a2cc1884dbb897a34716178c7b06e7bb2">poissonRatioOfUniformsInteger</a> (double L, std::mt19937 &amp;gen)</td></tr>
<tr class="memdesc:a2cc1884dbb897a34716178c7b06e7bb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This subfunction generates a integer with the poisson distribution using the ratio-of-uniforms rejection method (PRUAt). This approach is STABLE even for large L (e.g. it does not suffer from the overflow limit of the classical Knuth implementation) Execution time does not depend on L, except that it matters whether is within the range where ln(n!) is tabulated.  <br /></td></tr>
<tr class="separator:a2cc1884dbb897a34716178c7b06e7bb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef13acb79205bb8fe990f66e1fa203f3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#aef13acb79205bb8fe990f66e1fa203f3">poissonRatioOfUniformsInteger</a> (double L)</td></tr>
<tr class="separator:aef13acb79205bb8fe990f66e1fa203f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a212c052ae1efd3426a5ea49051f8011c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a212c052ae1efd3426a5ea49051f8011c">poissonRandomNumber</a> (double lambda, std::mt19937 &amp;gen)</td></tr>
<tr class="memdesc:a212c052ae1efd3426a5ea49051f8011c"><td class="mdescLeft">&#160;</td><td class="mdescRight">algorithm poisson random number (Knuth): init: Let L  e^, k  0 and p  1. do: k  k + 1. Generate uniform random number u in [0,1] and let p  p  u. while p &gt; L. return k  1.  <br /></td></tr>
<tr class="separator:a212c052ae1efd3426a5ea49051f8011c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee130ece16518760ce1f2c1a9da3a6e1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#aee130ece16518760ce1f2c1a9da3a6e1">poissonRandomNumber</a> (double lambda)</td></tr>
<tr class="separator:aee130ece16518760ce1f2c1a9da3a6e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06f5b66d996c91397fab66781fc73402"><td class="memTemplParams" colspan="2">template&lt;typename ScalarType &gt; </td></tr>
<tr class="memitem:a06f5b66d996c91397fab66781fc73402"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__space.html#ga13f2718b0763def563b8bd9f65982833">vcl::Point3</a>&lt; ScalarType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a06f5b66d996c91397fab66781fc73402">randomTriangleBarycentricCoordinate</a> (std::mt19937 &amp;gen)</td></tr>
<tr class="memdesc:a06f5b66d996c91397fab66781fc73402"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate the barycentric coords of a random point over a triangle, with a uniform distribution over the triangle. It uses the parallelogram folding trick.  <br /></td></tr>
<tr class="separator:a06f5b66d996c91397fab66781fc73402"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7b855bdab068b3fee59bc40914436e2"><td class="memTemplParams" colspan="2">template&lt;typename ScalarType &gt; </td></tr>
<tr class="memitem:ad7b855bdab068b3fee59bc40914436e2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__space.html#ga13f2718b0763def563b8bd9f65982833">vcl::Point3</a>&lt; ScalarType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ad7b855bdab068b3fee59bc40914436e2">randomTriangleBarycentricCoordinate</a> ()</td></tr>
<tr class="separator:ad7b855bdab068b3fee59bc40914436e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c7c00f108bb07302bfb7643c66f3ef4"><td class="memTemplParams" colspan="2">template&lt;typename ScalarType &gt; </td></tr>
<tr class="memitem:a7c7c00f108bb07302bfb7643c66f3ef4"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; ScalarType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a7c7c00f108bb07302bfb7643c66f3ef4">randomPolygonBarycentricCoordinate</a> (<a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> polySize, std::mt19937 &amp;gen)</td></tr>
<tr class="separator:a7c7c00f108bb07302bfb7643c66f3ef4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d0305c02567d29d5bc48a0cdbaacda3"><td class="memTemplParams" colspan="2">template&lt;typename ScalarType &gt; </td></tr>
<tr class="memitem:a3d0305c02567d29d5bc48a0cdbaacda3"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; ScalarType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a3d0305c02567d29d5bc48a0cdbaacda3">randomPolygonBarycentricCoordinate</a> (<a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> polySize)</td></tr>
<tr class="separator:a3d0305c02567d29d5bc48a0cdbaacda3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24901186f1a77f31a23d64f30f0b0dc3"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType , PointConcept PointType, typename ScalarType &gt; </td></tr>
<tr class="memitem:a24901186f1a77f31a23d64f30f0b0dc3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a24901186f1a77f31a23d64f30f0b0dc3">setTransformMatrixRotation</a> (MatrixType &amp;matrix, PointType axis, const ScalarType &amp;angleRad)</td></tr>
<tr class="memdesc:a24901186f1a77f31a23d64f30f0b0dc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an 3D axis and an angle expressed in randiants, fills the given matrix with a transform matrix that represents the rotation matrix of the given axis/angle.  <br /></td></tr>
<tr class="separator:a24901186f1a77f31a23d64f30f0b0dc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd5d95d87600e42a0da835735e35ea99"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType , PointConcept PointType, typename ScalarType &gt; </td></tr>
<tr class="memitem:abd5d95d87600e42a0da835735e35ea99"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#abd5d95d87600e42a0da835735e35ea99">setTransformMatrixRotationDeg</a> (MatrixType &amp;matrix, PointType axis, const ScalarType &amp;angleDeg)</td></tr>
<tr class="memdesc:abd5d95d87600e42a0da835735e35ea99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an 3D axis and an angle expressed in degrees, fills the given matrix with a transform matrix that represents the rotation matrix of the given axis/angle.  <br /></td></tr>
<tr class="separator:abd5d95d87600e42a0da835735e35ea99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbb9f1401057fda582e6b0cda2a36b18"><td class="memTemplParams" colspan="2">template&lt;typename ScalarType , PointConcept PointType&gt; </td></tr>
<tr class="memitem:adbb9f1401057fda582e6b0cda2a36b18"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#adbb9f1401057fda582e6b0cda2a36b18">setTrasformMatrixTranslation</a> (<a class="el" href="namespacevcl.html#ad82a126b390f21b2e9658c73e7a795ee">Matrix44</a>&lt; ScalarType &gt; &amp;matrix, const PointType &amp;translation)</td></tr>
<tr class="separator:adbb9f1401057fda582e6b0cda2a36b18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5a78d0411b7f20298f45618c3e2aff5"><td class="memTemplParams" colspan="2">template&lt;typename ScalarType , PointConcept PointType&gt; </td></tr>
<tr class="memitem:af5a78d0411b7f20298f45618c3e2aff5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#af5a78d0411b7f20298f45618c3e2aff5">setTrasformMatrixScale</a> (<a class="el" href="namespacevcl.html#ad82a126b390f21b2e9658c73e7a795ee">Matrix44</a>&lt; ScalarType &gt; &amp;matrix, const PointType &amp;<a class="el" href="namespacevcl.html#a5217f309d49911db6e36a4f6d31acdaa">scale</a>)</td></tr>
<tr class="separator:af5a78d0411b7f20298f45618c3e2aff5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefa0051d67bdf4a551140929a2cc0b2f"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType , PointConcept PointType, typename ScalarType &gt; </td></tr>
<tr class="memitem:aefa0051d67bdf4a551140929a2cc0b2f"><td class="memTemplItemLeft" align="right" valign="top">MatrixType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#aefa0051d67bdf4a551140929a2cc0b2f">rotationMatrix</a> (const PointType &amp;axis, const ScalarType &amp;angleRad)</td></tr>
<tr class="memdesc:aefa0051d67bdf4a551140929a2cc0b2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an 3D axis and an angle expressed in randiants, returns a transform matrix that represents the rotation matrix of the given axis/angle.  <br /></td></tr>
<tr class="separator:aefa0051d67bdf4a551140929a2cc0b2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f6b127154a5e14946cb66492d214de8"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType , PointConcept PointType, typename ScalarType &gt; </td></tr>
<tr class="memitem:a7f6b127154a5e14946cb66492d214de8"><td class="memTemplItemLeft" align="right" valign="top">MatrixType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a7f6b127154a5e14946cb66492d214de8">rotationMatrixDeg</a> (const PointType &amp;axis, const ScalarType &amp;angleDeg)</td></tr>
<tr class="memdesc:a7f6b127154a5e14946cb66492d214de8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an 3D axis and an angle expressed in degrees, fills the given matrix with a transform matrix that represents the rotation matrix of the given axis/angle.  <br /></td></tr>
<tr class="separator:a7f6b127154a5e14946cb66492d214de8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83e4e98dc107ee9f2b22550bcbb25ea7"><td class="memTemplParams" colspan="2">template&lt;EdgeMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga83e4e98dc107ee9f2b22550bcbb25ea7"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__edge__requirements.html#ga83e4e98dc107ee9f2b22550bcbb25ea7">isEdgeContainerCompact</a> (const MeshType &amp;m)</td></tr>
<tr class="memdesc:ga83e4e98dc107ee9f2b22550bcbb25ea7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if the given mesh has its EdgeContainer compact.  <br /></td></tr>
<tr class="separator:ga83e4e98dc107ee9f2b22550bcbb25ea7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c3b76563f3710059dd10a87a98967cb"><td class="memTemplParams" colspan="2">template&lt;EdgeMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga5c3b76563f3710059dd10a87a98967cb"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__edge__requirements.html#ga5c3b76563f3710059dd10a87a98967cb">isPerEdgeAdjacentEdgesAvailable</a> (const MeshType &amp;m)</td></tr>
<tr class="memdesc:ga5c3b76563f3710059dd10a87a98967cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the AdjacentEdges component is available (enabled) in the <a class="el" href="classvcl_1_1Edge.html" title="The Edge class represents an Edge element of the vcl::Mesh class.">Edge</a> element of the input mesh m.  <br /></td></tr>
<tr class="separator:ga5c3b76563f3710059dd10a87a98967cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga55a6207dd62fdf1e146a42119f65ee7d"><td class="memTemplParams" colspan="2">template&lt;EdgeMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga55a6207dd62fdf1e146a42119f65ee7d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__edge__requirements.html#ga55a6207dd62fdf1e146a42119f65ee7d">enableIfPerEdgeAdjacentEdgesOptional</a> (MeshType &amp;m)</td></tr>
<tr class="memdesc:ga55a6207dd62fdf1e146a42119f65ee7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the input mesh has a EdgeContainer, and the <a class="el" href="classvcl_1_1Edge.html" title="The Edge class represents an Edge element of the vcl::Mesh class.">Edge</a> <a class="el" href="classvcl_1_1Element.html" title="The Element class.">Element</a> has a AdjacentEdges Component, this function enables the Component in the <a class="el" href="classvcl_1_1Element.html" title="The Element class.">Element</a> if the component needs to be enabled (meaning that it is optional). Returns <code>true</code> if, after the call of this function, the AdjacentEdges component will be available in the <a class="el" href="classvcl_1_1Edge.html" title="The Edge class represents an Edge element of the vcl::Mesh class.">Edge</a> <a class="el" href="classvcl_1_1Element.html" title="The Element class.">Element</a> of the mesh.  <br /></td></tr>
<tr class="separator:ga55a6207dd62fdf1e146a42119f65ee7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6cde5476921f6aa1530542e40c3626d6"><td class="memTemplParams" colspan="2">template&lt;EdgeMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga6cde5476921f6aa1530542e40c3626d6"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__edge__requirements.html#ga6cde5476921f6aa1530542e40c3626d6">isPerEdgeAdjacentFacesAvailable</a> (const MeshType &amp;m)</td></tr>
<tr class="memdesc:ga6cde5476921f6aa1530542e40c3626d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the AdjacentFaces component is available (enabled) in the <a class="el" href="classvcl_1_1Edge.html" title="The Edge class represents an Edge element of the vcl::Mesh class.">Edge</a> element of the input mesh m.  <br /></td></tr>
<tr class="separator:ga6cde5476921f6aa1530542e40c3626d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab587d17dd049174b67e95fd1bdce9fc5"><td class="memTemplParams" colspan="2">template&lt;EdgeMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:gab587d17dd049174b67e95fd1bdce9fc5"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__edge__requirements.html#gab587d17dd049174b67e95fd1bdce9fc5">enableIfPerEdgeAdjacentFacesOptional</a> (MeshType &amp;m)</td></tr>
<tr class="memdesc:gab587d17dd049174b67e95fd1bdce9fc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the input mesh has a EdgeContainer, and the <a class="el" href="classvcl_1_1Edge.html" title="The Edge class represents an Edge element of the vcl::Mesh class.">Edge</a> <a class="el" href="classvcl_1_1Element.html" title="The Element class.">Element</a> has a AdjacentFaces Component, this function enables the Component in the <a class="el" href="classvcl_1_1Element.html" title="The Element class.">Element</a> if the component needs to be enabled (meaning that it is optional). Returns <code>true</code> if, after the call of this function, the AdjacentFaces component will be available in the <a class="el" href="classvcl_1_1Edge.html" title="The Edge class represents an Edge element of the vcl::Mesh class.">Edge</a> <a class="el" href="classvcl_1_1Element.html" title="The Element class.">Element</a> of the mesh.  <br /></td></tr>
<tr class="separator:gab587d17dd049174b67e95fd1bdce9fc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24af8033d5db434a5935b5646ee829be"><td class="memTemplParams" colspan="2">template&lt;EdgeMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga24af8033d5db434a5935b5646ee829be"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__edge__requirements.html#ga24af8033d5db434a5935b5646ee829be">isPerEdgeColorAvailable</a> (const MeshType &amp;m)</td></tr>
<tr class="memdesc:ga24af8033d5db434a5935b5646ee829be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the <a class="el" href="classvcl_1_1Color.html" title="The Color class represents a RGBA color.">Color</a> component is available (enabled) in the <a class="el" href="classvcl_1_1Edge.html" title="The Edge class represents an Edge element of the vcl::Mesh class.">Edge</a> element of the input mesh m.  <br /></td></tr>
<tr class="separator:ga24af8033d5db434a5935b5646ee829be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b5846c10685de9e77115bcc0695dee4"><td class="memTemplParams" colspan="2">template&lt;EdgeMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga7b5846c10685de9e77115bcc0695dee4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__edge__requirements.html#ga7b5846c10685de9e77115bcc0695dee4">enableIfPerEdgeColorOptional</a> (MeshType &amp;m)</td></tr>
<tr class="memdesc:ga7b5846c10685de9e77115bcc0695dee4"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the input mesh has a EdgeContainer, and the <a class="el" href="classvcl_1_1Edge.html" title="The Edge class represents an Edge element of the vcl::Mesh class.">Edge</a> <a class="el" href="classvcl_1_1Element.html" title="The Element class.">Element</a> has a <a class="el" href="classvcl_1_1Color.html" title="The Color class represents a RGBA color.">Color</a> Component, this function enables the Component in the <a class="el" href="classvcl_1_1Element.html" title="The Element class.">Element</a> if the component needs to be enabled (meaning that it is optional). Returns <code>true</code> if, after the call of this function, the <a class="el" href="classvcl_1_1Color.html" title="The Color class represents a RGBA color.">Color</a> component will be available in the <a class="el" href="classvcl_1_1Edge.html" title="The Edge class represents an Edge element of the vcl::Mesh class.">Edge</a> <a class="el" href="classvcl_1_1Element.html" title="The Element class.">Element</a> of the mesh.  <br /></td></tr>
<tr class="separator:ga7b5846c10685de9e77115bcc0695dee4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6844bace61ed05e1603075ca9b98b3ae"><td class="memTemplParams" colspan="2">template&lt;EdgeMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga6844bace61ed05e1603075ca9b98b3ae"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__edge__requirements.html#ga6844bace61ed05e1603075ca9b98b3ae">isPerEdgeMarkAvailable</a> (const MeshType &amp;m)</td></tr>
<tr class="memdesc:ga6844bace61ed05e1603075ca9b98b3ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the Mark component is available (enabled) in the <a class="el" href="classvcl_1_1Edge.html" title="The Edge class represents an Edge element of the vcl::Mesh class.">Edge</a> element of the input mesh m.  <br /></td></tr>
<tr class="separator:ga6844bace61ed05e1603075ca9b98b3ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga06074783595077e51f9d4baf34b96e58"><td class="memTemplParams" colspan="2">template&lt;EdgeMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga06074783595077e51f9d4baf34b96e58"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__edge__requirements.html#ga06074783595077e51f9d4baf34b96e58">enableIfPerEdgeMarkOptional</a> (MeshType &amp;m)</td></tr>
<tr class="memdesc:ga06074783595077e51f9d4baf34b96e58"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the input mesh has a EdgeContainer, and the <a class="el" href="classvcl_1_1Edge.html" title="The Edge class represents an Edge element of the vcl::Mesh class.">Edge</a> <a class="el" href="classvcl_1_1Element.html" title="The Element class.">Element</a> has a Mark Component, this function enables the Component in the <a class="el" href="classvcl_1_1Element.html" title="The Element class.">Element</a> if the component needs to be enabled (meaning that it is optional). Returns <code>true</code> if, after the call of this function, the Mark component will be available in the <a class="el" href="classvcl_1_1Edge.html" title="The Edge class represents an Edge element of the vcl::Mesh class.">Edge</a> <a class="el" href="classvcl_1_1Element.html" title="The Element class.">Element</a> of the mesh.  <br /></td></tr>
<tr class="separator:ga06074783595077e51f9d4baf34b96e58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa6c60f70395d97b9c9b4ecae76f5c947"><td class="memTemplParams" colspan="2">template&lt;EdgeMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:gaa6c60f70395d97b9c9b4ecae76f5c947"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__edge__requirements.html#gaa6c60f70395d97b9c9b4ecae76f5c947">isPerEdgeQualityAvailable</a> (const MeshType &amp;m)</td></tr>
<tr class="memdesc:gaa6c60f70395d97b9c9b4ecae76f5c947"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the Quality component is available (enabled) in the <a class="el" href="classvcl_1_1Edge.html" title="The Edge class represents an Edge element of the vcl::Mesh class.">Edge</a> element of the input mesh m.  <br /></td></tr>
<tr class="separator:gaa6c60f70395d97b9c9b4ecae76f5c947"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae7a4783178e3aa1db82a5965e9186581"><td class="memTemplParams" colspan="2">template&lt;EdgeMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:gae7a4783178e3aa1db82a5965e9186581"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__edge__requirements.html#gae7a4783178e3aa1db82a5965e9186581">enableIfPerEdgeQualityOptional</a> (MeshType &amp;m)</td></tr>
<tr class="memdesc:gae7a4783178e3aa1db82a5965e9186581"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the input mesh has a EdgeContainer, and the <a class="el" href="classvcl_1_1Edge.html" title="The Edge class represents an Edge element of the vcl::Mesh class.">Edge</a> <a class="el" href="classvcl_1_1Element.html" title="The Element class.">Element</a> has a Quality Component, this function enables the Component in the <a class="el" href="classvcl_1_1Element.html" title="The Element class.">Element</a> if the component needs to be enabled (meaning that it is optional). Returns <code>true</code> if, after the call of this function, the Quality component will be available in the <a class="el" href="classvcl_1_1Edge.html" title="The Edge class represents an Edge element of the vcl::Mesh class.">Edge</a> <a class="el" href="classvcl_1_1Element.html" title="The Element class.">Element</a> of the mesh.  <br /></td></tr>
<tr class="separator:gae7a4783178e3aa1db82a5965e9186581"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d66bb2b817db1d107bb1c2dcfb0679e"><td class="memTemplParams" colspan="2">template&lt;EdgeMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga4d66bb2b817db1d107bb1c2dcfb0679e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__edge__requirements.html#ga4d66bb2b817db1d107bb1c2dcfb0679e">requireEdgeContainerCompactness</a> (const MeshType &amp;m)</td></tr>
<tr class="memdesc:ga4d66bb2b817db1d107bb1c2dcfb0679e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function asserts that a <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a> has the EdgeContainer compact (no elements flagged as deleted).  <br /></td></tr>
<tr class="separator:ga4d66bb2b817db1d107bb1c2dcfb0679e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed78bac32311fa312f1eb9bcb2aab5eb"><td class="memTemplParams" colspan="2">template&lt;EdgeMeshConcept MeshType&gt; <br />
requires HasPerEdgeAdjacentEdges&lt;MeshType&gt;</td></tr>
<tr class="memitem:gaed78bac32311fa312f1eb9bcb2aab5eb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__edge__requirements.html#gaed78bac32311fa312f1eb9bcb2aab5eb">requirePerEdgeAdjacentEdges</a> (const MeshType &amp;m)</td></tr>
<tr class="memdesc:gaed78bac32311fa312f1eb9bcb2aab5eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function asserts that a <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a> has a EdgeContainer, the <a class="el" href="classvcl_1_1Edge.html" title="The Edge class represents an Edge element of the vcl::Mesh class.">Edge</a> has a AdjacentEdges Component, and that the AdjacentEdges Component is enabled and available at runtime.  <br /></td></tr>
<tr class="separator:gaed78bac32311fa312f1eb9bcb2aab5eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga82b37755a2e68c0b04c81a79fa82ad46"><td class="memTemplParams" colspan="2">template&lt;EdgeMeshConcept MeshType&gt; <br />
requires HasPerEdgeAdjacentFaces&lt;MeshType&gt;</td></tr>
<tr class="memitem:ga82b37755a2e68c0b04c81a79fa82ad46"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__edge__requirements.html#ga82b37755a2e68c0b04c81a79fa82ad46">requirePerEdgeAdjacentFaces</a> (const MeshType &amp;m)</td></tr>
<tr class="memdesc:ga82b37755a2e68c0b04c81a79fa82ad46"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function asserts that a <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a> has a EdgeContainer, the <a class="el" href="classvcl_1_1Edge.html" title="The Edge class represents an Edge element of the vcl::Mesh class.">Edge</a> has a AdjacentFaces Component, and that the AdjacentFaces Component is enabled and available at runtime.  <br /></td></tr>
<tr class="separator:ga82b37755a2e68c0b04c81a79fa82ad46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad1cac17f541eeabac2a6d8396a818f53"><td class="memTemplParams" colspan="2">template&lt;EdgeMeshConcept MeshType&gt; <br />
requires HasPerEdgeColor&lt;MeshType&gt;</td></tr>
<tr class="memitem:gad1cac17f541eeabac2a6d8396a818f53"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__edge__requirements.html#gad1cac17f541eeabac2a6d8396a818f53">requirePerEdgeColor</a> (const MeshType &amp;m)</td></tr>
<tr class="memdesc:gad1cac17f541eeabac2a6d8396a818f53"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function asserts that a <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a> has a EdgeContainer, the <a class="el" href="classvcl_1_1Edge.html" title="The Edge class represents an Edge element of the vcl::Mesh class.">Edge</a> has a <a class="el" href="classvcl_1_1Color.html" title="The Color class represents a RGBA color.">Color</a> Component, and that the <a class="el" href="classvcl_1_1Color.html" title="The Color class represents a RGBA color.">Color</a> Component is enabled and available at runtime.  <br /></td></tr>
<tr class="separator:gad1cac17f541eeabac2a6d8396a818f53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4033fc59330b356991232c063afb6bc1"><td class="memTemplParams" colspan="2">template&lt;EdgeMeshConcept MeshType&gt; <br />
requires HasPerEdgeMark&lt;MeshType&gt;</td></tr>
<tr class="memitem:ga4033fc59330b356991232c063afb6bc1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__edge__requirements.html#ga4033fc59330b356991232c063afb6bc1">requirePerEdgeMark</a> (const MeshType &amp;m)</td></tr>
<tr class="memdesc:ga4033fc59330b356991232c063afb6bc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function asserts that a <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a> has a EdgeContainer, the <a class="el" href="classvcl_1_1Edge.html" title="The Edge class represents an Edge element of the vcl::Mesh class.">Edge</a> has a Mark Component, and that the Mark Component is enabled and available at runtime.  <br /></td></tr>
<tr class="separator:ga4033fc59330b356991232c063afb6bc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae9df0edfc2990c2971514d87e866c31e"><td class="memTemplParams" colspan="2">template&lt;EdgeMeshConcept MeshType&gt; <br />
requires HasPerEdgeQuality&lt;MeshType&gt;</td></tr>
<tr class="memitem:gae9df0edfc2990c2971514d87e866c31e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__edge__requirements.html#gae9df0edfc2990c2971514d87e866c31e">requirePerEdgeQuality</a> (const MeshType &amp;m)</td></tr>
<tr class="memdesc:gae9df0edfc2990c2971514d87e866c31e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function asserts that a <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a> has a EdgeContainer, the <a class="el" href="classvcl_1_1Edge.html" title="The Edge class represents an Edge element of the vcl::Mesh class.">Edge</a> has a Quality Component, and that the Quality Component is enabled and available at runtime.  <br /></td></tr>
<tr class="separator:gae9df0edfc2990c2971514d87e866c31e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f4ab723ca992b97ebeba82f85fac787"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> ELEM_ID, MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga3f4ab723ca992b97ebeba82f85fac787"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mesh__requirements.html#ga3f4ab723ca992b97ebeba82f85fac787">isElementContainerCompact</a> (const MeshType &amp;m)</td></tr>
<tr class="memdesc:ga3f4ab723ca992b97ebeba82f85fac787"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if the given mesh has its Container of the given <a class="el" href="classvcl_1_1Element.html" title="The Element class.">Element</a> compact.  <br /></td></tr>
<tr class="separator:ga3f4ab723ca992b97ebeba82f85fac787"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0cb1dd17c45e56caf4a313f557e677c3"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> ELEM_ID, <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> COMP_ID, MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga0cb1dd17c45e56caf4a313f557e677c3"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mesh__requirements.html#ga0cb1dd17c45e56caf4a313f557e677c3">isPerElementComponentAvailable</a> (const MeshType &amp;m)</td></tr>
<tr class="memdesc:ga0cb1dd17c45e56caf4a313f557e677c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the given component is available in the given element of the input mesh m.  <br /></td></tr>
<tr class="separator:ga0cb1dd17c45e56caf4a313f557e677c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6ccafe282dfd418a16426fb85c5c416"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> ELEM_ID, <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> COMP_ID, MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:gac6ccafe282dfd418a16426fb85c5c416"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mesh__requirements.html#gac6ccafe282dfd418a16426fb85c5c416">enableIfPerElementComponentOptional</a> (MeshType &amp;m)</td></tr>
<tr class="memdesc:gac6ccafe282dfd418a16426fb85c5c416"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes available the given Component in the given <a class="el" href="classvcl_1_1Element.html" title="The Element class.">Element</a> of the input mesh m, and returns <code>true</code> if it succeeds.  <br /></td></tr>
<tr class="separator:gac6ccafe282dfd418a16426fb85c5c416"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b9a2c1e26cd387e348ef4e137ec912c"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> ELEM_ID, MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga6b9a2c1e26cd387e348ef4e137ec912c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mesh__requirements.html#ga6b9a2c1e26cd387e348ef4e137ec912c">requireElementContainerCompactness</a> (const MeshType &amp;m)</td></tr>
<tr class="memdesc:ga6b9a2c1e26cd387e348ef4e137ec912c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function asserts that a <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a> has the Container of the given <a class="el" href="classvcl_1_1Element.html" title="The Element class.">Element</a> ID compact (no elements flagged as deleted).  <br /></td></tr>
<tr class="separator:ga6b9a2c1e26cd387e348ef4e137ec912c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga64d5aafc5d7a737a9654c763ee5a8132"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> ELEM_ID, <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> COMP_ID, MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga64d5aafc5d7a737a9654c763ee5a8132"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mesh__requirements.html#ga64d5aafc5d7a737a9654c763ee5a8132">requirePerElementComponent</a> (const MeshType &amp;m)</td></tr>
<tr class="memdesc:ga64d5aafc5d7a737a9654c763ee5a8132"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function asserts that a <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a> has the Container of the given <a class="el" href="classvcl_1_1Element.html" title="The Element class.">Element</a> ID, the <a class="el" href="classvcl_1_1Element.html" title="The Element class.">Element</a> has a Component of the given Component ID, and that Component is available at runtime.  <br /></td></tr>
<tr class="separator:ga64d5aafc5d7a737a9654c763ee5a8132"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca827384c3a3069cf55d77dc48e3f4fa"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:gaca827384c3a3069cf55d77dc48e3f4fa"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__face__requirements.html#gaca827384c3a3069cf55d77dc48e3f4fa">isFaceContainerCompact</a> (const MeshType &amp;m)</td></tr>
<tr class="memdesc:gaca827384c3a3069cf55d77dc48e3f4fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if the given mesh has its FaceContainer compact.  <br /></td></tr>
<tr class="separator:gaca827384c3a3069cf55d77dc48e3f4fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33f24a91d99671c5977a6cd3f90c2993"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga33f24a91d99671c5977a6cd3f90c2993"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__face__requirements.html#ga33f24a91d99671c5977a6cd3f90c2993">isPerFaceAdjacentEdgesAvailable</a> (const MeshType &amp;m)</td></tr>
<tr class="memdesc:ga33f24a91d99671c5977a6cd3f90c2993"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the AdjacentEdges component is available (enabled) in the <a class="el" href="classvcl_1_1Face.html" title="The Face class represents an Face element of the vcl::Mesh class.">Face</a> element of the input mesh m.  <br /></td></tr>
<tr class="separator:ga33f24a91d99671c5977a6cd3f90c2993"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab711bf0021a9256445957b3ccc2e0502"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:gab711bf0021a9256445957b3ccc2e0502"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__face__requirements.html#gab711bf0021a9256445957b3ccc2e0502">enableIfPerFaceAdjacentEdgesOptional</a> (MeshType &amp;m)</td></tr>
<tr class="memdesc:gab711bf0021a9256445957b3ccc2e0502"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the input mesh has a FaceContainer, and the <a class="el" href="classvcl_1_1Face.html" title="The Face class represents an Face element of the vcl::Mesh class.">Face</a> <a class="el" href="classvcl_1_1Element.html" title="The Element class.">Element</a> has a AdjacentEdges Component, this function enables the Component in the <a class="el" href="classvcl_1_1Element.html" title="The Element class.">Element</a> if the component needs to be enabled (meaning that it is optional). Returns <code>true</code> if, after the call of this function, the AdjacentEdges component will be available in the <a class="el" href="classvcl_1_1Face.html" title="The Face class represents an Face element of the vcl::Mesh class.">Face</a> <a class="el" href="classvcl_1_1Element.html" title="The Element class.">Element</a> of the mesh.  <br /></td></tr>
<tr class="separator:gab711bf0021a9256445957b3ccc2e0502"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a2e0c28c27a21d47d332154fbce554b"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga3a2e0c28c27a21d47d332154fbce554b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__face__requirements.html#ga3a2e0c28c27a21d47d332154fbce554b">isPerFaceAdjacentFacesAvailable</a> (const MeshType &amp;m)</td></tr>
<tr class="memdesc:ga3a2e0c28c27a21d47d332154fbce554b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the AdjacentFaces component is available (enabled) in the <a class="el" href="classvcl_1_1Face.html" title="The Face class represents an Face element of the vcl::Mesh class.">Face</a> element of the input mesh m.  <br /></td></tr>
<tr class="separator:ga3a2e0c28c27a21d47d332154fbce554b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb30f645e6cc1b2c1d8655f445bf1843"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:gacb30f645e6cc1b2c1d8655f445bf1843"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__face__requirements.html#gacb30f645e6cc1b2c1d8655f445bf1843">enableIfPerFaceAdjacentFacesOptional</a> (MeshType &amp;m)</td></tr>
<tr class="memdesc:gacb30f645e6cc1b2c1d8655f445bf1843"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the input mesh has a FaceContainer, and the <a class="el" href="classvcl_1_1Face.html" title="The Face class represents an Face element of the vcl::Mesh class.">Face</a> <a class="el" href="classvcl_1_1Element.html" title="The Element class.">Element</a> has a AdjacentFaces Component, this function enables the Component in the <a class="el" href="classvcl_1_1Element.html" title="The Element class.">Element</a> if the component needs to be enabled (meaning that it is optional). Returns <code>true</code> if, after the call of this function, the AdjacentFaces component will be available in the <a class="el" href="classvcl_1_1Face.html" title="The Face class represents an Face element of the vcl::Mesh class.">Face</a> <a class="el" href="classvcl_1_1Element.html" title="The Element class.">Element</a> of the mesh.  <br /></td></tr>
<tr class="separator:gacb30f645e6cc1b2c1d8655f445bf1843"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac0944e94fb8c662edf2cca5f55b721c7"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:gac0944e94fb8c662edf2cca5f55b721c7"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__face__requirements.html#gac0944e94fb8c662edf2cca5f55b721c7">isPerFaceColorAvailable</a> (const MeshType &amp;m)</td></tr>
<tr class="memdesc:gac0944e94fb8c662edf2cca5f55b721c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the <a class="el" href="classvcl_1_1Color.html" title="The Color class represents a RGBA color.">Color</a> component is available (enabled) in the <a class="el" href="classvcl_1_1Face.html" title="The Face class represents an Face element of the vcl::Mesh class.">Face</a> element of the input mesh m.  <br /></td></tr>
<tr class="separator:gac0944e94fb8c662edf2cca5f55b721c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf3262073d55561ee24b5cfcc22250ee1"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:gaf3262073d55561ee24b5cfcc22250ee1"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__face__requirements.html#gaf3262073d55561ee24b5cfcc22250ee1">enableIfPerFaceColorOptional</a> (MeshType &amp;m)</td></tr>
<tr class="memdesc:gaf3262073d55561ee24b5cfcc22250ee1"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the input mesh has a FaceContainer, and the <a class="el" href="classvcl_1_1Face.html" title="The Face class represents an Face element of the vcl::Mesh class.">Face</a> <a class="el" href="classvcl_1_1Element.html" title="The Element class.">Element</a> has a <a class="el" href="classvcl_1_1Color.html" title="The Color class represents a RGBA color.">Color</a> Component, this function enables the Component in the <a class="el" href="classvcl_1_1Element.html" title="The Element class.">Element</a> if the component needs to be enabled (meaning that it is optional). Returns <code>true</code> if, after the call of this function, the <a class="el" href="classvcl_1_1Color.html" title="The Color class represents a RGBA color.">Color</a> component will be available in the <a class="el" href="classvcl_1_1Face.html" title="The Face class represents an Face element of the vcl::Mesh class.">Face</a> <a class="el" href="classvcl_1_1Element.html" title="The Element class.">Element</a> of the mesh.  <br /></td></tr>
<tr class="separator:gaf3262073d55561ee24b5cfcc22250ee1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a5688d9713cddb144509b29dfd9f8ab"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga8a5688d9713cddb144509b29dfd9f8ab"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__face__requirements.html#ga8a5688d9713cddb144509b29dfd9f8ab">isPerFaceMarkAvailable</a> (const MeshType &amp;m)</td></tr>
<tr class="memdesc:ga8a5688d9713cddb144509b29dfd9f8ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the Mark component is available (enabled) in the <a class="el" href="classvcl_1_1Face.html" title="The Face class represents an Face element of the vcl::Mesh class.">Face</a> element of the input mesh m.  <br /></td></tr>
<tr class="separator:ga8a5688d9713cddb144509b29dfd9f8ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0efcb1c23b82c5c20f26149672806012"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga0efcb1c23b82c5c20f26149672806012"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__face__requirements.html#ga0efcb1c23b82c5c20f26149672806012">enableIfPerFaceMarkOptional</a> (MeshType &amp;m)</td></tr>
<tr class="memdesc:ga0efcb1c23b82c5c20f26149672806012"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the input mesh has a FaceContainer, and the <a class="el" href="classvcl_1_1Face.html" title="The Face class represents an Face element of the vcl::Mesh class.">Face</a> <a class="el" href="classvcl_1_1Element.html" title="The Element class.">Element</a> has a Mark Component, this function enables the Component in the <a class="el" href="classvcl_1_1Element.html" title="The Element class.">Element</a> if the component needs to be enabled (meaning that it is optional). Returns <code>true</code> if, after the call of this function, the Mark component will be available in the <a class="el" href="classvcl_1_1Face.html" title="The Face class represents an Face element of the vcl::Mesh class.">Face</a> <a class="el" href="classvcl_1_1Element.html" title="The Element class.">Element</a> of the mesh.  <br /></td></tr>
<tr class="separator:ga0efcb1c23b82c5c20f26149672806012"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ab2973732b455aedeb6f6dfe424346f"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga6ab2973732b455aedeb6f6dfe424346f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__face__requirements.html#ga6ab2973732b455aedeb6f6dfe424346f">isPerFaceNormalAvailable</a> (const MeshType &amp;m)</td></tr>
<tr class="memdesc:ga6ab2973732b455aedeb6f6dfe424346f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the Normal component is available (enabled) in the <a class="el" href="classvcl_1_1Face.html" title="The Face class represents an Face element of the vcl::Mesh class.">Face</a> element of the input mesh m.  <br /></td></tr>
<tr class="separator:ga6ab2973732b455aedeb6f6dfe424346f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf07e8fad913b41d5db61c140e24d35c4"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:gaf07e8fad913b41d5db61c140e24d35c4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__face__requirements.html#gaf07e8fad913b41d5db61c140e24d35c4">enableIfPerFaceNormalOptional</a> (MeshType &amp;m)</td></tr>
<tr class="memdesc:gaf07e8fad913b41d5db61c140e24d35c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the input mesh has a FaceContainer, and the <a class="el" href="classvcl_1_1Face.html" title="The Face class represents an Face element of the vcl::Mesh class.">Face</a> <a class="el" href="classvcl_1_1Element.html" title="The Element class.">Element</a> has a Normal Component, this function enables the Component in the <a class="el" href="classvcl_1_1Element.html" title="The Element class.">Element</a> if the component needs to be enabled (meaning that it is optional). Returns <code>true</code> if, after the call of this function, the Normal component will be available in the <a class="el" href="classvcl_1_1Face.html" title="The Face class represents an Face element of the vcl::Mesh class.">Face</a> <a class="el" href="classvcl_1_1Element.html" title="The Element class.">Element</a> of the mesh.  <br /></td></tr>
<tr class="separator:gaf07e8fad913b41d5db61c140e24d35c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf6682edccdffa17b232dd83c08718cd5"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:gaf6682edccdffa17b232dd83c08718cd5"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__face__requirements.html#gaf6682edccdffa17b232dd83c08718cd5">isPerFacePrincipalCurvatureAvailable</a> (const MeshType &amp;m)</td></tr>
<tr class="memdesc:gaf6682edccdffa17b232dd83c08718cd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the <a class="el" href="classvcl_1_1PrincipalCurvature.html" title="The PrincipalCurvature class stores the principal curvature directions and values at a point on a sur...">PrincipalCurvature</a> component is available (enabled) in the <a class="el" href="classvcl_1_1Face.html" title="The Face class represents an Face element of the vcl::Mesh class.">Face</a> element of the input mesh m.  <br /></td></tr>
<tr class="separator:gaf6682edccdffa17b232dd83c08718cd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e4d93cc27448070bbb26df5cf3c200a"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga7e4d93cc27448070bbb26df5cf3c200a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__face__requirements.html#ga7e4d93cc27448070bbb26df5cf3c200a">enableIfPerFacePrincipalCurvatureOptional</a> (MeshType &amp;m)</td></tr>
<tr class="memdesc:ga7e4d93cc27448070bbb26df5cf3c200a"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the input mesh has a FaceContainer, and the <a class="el" href="classvcl_1_1Face.html" title="The Face class represents an Face element of the vcl::Mesh class.">Face</a> <a class="el" href="classvcl_1_1Element.html" title="The Element class.">Element</a> has a <a class="el" href="classvcl_1_1PrincipalCurvature.html" title="The PrincipalCurvature class stores the principal curvature directions and values at a point on a sur...">PrincipalCurvature</a> Component, this function enables the Component in the <a class="el" href="classvcl_1_1Element.html" title="The Element class.">Element</a> if the component needs to be enabled (meaning that it is optional). Returns <code>true</code> if, after the call of this function, the <a class="el" href="classvcl_1_1PrincipalCurvature.html" title="The PrincipalCurvature class stores the principal curvature directions and values at a point on a sur...">PrincipalCurvature</a> component will be available in the <a class="el" href="classvcl_1_1Face.html" title="The Face class represents an Face element of the vcl::Mesh class.">Face</a> <a class="el" href="classvcl_1_1Element.html" title="The Element class.">Element</a> of the mesh.  <br /></td></tr>
<tr class="separator:ga7e4d93cc27448070bbb26df5cf3c200a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga75a72c0a2cccc6981c1ac702ab4f5a5c"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga75a72c0a2cccc6981c1ac702ab4f5a5c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__face__requirements.html#ga75a72c0a2cccc6981c1ac702ab4f5a5c">isPerFaceQualityAvailable</a> (const MeshType &amp;m)</td></tr>
<tr class="memdesc:ga75a72c0a2cccc6981c1ac702ab4f5a5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the Quality component is available (enabled) in the <a class="el" href="classvcl_1_1Face.html" title="The Face class represents an Face element of the vcl::Mesh class.">Face</a> element of the input mesh m.  <br /></td></tr>
<tr class="separator:ga75a72c0a2cccc6981c1ac702ab4f5a5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga074866b13c60aa020dd3285eb206ee7e"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga074866b13c60aa020dd3285eb206ee7e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__face__requirements.html#ga074866b13c60aa020dd3285eb206ee7e">enableIfPerFaceQualityOptional</a> (MeshType &amp;m)</td></tr>
<tr class="memdesc:ga074866b13c60aa020dd3285eb206ee7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the input mesh has a FaceContainer, and the <a class="el" href="classvcl_1_1Face.html" title="The Face class represents an Face element of the vcl::Mesh class.">Face</a> <a class="el" href="classvcl_1_1Element.html" title="The Element class.">Element</a> has a Quality Component, this function enables the Component in the <a class="el" href="classvcl_1_1Element.html" title="The Element class.">Element</a> if the component needs to be enabled (meaning that it is optional). Returns <code>true</code> if, after the call of this function, the Quality component will be available in the <a class="el" href="classvcl_1_1Face.html" title="The Face class represents an Face element of the vcl::Mesh class.">Face</a> <a class="el" href="classvcl_1_1Element.html" title="The Element class.">Element</a> of the mesh.  <br /></td></tr>
<tr class="separator:ga074866b13c60aa020dd3285eb206ee7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga817a6cd5920e1bb0e8850c183367e112"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga817a6cd5920e1bb0e8850c183367e112"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__face__requirements.html#ga817a6cd5920e1bb0e8850c183367e112">isPerFaceWedgeColorsAvailable</a> (const MeshType &amp;m)</td></tr>
<tr class="memdesc:ga817a6cd5920e1bb0e8850c183367e112"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the WedgeColors component is available (enabled) in the <a class="el" href="classvcl_1_1Face.html" title="The Face class represents an Face element of the vcl::Mesh class.">Face</a> element of the input mesh m.  <br /></td></tr>
<tr class="separator:ga817a6cd5920e1bb0e8850c183367e112"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf2bc7d8c340f922fda76e1d01588433c"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:gaf2bc7d8c340f922fda76e1d01588433c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__face__requirements.html#gaf2bc7d8c340f922fda76e1d01588433c">enableIfPerFaceWedgeColorsOptional</a> (MeshType &amp;m)</td></tr>
<tr class="memdesc:gaf2bc7d8c340f922fda76e1d01588433c"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the input mesh has a FaceContainer, and the <a class="el" href="classvcl_1_1Face.html" title="The Face class represents an Face element of the vcl::Mesh class.">Face</a> <a class="el" href="classvcl_1_1Element.html" title="The Element class.">Element</a> has a WedgeColors Component, this function enables the Component in the <a class="el" href="classvcl_1_1Element.html" title="The Element class.">Element</a> if the component needs to be enabled (meaning that it is optional). Returns <code>true</code> if, after the call of this function, the WedgeColors component will be available in the <a class="el" href="classvcl_1_1Face.html" title="The Face class represents an Face element of the vcl::Mesh class.">Face</a> <a class="el" href="classvcl_1_1Element.html" title="The Element class.">Element</a> of the mesh.  <br /></td></tr>
<tr class="separator:gaf2bc7d8c340f922fda76e1d01588433c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5fbed843fdb42d0018a5f343523b0719"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga5fbed843fdb42d0018a5f343523b0719"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__face__requirements.html#ga5fbed843fdb42d0018a5f343523b0719">isPerFaceWedgeTexCoordsAvailable</a> (const MeshType &amp;m)</td></tr>
<tr class="memdesc:ga5fbed843fdb42d0018a5f343523b0719"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the WedgeTexCoords component is available (enabled) in the <a class="el" href="classvcl_1_1Face.html" title="The Face class represents an Face element of the vcl::Mesh class.">Face</a> element of the input mesh m.  <br /></td></tr>
<tr class="separator:ga5fbed843fdb42d0018a5f343523b0719"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5cfd1a61b06b32978aa70024f8b8e8f3"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga5cfd1a61b06b32978aa70024f8b8e8f3"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__face__requirements.html#ga5cfd1a61b06b32978aa70024f8b8e8f3">enableIfPerFaceWedgeTexCoordsOptional</a> (MeshType &amp;m)</td></tr>
<tr class="memdesc:ga5cfd1a61b06b32978aa70024f8b8e8f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the input mesh has a FaceContainer, and the <a class="el" href="classvcl_1_1Face.html" title="The Face class represents an Face element of the vcl::Mesh class.">Face</a> <a class="el" href="classvcl_1_1Element.html" title="The Element class.">Element</a> has a WedgeTexCoords Component, this function enables the Component in the <a class="el" href="classvcl_1_1Element.html" title="The Element class.">Element</a> if the component needs to be enabled (meaning that it is optional). Returns <code>true</code> if, after the call of this function, the WedgeTexCoords component will be available in the <a class="el" href="classvcl_1_1Face.html" title="The Face class represents an Face element of the vcl::Mesh class.">Face</a> <a class="el" href="classvcl_1_1Element.html" title="The Element class.">Element</a> of the mesh.  <br /></td></tr>
<tr class="separator:ga5cfd1a61b06b32978aa70024f8b8e8f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa5e8d79003b3a928d430219d244a4855"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:gaa5e8d79003b3a928d430219d244a4855"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__face__requirements.html#gaa5e8d79003b3a928d430219d244a4855">requireFaceContainerCompactness</a> (const MeshType &amp;m)</td></tr>
<tr class="memdesc:gaa5e8d79003b3a928d430219d244a4855"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function asserts that a <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a> has the FaceContainer compact (no elements flagged as deleted).  <br /></td></tr>
<tr class="separator:gaa5e8d79003b3a928d430219d244a4855"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga806ec8c0b627a10d684745c6eee1ce20"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; <br />
requires HasPerFaceAdjacentEdges&lt;MeshType&gt;</td></tr>
<tr class="memitem:ga806ec8c0b627a10d684745c6eee1ce20"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__face__requirements.html#ga806ec8c0b627a10d684745c6eee1ce20">requirePerFaceAdjacentEdges</a> (const MeshType &amp;m)</td></tr>
<tr class="memdesc:ga806ec8c0b627a10d684745c6eee1ce20"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function asserts that a <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a> has a FaceContainer, the <a class="el" href="classvcl_1_1Face.html" title="The Face class represents an Face element of the vcl::Mesh class.">Face</a> has a AdjacentEdges Component, and that the AdjacentEdges Component is enabled and available at runtime.  <br /></td></tr>
<tr class="separator:ga806ec8c0b627a10d684745c6eee1ce20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff3602e750a1d1c93374f642be47a6b0"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; <br />
requires HasPerFaceAdjacentFaces&lt;MeshType&gt;</td></tr>
<tr class="memitem:gaff3602e750a1d1c93374f642be47a6b0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__face__requirements.html#gaff3602e750a1d1c93374f642be47a6b0">requirePerFaceAdjacentFaces</a> (const MeshType &amp;m)</td></tr>
<tr class="memdesc:gaff3602e750a1d1c93374f642be47a6b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function asserts that a <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a> has a FaceContainer, the <a class="el" href="classvcl_1_1Face.html" title="The Face class represents an Face element of the vcl::Mesh class.">Face</a> has a AdjacentFaces Component, and that the AdjacentFaces Component is enabled and available at runtime.  <br /></td></tr>
<tr class="separator:gaff3602e750a1d1c93374f642be47a6b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae6372afb65d4cb206aed162aff2d71c3"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; <br />
requires HasPerFaceColor&lt;MeshType&gt;</td></tr>
<tr class="memitem:gae6372afb65d4cb206aed162aff2d71c3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__face__requirements.html#gae6372afb65d4cb206aed162aff2d71c3">requirePerFaceColor</a> (const MeshType &amp;m)</td></tr>
<tr class="memdesc:gae6372afb65d4cb206aed162aff2d71c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function asserts that a <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a> has a FaceContainer, the <a class="el" href="classvcl_1_1Face.html" title="The Face class represents an Face element of the vcl::Mesh class.">Face</a> has a <a class="el" href="classvcl_1_1Color.html" title="The Color class represents a RGBA color.">Color</a> Component, and that the <a class="el" href="classvcl_1_1Color.html" title="The Color class represents a RGBA color.">Color</a> Component is enabled and available at runtime.  <br /></td></tr>
<tr class="separator:gae6372afb65d4cb206aed162aff2d71c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac96a0a92c22ced9c629b174dade3dd70"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; <br />
requires HasPerFaceMark&lt;MeshType&gt;</td></tr>
<tr class="memitem:gac96a0a92c22ced9c629b174dade3dd70"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__face__requirements.html#gac96a0a92c22ced9c629b174dade3dd70">requirePerFaceMark</a> (const MeshType &amp;m)</td></tr>
<tr class="memdesc:gac96a0a92c22ced9c629b174dade3dd70"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function asserts that a <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a> has a FaceContainer, the <a class="el" href="classvcl_1_1Face.html" title="The Face class represents an Face element of the vcl::Mesh class.">Face</a> has a Mark Component, and that the Mark Component is enabled and available at runtime.  <br /></td></tr>
<tr class="separator:gac96a0a92c22ced9c629b174dade3dd70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac641c6af53b47b21fe2b1b85f1b1c8c4"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; <br />
requires HasPerFaceNormal&lt;MeshType&gt;</td></tr>
<tr class="memitem:gac641c6af53b47b21fe2b1b85f1b1c8c4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__face__requirements.html#gac641c6af53b47b21fe2b1b85f1b1c8c4">requirePerFaceNormal</a> (const MeshType &amp;m)</td></tr>
<tr class="memdesc:gac641c6af53b47b21fe2b1b85f1b1c8c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function asserts that a <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a> has a FaceContainer, the <a class="el" href="classvcl_1_1Face.html" title="The Face class represents an Face element of the vcl::Mesh class.">Face</a> has a Normal Component, and that the Normal Component is enabled and available at runtime.  <br /></td></tr>
<tr class="separator:gac641c6af53b47b21fe2b1b85f1b1c8c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga880bfabf90d17524361cc4115587db56"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; <br />
requires HasPerFacePrincipalCurvature&lt;MeshType&gt;</td></tr>
<tr class="memitem:ga880bfabf90d17524361cc4115587db56"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__face__requirements.html#ga880bfabf90d17524361cc4115587db56">requirePerFacePrincipalCurvature</a> (const MeshType &amp;m)</td></tr>
<tr class="memdesc:ga880bfabf90d17524361cc4115587db56"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function asserts that a <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a> has a FaceContainer, the <a class="el" href="classvcl_1_1Face.html" title="The Face class represents an Face element of the vcl::Mesh class.">Face</a> has a <a class="el" href="classvcl_1_1PrincipalCurvature.html" title="The PrincipalCurvature class stores the principal curvature directions and values at a point on a sur...">PrincipalCurvature</a> Component, and that the <a class="el" href="classvcl_1_1PrincipalCurvature.html" title="The PrincipalCurvature class stores the principal curvature directions and values at a point on a sur...">PrincipalCurvature</a> Component is enabled and available at runtime.  <br /></td></tr>
<tr class="separator:ga880bfabf90d17524361cc4115587db56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c3e051c842750da953304d22258d704"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; <br />
requires HasPerFaceQuality&lt;MeshType&gt;</td></tr>
<tr class="memitem:ga7c3e051c842750da953304d22258d704"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__face__requirements.html#ga7c3e051c842750da953304d22258d704">requirePerFaceQuality</a> (const MeshType &amp;m)</td></tr>
<tr class="memdesc:ga7c3e051c842750da953304d22258d704"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function asserts that a <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a> has a FaceContainer, the <a class="el" href="classvcl_1_1Face.html" title="The Face class represents an Face element of the vcl::Mesh class.">Face</a> has a Quality Component, and that the Quality Component is enabled and available at runtime.  <br /></td></tr>
<tr class="separator:ga7c3e051c842750da953304d22258d704"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef39ab9380581074304975fc0cb49570"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; <br />
requires HasPerFaceWedgeColors&lt;MeshType&gt;</td></tr>
<tr class="memitem:gaef39ab9380581074304975fc0cb49570"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__face__requirements.html#gaef39ab9380581074304975fc0cb49570">requirePerFaceWedgeColors</a> (const MeshType &amp;m)</td></tr>
<tr class="memdesc:gaef39ab9380581074304975fc0cb49570"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function asserts that a <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a> has a FaceContainer, the <a class="el" href="classvcl_1_1Face.html" title="The Face class represents an Face element of the vcl::Mesh class.">Face</a> has a WedgeColors Component, and that the WedgeColors Component is enabled and available at runtime.  <br /></td></tr>
<tr class="separator:gaef39ab9380581074304975fc0cb49570"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f262a65d84b84b17a5d41b13fa98329"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; <br />
requires HasPerFaceWedgeTexCoords&lt;MeshType&gt;</td></tr>
<tr class="memitem:ga7f262a65d84b84b17a5d41b13fa98329"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__face__requirements.html#ga7f262a65d84b84b17a5d41b13fa98329">requirePerFaceWedgeTexCoords</a> (const MeshType &amp;m)</td></tr>
<tr class="memdesc:ga7f262a65d84b84b17a5d41b13fa98329"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function asserts that a <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a> has a FaceContainer, the <a class="el" href="classvcl_1_1Face.html" title="The Face class represents an Face element of the vcl::Mesh class.">Face</a> has a WedgeTexCoords Component, and that the WedgeTexCoords Component is enabled and available at runtime.  <br /></td></tr>
<tr class="separator:ga7f262a65d84b84b17a5d41b13fa98329"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f44643cdd6a934b9ab5f60315e6f01a"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga2f44643cdd6a934b9ab5f60315e6f01a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mesh__requirements.html#ga2f44643cdd6a934b9ab5f60315e6f01a">isTriangleMesh</a> (const MeshType &amp;m)</td></tr>
<tr class="memdesc:ga2f44643cdd6a934b9ab5f60315e6f01a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks <em>at run time</em> if the mesh m is composed of triangles.  <br /></td></tr>
<tr class="separator:ga2f44643cdd6a934b9ab5f60315e6f01a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1878ac13ce283e3535efd93d254d1843"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga1878ac13ce283e3535efd93d254d1843"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mesh__requirements.html#ga1878ac13ce283e3535efd93d254d1843">isQuadMesh</a> (const MeshType &amp;m)</td></tr>
<tr class="memdesc:ga1878ac13ce283e3535efd93d254d1843"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks <em>at run time</em> if the mesh is composed of quads.  <br /></td></tr>
<tr class="separator:ga1878ac13ce283e3535efd93d254d1843"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb9fbe7647f2b656ab871e2bb20b8c33"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:gacb9fbe7647f2b656ab871e2bb20b8c33"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mesh__requirements.html#gacb9fbe7647f2b656ab871e2bb20b8c33">isCompact</a> (const MeshType &amp;m)</td></tr>
<tr class="memdesc:gacb9fbe7647f2b656ab871e2bb20b8c33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a> is compact, that is if it does not contains deleted elements.  <br /></td></tr>
<tr class="separator:gacb9fbe7647f2b656ab871e2bb20b8c33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f347e31d2e1fd9471cc98f46668c64c"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga3f347e31d2e1fd9471cc98f46668c64c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mesh__requirements.html#ga3f347e31d2e1fd9471cc98f46668c64c">requireTriangleMesh</a> (const MeshType &amp;m)</td></tr>
<tr class="memdesc:ga3f347e31d2e1fd9471cc98f46668c64c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the mesh is composed of triangles, and if not, throws an exception.  <br /></td></tr>
<tr class="separator:ga3f347e31d2e1fd9471cc98f46668c64c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa713300521a68b8fe8bf5154fdae27b8"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:gaa713300521a68b8fe8bf5154fdae27b8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mesh__requirements.html#gaa713300521a68b8fe8bf5154fdae27b8">requireQuadMesh</a> (const MeshType &amp;m)</td></tr>
<tr class="memdesc:gaa713300521a68b8fe8bf5154fdae27b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the mesh is composed of quads, and if not, throws an exception.  <br /></td></tr>
<tr class="separator:gaa713300521a68b8fe8bf5154fdae27b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga84e84c881525f5d76599d6ef8d4a0933"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga84e84c881525f5d76599d6ef8d4a0933"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mesh__requirements.html#ga84e84c881525f5d76599d6ef8d4a0933">requireCompactness</a> (const MeshType &amp;m)</td></tr>
<tr class="memdesc:ga84e84c881525f5d76599d6ef8d4a0933"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a> is compact, that is if it does not contains deleted elements, and if not, throws an exception.  <br /></td></tr>
<tr class="separator:ga84e84c881525f5d76599d6ef8d4a0933"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf71077b0dd03e109c80a05dc1bcafdf5"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:gaf71077b0dd03e109c80a05dc1bcafdf5"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__vertex__requirements.html#gaf71077b0dd03e109c80a05dc1bcafdf5">isVertexContainerCompact</a> (const MeshType &amp;m)</td></tr>
<tr class="memdesc:gaf71077b0dd03e109c80a05dc1bcafdf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if the given mesh has its <a class="el" href="classvcl_1_1Vertex.html" title="The Vertex class represents an Vertex element of the vcl::Mesh class.">Vertex</a> Container compact.  <br /></td></tr>
<tr class="separator:gaf71077b0dd03e109c80a05dc1bcafdf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e568fca42924a53fde391597ff4e560"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a3e568fca42924a53fde391597ff4e560"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a3e568fca42924a53fde391597ff4e560">isPerVertexAdjacentFacesAvailable</a> (const MeshType &amp;m)</td></tr>
<tr class="separator:a3e568fca42924a53fde391597ff4e560"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a617cf756eac51fcf6b566ce5d4c09393"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a617cf756eac51fcf6b566ce5d4c09393"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a617cf756eac51fcf6b566ce5d4c09393">enableIfPerVertexAdjacentFacesOptional</a> (MeshType &amp;m)</td></tr>
<tr class="separator:a617cf756eac51fcf6b566ce5d4c09393"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84a2badab79a21f537f854257457ae8e"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a84a2badab79a21f537f854257457ae8e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a84a2badab79a21f537f854257457ae8e">isPerVertexAdjacentVerticesAvailable</a> (const MeshType &amp;m)</td></tr>
<tr class="separator:a84a2badab79a21f537f854257457ae8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e15c93274d1207f45bb0673fce3ba8a"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a6e15c93274d1207f45bb0673fce3ba8a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a6e15c93274d1207f45bb0673fce3ba8a">enableIfPerVertexAdjacentVerticesOptional</a> (MeshType &amp;m)</td></tr>
<tr class="separator:a6e15c93274d1207f45bb0673fce3ba8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac805cc3d735ee5883647218cdd1ee7e0"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ac805cc3d735ee5883647218cdd1ee7e0"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ac805cc3d735ee5883647218cdd1ee7e0">isPerVertexColorAvailable</a> (const MeshType &amp;m)</td></tr>
<tr class="separator:ac805cc3d735ee5883647218cdd1ee7e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a802d56a620a24d04972ba5d483a2730a"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a802d56a620a24d04972ba5d483a2730a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a802d56a620a24d04972ba5d483a2730a">enableIfPerVertexColorOptional</a> (MeshType &amp;m)</td></tr>
<tr class="separator:a802d56a620a24d04972ba5d483a2730a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dc8c6d96d74cceffb34a1a480864563"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a7dc8c6d96d74cceffb34a1a480864563"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a7dc8c6d96d74cceffb34a1a480864563">isPerVertexMarkAvailable</a> (const MeshType &amp;m)</td></tr>
<tr class="separator:a7dc8c6d96d74cceffb34a1a480864563"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64bde18cc07f8804c0c96e5def984f26"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a64bde18cc07f8804c0c96e5def984f26"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a64bde18cc07f8804c0c96e5def984f26">enableIfPerVertexMarkOptional</a> (MeshType &amp;m)</td></tr>
<tr class="separator:a64bde18cc07f8804c0c96e5def984f26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af37173d6ec6aa5b11580217057aa6e24"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:af37173d6ec6aa5b11580217057aa6e24"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#af37173d6ec6aa5b11580217057aa6e24">isPerVertexNormalAvailable</a> (const MeshType &amp;m)</td></tr>
<tr class="separator:af37173d6ec6aa5b11580217057aa6e24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4a7a739d6f30a2e4768b7b12c663418"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:af4a7a739d6f30a2e4768b7b12c663418"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#af4a7a739d6f30a2e4768b7b12c663418">enableIfPerVertexNormalOptional</a> (MeshType &amp;m)</td></tr>
<tr class="separator:af4a7a739d6f30a2e4768b7b12c663418"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeba9629e5f1c2363b2b35bc865f9d11e"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:aeba9629e5f1c2363b2b35bc865f9d11e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#aeba9629e5f1c2363b2b35bc865f9d11e">isPerVertexPrincipalCurvatureAvailable</a> (const MeshType &amp;m)</td></tr>
<tr class="separator:aeba9629e5f1c2363b2b35bc865f9d11e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a579b161f8a4132e5106608bebc70e363"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a579b161f8a4132e5106608bebc70e363"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a579b161f8a4132e5106608bebc70e363">enableIfPerVertexPrincipalCurvatureOptional</a> (MeshType &amp;m)</td></tr>
<tr class="separator:a579b161f8a4132e5106608bebc70e363"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09449154647e40fd0a3c1e965a91bf49"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a09449154647e40fd0a3c1e965a91bf49"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a09449154647e40fd0a3c1e965a91bf49">isPerVertexQualityAvailable</a> (const MeshType &amp;m)</td></tr>
<tr class="separator:a09449154647e40fd0a3c1e965a91bf49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9eb68875b4658e81e104725173df6fd"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:aa9eb68875b4658e81e104725173df6fd"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#aa9eb68875b4658e81e104725173df6fd">enableIfPerVertexQualityOptional</a> (MeshType &amp;m)</td></tr>
<tr class="separator:aa9eb68875b4658e81e104725173df6fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91da20c5938a63be8d206b547892a205"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a91da20c5938a63be8d206b547892a205"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a91da20c5938a63be8d206b547892a205">isPerVertexTexCoordAvailable</a> (const MeshType &amp;m)</td></tr>
<tr class="separator:a91da20c5938a63be8d206b547892a205"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a369d2067cce035b7b4a710c5b364a28c"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:a369d2067cce035b7b4a710c5b364a28c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a369d2067cce035b7b4a710c5b364a28c">enableIfPerVertexTexCoordOptional</a> (MeshType &amp;m)</td></tr>
<tr class="separator:a369d2067cce035b7b4a710c5b364a28c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5e94dd9b89e9bc4fb21701af6e788ca"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ae5e94dd9b89e9bc4fb21701af6e788ca"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ae5e94dd9b89e9bc4fb21701af6e788ca">requireVertexContainerCompactness</a> (const MeshType &amp;m)</td></tr>
<tr class="separator:ae5e94dd9b89e9bc4fb21701af6e788ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f6666a7b9cd7293ab07aaf6cbc1dc4c"><td class="memTemplParams" colspan="2">template&lt;typename MeshType &gt; <br />
requires HasPerVertexAdjacentFaces&lt;MeshType&gt;</td></tr>
<tr class="memitem:a1f6666a7b9cd7293ab07aaf6cbc1dc4c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a1f6666a7b9cd7293ab07aaf6cbc1dc4c">requirePerVertexAdjacentFaces</a> (const MeshType &amp;m)</td></tr>
<tr class="separator:a1f6666a7b9cd7293ab07aaf6cbc1dc4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a224534742afebeedf036df597231c700"><td class="memTemplParams" colspan="2">template&lt;typename MeshType &gt; <br />
requires HasPerVertexAdjacentVertices&lt;MeshType&gt;</td></tr>
<tr class="memitem:a224534742afebeedf036df597231c700"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a224534742afebeedf036df597231c700">requirePerVertexAdjacentVertices</a> (const MeshType &amp;m)</td></tr>
<tr class="separator:a224534742afebeedf036df597231c700"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fc65a005474dd6f983d5f9b235b5387"><td class="memTemplParams" colspan="2">template&lt;typename MeshType &gt; <br />
requires HasPerVertexColor&lt;MeshType&gt;</td></tr>
<tr class="memitem:a3fc65a005474dd6f983d5f9b235b5387"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a3fc65a005474dd6f983d5f9b235b5387">requirePerVertexColor</a> (const MeshType &amp;m)</td></tr>
<tr class="separator:a3fc65a005474dd6f983d5f9b235b5387"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1b0cb92a48a555d7084bb6fb94ef359"><td class="memTemplParams" colspan="2">template&lt;typename MeshType &gt; <br />
requires HasPerVertexMark&lt;MeshType&gt;</td></tr>
<tr class="memitem:ad1b0cb92a48a555d7084bb6fb94ef359"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ad1b0cb92a48a555d7084bb6fb94ef359">requirePerVertexMark</a> (const MeshType &amp;m)</td></tr>
<tr class="separator:ad1b0cb92a48a555d7084bb6fb94ef359"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab43f884f6ca679c8f57255e11ddaa768"><td class="memTemplParams" colspan="2">template&lt;typename MeshType &gt; <br />
requires HasPerVertexNormal&lt;MeshType&gt;</td></tr>
<tr class="memitem:ab43f884f6ca679c8f57255e11ddaa768"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ab43f884f6ca679c8f57255e11ddaa768">requirePerVertexNormal</a> (const MeshType &amp;m)</td></tr>
<tr class="separator:ab43f884f6ca679c8f57255e11ddaa768"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af330a765b2c7772ff85378f617ade27b"><td class="memTemplParams" colspan="2">template&lt;typename MeshType &gt; <br />
requires HasPerVertexPrincipalCurvature&lt;MeshType&gt;</td></tr>
<tr class="memitem:af330a765b2c7772ff85378f617ade27b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#af330a765b2c7772ff85378f617ade27b">requirePerVertexPrincipalCurvature</a> (const MeshType &amp;m)</td></tr>
<tr class="separator:af330a765b2c7772ff85378f617ade27b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49287ff6e3778f10a280b1166006dff9"><td class="memTemplParams" colspan="2">template&lt;typename MeshType &gt; <br />
requires HasPerVertexQuality&lt;MeshType&gt;</td></tr>
<tr class="memitem:a49287ff6e3778f10a280b1166006dff9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a49287ff6e3778f10a280b1166006dff9">requirePerVertexQuality</a> (const MeshType &amp;m)</td></tr>
<tr class="separator:a49287ff6e3778f10a280b1166006dff9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f20fd534d1bb822fe5b13f2515025ee"><td class="memTemplParams" colspan="2">template&lt;typename MeshType &gt; <br />
requires HasPerVertexTexCoord&lt;MeshType&gt;</td></tr>
<tr class="memitem:a5f20fd534d1bb822fe5b13f2515025ee"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a5f20fd534d1bb822fe5b13f2515025ee">requirePerVertexTexCoord</a> (const MeshType &amp;m)</td></tr>
<tr class="separator:a5f20fd534d1bb822fe5b13f2515025ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca4e61e9eb02bae8617f346aaf830452"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Args&gt; </td></tr>
<tr class="memitem:aca4e61e9eb02bae8617f346aaf830452"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#aca4e61e9eb02bae8617f346aaf830452">compactVector</a> (std::vector&lt; T, Args... &gt; &amp;vec, const std::vector&lt; <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> &gt; &amp;newIndices)</td></tr>
<tr class="memdesc:aca4e61e9eb02bae8617f346aaf830452"><td class="mdescLeft">&#160;</td><td class="mdescRight">It will take care of compacting the vector vec, depending on the content of the vector newIndices.  <br /></td></tr>
<tr class="separator:aca4e61e9eb02bae8617f346aaf830452"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb189433c1c9d7bf52a96ff359f364ec"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Rest&gt; </td></tr>
<tr class="memitem:aeb189433c1c9d7bf52a96ff359f364ec"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#aeb189433c1c9d7bf52a96ff359f364ec">hashCombine</a> (std::size_t &amp;seed, const T &amp;v, const Rest &amp;... rest)</td></tr>
<tr class="memdesc:aeb189433c1c9d7bf52a96ff359f364ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starting from a seed, computes the hash of a series of objects.  <br /></td></tr>
<tr class="separator:aeb189433c1c9d7bf52a96ff359f364ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9692d4f1afe48a370a2fe551d5ea55d4"><td class="memTemplParams" colspan="2">template&lt;LoggerConcept T&gt; </td></tr>
<tr class="memitem:a9692d4f1afe48a370a2fe551d5ea55d4"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a9692d4f1afe48a370a2fe551d5ea55d4">isLoggerValid</a> ()</td></tr>
<tr class="memdesc:a9692d4f1afe48a370a2fe551d5ea55d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="namespacevcl.html#a9692d4f1afe48a370a2fe551d5ea55d4" title="The isLoggerValid() function returns true if the type T is not the NullLogger type.">isLoggerValid()</a> function returns true if the type T is not the <a class="el" href="classvcl_1_1NullLogger.html" title="The NullLogger class is an empty class that is used as default type in all the library functions that...">NullLogger</a> type.  <br /></td></tr>
<tr class="separator:a9692d4f1afe48a370a2fe551d5ea55d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abde6b767fa0b116a5fd8b2a5fa0af488"><td class="memTemplParams" colspan="2">template&lt;typename Iterator , typename Lambda &gt; </td></tr>
<tr class="memitem:abde6b767fa0b116a5fd8b2a5fa0af488"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#abde6b767fa0b116a5fd8b2a5fa0af488">parallelFor</a> (Iterator &amp;&amp;begin, Iterator &amp;&amp;end, Lambda &amp;&amp;F)</td></tr>
<tr class="memdesc:abde6b767fa0b116a5fd8b2a5fa0af488"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function executes a parallel for over the elements iterated between <code>begin</code> and <code>end</code> iterators, if parallel requirements have been found in the system.  <br /></td></tr>
<tr class="separator:abde6b767fa0b116a5fd8b2a5fa0af488"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac74faed2021a2b157f5b80757ee694d8"><td class="memTemplParams" colspan="2">template&lt;typename Iterator , typename Lambda &gt; </td></tr>
<tr class="memitem:ac74faed2021a2b157f5b80757ee694d8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ac74faed2021a2b157f5b80757ee694d8">parallelFor</a> (const Iterator &amp;begin, const Iterator &amp;end, Lambda &amp;&amp;F)</td></tr>
<tr class="memdesc:ac74faed2021a2b157f5b80757ee694d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function executes a parallel for over the elements iterated between <code>begin</code> and <code>end</code> iterators, if parallel requirements have been found in the system.  <br /></td></tr>
<tr class="separator:ac74faed2021a2b157f5b80757ee694d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bbb25a5a74276bc05a251ab860a286d"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="conceptvcl_1_1Range.html">vcl::Range</a> Rng, typename Lambda &gt; </td></tr>
<tr class="memitem:a0bbb25a5a74276bc05a251ab860a286d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a0bbb25a5a74276bc05a251ab860a286d">parallelFor</a> (Rng &amp;&amp;r, Lambda &amp;&amp;F)</td></tr>
<tr class="memdesc:a0bbb25a5a74276bc05a251ab860a286d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function executes a parallel for over a range if parallel requirements have been found in the system.  <br /></td></tr>
<tr class="separator:a0bbb25a5a74276bc05a251ab860a286d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad43b0e6c5acf9f903daf25853361a24c"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="conceptvcl_1_1Range.html">vcl::Range</a> Rng, typename Lambda &gt; </td></tr>
<tr class="memitem:ad43b0e6c5acf9f903daf25853361a24c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ad43b0e6c5acf9f903daf25853361a24c">parallelFor</a> (const Rng &amp;r, Lambda &amp;&amp;F)</td></tr>
<tr class="memdesc:ad43b0e6c5acf9f903daf25853361a24c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function executes a parallel for over a range if parallel requirements have been found in the system.  <br /></td></tr>
<tr class="separator:ad43b0e6c5acf9f903daf25853361a24c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08ddfb40632cb38ec4750610e0e2ebaa"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename... Us&gt; </td></tr>
<tr class="memitem:a08ddfb40632cb38ec4750610e0e2ebaa"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a08ddfb40632cb38ec4750610e0e2ebaa">tupleIndexByType</a> (const std::tuple&lt; U, Us... &gt; &amp;)</td></tr>
<tr class="memdesc:a08ddfb40632cb38ec4750610e0e2ebaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of a type T in a std::tuple&lt;U, Us...&gt; passed as parameter; Returns UINT_NULL if the type T is not found in the tuple.  <br /></td></tr>
<tr class="separator:a08ddfb40632cb38ec4750610e0e2ebaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10783cb155a40826adff62ef42123efe"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:a10783cb155a40826adff62ef42123efe"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a10783cb155a40826adff62ef42123efe">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classvcl_1_1Array.html">Array</a>&lt; Scalar, 2 &gt; &amp;a)</td></tr>
<tr class="separator:a10783cb155a40826adff62ef42123efe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05dd102880d029a4ce6a952207559088"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a05dd102880d029a4ce6a952207559088">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classvcl_1_1Color.html">Color</a> &amp;c)</td></tr>
<tr class="memdesc:a05dd102880d029a4ce6a952207559088"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload of stream operator to allow a pretty print of a <a class="el" href="classvcl_1_1Color.html" title="The Color class represents a RGBA color.">vcl::Color</a>.  <br /></td></tr>
<tr class="separator:a05dd102880d029a4ce6a952207559088"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dcc49648719fc830554b892110ff8f2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Color.html">Color</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a9dcc49648719fc830554b892110ff8f2">colorLerp</a> (const <a class="el" href="classvcl_1_1Color.html">Color</a> &amp;c0, const <a class="el" href="classvcl_1_1Color.html">Color</a> &amp;c1, float value)</td></tr>
<tr class="memdesc:a9dcc49648719fc830554b892110ff8f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an interval of colors (from <code>c0</code> to <code>c1</code>) and a value in the interval [0, 1], returns the linear interpolation color between <code>c0</code> and <code>c1</code> based on <code>value</code> in the [0, 1] interval. If <code>value</code> is out of range, it will be set to the nearest extreme of the interval.  <br /></td></tr>
<tr class="separator:a9dcc49648719fc830554b892110ff8f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c348d7127fb95f134332b8c275846f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Color.html">Color</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a6c348d7127fb95f134332b8c275846f7">colorFromIntervalRedBlue</a> (float value)</td></tr>
<tr class="memdesc:a6c348d7127fb95f134332b8c275846f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a color in the interval from Red to Blue depending on the position of the given value in the interval [0, 1].  <br /></td></tr>
<tr class="separator:a6c348d7127fb95f134332b8c275846f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa361024b35e8aef9609826b177ac1cb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Color.html">Color</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#afa361024b35e8aef9609826b177ac1cb">colorFromIntervalRedBlue</a> (float <a class="el" href="namespacevcl.html#a3edcb561672a6be17e9453bd1ea446d5">min</a>, float <a class="el" href="namespacevcl.html#a69cc63a5ad2974d082145ed1dee7846b">max</a>, float value)</td></tr>
<tr class="memdesc:afa361024b35e8aef9609826b177ac1cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a color in the interval from Red to Blue depending on the position of the given value in the given interval [min, max].  <br /></td></tr>
<tr class="separator:afa361024b35e8aef9609826b177ac1cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7728ec836fa169f447a90a4d2eee3df5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Color.html">Color</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a7728ec836fa169f447a90a4d2eee3df5">colorFromIntervalParula</a> (float value)</td></tr>
<tr class="memdesc:a7728ec836fa169f447a90a4d2eee3df5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a color in the Paraula colormap depending on the position of the given value in the interval [0, 1].  <br /></td></tr>
<tr class="separator:a7728ec836fa169f447a90a4d2eee3df5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9725bc9a2f5b27ce885e76be92185a20"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Color.html">Color</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a9725bc9a2f5b27ce885e76be92185a20">colorFromIntervalParula</a> (float <a class="el" href="namespacevcl.html#a3edcb561672a6be17e9453bd1ea446d5">min</a>, float <a class="el" href="namespacevcl.html#a69cc63a5ad2974d082145ed1dee7846b">max</a>, float value)</td></tr>
<tr class="memdesc:a9725bc9a2f5b27ce885e76be92185a20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a color in the Paraula colormap depending on the position of the given value in the given interval [min, max].  <br /></td></tr>
<tr class="separator:a9725bc9a2f5b27ce885e76be92185a20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8232d4e3c3aca4125e84cb8f124ebc29"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Color.html">Color</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a8232d4e3c3aca4125e84cb8f124ebc29">colorFromIntervalGreyShade</a> (float value)</td></tr>
<tr class="memdesc:a8232d4e3c3aca4125e84cb8f124ebc29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a color in the grey shade colormap depending on the position of the given value in the interval [0, 1].  <br /></td></tr>
<tr class="separator:a8232d4e3c3aca4125e84cb8f124ebc29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99b591f2eba1ded24ebf6f4b0ee4353f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Color.html">Color</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a99b591f2eba1ded24ebf6f4b0ee4353f">colorFromIntervalGreyShade</a> (float <a class="el" href="namespacevcl.html#a3edcb561672a6be17e9453bd1ea446d5">min</a>, float <a class="el" href="namespacevcl.html#a69cc63a5ad2974d082145ed1dee7846b">max</a>, float value)</td></tr>
<tr class="memdesc:a99b591f2eba1ded24ebf6f4b0ee4353f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a color in the grey shade colormap depending on the position of the given value in the given interval [min, max].  <br /></td></tr>
<tr class="separator:a99b591f2eba1ded24ebf6f4b0ee4353f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5851edce0478bfc7f4084e3529ae6962"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Color.html">Color</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a5851edce0478bfc7f4084e3529ae6962">colorFromInterval</a> (float value, <a class="el" href="classvcl_1_1Color.html#a32ace7bd7fccf742b39f6cd83042a10f">Color::ColorMap</a> cm)</td></tr>
<tr class="memdesc:a5851edce0478bfc7f4084e3529ae6962"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a <code>value</code> in the interval [0, 1], it returns the color in the position in the given ColorMap <code>cm</code> corresponding to the position of <code>value</code> in the interval [0, 1].  <br /></td></tr>
<tr class="separator:a5851edce0478bfc7f4084e3529ae6962"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5a54ddc3c9d67e0c7ed179e78c2ca06"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Color.html">Color</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ab5a54ddc3c9d67e0c7ed179e78c2ca06">colorFromInterval</a> (float <a class="el" href="namespacevcl.html#a3edcb561672a6be17e9453bd1ea446d5">min</a>, float <a class="el" href="namespacevcl.html#a69cc63a5ad2974d082145ed1dee7846b">max</a>, float value, <a class="el" href="classvcl_1_1Color.html#a32ace7bd7fccf742b39f6cd83042a10f">Color::ColorMap</a> cm)</td></tr>
<tr class="memdesc:ab5a54ddc3c9d67e0c7ed179e78c2ca06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a color in the interval from the minimum color to the maximum color of the given colormap <code>cm</code>, depending on the position of the given value in the given interval [min, max].  <br /></td></tr>
<tr class="separator:ab5a54ddc3c9d67e0c7ed179e78c2ca06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e24134fa80806f677e3d5d72cd9c9e9"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classvcl_1_1Color.html">Color</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a7e24134fa80806f677e3d5d72cd9c9e9">colorScattering</a> (<a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> n, float sat=0.3, float val=0.9)</td></tr>
<tr class="memdesc:a7e24134fa80806f677e3d5d72cd9c9e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a number <code>n</code>, returns a vector of <code>n</code> colors so that each color differs as much as possible from the previous one of the vector.  <br /></td></tr>
<tr class="separator:a7e24134fa80806f677e3d5d72cd9c9e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1420d0b9ba83dea9e692db635533f46c"><td class="memTemplParams" colspan="2">template&lt;PointConcept PointType, typename D &gt; </td></tr>
<tr class="memitem:a1420d0b9ba83dea9e692db635533f46c"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a1420d0b9ba83dea9e692db635533f46c">RegularGrid</a> (PointType, PointType, D) -&gt; <a class="el" href="classvcl_1_1RegularGrid.html">RegularGrid</a>&lt; typename PointType::ScalarType, PointType::DIM &gt;</td></tr>
<tr class="separator:a1420d0b9ba83dea9e692db635533f46c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f45446c5f7bcad8bd9dd9c515bf1e55"><td class="memTemplParams" colspan="2">template&lt;PointConcept PointType&gt; </td></tr>
<tr class="memitem:a6f45446c5f7bcad8bd9dd9c515bf1e55"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Point.html">Point</a>&lt; <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a>, PointType::DIM &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a6f45446c5f7bcad8bd9dd9c515bf1e55">bestGridSize</a> (const PointType &amp;lengths, <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> nElements)</td></tr>
<tr class="memdesc:a6f45446c5f7bcad8bd9dd9c515bf1e55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the best sizes (number of cells per dimension) of a Grid, starting from the lengths of the grid and the number of elements to place in the grid.  <br /></td></tr>
<tr class="separator:a6f45446c5f7bcad8bd9dd9c515bf1e55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1f5ecc820f6ab64fb437ba12296601c"><td class="memTemplParams" colspan="2">template&lt;PointIteratorConcept It&gt; </td></tr>
<tr class="memitem:ab1f5ecc820f6ab64fb437ba12296601c"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ab1f5ecc820f6ab64fb437ba12296601c">StaticGrid</a> (It, It) -&gt; <a class="el" href="classvcl_1_1StaticGrid.html">StaticGrid</a>&lt; <a class="el" href="classvcl_1_1RegularGrid.html">RegularGrid</a>&lt; typename It::value_type, It::value_type::DIM &gt;, typename It::value_type::ScalarType &gt;</td></tr>
<tr class="separator:ab1f5ecc820f6ab64fb437ba12296601c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7586ced2cedb8cd2aa668c8136b24603"><td class="memTemplParams" colspan="2">template&lt;PointIteratorConcept It, typename F &gt; </td></tr>
<tr class="memitem:a7586ced2cedb8cd2aa668c8136b24603"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a7586ced2cedb8cd2aa668c8136b24603">StaticGrid</a> (It, It, F) -&gt; <a class="el" href="classvcl_1_1StaticGrid.html">StaticGrid</a>&lt; <a class="el" href="classvcl_1_1RegularGrid.html">RegularGrid</a>&lt; typename It::value_type, It::value_type::DIM &gt;, typename It::value_type::ScalarType &gt;</td></tr>
<tr class="separator:a7586ced2cedb8cd2aa668c8136b24603"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6d4557abc45cc5daf2fe2e389b91ce9"><td class="memTemplParams" colspan="2">template&lt;VertexPointerRangeConcept Rng&gt; </td></tr>
<tr class="memitem:ae6d4557abc45cc5daf2fe2e389b91ce9"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ae6d4557abc45cc5daf2fe2e389b91ce9">StaticGrid</a> (Rng) -&gt; <a class="el" href="classvcl_1_1StaticGrid.html">StaticGrid</a>&lt; <a class="el" href="classvcl_1_1RegularGrid.html">RegularGrid</a>&lt; typename std::remove_pointer_t&lt; typename std::ranges::iterator_t&lt; Rng &gt;::value_type &gt;::CoordType::ScalarType, 3 &gt;, typename std::ranges::iterator_t&lt; Rng &gt;::value_type &gt;</td></tr>
<tr class="separator:ae6d4557abc45cc5daf2fe2e389b91ce9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7606be147f292f38e1e22a709708a19"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ab7606be147f292f38e1e22a709708a19"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ab7606be147f292f38e1e22a709708a19">KDTree</a> (const MeshType &amp;m) -&gt; <a class="el" href="classvcl_1_1KDTree.html">KDTree</a>&lt; typename MeshType::VertexType::CoordType &gt;</td></tr>
<tr class="separator:ab7606be147f292f38e1e22a709708a19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1ec171b583b3872ae8b1b5e6a513b49"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ab1ec171b583b3872ae8b1b5e6a513b49"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ab1ec171b583b3872ae8b1b5e6a513b49">KDTree</a> (const MeshType &amp;m, <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> pointsPerCell) -&gt; <a class="el" href="classvcl_1_1KDTree.html">KDTree</a>&lt; typename MeshType::VertexType::CoordType &gt;</td></tr>
<tr class="separator:ab1ec171b583b3872ae8b1b5e6a513b49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5c4a6423ece2f30e5d81a3f5b0026b9"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ae5c4a6423ece2f30e5d81a3f5b0026b9"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ae5c4a6423ece2f30e5d81a3f5b0026b9">KDTree</a> (const MeshType &amp;m, <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> pointsPerCell, <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> maxDepth) -&gt; <a class="el" href="classvcl_1_1KDTree.html">KDTree</a>&lt; typename MeshType::VertexType::CoordType &gt;</td></tr>
<tr class="separator:ae5c4a6423ece2f30e5d81a3f5b0026b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9e8e92d81c40489de3567c10b3db44c"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ae9e8e92d81c40489de3567c10b3db44c"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ae9e8e92d81c40489de3567c10b3db44c">KDTree</a> (const MeshType &amp;m, <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> pointsPerCell, <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> maxDepth, bool balanced) -&gt; <a class="el" href="classvcl_1_1KDTree.html">KDTree</a>&lt; typename MeshType::VertexType::CoordType &gt;</td></tr>
<tr class="separator:ae9e8e92d81c40489de3567c10b3db44c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25bd91133ba21843329a21218fa52069"><td class="memTemplParams" colspan="2">template&lt;EigenMatrixConcept MatrixType, PointConcept PointType&gt; <br />
requires ( MatrixType::RowsAtCompileTime == PointType::DIM &amp;&amp; MatrixType::ColsAtCompileTime == PointType::DIM)</td></tr>
<tr class="memitem:a25bd91133ba21843329a21218fa52069"><td class="memTemplItemLeft" align="right" valign="top">PointType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a25bd91133ba21843329a21218fa52069">operator*</a> (const MatrixType &amp;m, const PointType &amp;p)</td></tr>
<tr class="memdesc:a25bd91133ba21843329a21218fa52069"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies a matrix and a point.  <br /></td></tr>
<tr class="separator:a25bd91133ba21843329a21218fa52069"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2b5fc956b8e7b0ed2fe7f1846a6a74d"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> N&gt; </td></tr>
<tr class="memitem:aa2b5fc956b8e7b0ed2fe7f1846a6a74d"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#aa2b5fc956b8e7b0ed2fe7f1846a6a74d">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classvcl_1_1Point.html">Point</a>&lt; Scalar, N &gt; &amp;p1)</td></tr>
<tr class="memdesc:aa2b5fc956b8e7b0ed2fe7f1846a6a74d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes this point to an output stream.  <br /></td></tr>
<tr class="separator:aa2b5fc956b8e7b0ed2fe7f1846a6a74d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf860b9816e4dc7fc87d0bf27aaa0670"><td class="memTemplParams" colspan="2">template&lt;typename S , typename... Scalars&gt; </td></tr>
<tr class="memitem:aaf860b9816e4dc7fc87d0bf27aaa0670"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#aaf860b9816e4dc7fc87d0bf27aaa0670">Point</a> (S, Scalars... scalars) -&gt; <a class="el" href="classvcl_1_1Point.html">Point</a>&lt; S, sizeof...(Scalars)+1 &gt;</td></tr>
<tr class="separator:aaf860b9816e4dc7fc87d0bf27aaa0670"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a1a624c7abe7c703618b7f512c33039"><td class="memTemplParams" colspan="2">template&lt;Point3Concept P, typename T &gt; </td></tr>
<tr class="memitem:a0a1a624c7abe7c703618b7f512c33039"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a0a1a624c7abe7c703618b7f512c33039">Sphere</a> (P, T) -&gt; <a class="el" href="classvcl_1_1Sphere.html">Sphere</a>&lt; typename P::ScalarType &gt;</td></tr>
<tr class="separator:a0a1a624c7abe7c703618b7f512c33039"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ca8accd2e2b6881a3b2359e56396e77"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9ca8accd2e2b6881a3b2359e56396e77"><td class="memTemplItemLeft" align="right" valign="top">constexpr T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a9ca8accd2e2b6881a3b2359e56396e77">asConst</a> (const T &amp;value) noexcept</td></tr>
<tr class="separator:a9ca8accd2e2b6881a3b2359e56396e77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a943a3fda661e6e71d8fd7106f41dd878"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a943a3fda661e6e71d8fd7106f41dd878"><td class="memTemplItemLeft" align="right" valign="top">constexpr T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a943a3fda661e6e71d8fd7106f41dd878">asConst</a> (const T *value) noexcept</td></tr>
<tr class="separator:a943a3fda661e6e71d8fd7106f41dd878"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe5c457181ae725f99627c541993a3a8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:abe5c457181ae725f99627c541993a3a8"><td class="memTemplItemLeft" align="right" valign="top">constexpr T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#abe5c457181ae725f99627c541993a3a8">asConst</a> (T *value) noexcept</td></tr>
<tr class="separator:abe5c457181ae725f99627c541993a3a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58e916cd5d73eca35e6f8ae1be248637"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a58e916cd5d73eca35e6f8ae1be248637"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a58e916cd5d73eca35e6f8ae1be248637">asConst</a> (const T &amp;&amp;)=delete</td></tr>
<tr class="separator:a58e916cd5d73eca35e6f8ae1be248637"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86d50e779d2b4fd59e31de5a48e6d112"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> COMP_ID&gt; </td></tr>
<tr class="memitem:a86d50e779d2b4fd59e31de5a48e6d112"><td class="memTemplItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a86d50e779d2b4fd59e31de5a48e6d112">componentEnumString</a> ()</td></tr>
<tr class="memdesc:a86d50e779d2b4fd59e31de5a48e6d112"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the string associated to the COMP_ID value.  <br /></td></tr>
<tr class="separator:a86d50e779d2b4fd59e31de5a48e6d112"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b16b64a5d64ed8cf8ef24f9a0639562"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> ELEM_ID&gt; </td></tr>
<tr class="memitem:a9b16b64a5d64ed8cf8ef24f9a0639562"><td class="memTemplItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a9b16b64a5d64ed8cf8ef24f9a0639562">elementEnumString</a> ()</td></tr>
<tr class="separator:a9b16b64a5d64ed8cf8ef24f9a0639562"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aada6c7f7d741d8f7885af287bcc6f746"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aada6c7f7d741d8f7885af287bcc6f746"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#aada6c7f7d741d8f7885af287bcc6f746">dereferencePtr</a> (T &amp;&amp;obj)</td></tr>
<tr class="memdesc:aada6c7f7d741d8f7885af287bcc6f746"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function that applies the unary operator '*' to the argument only if the object is a pointer.  <br /></td></tr>
<tr class="separator:aada6c7f7d741d8f7885af287bcc6f746"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae32401c3c5edbdeead1769b4d6160f87"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae32401c3c5edbdeead1769b4d6160f87"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ae32401c3c5edbdeead1769b4d6160f87">addressOfObj</a> (T &amp;obj)</td></tr>
<tr class="memdesc:ae32401c3c5edbdeead1769b4d6160f87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function that applies the unary operator '&amp;' to the argument only if it is not a pointer.  <br /></td></tr>
<tr class="separator:ae32401c3c5edbdeead1769b4d6160f87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae01694fdca8b252384be3296f82fa946"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename... Us&gt; </td></tr>
<tr class="memitem:ae01694fdca8b252384be3296f82fa946"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ae01694fdca8b252384be3296f82fa946">indexInTypePack</a> ()</td></tr>
<tr class="separator:ae01694fdca8b252384be3296f82fa946"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac398b3cd16575f92ffc3e6cfd6ba1669"><td class="memTemplParams" colspan="2">template&lt;typename U , typename... Us&gt; </td></tr>
<tr class="memitem:ac398b3cd16575f92ffc3e6cfd6ba1669"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ac398b3cd16575f92ffc3e6cfd6ba1669">indexInTypePack</a> (std::type_index ti)</td></tr>
<tr class="separator:ac398b3cd16575f92ffc3e6cfd6ba1669"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6ce6ce1ca6a9813f3437aa0aeee2d94"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:ad6ce6ce1ca6a9813f3437aa0aeee2d94"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ad6ce6ce1ca6a9813f3437aa0aeee2d94">indexInTypePack</a> (std::type_index ti, <a class="el" href="structvcl_1_1TypeWrapper.html">TypeWrapper</a>&lt; Args... &gt;)</td></tr>
<tr class="separator:ad6ce6ce1ca6a9813f3437aa0aeee2d94"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga3377e3c875ec245e90ac5a395105ce99"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classvcl_1_1NullLogger.html">NullLogger</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__miscellaneous.html#ga3377e3c875ec245e90ac5a395105ce99">nullLogger</a></td></tr>
<tr class="memdesc:ga3377e3c875ec245e90ac5a395105ce99"><td class="mdescLeft">&#160;</td><td class="mdescRight">The static nullLogger object is an object of type <a class="el" href="classvcl_1_1NullLogger.html" title="The NullLogger class is an empty class that is used as default type in all the library functions that...">NullLogger</a> that is used as default argument in the functions that can take as input a logger.  <br /></td></tr>
<tr class="separator:ga3377e3c875ec245e90ac5a395105ce99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a519b68bed74d2385e33a29e725601002"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a519b68bed74d2385e33a29e725601002">UINT_NULL</a> = std::numeric_limits&lt;<a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a>&gt;<a class="el" href="namespacevcl.html#a69cc63a5ad2974d082145ed1dee7846b">::max</a>()</td></tr>
<tr class="separator:a519b68bed74d2385e33a29e725601002"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb0898aa5c2f881895bf9bb13782ca7a"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#aeb0898aa5c2f881895bf9bb13782ca7a">COMPONENTS_NUMBER</a> = 19</td></tr>
<tr class="separator:aeb0898aa5c2f881895bf9bb13782ca7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade68ad454a7ebe0c36e50f8db6191baa"><td class="memItemLeft" align="right" valign="top">static constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#ade68ad454a7ebe0c36e50f8db6191baa">COMPONENT_ENUM_STRINGS</a> [<a class="el" href="namespacevcl.html#aeb0898aa5c2f881895bf9bb13782ca7a">COMPONENTS_NUMBER</a>]</td></tr>
<tr class="separator:ade68ad454a7ebe0c36e50f8db6191baa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3223af8226ed14333c89406bcc16693"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#aa3223af8226ed14333c89406bcc16693">ELEMENTS_NUMBER</a> = 3</td></tr>
<tr class="separator:aa3223af8226ed14333c89406bcc16693"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53b0be19fd1313a6d531a0fd1ce629f0"><td class="memItemLeft" align="right" valign="top">static constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevcl.html#a53b0be19fd1313a6d531a0fd1ce629f0">ELEMENT_ENUM_STRINGS</a> [<a class="el" href="namespacevcl.html#aa3223af8226ed14333c89406bcc16693">ELEMENTS_NUMBER</a>]</td></tr>
<tr class="separator:a53b0be19fd1313a6d531a0fd1ce629f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ad892770b57d7187fe007fc5c7b8e28c6" name="ad892770b57d7187fe007fc5c7b8e28c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad892770b57d7187fe007fc5c7b8e28c6">&#9670;&#160;</a></span>Box2</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename S &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevcl.html#ad892770b57d7187fe007fc5c7b8e28c6">vcl::Box2</a> = typedef <a class="el" href="classvcl_1_1Box.html">Box</a>&lt;<a class="el" href="group__space.html#ga6d15a5d1bc87330938ae9b8a55373334">Point2</a>&lt;S&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a77d7b12e8258d508469b505f056917f1" name="a77d7b12e8258d508469b505f056917f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77d7b12e8258d508469b505f056917f1">&#9670;&#160;</a></span>Box2d</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevcl.html#a77d7b12e8258d508469b505f056917f1">vcl::Box2d</a> = typedef <a class="el" href="classvcl_1_1Box.html">Box</a>&lt;<a class="el" href="group__space.html#ga4b02e85ff4d51fe7d689f8dd0e87ecd5">Point2d</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae6dc1589c361fc5f1b6444b74aae377d" name="ae6dc1589c361fc5f1b6444b74aae377d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6dc1589c361fc5f1b6444b74aae377d">&#9670;&#160;</a></span>Box2f</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevcl.html#ae6dc1589c361fc5f1b6444b74aae377d">vcl::Box2f</a> = typedef <a class="el" href="classvcl_1_1Box.html">Box</a>&lt;<a class="el" href="group__space.html#gac9560ad588438ce539ec3fdc5658746a">Point2f</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a43d66b66fa1219da110325fc3c9020f9" name="a43d66b66fa1219da110325fc3c9020f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43d66b66fa1219da110325fc3c9020f9">&#9670;&#160;</a></span>Box2i</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevcl.html#a43d66b66fa1219da110325fc3c9020f9">vcl::Box2i</a> = typedef <a class="el" href="classvcl_1_1Box.html">Box</a>&lt;<a class="el" href="group__space.html#ga94bdb300286f9b4bf31987102e011f8d">Point2i</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6539e58b4183d50e78e631047cd7ad12" name="a6539e58b4183d50e78e631047cd7ad12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6539e58b4183d50e78e631047cd7ad12">&#9670;&#160;</a></span>Box3</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename S &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevcl.html#a6539e58b4183d50e78e631047cd7ad12">vcl::Box3</a> = typedef <a class="el" href="classvcl_1_1Box.html">Box</a>&lt;<a class="el" href="group__space.html#ga13f2718b0763def563b8bd9f65982833">Point3</a>&lt;S&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4d5a81b5a74bca25157b2bf0de2c3f6d" name="a4d5a81b5a74bca25157b2bf0de2c3f6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d5a81b5a74bca25157b2bf0de2c3f6d">&#9670;&#160;</a></span>Box3d</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevcl.html#a4d5a81b5a74bca25157b2bf0de2c3f6d">vcl::Box3d</a> = typedef <a class="el" href="classvcl_1_1Box.html">Box</a>&lt;<a class="el" href="group__space.html#gabb47c1364fb2fe1464a54417684f011e">Point3d</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad03a804ee48eb9b3cd5aaf47f7641b3f" name="ad03a804ee48eb9b3cd5aaf47f7641b3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad03a804ee48eb9b3cd5aaf47f7641b3f">&#9670;&#160;</a></span>Box3f</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevcl.html#ad03a804ee48eb9b3cd5aaf47f7641b3f">vcl::Box3f</a> = typedef <a class="el" href="classvcl_1_1Box.html">Box</a>&lt;<a class="el" href="group__space.html#gae19b0e9639a4f90c91e46910ee66f54c">Point3f</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a84825556201de0537b996b08d1f8aeca" name="a84825556201de0537b996b08d1f8aeca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84825556201de0537b996b08d1f8aeca">&#9670;&#160;</a></span>Box3i</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevcl.html#a84825556201de0537b996b08d1f8aeca">vcl::Box3i</a> = typedef <a class="el" href="classvcl_1_1Box.html">Box</a>&lt;<a class="el" href="group__space.html#ga54b0dffe79fabd0458fc78332c91e73a">Point3i</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae166b0242a891e25bde6507bf6776730" name="ae166b0242a891e25bde6507bf6776730"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae166b0242a891e25bde6507bf6776730">&#9670;&#160;</a></span>ConstCustomComponentVectorHandle</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevcl.html#ae166b0242a891e25bde6507bf6776730">vcl::ConstCustomComponentVectorHandle</a> = typedef <a class="el" href="classvcl_1_1CustomComponentVectorHandle.html">CustomComponentVectorHandle</a>&lt;const T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a70592efcf2670361a337c528b34e4dfb" name="a70592efcf2670361a337c528b34e4dfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70592efcf2670361a337c528b34e4dfb">&#9670;&#160;</a></span>ConstEdgeAdjFaceIterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FaceType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevcl.html#a70592efcf2670361a337c528b34e4dfb">vcl::ConstEdgeAdjFaceIterator</a> = typedef <a class="el" href="classvcl_1_1EdgeAdjFaceIterator.html">EdgeAdjFaceIterator</a>&lt;FaceType, true&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa909fb65065f7aa1f08e7ae17265653d" name="aa909fb65065f7aa1f08e7ae17265653d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa909fb65065f7aa1f08e7ae17265653d">&#9670;&#160;</a></span>ConstElementContainerIterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename, typename... &gt; typename Container, typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevcl.html#aa909fb65065f7aa1f08e7ae17265653d">vcl::ConstElementContainerIterator</a> = typedef <a class="el" href="classvcl_1_1ElementContainerIterator.html">ElementContainerIterator</a>&lt;Container, T, true&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af12c15595ec95998920b3ded3c1a8dbf" name="af12c15595ec95998920b3ded3c1a8dbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af12c15595ec95998920b3ded3c1a8dbf">&#9670;&#160;</a></span>ConstVertexSampler</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;VertexConcept VertexType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevcl.html#af12c15595ec95998920b3ded3c1a8dbf">vcl::ConstVertexSampler</a> = typedef internal::VertexSampler&lt;VertexType, true&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aadd5d4f0adc881097d2c62b003a449cc" name="aadd5d4f0adc881097d2c62b003a449cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadd5d4f0adc881097d2c62b003a449cc">&#9670;&#160;</a></span>EdgeMesh</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevcl.html#aadd5d4f0adc881097d2c62b003a449cc">vcl::EdgeMesh</a> = typedef <a class="el" href="classvcl_1_1EdgeMeshT.html">EdgeMeshT</a>&lt;double&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acbb0bc2af8032a1d07969e3785645a9c" name="acbb0bc2af8032a1d07969e3785645a9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbb0bc2af8032a1d07969e3785645a9c">&#9670;&#160;</a></span>EdgeMeshf</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevcl.html#acbb0bc2af8032a1d07969e3785645a9c">vcl::EdgeMeshf</a> = typedef <a class="el" href="classvcl_1_1EdgeMeshT.html">EdgeMeshT</a>&lt;float&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a85b2f3d72f837560dc3dac7b128dd286" name="a85b2f3d72f837560dc3dac7b128dd286"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85b2f3d72f837560dc3dac7b128dd286">&#9670;&#160;</a></span>HashTableGrid2</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename ScalarType  = double, bool AllowDuplicates = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevcl.html#a85b2f3d72f837560dc3dac7b128dd286">vcl::HashTableGrid2</a> = typedef <a class="el" href="classvcl_1_1HashTableGrid.html">HashTableGrid</a>&lt;<a class="el" href="namespacevcl.html#acf35775c9f8314906299b1b19f6c5f9b">RegularGrid2</a>&lt;ScalarType&gt;, ValueType, AllowDuplicates&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4258b9247c46311b39535faa3c2cfaa7" name="a4258b9247c46311b39535faa3c2cfaa7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4258b9247c46311b39535faa3c2cfaa7">&#9670;&#160;</a></span>HashTableGrid3</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename ScalarType  = double, bool AllowDuplicates = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevcl.html#a4258b9247c46311b39535faa3c2cfaa7">vcl::HashTableGrid3</a> = typedef <a class="el" href="classvcl_1_1HashTableGrid.html">HashTableGrid</a>&lt;<a class="el" href="namespacevcl.html#a8d7cc878c7f7ccb25c576ebf7ad2df5b">RegularGrid3</a>&lt;ScalarType&gt;, ValueType, AllowDuplicates&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7eaa15c791dc5118a8eea9677c6ba9b7" name="a7eaa15c791dc5118a8eea9677c6ba9b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7eaa15c791dc5118a8eea9677c6ba9b7">&#9670;&#160;</a></span>Histogramd</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevcl.html#a7eaa15c791dc5118a8eea9677c6ba9b7">vcl::Histogramd</a> = typedef <a class="el" href="classvcl_1_1Histogram.html">Histogram</a>&lt;double&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a294d3a64b949108ec1f6381b950945e9" name="a294d3a64b949108ec1f6381b950945e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a294d3a64b949108ec1f6381b950945e9">&#9670;&#160;</a></span>Histogramf</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevcl.html#a294d3a64b949108ec1f6381b950945e9">vcl::Histogramf</a> = typedef <a class="el" href="classvcl_1_1Histogram.html">Histogram</a>&lt;float&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aca4b0f0c23a3bd7ad471022123a5a0d8" name="aca4b0f0c23a3bd7ad471022123a5a0d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca4b0f0c23a3bd7ad471022123a5a0d8">&#9670;&#160;</a></span>IsDerivedFromTemplateSpecialization</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename derived , template&lt; typename... &gt; class base&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevcl.html#aca4b0f0c23a3bd7ad471022123a5a0d8">vcl::IsDerivedFromTemplateSpecialization</a> = typedef std::invoke_result&lt; internal::IsDerivedFromImplementation&lt;base&gt;, typename std::remove_cv&lt;derived&gt;::type*&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a707bb169c4d4cafd5d84170b495721dc" name="a707bb169c4d4cafd5d84170b495721dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a707bb169c4d4cafd5d84170b495721dc">&#9670;&#160;</a></span>Matrix33</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevcl.html#a707bb169c4d4cafd5d84170b495721dc">vcl::Matrix33</a> = typedef Eigen::Matrix&lt;Scalar, 3, 3&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a21e274a73f9088730a856902ede6ee37" name="a21e274a73f9088730a856902ede6ee37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21e274a73f9088730a856902ede6ee37">&#9670;&#160;</a></span>Matrix33d</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevcl.html#a21e274a73f9088730a856902ede6ee37">vcl::Matrix33d</a> = typedef <a class="el" href="namespacevcl.html#a707bb169c4d4cafd5d84170b495721dc">Matrix33</a>&lt;double&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac96c7ac5d789e9dbf055e35fa5a24835" name="ac96c7ac5d789e9dbf055e35fa5a24835"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac96c7ac5d789e9dbf055e35fa5a24835">&#9670;&#160;</a></span>Matrix33f</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevcl.html#ac96c7ac5d789e9dbf055e35fa5a24835">vcl::Matrix33f</a> = typedef <a class="el" href="namespacevcl.html#a707bb169c4d4cafd5d84170b495721dc">Matrix33</a>&lt;float&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa2e70d03403788ee68a3f150a70d8039" name="aa2e70d03403788ee68a3f150a70d8039"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2e70d03403788ee68a3f150a70d8039">&#9670;&#160;</a></span>Matrix33i</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevcl.html#aa2e70d03403788ee68a3f150a70d8039">vcl::Matrix33i</a> = typedef <a class="el" href="namespacevcl.html#a707bb169c4d4cafd5d84170b495721dc">Matrix33</a>&lt;int&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad82a126b390f21b2e9658c73e7a795ee" name="ad82a126b390f21b2e9658c73e7a795ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad82a126b390f21b2e9658c73e7a795ee">&#9670;&#160;</a></span>Matrix44</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevcl.html#ad82a126b390f21b2e9658c73e7a795ee">vcl::Matrix44</a> = typedef Eigen::Matrix&lt;Scalar, 4, 4&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0c9537d456b6db5dc5f2216dfc8bccdc" name="a0c9537d456b6db5dc5f2216dfc8bccdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c9537d456b6db5dc5f2216dfc8bccdc">&#9670;&#160;</a></span>Matrix44d</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevcl.html#a0c9537d456b6db5dc5f2216dfc8bccdc">vcl::Matrix44d</a> = typedef <a class="el" href="namespacevcl.html#ad82a126b390f21b2e9658c73e7a795ee">Matrix44</a>&lt;double&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6891233f7166ae9569a840d151cfe140" name="a6891233f7166ae9569a840d151cfe140"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6891233f7166ae9569a840d151cfe140">&#9670;&#160;</a></span>Matrix44f</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevcl.html#a6891233f7166ae9569a840d151cfe140">vcl::Matrix44f</a> = typedef <a class="el" href="namespacevcl.html#ad82a126b390f21b2e9658c73e7a795ee">Matrix44</a>&lt;float&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af09e528e12eb6fb1fc6e596b46da8beb" name="af09e528e12eb6fb1fc6e596b46da8beb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af09e528e12eb6fb1fc6e596b46da8beb">&#9670;&#160;</a></span>Matrix44i</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevcl.html#af09e528e12eb6fb1fc6e596b46da8beb">vcl::Matrix44i</a> = typedef <a class="el" href="namespacevcl.html#ad82a126b390f21b2e9658c73e7a795ee">Matrix44</a>&lt;int&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5b13dcb16a658633be61033f53c3590e" name="a5b13dcb16a658633be61033f53c3590e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b13dcb16a658633be61033f53c3590e">&#9670;&#160;</a></span>NestedInitializerLists</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t L&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevcl.html#a5b13dcb16a658633be61033f53c3590e">vcl::NestedInitializerLists</a> = typedef internal::NestedInitializerListsTraits&lt;T, L&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The NestedInitializerLists class manages nested std::initializer_list&lt;T&gt; types of L levels L must be known at compile time, and compilation will fail if the NestedInitializerLists used does not correspond to the number of used levels. </p>

</div>
</div>
<a id="a08ef90973b043cbb709bec85607f8313" name="a08ef90973b043cbb709bec85607f8313"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08ef90973b043cbb709bec85607f8313">&#9670;&#160;</a></span>Planed</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevcl.html#a08ef90973b043cbb709bec85607f8313">vcl::Planed</a> = typedef <a class="el" href="classvcl_1_1Plane.html">Plane</a>&lt;double&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6fa66e0f1a04578cf69387027e898c8d" name="a6fa66e0f1a04578cf69387027e898c8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fa66e0f1a04578cf69387027e898c8d">&#9670;&#160;</a></span>Planef</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevcl.html#a6fa66e0f1a04578cf69387027e898c8d">vcl::Planef</a> = typedef <a class="el" href="classvcl_1_1Plane.html">Plane</a>&lt;float&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab2939073dbb778a3a2f5d9f93e3fb146" name="ab2939073dbb778a3a2f5d9f93e3fb146"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2939073dbb778a3a2f5d9f93e3fb146">&#9670;&#160;</a></span>PointCloud</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevcl.html#ab2939073dbb778a3a2f5d9f93e3fb146">vcl::PointCloud</a> = typedef <a class="el" href="classvcl_1_1PointCloudT.html">PointCloudT</a>&lt;double&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae1ddd0d2b0a8168f7a6134ed53cd1f3c" name="ae1ddd0d2b0a8168f7a6134ed53cd1f3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1ddd0d2b0a8168f7a6134ed53cd1f3c">&#9670;&#160;</a></span>PointCloudf</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevcl.html#ae1ddd0d2b0a8168f7a6134ed53cd1f3c">vcl::PointCloudf</a> = typedef <a class="el" href="classvcl_1_1PointCloudT.html">PointCloudT</a>&lt;float&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a924ac7eb7740e67b7701c82f079ca13b" name="a924ac7eb7740e67b7701c82f079ca13b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a924ac7eb7740e67b7701c82f079ca13b">&#9670;&#160;</a></span>Polygon2</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevcl.html#a924ac7eb7740e67b7701c82f079ca13b">vcl::Polygon2</a> = typedef <a class="el" href="classvcl_1_1Polygon.html">Polygon</a>&lt;<a class="el" href="group__space.html#ga6d15a5d1bc87330938ae9b8a55373334">Point2</a>&lt;Scalar&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a386fd968f85ff551b4d58e109c21db9a" name="a386fd968f85ff551b4d58e109c21db9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a386fd968f85ff551b4d58e109c21db9a">&#9670;&#160;</a></span>Polygon2d</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevcl.html#a386fd968f85ff551b4d58e109c21db9a">vcl::Polygon2d</a> = typedef <a class="el" href="classvcl_1_1Polygon.html">Polygon</a>&lt;<a class="el" href="group__space.html#ga4b02e85ff4d51fe7d689f8dd0e87ecd5">Point2d</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2d13400e95eb6871c2e4f6169ef08c23" name="a2d13400e95eb6871c2e4f6169ef08c23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d13400e95eb6871c2e4f6169ef08c23">&#9670;&#160;</a></span>Polygon2f</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevcl.html#a2d13400e95eb6871c2e4f6169ef08c23">vcl::Polygon2f</a> = typedef <a class="el" href="classvcl_1_1Polygon.html">Polygon</a>&lt;<a class="el" href="group__space.html#gac9560ad588438ce539ec3fdc5658746a">Point2f</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac04b9a59a6c30f22d15b0d1932e60457" name="ac04b9a59a6c30f22d15b0d1932e60457"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac04b9a59a6c30f22d15b0d1932e60457">&#9670;&#160;</a></span>Polygon3</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevcl.html#ac04b9a59a6c30f22d15b0d1932e60457">vcl::Polygon3</a> = typedef <a class="el" href="classvcl_1_1Polygon.html">Polygon</a>&lt;<a class="el" href="group__space.html#ga13f2718b0763def563b8bd9f65982833">Point3</a>&lt;Scalar&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac010b9e655ca9ca0c32f8c61b1eb56a2" name="ac010b9e655ca9ca0c32f8c61b1eb56a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac010b9e655ca9ca0c32f8c61b1eb56a2">&#9670;&#160;</a></span>Polygon3d</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevcl.html#ac010b9e655ca9ca0c32f8c61b1eb56a2">vcl::Polygon3d</a> = typedef <a class="el" href="classvcl_1_1Polygon.html">Polygon</a>&lt;<a class="el" href="group__space.html#gabb47c1364fb2fe1464a54417684f011e">Point3d</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4a359353bfe1b3e56f12a750b2de4abc" name="a4a359353bfe1b3e56f12a750b2de4abc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a359353bfe1b3e56f12a750b2de4abc">&#9670;&#160;</a></span>Polygon3f</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevcl.html#a4a359353bfe1b3e56f12a750b2de4abc">vcl::Polygon3f</a> = typedef <a class="el" href="classvcl_1_1Polygon.html">Polygon</a>&lt;<a class="el" href="group__space.html#gae19b0e9639a4f90c91e46910ee66f54c">Point3f</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a416d891cfc10982e070d934a5ab00e7b" name="a416d891cfc10982e070d934a5ab00e7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a416d891cfc10982e070d934a5ab00e7b">&#9670;&#160;</a></span>PolyMesh</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevcl.html#a416d891cfc10982e070d934a5ab00e7b">vcl::PolyMesh</a> = typedef <a class="el" href="classvcl_1_1PolyMeshT.html">PolyMeshT</a>&lt;double&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="adde03ea7837ce8e0d2e4e5aef04a1792" name="adde03ea7837ce8e0d2e4e5aef04a1792"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adde03ea7837ce8e0d2e4e5aef04a1792">&#9670;&#160;</a></span>PolyMeshf</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevcl.html#adde03ea7837ce8e0d2e4e5aef04a1792">vcl::PolyMeshf</a> = typedef <a class="el" href="classvcl_1_1PolyMeshT.html">PolyMeshT</a>&lt;float&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acf35775c9f8314906299b1b19f6c5f9b" name="acf35775c9f8314906299b1b19f6c5f9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf35775c9f8314906299b1b19f6c5f9b">&#9670;&#160;</a></span>RegularGrid2</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevcl.html#acf35775c9f8314906299b1b19f6c5f9b">vcl::RegularGrid2</a> = typedef <a class="el" href="classvcl_1_1RegularGrid.html">RegularGrid</a>&lt;Scalar, 2&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8d7cc878c7f7ccb25c576ebf7ad2df5b" name="a8d7cc878c7f7ccb25c576ebf7ad2df5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d7cc878c7f7ccb25c576ebf7ad2df5b">&#9670;&#160;</a></span>RegularGrid3</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevcl.html#a8d7cc878c7f7ccb25c576ebf7ad2df5b">vcl::RegularGrid3</a> = typedef <a class="el" href="classvcl_1_1RegularGrid.html">RegularGrid</a>&lt;Scalar, 3&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8a8e5224d2d66eae96da5ec5f8bd7eb5" name="a8a8e5224d2d66eae96da5ec5f8bd7eb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a8e5224d2d66eae96da5ec5f8bd7eb5">&#9670;&#160;</a></span>RemoveConstFromPointer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevcl.html#a8a8e5224d2d66eae96da5ec5f8bd7eb5">vcl::RemoveConstFromPointer</a> = typedef std::conditional_t&lt;std::is_pointer_v&lt;T&gt;, std::add_pointer_t&lt;typename std::remove_cv_t&lt;typename std::remove_pointer_t&lt;T&gt; &gt;&gt;, T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2ec2f45ee6feff2a4aff0f15d6b0b0b0" name="a2ec2f45ee6feff2a4aff0f15d6b0b0b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ec2f45ee6feff2a4aff0f15d6b0b0b0">&#9670;&#160;</a></span>RemoveCVRefAndPointer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevcl.html#a2ec2f45ee6feff2a4aff0f15d6b0b0b0">vcl::RemoveCVRefAndPointer</a> = typedef typename std::remove_cvref_t&lt;std::remove_pointer_t&lt;T&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af8c7ce5479499796837976d3247e4df8" name="af8c7ce5479499796837976d3247e4df8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8c7ce5479499796837976d3247e4df8">&#9670;&#160;</a></span>Segment2</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename S &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevcl.html#af8c7ce5479499796837976d3247e4df8">vcl::Segment2</a> = typedef <a class="el" href="classvcl_1_1Segment.html">Segment</a>&lt;<a class="el" href="group__space.html#ga6d15a5d1bc87330938ae9b8a55373334">Point2</a>&lt;S&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae5da8472ea5b5275ab7109e52d50af04" name="ae5da8472ea5b5275ab7109e52d50af04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5da8472ea5b5275ab7109e52d50af04">&#9670;&#160;</a></span>Segment2d</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevcl.html#ae5da8472ea5b5275ab7109e52d50af04">vcl::Segment2d</a> = typedef <a class="el" href="classvcl_1_1Segment.html">Segment</a>&lt;<a class="el" href="group__space.html#ga4b02e85ff4d51fe7d689f8dd0e87ecd5">Point2d</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a83dc041e1243c07111706a89433af7a9" name="a83dc041e1243c07111706a89433af7a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83dc041e1243c07111706a89433af7a9">&#9670;&#160;</a></span>Segment2f</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevcl.html#a83dc041e1243c07111706a89433af7a9">vcl::Segment2f</a> = typedef <a class="el" href="classvcl_1_1Segment.html">Segment</a>&lt;<a class="el" href="group__space.html#gac9560ad588438ce539ec3fdc5658746a">Point2f</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9ca08e736f7887a86fa4fc2dd396cdc5" name="a9ca08e736f7887a86fa4fc2dd396cdc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ca08e736f7887a86fa4fc2dd396cdc5">&#9670;&#160;</a></span>Segment2i</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevcl.html#a9ca08e736f7887a86fa4fc2dd396cdc5">vcl::Segment2i</a> = typedef <a class="el" href="classvcl_1_1Segment.html">Segment</a>&lt;<a class="el" href="group__space.html#ga94bdb300286f9b4bf31987102e011f8d">Point2i</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afc9c518fdcc207d621776ebeeedc0db5" name="afc9c518fdcc207d621776ebeeedc0db5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc9c518fdcc207d621776ebeeedc0db5">&#9670;&#160;</a></span>Segment3</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename S &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevcl.html#afc9c518fdcc207d621776ebeeedc0db5">vcl::Segment3</a> = typedef <a class="el" href="classvcl_1_1Segment.html">Segment</a>&lt;<a class="el" href="group__space.html#ga13f2718b0763def563b8bd9f65982833">Point3</a>&lt;S&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a77d6ff7d119b08bd6bc8d5e84b9fe2ec" name="a77d6ff7d119b08bd6bc8d5e84b9fe2ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77d6ff7d119b08bd6bc8d5e84b9fe2ec">&#9670;&#160;</a></span>Segment3d</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevcl.html#a77d6ff7d119b08bd6bc8d5e84b9fe2ec">vcl::Segment3d</a> = typedef <a class="el" href="classvcl_1_1Segment.html">Segment</a>&lt;<a class="el" href="group__space.html#gabb47c1364fb2fe1464a54417684f011e">Point3d</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a01b4f12a5cd0b2470b2abcd9890f1de1" name="a01b4f12a5cd0b2470b2abcd9890f1de1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01b4f12a5cd0b2470b2abcd9890f1de1">&#9670;&#160;</a></span>Segment3f</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevcl.html#a01b4f12a5cd0b2470b2abcd9890f1de1">vcl::Segment3f</a> = typedef <a class="el" href="classvcl_1_1Segment.html">Segment</a>&lt;<a class="el" href="group__space.html#gae19b0e9639a4f90c91e46910ee66f54c">Point3f</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0694142b42086cf347becff6f0db0c9c" name="a0694142b42086cf347becff6f0db0c9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0694142b42086cf347becff6f0db0c9c">&#9670;&#160;</a></span>Segment3i</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevcl.html#a0694142b42086cf347becff6f0db0c9c">vcl::Segment3i</a> = typedef <a class="el" href="classvcl_1_1Segment.html">Segment</a>&lt;<a class="el" href="group__space.html#ga54b0dffe79fabd0458fc78332c91e73a">Point3i</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a125a3b42c101ab958048c730060aa8c8" name="a125a3b42c101ab958048c730060aa8c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a125a3b42c101ab958048c730060aa8c8">&#9670;&#160;</a></span>Sphered</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevcl.html#a125a3b42c101ab958048c730060aa8c8">vcl::Sphered</a> = typedef <a class="el" href="classvcl_1_1Sphere.html">Sphere</a>&lt;double&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a918b0af3e76ff4b82da382ddfab126d0" name="a918b0af3e76ff4b82da382ddfab126d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a918b0af3e76ff4b82da382ddfab126d0">&#9670;&#160;</a></span>Spheref</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevcl.html#a918b0af3e76ff4b82da382ddfab126d0">vcl::Spheref</a> = typedef <a class="el" href="classvcl_1_1Sphere.html">Sphere</a>&lt;float&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2bbbace04824cfa901027d8e90d830c6" name="a2bbbace04824cfa901027d8e90d830c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bbbace04824cfa901027d8e90d830c6">&#9670;&#160;</a></span>StaticGrid2</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename ScalarType  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevcl.html#a2bbbace04824cfa901027d8e90d830c6">vcl::StaticGrid2</a> = typedef <a class="el" href="classvcl_1_1StaticGrid.html">StaticGrid</a>&lt;<a class="el" href="namespacevcl.html#acf35775c9f8314906299b1b19f6c5f9b">RegularGrid2</a>&lt;ScalarType&gt;, ValueType&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afa27c3398ca14cd8a5a7e1423d7a68cd" name="afa27c3398ca14cd8a5a7e1423d7a68cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa27c3398ca14cd8a5a7e1423d7a68cd">&#9670;&#160;</a></span>StaticGrid3</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename ScalarType  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevcl.html#afa27c3398ca14cd8a5a7e1423d7a68cd">vcl::StaticGrid3</a> = typedef <a class="el" href="classvcl_1_1StaticGrid.html">StaticGrid</a>&lt;<a class="el" href="namespacevcl.html#a8d7cc878c7f7ccb25c576ebf7ad2df5b">RegularGrid3</a>&lt;ScalarType&gt;, ValueType&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aec42e251f09249cda2fe0463b81c0f79" name="aec42e251f09249cda2fe0463b81c0f79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec42e251f09249cda2fe0463b81c0f79">&#9670;&#160;</a></span>TexCoordd</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevcl.html#aec42e251f09249cda2fe0463b81c0f79">vcl::TexCoordd</a> = typedef <a class="el" href="classvcl_1_1TexCoord.html">TexCoord</a>&lt;double&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6ccd8e32ef2f6bf0decb43463f41fb2b" name="a6ccd8e32ef2f6bf0decb43463f41fb2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ccd8e32ef2f6bf0decb43463f41fb2b">&#9670;&#160;</a></span>TexCoordf</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevcl.html#a6ccd8e32ef2f6bf0decb43463f41fb2b">vcl::TexCoordf</a> = typedef <a class="el" href="classvcl_1_1TexCoord.html">TexCoord</a>&lt;float&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a917984925513fc8634c94e269ee0cf82" name="a917984925513fc8634c94e269ee0cf82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a917984925513fc8634c94e269ee0cf82">&#9670;&#160;</a></span>TexCoordi</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevcl.html#a917984925513fc8634c94e269ee0cf82">vcl::TexCoordi</a> = typedef <a class="el" href="classvcl_1_1TexCoord.html">TexCoord</a>&lt;int&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aac0ef38a541827b51057bfae9e8c5039" name="aac0ef38a541827b51057bfae9e8c5039"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac0ef38a541827b51057bfae9e8c5039">&#9670;&#160;</a></span>Triangle2</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevcl.html#aac0ef38a541827b51057bfae9e8c5039">vcl::Triangle2</a> = typedef <a class="el" href="classvcl_1_1Triangle.html">Triangle</a>&lt;<a class="el" href="group__space.html#ga6d15a5d1bc87330938ae9b8a55373334">Point2</a>&lt;Scalar&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8e9344ae874797a2a653deab133d870f" name="a8e9344ae874797a2a653deab133d870f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e9344ae874797a2a653deab133d870f">&#9670;&#160;</a></span>Triangle2d</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevcl.html#a8e9344ae874797a2a653deab133d870f">vcl::Triangle2d</a> = typedef <a class="el" href="classvcl_1_1Triangle.html">Triangle</a>&lt;<a class="el" href="group__space.html#ga4b02e85ff4d51fe7d689f8dd0e87ecd5">Point2d</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad1f6b217d733de32db193f0e751ece25" name="ad1f6b217d733de32db193f0e751ece25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1f6b217d733de32db193f0e751ece25">&#9670;&#160;</a></span>Triangle2f</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevcl.html#ad1f6b217d733de32db193f0e751ece25">vcl::Triangle2f</a> = typedef <a class="el" href="classvcl_1_1Triangle.html">Triangle</a>&lt;<a class="el" href="group__space.html#gac9560ad588438ce539ec3fdc5658746a">Point2f</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae03921c36e8b060269d9ff90b068db39" name="ae03921c36e8b060269d9ff90b068db39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae03921c36e8b060269d9ff90b068db39">&#9670;&#160;</a></span>Triangle3</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevcl.html#ae03921c36e8b060269d9ff90b068db39">vcl::Triangle3</a> = typedef <a class="el" href="classvcl_1_1Triangle.html">Triangle</a>&lt;<a class="el" href="group__space.html#ga13f2718b0763def563b8bd9f65982833">Point3</a>&lt;Scalar&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a02db1e7fb252318c4435c8ca9944401e" name="a02db1e7fb252318c4435c8ca9944401e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02db1e7fb252318c4435c8ca9944401e">&#9670;&#160;</a></span>Triangle3d</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevcl.html#a02db1e7fb252318c4435c8ca9944401e">vcl::Triangle3d</a> = typedef <a class="el" href="classvcl_1_1Triangle.html">Triangle</a>&lt;<a class="el" href="group__space.html#gabb47c1364fb2fe1464a54417684f011e">Point3d</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afa2a67863f5edd83d508344306bd7bb3" name="afa2a67863f5edd83d508344306bd7bb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa2a67863f5edd83d508344306bd7bb3">&#9670;&#160;</a></span>Triangle3f</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevcl.html#afa2a67863f5edd83d508344306bd7bb3">vcl::Triangle3f</a> = typedef <a class="el" href="classvcl_1_1Triangle.html">Triangle</a>&lt;<a class="el" href="group__space.html#gae19b0e9639a4f90c91e46910ee66f54c">Point3f</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a92c93a12005e031d04c92971247414ef" name="a92c93a12005e031d04c92971247414ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92c93a12005e031d04c92971247414ef">&#9670;&#160;</a></span>TriangleWrapper2</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevcl.html#a92c93a12005e031d04c92971247414ef">vcl::TriangleWrapper2</a> = typedef <a class="el" href="classvcl_1_1TriangleWrapper.html">TriangleWrapper</a>&lt;<a class="el" href="group__space.html#ga6d15a5d1bc87330938ae9b8a55373334">Point2</a>&lt;Scalar&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a27931fc2ea467c03c1019dc025d218e5" name="a27931fc2ea467c03c1019dc025d218e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27931fc2ea467c03c1019dc025d218e5">&#9670;&#160;</a></span>TriangleWrapper2d</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevcl.html#a27931fc2ea467c03c1019dc025d218e5">vcl::TriangleWrapper2d</a> = typedef <a class="el" href="classvcl_1_1TriangleWrapper.html">TriangleWrapper</a>&lt;<a class="el" href="group__space.html#ga4b02e85ff4d51fe7d689f8dd0e87ecd5">Point2d</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5ff16ee6b33f9bdd47405cb91f29e2d0" name="a5ff16ee6b33f9bdd47405cb91f29e2d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ff16ee6b33f9bdd47405cb91f29e2d0">&#9670;&#160;</a></span>TriangleWrapper2f</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevcl.html#a5ff16ee6b33f9bdd47405cb91f29e2d0">vcl::TriangleWrapper2f</a> = typedef <a class="el" href="classvcl_1_1TriangleWrapper.html">TriangleWrapper</a>&lt;<a class="el" href="group__space.html#gac9560ad588438ce539ec3fdc5658746a">Point2f</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a439efbe438907a52943d563d8a12daab" name="a439efbe438907a52943d563d8a12daab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a439efbe438907a52943d563d8a12daab">&#9670;&#160;</a></span>TriangleWrapper3</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevcl.html#a439efbe438907a52943d563d8a12daab">vcl::TriangleWrapper3</a> = typedef <a class="el" href="classvcl_1_1TriangleWrapper.html">TriangleWrapper</a>&lt;<a class="el" href="group__space.html#ga13f2718b0763def563b8bd9f65982833">Point3</a>&lt;Scalar&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ace2761031333634f83908ed3d4e5fb19" name="ace2761031333634f83908ed3d4e5fb19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace2761031333634f83908ed3d4e5fb19">&#9670;&#160;</a></span>TriangleWrapper3d</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevcl.html#ace2761031333634f83908ed3d4e5fb19">vcl::TriangleWrapper3d</a> = typedef <a class="el" href="classvcl_1_1TriangleWrapper.html">TriangleWrapper</a>&lt;<a class="el" href="group__space.html#gabb47c1364fb2fe1464a54417684f011e">Point3d</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a295b4c2f1ffcf361e32166b44a5a4476" name="a295b4c2f1ffcf361e32166b44a5a4476"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a295b4c2f1ffcf361e32166b44a5a4476">&#9670;&#160;</a></span>TriangleWrapper3f</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevcl.html#a295b4c2f1ffcf361e32166b44a5a4476">vcl::TriangleWrapper3f</a> = typedef <a class="el" href="classvcl_1_1TriangleWrapper.html">TriangleWrapper</a>&lt;<a class="el" href="group__space.html#gae19b0e9639a4f90c91e46910ee66f54c">Point3f</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2cb93e7b8a1ccd33f76ba2d53ef9ecfa" name="a2cb93e7b8a1ccd33f76ba2d53ef9ecfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cb93e7b8a1ccd33f76ba2d53ef9ecfa">&#9670;&#160;</a></span>VertexSampler</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;VertexConcept VertexType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevcl.html#a2cb93e7b8a1ccd33f76ba2d53ef9ecfa">vcl::VertexSampler</a> = typedef internal::VertexSampler&lt;VertexType, false&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a3f1474ce703c6b063677f747fccaffd6" name="a3f1474ce703c6b063677f747fccaffd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f1474ce703c6b063677f747fccaffd6">&#9670;&#160;</a></span>ComponentIDEnum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacevcl.html#a3f1474ce703c6b063677f747fccaffd6">vcl::ComponentIDEnum</a> : <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a3f1474ce703c6b063677f747fccaffd6a96af186d25705f291379814fe1f2ef8e" name="a3f1474ce703c6b063677f747fccaffd6a96af186d25705f291379814fe1f2ef8e"></a>BIT_FLAGS&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a3f1474ce703c6b063677f747fccaffd6a2518c9b8b4cfd9843ffd5399a2e6f7ad" name="a3f1474ce703c6b063677f747fccaffd6a2518c9b8b4cfd9843ffd5399a2e6f7ad"></a>COORDINATE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a3f1474ce703c6b063677f747fccaffd6a391cebfb461095102db45aca2deac4b1" name="a3f1474ce703c6b063677f747fccaffd6a391cebfb461095102db45aca2deac4b1"></a>NORMAL&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a3f1474ce703c6b063677f747fccaffd6af20ccd0cc636dcdc7ddfdc951bbcff12" name="a3f1474ce703c6b063677f747fccaffd6af20ccd0cc636dcdc7ddfdc951bbcff12"></a>COLOR&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a3f1474ce703c6b063677f747fccaffd6a3ae1b3b0757067aabc1c3c8464e6c3fa" name="a3f1474ce703c6b063677f747fccaffd6a3ae1b3b0757067aabc1c3c8464e6c3fa"></a>QUALITY&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a3f1474ce703c6b063677f747fccaffd6ad37ecc06b487f1e4b2c4dec7091029a2" name="a3f1474ce703c6b063677f747fccaffd6ad37ecc06b487f1e4b2c4dec7091029a2"></a>MARK&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a3f1474ce703c6b063677f747fccaffd6afb61ac208cf6f113d02518e9d2db513c" name="a3f1474ce703c6b063677f747fccaffd6afb61ac208cf6f113d02518e9d2db513c"></a>PRINCIPAL_CURVATURE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a3f1474ce703c6b063677f747fccaffd6a301ae6d835b1530434994e44cc5beebc" name="a3f1474ce703c6b063677f747fccaffd6a301ae6d835b1530434994e44cc5beebc"></a>TEX_COORD&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a3f1474ce703c6b063677f747fccaffd6a848ff528789e6d6d1590fbe406f6e7ca" name="a3f1474ce703c6b063677f747fccaffd6a848ff528789e6d6d1590fbe406f6e7ca"></a>VERTEX_PTRS&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a3f1474ce703c6b063677f747fccaffd6ae8d3db0b18558b89d3fad8cfbbf3baf0" name="a3f1474ce703c6b063677f747fccaffd6ae8d3db0b18558b89d3fad8cfbbf3baf0"></a>ADJACENT_EDGES&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a3f1474ce703c6b063677f747fccaffd6a66fc76888ade90ce07ebb705d0b2af9c" name="a3f1474ce703c6b063677f747fccaffd6a66fc76888ade90ce07ebb705d0b2af9c"></a>ADJACENT_FACES&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a3f1474ce703c6b063677f747fccaffd6a05010a40c6adc052d230f646106fdc3c" name="a3f1474ce703c6b063677f747fccaffd6a05010a40c6adc052d230f646106fdc3c"></a>ADJACENT_VERTICES&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a3f1474ce703c6b063677f747fccaffd6afdd8a9baf552cee157a83240111b5317" name="a3f1474ce703c6b063677f747fccaffd6afdd8a9baf552cee157a83240111b5317"></a>WEDGE_COLORS&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a3f1474ce703c6b063677f747fccaffd6a9ca2b21f4e6c633fd482276d1979b497" name="a3f1474ce703c6b063677f747fccaffd6a9ca2b21f4e6c633fd482276d1979b497"></a>WEDGE_TEX_COORDS&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a3f1474ce703c6b063677f747fccaffd6a4388f6baca6989c69c0bacf41a28bb37" name="a3f1474ce703c6b063677f747fccaffd6a4388f6baca6989c69c0bacf41a28bb37"></a>BOUNDING_BOX&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a3f1474ce703c6b063677f747fccaffd6aaa06362739c3118aa022cd54160245f0" name="a3f1474ce703c6b063677f747fccaffd6aaa06362739c3118aa022cd54160245f0"></a>NAME&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a3f1474ce703c6b063677f747fccaffd6a242ce2627ed5591d7913c3485b5e0f41" name="a3f1474ce703c6b063677f747fccaffd6a242ce2627ed5591d7913c3485b5e0f41"></a>TEXTURE_PATHS&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a3f1474ce703c6b063677f747fccaffd6aba543e5ee5048450527106b123686aa8" name="a3f1474ce703c6b063677f747fccaffd6aba543e5ee5048450527106b123686aa8"></a>TRANSFORM_MATRIX&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a3f1474ce703c6b063677f747fccaffd6a14a144ed134908cae680884da549edfa" name="a3f1474ce703c6b063677f747fccaffd6a14a144ed134908cae680884da549edfa"></a>CUSTOM_COMPONENTS&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="ae046f7dd555ae870338041167e1fcb72" name="ae046f7dd555ae870338041167e1fcb72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae046f7dd555ae870338041167e1fcb72">&#9670;&#160;</a></span>ElementIDEnum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacevcl.html#ae046f7dd555ae870338041167e1fcb72">vcl::ElementIDEnum</a> : <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ae046f7dd555ae870338041167e1fcb72a2b976bb23bc172fe0c729ce8f367b76e" name="ae046f7dd555ae870338041167e1fcb72a2b976bb23bc172fe0c729ce8f367b76e"></a>VERTEX&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ae046f7dd555ae870338041167e1fcb72a0deacef785932de145d594f20e312b58" name="ae046f7dd555ae870338041167e1fcb72a0deacef785932de145d594f20e312b58"></a>FACE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ae046f7dd555ae870338041167e1fcb72a277eb4b09247da79fe02b8a334452e67" name="ae046f7dd555ae870338041167e1fcb72a277eb4b09247da79fe02b8a334452e67"></a>EDGE&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a5a4e8376b2d47797f9167f2a8dd6fb0e" name="a5a4e8376b2d47797f9167f2a8dd6fb0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a4e8376b2d47797f9167f2a8dd6fb0e">&#9670;&#160;</a></span>HausdorffSamplingMethod</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacevcl.html#a5a4e8376b2d47797f9167f2a8dd6fb0e">vcl::HausdorffSamplingMethod</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a5a4e8376b2d47797f9167f2a8dd6fb0ea33aad0431cadce18cad82201cb732f49" name="a5a4e8376b2d47797f9167f2a8dd6fb0ea33aad0431cadce18cad82201cb732f49"></a>HAUSDORFF_VERTEX_UNIFORM&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a5a4e8376b2d47797f9167f2a8dd6fb0eac8770691ceb41b51c7ab63b70f1da9c6" name="a5a4e8376b2d47797f9167f2a8dd6fb0eac8770691ceb41b51c7ab63b70f1da9c6"></a>HAUSDORFF_EDGE_UNIFORM&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a5a4e8376b2d47797f9167f2a8dd6fb0eaf9d0153b4af81b71be3972e5a9e3307a" name="a5a4e8376b2d47797f9167f2a8dd6fb0eaf9d0153b4af81b71be3972e5a9e3307a"></a>HAUSDORFF_MONTECARLO&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="aaca879a6bfd47ff8429d6b2f6cfa9440" name="aaca879a6bfd47ff8429d6b2f6cfa9440"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaca879a6bfd47ff8429d6b2f6cfa9440">&#9670;&#160;</a></span>VCLibPrincipalCurvatureAlgorithm</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacevcl.html#aaca879a6bfd47ff8429d6b2f6cfa9440">vcl::VCLibPrincipalCurvatureAlgorithm</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aaca879a6bfd47ff8429d6b2f6cfa9440a16e818963316b0b43fcbdec6d75f25ed" name="aaca879a6bfd47ff8429d6b2f6cfa9440a16e818963316b0b43fcbdec6d75f25ed"></a>VCL_PRINCIPAL_CURVATURE_TAUBIN95&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aaca879a6bfd47ff8429d6b2f6cfa9440a2c812dad0f96c382657b60bb2d2f8180" name="aaca879a6bfd47ff8429d6b2f6cfa9440a2c812dad0f96c382657b60bb2d2f8180"></a>VCL_PRINCIPAL_CURVATURE_PCA&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a338dea159760ae814dc6e78425e284a1" name="a338dea159760ae814dc6e78425e284a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a338dea159760ae814dc6e78425e284a1">&#9670;&#160;</a></span>_check_gl_error()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vcl::_check_gl_error </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>line</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae32401c3c5edbdeead1769b4d6160f87" name="ae32401c3c5edbdeead1769b4d6160f87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae32401c3c5edbdeead1769b4d6160f87">&#9670;&#160;</a></span>addressOfObj()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto vcl::addressOfObj </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Utility function that applies the unary operator '&amp;' to the argument only if it is not a pointer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the address of 'obj' if obj is not a pointer, or obj if it is a pointer. </dd></dl>

</div>
</div>
<a id="acad48a316f6b47d2ce4fa978be50a97e" name="acad48a316f6b47d2ce4fa978be50a97e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acad48a316f6b47d2ce4fa978be50a97e">&#9670;&#160;</a></span>addTriangleFacesFromPolygon() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> vcl::addTriangleFacesFromPolygon </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>polygon</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a vector of indices of vertices in a mesh representing a polyon, this function adds N triangular faces to the mesh, that are the triangulation of the input polygon. <a class="el" href="classvcl_1_1Triangle.html">Triangle</a> edges that are internal in the polygon are marked as faux. This function returns the index of the first added triangle. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classvcl_1_1BadVertexIndexException.html">BadVertexIndexException</a></td><td>if there is a vertex index in the polygon that is out of range, or that references a vertex that results deleted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MeshType</td><td>the type of the face that satisfies the FaceMeshConcept.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">m</td><td>the mesh on which add the triangulation of the polygon. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">polygon</td><td>the vertex indices in the mesh representing the polygon. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the first triangle added to the mesh. </dd></dl>

</div>
</div>
<a id="aab5bd336ab6b6a6138f89ffbb56ef3b5" name="aab5bd336ab6b6a6138f89ffbb56ef3b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab5bd336ab6b6a6138f89ffbb56ef3b5">&#9670;&#160;</a></span>addTriangleFacesFromPolygon() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType, FaceConcept FaceType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::addTriangleFacesFromPolygon </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FaceType &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>polygon</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a vector of indices of vertices in a mesh representing a polyon, this function adds N triangular faces to the mesh, that are the triangulation of the input polygon. <a class="el" href="classvcl_1_1Triangle.html">Triangle</a> edges that are internal in the polygon are marked as faux. </p>
<p>This function assumes that the first (triangular) face has been already added to the mesh and just needs to be filled with vertex references. This is useful in some cases (e.g. when reading from file and you realize just at some point that you need to manage a polygon). In all the other cases, you should use the function that does not take a face in input, that is:</p>
<div class="fragment"><div class="line"><a class="code hl_typedef" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> fid = <a class="code hl_function" href="namespacevcl.html#aab5bd336ab6b6a6138f89ffbb56ef3b5">addTriangleFacesFromPolygon</a>(mesh, polygon);</div>
<div class="ttc" id="anamespacevcl_html_aab5bd336ab6b6a6138f89ffbb56ef3b5"><div class="ttname"><a href="namespacevcl.html#aab5bd336ab6b6a6138f89ffbb56ef3b5">vcl::addTriangleFacesFromPolygon</a></div><div class="ttdeci">void addTriangleFacesFromPolygon(MeshType &amp;m, FaceType &amp;f, const std::vector&lt; uint &gt; &amp;polygon)</div><div class="ttdoc">Given a vector of indices of vertices in a mesh representing a polyon, this function adds N triangula...</div><div class="ttdef"><b>Definition:</b> topology.h:415</div></div>
<div class="ttc" id="atypes_2base_8h_html_a69aa29b598b851b0640aa225a9e5d61d"><div class="ttname"><a href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a></div><div class="ttdeci">unsigned int uint</div><div class="ttdef"><b>Definition:</b> base.h:31</div></div>
</div><!-- fragment --><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classvcl_1_1BadVertexIndexException.html">BadVertexIndexException</a></td><td>if there is a vertex index in the polygon that is out of range, or that references a vertex that results deleted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MeshType</td><td>the type of the face that satisfies the FaceMeshConcept. </td></tr>
    <tr><td class="paramname">FaceType</td><td>the type of the face that satisfies the FaceConcept.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">m</td><td>the mesh on which add the triangulation of the polygon. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">f</td><td>the first face of the triangulation, that will be filled. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">polygon</td><td>the vertex indices in the mesh representing the polygon. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a90d821ff0dab1c3c45fdfe82ce48448f" name="a90d821ff0dab1c3c45fdfe82ce48448f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90d821ff0dab1c3c45fdfe82ce48448f">&#9670;&#160;</a></span>applyTransformMatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType, typename ScalarM &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::applyTransformMatrix </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacevcl.html#ad82a126b390f21b2e9658c73e7a795ee">Matrix44</a>&lt; ScalarM &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>updateNormals</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a58e916cd5d73eca35e6f8ae1be248637" name="a58e916cd5d73eca35e6f8ae1be248637"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58e916cd5d73eca35e6f8ae1be248637">&#9670;&#160;</a></span>asConst() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vcl::asConst </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9ca8accd2e2b6881a3b2359e56396e77" name="a9ca8accd2e2b6881a3b2359e56396e77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ca8accd2e2b6881a3b2359e56396e77">&#9670;&#160;</a></span>asConst() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr T &amp; vcl::asConst </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a943a3fda661e6e71d8fd7106f41dd878" name="a943a3fda661e6e71d8fd7106f41dd878"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a943a3fda661e6e71d8fd7106f41dd878">&#9670;&#160;</a></span>asConst() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr T * vcl::asConst </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="abe5c457181ae725f99627c541993a3a8" name="abe5c457181ae725f99627c541993a3a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe5c457181ae725f99627c541993a3a8">&#9670;&#160;</a></span>asConst() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr T * vcl::asConst </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a66e2e1e0ec5d91e9def735ecf4f84b0e" name="a66e2e1e0ec5d91e9def735ecf4f84b0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66e2e1e0ec5d91e9def735ecf4f84b0e">&#9670;&#160;</a></span>barycenter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">MeshType::VertexType::CoordType vcl::barycenter </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the barycenter of the mesh, that is the simple average of all the vertex coordintes of the mesh. </p>
<p>Requirements:</p><ul>
<li><a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>:<ul>
<li>Vertices</li>
</ul>
</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>input mesh on which compute the barycenter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The barycenter of the input mesh. </dd></dl>

</div>
</div>
<a id="a6f45446c5f7bcad8bd9dd9c515bf1e55" name="a6f45446c5f7bcad8bd9dd9c515bf1e55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f45446c5f7bcad8bd9dd9c515bf1e55">&#9670;&#160;</a></span>bestGridSize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;PointConcept PointType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Point.html">Point</a>&lt; <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a>, PointType::DIM &gt; vcl::bestGridSize </td>
          <td>(</td>
          <td class="paramtype">const PointType &amp;&#160;</td>
          <td class="paramname"><em>lengths</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a>&#160;</td>
          <td class="paramname"><em>nElements</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the best sizes (number of cells per dimension) of a Grid, starting from the lengths of the grid and the number of elements to place in the grid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lengths</td><td></td></tr>
    <tr><td class="paramname">nElements</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a86c0811cfbc37a3b319d57902e81e949" name="a86c0811cfbc37a3b319d57902e81e949"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86c0811cfbc37a3b319d57902e81e949">&#9670;&#160;</a></span>borderLength()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double vcl::borderLength </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the border length of the given <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>, that is the sum of the length of the edges that are on border in the given mesh. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>mesh on which compute the border length. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The border length of the given mesh. </dd></dl>

</div>
</div>
<a id="a47188a6c411a5a4fbd8542d5ce1525aa" name="a47188a6c411a5a4fbd8542d5ce1525aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47188a6c411a5a4fbd8542d5ce1525aa">&#9670;&#160;</a></span>checkFlipEdge()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceConcept FaceType&gt; <br />
requires comp::HasAdjacentFaces&lt;FaceType&gt;</div>
      <table class="memname">
        <tr>
          <td class="memname">bool vcl::checkFlipEdge </td>
          <td>(</td>
          <td class="paramtype">const FaceType &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a>&#160;</td>
          <td class="paramname"><em>edge</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a boolean value indicating whether the edge flip operation is allowed or not. </p>
<p>This function requires AdjacentFaces component, that must be available and computed before calling this function.</p>
<p>The function first checks if the specified edge is a boundary edge, in which case the flip operation is not allowed. If the edge is not a boundary edge, the function checks whether the mesh is well-oriented by verifying that the vertices of the edge to be flipped are the same in the adjacent face.</p>
<p>Next, the function checks if the flipped edge already exists in the mesh. To do this, the function performs a depth-first search starting from the current face, following the edges that share the opposite vertex to the edge being flipped. The search checks if the vertex on the other end of the flipped edge is already connected to any other face in the mesh. If it is, the flip operation is not allowed.</p>
<p>The depth-first search is limited to the faces that share the opposite vertex to the edge being flipped, so it does not perform an exhaustive search of the entire mesh. However, it is sufficient to detect non-manifoldness caused by the flipped edge.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classvcl_1_1MissingComponentException.html">vcl::MissingComponentException</a></td><td>If the "AdjacentFaces" component is not available on <code>f</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FaceType</td><td>the type of the face that satisfies the FaceConcept.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>The face that contains the edge to flip. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">edge</td><td>The index of the edge to flip.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the edge flip is allowed, false otherwise. </dd></dl>

</div>
</div>
<a id="a748cd8beb49f3c7a18dbd1efdcd8bf21" name="a748cd8beb49f3c7a18dbd1efdcd8bf21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a748cd8beb49f3c7a18dbd1efdcd8bf21">&#9670;&#160;</a></span>clampPerFaceQuality()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::clampPerFaceQuality </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename MeshType::FaceType::QualityType&#160;</td>
          <td class="paramname"><em>minS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename MeshType::FaceType::QualityType&#160;</td>
          <td class="paramname"><em>maxS</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clamps the face quality of a mesh in a given interval. </p>
<p>Requirements:</p><ul>
<li><a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>:<ul>
<li>Faces:<ul>
<li>Quality</li>
</ul>
</li>
</ul>
</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">m</td><td>mesh on which clamp the face quality </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">minS</td><td>minimum value of the clamping interval </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxS</td><td>maximum value of the clamping interval </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a696dc0c7e7d1e45751850aaa7a51f247" name="a696dc0c7e7d1e45751850aaa7a51f247"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a696dc0c7e7d1e45751850aaa7a51f247">&#9670;&#160;</a></span>clampPerVertexQuality()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::clampPerVertexQuality </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename MeshType::VertexType::QualityType&#160;</td>
          <td class="paramname"><em>minS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename MeshType::VertexType::QualityType&#160;</td>
          <td class="paramname"><em>maxS</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clamps the vertex quality of a mesh in a given interval. </p>
<p>Requirements:</p><ul>
<li><a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>:<ul>
<li>Vertices:<ul>
<li>Quality</li>
</ul>
</li>
</ul>
</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">m</td><td>mesh on which clamp the vertex quality </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">minS</td><td>minimum value of the clamping interval </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxS</td><td>maximum value of the clamping interval </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0416a0056c7bbd35f81e72bb9b536db0" name="a0416a0056c7bbd35f81e72bb9b536db0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0416a0056c7bbd35f81e72bb9b536db0">&#9670;&#160;</a></span>clearEdgeSelection()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;EdgeMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::clearEdgeSelection </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abb5edd39f9dd2fc2220d8b08be523e29" name="abb5edd39f9dd2fc2220d8b08be523e29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb5edd39f9dd2fc2220d8b08be523e29">&#9670;&#160;</a></span>clearFaceSelection()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::clearFaceSelection </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aec301aa1e068ae4ceeeef43761b9ee04" name="aec301aa1e068ae4ceeeef43761b9ee04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec301aa1e068ae4ceeeef43761b9ee04">&#9670;&#160;</a></span>clearPerFaceAdjacentFaces()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::clearPerFaceAdjacentFaces </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clears the adjacent faces of each face of the mesh. </p>
<p>Since the number of adjacent faces per face is tied to the number of vertices of the face, at the end of this function each face will have f-&gt;vertexNumber() adjacent faces set to nullptr.</p>
<p>Requirements:</p><ul>
<li><a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>:<ul>
<li>Faces:<ul>
<li>AdjacentFaces</li>
</ul>
</li>
</ul>
</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>the mesh on which clear the per face adjacent faces. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa5ad240da55effe35e495f1aad2e3507" name="aa5ad240da55effe35e495f1aad2e3507"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5ad240da55effe35e495f1aad2e3507">&#9670;&#160;</a></span>clearPerReferencedVertexNormals()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::clearPerReferencedVertexNormals </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets to zero all the normals of vertices that are referenced by at least one face, leaving unchanged all the normals of the unreferenced vertices that may be still useful. </p>
<p>Requirements:</p><ul>
<li><a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>:<ul>
<li>Vertices:<ul>
<li>Normal</li>
</ul>
</li>
<li>Faces</li>
</ul>
</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">m</td><td>The mesh on which clear the referenced vertex normals. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a54e8371c2ddda188c9540ea7e7bddf78" name="a54e8371c2ddda188c9540ea7e7bddf78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54e8371c2ddda188c9540ea7e7bddf78">&#9670;&#160;</a></span>clearPerVertexAdjacentFaces()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::clearPerVertexAdjacentFaces </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clears the adjacent faces of each vertex of the mesh. </p>
<p>Since the number of adjacent faces per vertex is dynamic, at the end of this function each vertex will have 0 adjacent Faces.</p>
<p>Requirements:</p><ul>
<li><a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>:<ul>
<li>Vertices:<ul>
<li>AdjacentFaces</li>
</ul>
</li>
</ul>
</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>the mesh on which clear the per vertex adjacent faces. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a312c8ca27b3e94994a1f03bc1a3d826d" name="a312c8ca27b3e94994a1f03bc1a3d826d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a312c8ca27b3e94994a1f03bc1a3d826d">&#9670;&#160;</a></span>clearPerVertexAdjacentVertices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::clearPerVertexAdjacentVertices </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clears the adjacent vertices of each vertex of the mesh. </p>
<p>Since the number of adjacent vertices per vertex is dynamic, at the end of this function each vertex will have 0 adjacent vertices.</p>
<p>Requirements:</p><ul>
<li><a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>:<ul>
<li>Vertices:<ul>
<li>AdjacentVertices</li>
</ul>
</li>
</ul>
</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>the mesh on which clear the per vertex adjacent vertices. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad6a0e2bc172c69d34a84631e824c75a4" name="ad6a0e2bc172c69d34a84631e824c75a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6a0e2bc172c69d34a84631e824c75a4">&#9670;&#160;</a></span>clearPerVertexNormals()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::clearPerVertexNormals </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets to zero the normals of all the vertices of the mesh, including the unreferenced ones. </p>
<p>Requirements:</p><ul>
<li><a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>:<ul>
<li>Vertices:<ul>
<li>Normal</li>
</ul>
</li>
</ul>
</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">m</td><td>The mesh on which clear the vertex normals. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7b0bc5dbd8005d39d14ccf664ffca33c" name="a7b0bc5dbd8005d39d14ccf664ffca33c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b0bc5dbd8005d39d14ccf664ffca33c">&#9670;&#160;</a></span>clearVertexSelection()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::clearVertexSelection </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab5a54ddc3c9d67e0c7ed179e78c2ca06" name="ab5a54ddc3c9d67e0c7ed179e78c2ca06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5a54ddc3c9d67e0c7ed179e78c2ca06">&#9670;&#160;</a></span>colorFromInterval() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Color.html">Color</a> vcl::colorFromInterval </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Color.html#a32ace7bd7fccf742b39f6cd83042a10f">Color::ColorMap</a>&#160;</td>
          <td class="paramname"><em>cm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a color in the interval from the minimum color to the maximum color of the given colormap <code>cm</code>, depending on the position of the given value in the given interval [min, max]. </p>
<p>If the given value is less than the minimum value of the interval, the minimum color will be returned. If the given value is higher than the maximum value of the interval, the maximum color will be returned. If min and max are equal, the Grey color will be returned.</p>
<p>This function works also if the values of the interval are swapped.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">min</td><td>minimum value of the interval </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max</td><td>maximum value of the interval </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>the value in the interval to ramp. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cm</td><td>the colormap on which compute the color. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A color in the given colormap representing the position of value in the interval [min, max]. </dd></dl>

</div>
</div>
<a id="a5851edce0478bfc7f4084e3529ae6962" name="a5851edce0478bfc7f4084e3529ae6962"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5851edce0478bfc7f4084e3529ae6962">&#9670;&#160;</a></span>colorFromInterval() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Color.html">Color</a> vcl::colorFromInterval </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Color.html#a32ace7bd7fccf742b39f6cd83042a10f">Color::ColorMap</a>&#160;</td>
          <td class="paramname"><em>cm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a <code>value</code> in the interval [0, 1], it returns the color in the position in the given ColorMap <code>cm</code> corresponding to the position of <code>value</code> in the interval [0, 1]. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>a float value between 0 and 1. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">[cm]</td><td>cm: the colormap used to compute the color. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The color in the position of <code>value</code> in the given colormap. </dd></dl>

</div>
</div>
<a id="a99b591f2eba1ded24ebf6f4b0ee4353f" name="a99b591f2eba1ded24ebf6f4b0ee4353f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99b591f2eba1ded24ebf6f4b0ee4353f">&#9670;&#160;</a></span>colorFromIntervalGreyShade() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Color.html">Color</a> vcl::colorFromIntervalGreyShade </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a color in the grey shade colormap depending on the position of the given value in the given interval [min, max]. </p>
<p>If the given value is less than the minimum value of the interval, the minimum color of the colormap will be returned. If the given value is higher than the maximum value of the interval, the maximum color in the colormap will be returned. If min and max are equal, the Grey color will be returned.</p>
<p>This function works also if the values of the interval are swapped.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">min</td><td>minimum value of the interval </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max</td><td>maximum value of the interval </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>the value in the interval to ramp. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A color in the grey shade colormap representing the position of value in the interval [min, max]. </dd></dl>

</div>
</div>
<a id="a8232d4e3c3aca4125e84cb8f124ebc29" name="a8232d4e3c3aca4125e84cb8f124ebc29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8232d4e3c3aca4125e84cb8f124ebc29">&#9670;&#160;</a></span>colorFromIntervalGreyShade() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Color.html">Color</a> vcl::colorFromIntervalGreyShade </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a color in the grey shade colormap depending on the position of the given value in the interval [0, 1]. </p>
<p>If the given value is less than 0, the minimum color of the colormap will be returned. If the given value is higher than 1, the maximum color in the colormap will be returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>the value between 0 and 1 to ramp. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A color in the grey shade colormap representing the position of value in the interval [0, 1]. </dd></dl>

</div>
</div>
<a id="a9725bc9a2f5b27ce885e76be92185a20" name="a9725bc9a2f5b27ce885e76be92185a20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9725bc9a2f5b27ce885e76be92185a20">&#9670;&#160;</a></span>colorFromIntervalParula() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Color.html">Color</a> vcl::colorFromIntervalParula </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a color in the Paraula colormap depending on the position of the given value in the given interval [min, max]. </p>
<p>If the given value is less than the minimum value of the interval, the minimum color of the colormap will be returned. If the given value is higher than the maximum value of the interval, the maximum color in the colormap will be returned. If min and max are equal, the Grey color will be returned.</p>
<p>This function works also if the values of the interval are swapped.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">min</td><td>minimum value of the interval </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max</td><td>maximum value of the interval </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>the value in the interval to ramp. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A color in the Parula colormap representing the position of value in the interval [min, max]. </dd></dl>

</div>
</div>
<a id="a7728ec836fa169f447a90a4d2eee3df5" name="a7728ec836fa169f447a90a4d2eee3df5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7728ec836fa169f447a90a4d2eee3df5">&#9670;&#160;</a></span>colorFromIntervalParula() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Color.html">Color</a> vcl::colorFromIntervalParula </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a color in the Paraula colormap depending on the position of the given value in the interval [0, 1]. </p>
<p>If the given value is less than 0, the minimum color of the colormap will be returned. If the given value is higher than 1, the maximum color in the colormap will be returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>the value between 0 and 1 to ramp. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A color in the Parula colormap representing the position of value in the interval [0, 1]. </dd></dl>

</div>
</div>
<a id="afa361024b35e8aef9609826b177ac1cb" name="afa361024b35e8aef9609826b177ac1cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa361024b35e8aef9609826b177ac1cb">&#9670;&#160;</a></span>colorFromIntervalRedBlue() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Color.html">Color</a> vcl::colorFromIntervalRedBlue </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a color in the interval from Red to Blue depending on the position of the given value in the given interval [min, max]. </p>
<p>If the given value is less than the minimum value of the interval, the Red color will be returned. If the given value is higher than the maximum value of the interval, the Blue color will be returned. If min and max are equal, the Grey color will be returned.</p>
<p>This function works also if the values of the interval are swapped.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">min</td><td>minimum value of the interval </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max</td><td>maximum value of the interval </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>the value in the interval to ramp. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A color between Red and Blue representing the position of value in the interval [min, max]. </dd></dl>

</div>
</div>
<a id="a6c348d7127fb95f134332b8c275846f7" name="a6c348d7127fb95f134332b8c275846f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c348d7127fb95f134332b8c275846f7">&#9670;&#160;</a></span>colorFromIntervalRedBlue() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Color.html">Color</a> vcl::colorFromIntervalRedBlue </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a color in the interval from Red to Blue depending on the position of the given value in the interval [0, 1]. </p>
<p>If the given value is less than 0, the Red color will be returned. If the given value is higher than 1, the Blue color will be returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>the value between 0 and 1 to ramp. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A color between Red and Blue representing the position of value in the interval [0, 1]. </dd></dl>

</div>
</div>
<a id="a9dcc49648719fc830554b892110ff8f2" name="a9dcc49648719fc830554b892110ff8f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9dcc49648719fc830554b892110ff8f2">&#9670;&#160;</a></span>colorLerp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Color.html">Color</a> vcl::colorLerp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvcl_1_1Color.html">Color</a> &amp;&#160;</td>
          <td class="paramname"><em>c0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvcl_1_1Color.html">Color</a> &amp;&#160;</td>
          <td class="paramname"><em>c1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given an interval of colors (from <code>c0</code> to <code>c1</code>) and a value in the interval [0, 1], returns the linear interpolation color between <code>c0</code> and <code>c1</code> based on <code>value</code> in the [0, 1] interval. If <code>value</code> is out of range, it will be set to the nearest extreme of the interval. </p>
<p>Linear interpolation is computed in the RGBA values of the two colors.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">c0</td><td>minimum in the input color interval. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">c1</td><td>minimum in the input color interval. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>a float value between 0 and 1. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The linear interpolation between <code>c0</code> and <code>c1</code>. </dd></dl>

</div>
</div>
<a id="a7e24134fa80806f677e3d5d72cd9c9e9" name="a7e24134fa80806f677e3d5d72cd9c9e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e24134fa80806f677e3d5d72cd9c9e9">&#9670;&#160;</a></span>colorScattering()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classvcl_1_1Color.html">Color</a> &gt; vcl::colorScattering </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>sat</em> = <code>0.3</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>val</em> = <code>0.9</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a number <code>n</code>, returns a vector of <code>n</code> colors so that each color differs as much as possible from the previous one of the vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the number of colors in the returned vector </td></tr>
    <tr><td class="paramname">sat</td><td>the saturation in the returned colors </td></tr>
    <tr><td class="paramname">val</td><td>the value in the returned colors </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector of different colors. </dd></dl>

</div>
</div>
<a id="aca4e61e9eb02bae8617f346aaf830452" name="aca4e61e9eb02bae8617f346aaf830452"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca4e61e9eb02bae8617f346aaf830452">&#9670;&#160;</a></span>compactVector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::compactVector </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T, Args... &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>newIndices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>It will take care of compacting the vector vec, depending on the content of the vector newIndices. </p>
<p>Given the vector newIndices having the following features:</p><ul>
<li>has the same size of vec</li>
<li>for each position i:<ul>
<li>newIndices[i] contains the new position of the element vec[i] after the compactness</li>
<li>newIndices[i] contains the value UINT_NULL if the element vec[i] must be deleted</li>
</ul>
</li>
</ul>
<p>Non-null elements of newIndices must unique, and their value must be less than the new size of vec after the compactness. The new size of vec will be the number of non-null elements of newIndices.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td></td></tr>
    <tr><td class="paramname">newIndices</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a86d50e779d2b4fd59e31de5a48e6d112" name="a86d50e779d2b4fd59e31de5a48e6d112"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86d50e779d2b4fd59e31de5a48e6d112">&#9670;&#160;</a></span>componentEnumString()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> COMP_ID&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char * vcl::componentEnumString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the string associated to the COMP_ID value. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">COMP_ID</td><td>an unsigned integer that idetinfies the component. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The string associated to the COMP_ID value. </dd></dl>

</div>
</div>
<a id="a49e57acf0c1cb51e98f7a176051d99ee" name="a49e57acf0c1cb51e98f7a176051d99ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49e57acf0c1cb51e98f7a176051d99ee">&#9670;&#160;</a></span>covarianceMatrixOfMesh()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto vcl::covarianceMatrixOfMesh </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute covariance matrix of a mesh, i.e. the integral int_{m} { (x-b)(x-b)^T }dx where b is the barycenter and x spans over the mesh m. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The 3x3 covariance matrix of the given mesh. </dd></dl>

</div>
</div>
<a id="a46a67e9dd1e0a9805f812c10328caaa2" name="a46a67e9dd1e0a9805f812c10328caaa2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46a67e9dd1e0a9805f812c10328caaa2">&#9670;&#160;</a></span>covarianceMatrixOfPointCloud() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto vcl::covarianceMatrixOfPointCloud </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the covariance matrix of a <a class="el" href="classvcl_1_1Point.html" title="The Point class represents an N-dimensional point containing N scalar values.">Point</a> Cloud <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>. </p>
<p>Requirements:</p><ul>
<li><a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>:<ul>
<li>Vertices</li>
</ul>
</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The 3x3 covariance matrix of the given point cloud. </dd></dl>

</div>
</div>
<a id="af9fd633374c0d8ab86df9e354a9a0fb5" name="af9fd633374c0d8ab86df9e354a9a0fb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9fd633374c0d8ab86df9e354a9a0fb5">&#9670;&#160;</a></span>covarianceMatrixOfPointCloud() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;PointConcept PointType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto vcl::covarianceMatrixOfPointCloud </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; PointType &gt; &amp;&#160;</td>
          <td class="paramname"><em>pointVec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the covariance matrix of a set of points. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pointVec</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The 3x3 covariance matrix of the given set of points. </dd></dl>

</div>
</div>
<a id="aada6c7f7d741d8f7885af287bcc6f746" name="aada6c7f7d741d8f7885af287bcc6f746"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aada6c7f7d741d8f7885af287bcc6f746">&#9670;&#160;</a></span>dereferencePtr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto vcl::dereferencePtr </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Utility function that applies the unary operator '*' to the argument only if the object is a pointer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>obj if it is not a pointer, or *obj if it is a pointer. </dd></dl>

</div>
</div>
<a id="a3109cc4c0e2128888f2a3fa6ae27a98f" name="a3109cc4c0e2128888f2a3fa6ae27a98f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3109cc4c0e2128888f2a3fa6ae27a98f">&#9670;&#160;</a></span>detachAdjacentFacesOnEdge()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceConcept FaceType&gt; <br />
requires comp::HasAdjacentFaces&lt;FaceType&gt;</div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::detachAdjacentFacesOnEdge </td>
          <td>(</td>
          <td class="paramtype">FaceType &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a>&#160;</td>
          <td class="paramname"><em>edge</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Detaches the face <code>f</code> on the given edge, which consists on updating adjacent faces such that any face that was linking the face <code>f</code> won't link it anymore. It manages also non-manifold edges. </p>
<p>If the given pair face-edge is on border, nothing is done. If the given pair face-edge is a normal manifold edge, this operation will set nullptr as adjacent face of f (making edge a border) and vice versa on the adjacent face. If the given pair face-edge is a non-manifold edge, the function will "remove" the current face from the ring of faces incident on the edge. The given face f will have the given edge set as a border (nullptr).</p>
<p>This function is designed to work with faces that have an available "AdjacentFaces" component. If the component is not available, a <a class="el" href="classvcl_1_1MissingComponentException.html">MissingComponentException</a> is thrown.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classvcl_1_1MissingComponentException.html">vcl::MissingComponentException</a></td><td>If the "AdjacentFaces" component is not available on <code>f</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FaceType</td><td>the type of the face that satisfies the FaceConcept.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>The face to detach on the given edge. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">edge</td><td>The index of the edge to detach the face from. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af67d9147410404febe19163fb506397d" name="af67d9147410404febe19163fb506397d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af67d9147410404febe19163fb506397d">&#9670;&#160;</a></span>detachFace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceConcept FaceType&gt; <br />
requires comp::HasAdjacentFaces&lt;FaceType&gt;</div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::detachFace </td>
          <td>(</td>
          <td class="paramtype">FaceType &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Detaches the given face from all its adjacent vertices and adjacent faces. </p>
<p>The detachFace function detaches the given face from all its adjacent vertices and adjacent faces. This means that every vertex and face will no longer link to the face <code>f</code> as an adjacent face, and <code>f</code> will no longer have any adjacent faces (all their values are set to nullptr). The vertices of the face <code>f</code> are unchanged.</p>
<p>This function is designed to work with faces that have an available "Adjacent
Faces" component. If the component is not available, a <a class="el" href="classvcl_1_1MissingComponentException.html">MissingComponentException</a> is thrown.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classvcl_1_1MissingComponentException.html">MissingComponentException</a></td><td>if the adjacent faces component is not available on the face.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FaceType</td><td>the type of the face that satisfies the FaceConcept.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>The face to detach from its vertices and adjacent faces. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acec9c589f837b0294e6d50a9a3388b92" name="acec9c589f837b0294e6d50a9a3388b92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acec9c589f837b0294e6d50a9a3388b92">&#9670;&#160;</a></span>drawArrow3()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vcl::drawArrow3 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__space.html#gabb47c1364fb2fe1464a54417684f011e">Point3d</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__space.html#gabb47c1364fb2fe1464a54417684f011e">Point3d</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>bottom_radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvcl_1_1Color.html">Color</a> &amp;&#160;</td>
          <td class="paramname"><em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>slices</em> = <code>50</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>stacks</em> = <code>10</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a63eea0cb7f075cb1b25868a94a9755d2" name="a63eea0cb7f075cb1b25868a94a9755d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63eea0cb7f075cb1b25868a94a9755d2">&#9670;&#160;</a></span>drawBox3() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vcl::drawBox3 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__space.html#gabb47c1364fb2fe1464a54417684f011e">Point3d</a> &amp;&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__space.html#gabb47c1364fb2fe1464a54417684f011e">Point3d</a> &amp;&#160;</td>
          <td class="paramname"><em>max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvcl_1_1Color.html">Color</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em> = <code>3</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draws an axis aligned 3D box using opengl lines. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">min</td><td></td></tr>
    <tr><td class="paramname">max</td><td></td></tr>
    <tr><td class="paramname">c</td><td></td></tr>
    <tr><td class="paramname">width</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a750ed5084363ad069179728eda8d02e4" name="a750ed5084363ad069179728eda8d02e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a750ed5084363ad069179728eda8d02e4">&#9670;&#160;</a></span>drawBox3() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vcl::drawBox3 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__space.html#gabb47c1364fb2fe1464a54417684f011e">Point3d</a> &amp;&#160;</td>
          <td class="paramname"><em>p0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__space.html#gabb47c1364fb2fe1464a54417684f011e">Point3d</a> &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__space.html#gabb47c1364fb2fe1464a54417684f011e">Point3d</a> &amp;&#160;</td>
          <td class="paramname"><em>p2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__space.html#gabb47c1364fb2fe1464a54417684f011e">Point3d</a> &amp;&#160;</td>
          <td class="paramname"><em>p3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__space.html#gabb47c1364fb2fe1464a54417684f011e">Point3d</a> &amp;&#160;</td>
          <td class="paramname"><em>p4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__space.html#gabb47c1364fb2fe1464a54417684f011e">Point3d</a> &amp;&#160;</td>
          <td class="paramname"><em>p5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__space.html#gabb47c1364fb2fe1464a54417684f011e">Point3d</a> &amp;&#160;</td>
          <td class="paramname"><em>p6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__space.html#gabb47c1364fb2fe1464a54417684f011e">Point3d</a> &amp;&#160;</td>
          <td class="paramname"><em>p7</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvcl_1_1Color.html">Color</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em> = <code>3</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab5ec2b87d6e4cd7c08e8cd230d1e19c6" name="ab5ec2b87d6e4cd7c08e8cd230d1e19c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5ec2b87d6e4cd7c08e8cd230d1e19c6">&#9670;&#160;</a></span>drawBox3() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vcl::drawBox3 </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="group__space.html#gabb47c1364fb2fe1464a54417684f011e">Point3d</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvcl_1_1Color.html">Color</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em> = <code>3</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draws the box composed by the first 8 point contained on the vector passed as parameter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td></td></tr>
    <tr><td class="paramname">c</td><td></td></tr>
    <tr><td class="paramname">width</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a827383d99bab0852a41372b2cedd4f42" name="a827383d99bab0852a41372b2cedd4f42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a827383d99bab0852a41372b2cedd4f42">&#9670;&#160;</a></span>drawCylinder()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vcl::drawCylinder </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__space.html#gabb47c1364fb2fe1464a54417684f011e">Point3d</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__space.html#gabb47c1364fb2fe1464a54417684f011e">Point3d</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>top_radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>bottom_radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvcl_1_1Color.html">Color</a> &amp;&#160;</td>
          <td class="paramname"><em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>slices</em> = <code>50</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>stacks</em> = <code>10</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draws a cylinder with opengl. The cylinder links the two points passed as parameters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>first point of the cylinder </td></tr>
    <tr><td class="paramname">b</td><td>second point of the cylinder </td></tr>
    <tr><td class="paramname">top_radius</td><td>radius at the "a" point </td></tr>
    <tr><td class="paramname">bottom_radius</td><td>radius at the "b" point </td></tr>
    <tr><td class="paramname">color</td><td>color of the cylinder </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3d79778f20004b0238af02eea0170b06" name="a3d79778f20004b0238af02eea0170b06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d79778f20004b0238af02eea0170b06">&#9670;&#160;</a></span>drawDashedLine3()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vcl::drawDashedLine3 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__space.html#gabb47c1364fb2fe1464a54417684f011e">Point3d</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__space.html#gabb47c1364fb2fe1464a54417684f011e">Point3d</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvcl_1_1Color.html">Color</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em> = <code>3</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>drawDashedLine </p>
<p>Draws a dashed line with opengl that links the two points passed as parameters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>first point of the dashed line </td></tr>
    <tr><td class="paramname">b</td><td>second point of the dashed line </td></tr>
    <tr><td class="paramname">c</td><td>color of the dashed line </td></tr>
    <tr><td class="paramname">width</td><td>width of the dashed line (default: 3) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a11cf68ac82c35fc923d8406b4a8aad9e" name="a11cf68ac82c35fc923d8406b4a8aad9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11cf68ac82c35fc923d8406b4a8aad9e">&#9670;&#160;</a></span>drawLine2()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vcl::drawLine2 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__space.html#ga4b02e85ff4d51fe7d689f8dd0e87ecd5">Point2d</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__space.html#ga4b02e85ff4d51fe7d689f8dd0e87ecd5">Point2d</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvcl_1_1Color.html">Color</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em> = <code>3</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>drawLine2 </p>
<p>Draws a line with opengl on the plane (z=0 if 3D). It links the two points passed as parameters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>first point of the line </td></tr>
    <tr><td class="paramname">b</td><td>second point of the line </td></tr>
    <tr><td class="paramname">c</td><td>color of the line </td></tr>
    <tr><td class="paramname">width</td><td>width of the line (default: 3) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5b332fa5ff7656af768ec5adad56c7ef" name="a5b332fa5ff7656af768ec5adad56c7ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b332fa5ff7656af768ec5adad56c7ef">&#9670;&#160;</a></span>drawLine3()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vcl::drawLine3 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__space.html#gabb47c1364fb2fe1464a54417684f011e">Point3d</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__space.html#gabb47c1364fb2fe1464a54417684f011e">Point3d</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvcl_1_1Color.html">Color</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em> = <code>3</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draws a line with opengl that links the two points passed as parameters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>first point of the line </td></tr>
    <tr><td class="paramname">b</td><td>second point of the line </td></tr>
    <tr><td class="paramname">c</td><td>color of the line </td></tr>
    <tr><td class="paramname">width</td><td>width of the line (default: 3) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a516ae081ca79f1afbf5a77883613be72" name="a516ae081ca79f1afbf5a77883613be72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a516ae081ca79f1afbf5a77883613be72">&#9670;&#160;</a></span>drawPoint2()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vcl::drawPoint2 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__space.html#ga4b02e85ff4d51fe7d689f8dd0e87ecd5">Point2d</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvcl_1_1Color.html">Color</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em> = <code>8</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>drawPoint2 </p>
<p>Draws a point on the plane (coord z = 0 if 3D).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>coordinates of the point </td></tr>
    <tr><td class="paramname">c</td><td>color of the point </td></tr>
    <tr><td class="paramname">size</td><td>size of the point (default: 8) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a28c3f4bdb0bf107ad6870d3a89f522d8" name="a28c3f4bdb0bf107ad6870d3a89f522d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28c3f4bdb0bf107ad6870d3a89f522d8">&#9670;&#160;</a></span>drawPoint3()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vcl::drawPoint3 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__space.html#gabb47c1364fb2fe1464a54417684f011e">Point3d</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvcl_1_1Color.html">Color</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em> = <code>8</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draws a point on the plane (coord z = 0 if 3D). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>coordinates of the point </td></tr>
    <tr><td class="paramname">c</td><td>color of the point </td></tr>
    <tr><td class="paramname">size</td><td>size of the point </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaf0a4439a6ce94a7bd97459505578043" name="aaf0a4439a6ce94a7bd97459505578043"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf0a4439a6ce94a7bd97459505578043">&#9670;&#160;</a></span>drawQuad2() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vcl::drawQuad2 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__space.html#ga4b02e85ff4d51fe7d689f8dd0e87ecd5">Point2d</a> &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__space.html#ga4b02e85ff4d51fe7d689f8dd0e87ecd5">Point2d</a> &amp;&#160;</td>
          <td class="paramname"><em>p2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__space.html#ga4b02e85ff4d51fe7d689f8dd0e87ecd5">Point2d</a> &amp;&#160;</td>
          <td class="paramname"><em>p3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__space.html#ga4b02e85ff4d51fe7d689f8dd0e87ecd5">Point2d</a> &amp;&#160;</td>
          <td class="paramname"><em>p4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvcl_1_1Color.html">Color</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em> = <code>3</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fill</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="abb8951e6b832297167e55b3bbfe366a1" name="abb8951e6b832297167e55b3bbfe366a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb8951e6b832297167e55b3bbfe366a1">&#9670;&#160;</a></span>drawQuad2() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vcl::drawQuad2 </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; <a class="el" href="group__space.html#ga4b02e85ff4d51fe7d689f8dd0e87ecd5">Point2d</a>, 4 &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvcl_1_1Color.html">Color</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em> = <code>3</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fill</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aee24b3c24b38932469ae9ef367c7f001" name="aee24b3c24b38932469ae9ef367c7f001"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee24b3c24b38932469ae9ef367c7f001">&#9670;&#160;</a></span>drawQuad3()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vcl::drawQuad3 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__space.html#gabb47c1364fb2fe1464a54417684f011e">Point3d</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__space.html#gabb47c1364fb2fe1464a54417684f011e">Point3d</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__space.html#gabb47c1364fb2fe1464a54417684f011e">Point3d</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__space.html#gabb47c1364fb2fe1464a54417684f011e">Point3d</a> &amp;&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em> = <code>3</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a44f0d7c3d49978fb964728e9457b76dd" name="a44f0d7c3d49978fb964728e9457b76dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44f0d7c3d49978fb964728e9457b76dd">&#9670;&#160;</a></span>drawSegment3()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vcl::drawSegment3 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__space.html#gabb47c1364fb2fe1464a54417684f011e">Point3d</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__space.html#gabb47c1364fb2fe1464a54417684f011e">Point3d</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvcl_1_1Color.html">Color</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em> = <code>3</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacevcl.html#a5b332fa5ff7656af768ec5adad56c7ef" title="Draws a line with opengl that links the two points passed as parameters.">drawLine3</a> </dd></dl>

</div>
</div>
<a id="a323c893b90e6dc2a41ac41eb9e7691a2" name="a323c893b90e6dc2a41ac41eb9e7691a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a323c893b90e6dc2a41ac41eb9e7691a2">&#9670;&#160;</a></span>drawSphere()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vcl::drawSphere </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__space.html#gabb47c1364fb2fe1464a54417684f011e">Point3d</a> &amp;&#160;</td>
          <td class="paramname"><em>center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvcl_1_1Color.html">Color</a> &amp;&#160;</td>
          <td class="paramname"><em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>precision</em> = <code>4</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draws a sphere with opengl. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">center</td><td>coordinates of the center of the sphere </td></tr>
    <tr><td class="paramname">radius</td><td>radius of the sphere </td></tr>
    <tr><td class="paramname">color</td><td>color of the sphere </td></tr>
    <tr><td class="paramname">precision</td><td>precision of the rendered sphere </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3fe90c17e9b40d28753fa4428bbba626" name="a3fe90c17e9b40d28753fa4428bbba626"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fe90c17e9b40d28753fa4428bbba626">&#9670;&#160;</a></span>drawTriangle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vcl::drawTriangle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__space.html#gabb47c1364fb2fe1464a54417684f011e">Point3d</a> &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__space.html#gabb47c1364fb2fe1464a54417684f011e">Point3d</a> &amp;&#160;</td>
          <td class="paramname"><em>p2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__space.html#gabb47c1364fb2fe1464a54417684f011e">Point3d</a> &amp;&#160;</td>
          <td class="paramname"><em>p3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvcl_1_1Color.html">Color</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em> = <code>3</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fill</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af9376bbd1e5522814ec359777aabdcf3" name="af9376bbd1e5522814ec359777aabdcf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9376bbd1e5522814ec359777aabdcf3">&#9670;&#160;</a></span>drawTriangle2() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vcl::drawTriangle2 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__space.html#ga4b02e85ff4d51fe7d689f8dd0e87ecd5">Point2d</a> &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__space.html#ga4b02e85ff4d51fe7d689f8dd0e87ecd5">Point2d</a> &amp;&#160;</td>
          <td class="paramname"><em>p2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__space.html#ga4b02e85ff4d51fe7d689f8dd0e87ecd5">Point2d</a> &amp;&#160;</td>
          <td class="paramname"><em>p3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvcl_1_1Color.html">Color</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em> = <code>3</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fill</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2f8b82d8c87385e00570c863a8976fe1" name="a2f8b82d8c87385e00570c863a8976fe1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f8b82d8c87385e00570c863a8976fe1">&#9670;&#160;</a></span>drawTriangle2() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vcl::drawTriangle2 </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; <a class="el" href="group__space.html#ga4b02e85ff4d51fe7d689f8dd0e87ecd5">Point2d</a>, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvcl_1_1Color.html">Color</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em> = <code>3</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fill</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3983ab4b434d669a765240b81daa236e" name="a3983ab4b434d669a765240b81daa236e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3983ab4b434d669a765240b81daa236e">&#9670;&#160;</a></span>earCut()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceConcept Face&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> &gt; vcl::earCut </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvcl_1_1Face.html">Face</a> &amp;&#160;</td>
          <td class="paramname"><em>polygon</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the earcut algorithm of a 3D <em>planar</em> polygon, that returns a triangulation of the polygon. </p>
<p>Returns a list of indices in which each index is the index of a point of the 3D input polgon, organized in triplets, each one of these is a triangle of the resulting triangulation.</p>
<p>This algorithm first computes the normal of the given polygon, then projects it in a 2D plane and executes the classic 2D EarCut algorithm.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="el" href="classvcl_1_1Face.html" title="The Face class represents an Face element of the vcl::Mesh class.">Face</a></td><td>the type of the face that satisfies the FaceConcept.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">polygon</td><td>A (polygonal) face of a <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">vcl::Mesh</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of indices, representing the triplets of the triangulation of the polygon. </dd></dl>

</div>
</div>
<a id="a77bd6f212cc6ca4ad37ce181c2ba6d1b" name="a77bd6f212cc6ca4ad37ce181c2ba6d1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77bd6f212cc6ca4ad37ce181c2ba6d1b">&#9670;&#160;</a></span>edgeAdjacentFacesNumber()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceConcept FaceType&gt; <br />
requires comp::HasAdjacentFaces&lt;FaceType&gt;</div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> vcl::edgeAdjacentFacesNumber </td>
          <td>(</td>
          <td class="paramtype">const FaceType &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a>&#160;</td>
          <td class="paramname"><em>edge</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of adjacent faces to the given edge of the face f. </p>
<p>If the given edge is manifold, the returned number will be 1 (if the edge is on border - just one face) or 2 (two adjacent faces on the edge). If the edge is non manifold, the number of faces adjacent to the given face will be counted.</p>
<p>This function requires AdjacentFaces component, that must be available and computed before calling this function.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classvcl_1_1MissingComponentException.html">vcl::MissingComponentException</a></td><td>If the "AdjacentFaces" component is not available on <code>f</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FaceType</td><td>the type of the face that satisfies the FaceConcept.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>the face containing the edge </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">edge</td><td>the index of the edge of the face </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of adjacent faces to the given edge of the face <code>f</code> </dd></dl>

</div>
</div>
<a id="a59d8e830fa317191e2d02ff5cafc7149" name="a59d8e830fa317191e2d02ff5cafc7149"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59d8e830fa317191e2d02ff5cafc7149">&#9670;&#160;</a></span>edgeMatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MatrixConcept Matrix, EdgeMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Matrix vcl::edgeMatrix </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a #V*3 Matrix of scalars containing the coordinates of the vertices of a <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>. The function is templated on the Matrix itself. </p>
<p>This function works with every Matrix type that satisfies the MatrixConcept.</p>
<p>Usage example with an Eigen Matrix:</p>
<div class="fragment"><div class="line">   Eigen::MatrixX3d V = vcl::vertexMatrix&lt;Eigen::MatrixX3d&gt;(myMesh);</div>
<div class="line">   <span class="keyword">@end</span><span class="keywordflow">if</span></div>
<div class="line">  </div>
<div class="line">   @note This function does not guarantee that the rows of the matrix</div>
<div class="line">   correspond to the vertex indices of the mesh. This scenario is possible</div>
<div class="line">   when the mesh has deleted vertices. To be sure to have a direct</div>
<div class="line">   correspondence, compact the vertex container before calling <span class="keyword">this</span> function.</div>
<div class="line">  </div>
<div class="line">   @tparam Matrix: type of the matrix to be returned, it must satisfy the</div>
<div class="line">   MatrixConcept.</div>
<div class="line">   @tparam MeshType: type of the input mesh, it must satisfy the MeshConcept.</div>
<div class="line">  </div>
<div class="line">   @param[in] mesh: input mesh</div>
<div class="line">   @<span class="keywordflow">return</span> #V*3 matrix of scalars (vertex coordinates)</div>
<div class="line">  /</div>
<div class="line"><span class="keyword">template</span>&lt;MatrixConcept Matrix, MeshConcept MeshType&gt;</div>
<div class="line">Matrix vertexMatrix(<span class="keyword">const</span> MeshType&amp; mesh)</div>
<div class="line">{</div>
<div class="line">    Matrix V(mesh.vertexNumber(), 3);</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_typedef" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> i = 0;</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; v : mesh.vertices()) {</div>
<div class="line">        <span class="keywordflow">for</span> (<a class="code hl_typedef" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> j = 0; j &lt; 3; ++j) {</div>
<div class="line">            V(i, j) = v.coord()[j];</div>
<div class="line">        }</div>
<div class="line">        ++i;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> V;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span>&lt;MatrixConcept Matrix, FaceMeshConcept MeshType&gt;</div>
<div class="line">Matrix faceMatrix(<span class="keyword">const</span> MeshType&amp; mesh)</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_function" href="namespacevcl.html#ae5e94dd9b89e9bc4fb21701af6e788ca">vcl::requireVertexContainerCompactness</a>(mesh);</div>
<div class="line"> </div>
<div class="line">    Matrix F(mesh.faceNumber(), 3);</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_typedef" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> i = 0;</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; f : mesh.faces()){</div>
<div class="line">        <span class="comment">// check if this face is greater than the cols of the matrix</span></div>
<div class="line">        <span class="keywordflow">if</span> (f.vertexNumber() &gt; F.cols()) { <span class="comment">// need to resize</span></div>
<div class="line">            <a class="code hl_typedef" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> oldCols = F.cols(); <span class="comment">// save old cols number</span></div>
<div class="line">            F.conservativeResize(F.rows(), f.vertexNumber());</div>
<div class="line">            <span class="comment">// need to set to -1 all the previous rows that have been resized</span></div>
<div class="line">            <span class="keywordflow">for</span> (<a class="code hl_typedef" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> k = 0; k &lt; i; ++k){</div>
<div class="line">                <span class="keywordflow">for</span> (<a class="code hl_typedef" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> j = oldCols; j &lt; F.cols(); ++j)</div>
<div class="line">                    F(k, j) = -1;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">        <a class="code hl_typedef" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> j = 0;</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>* v : f.vertices()){</div>
<div class="line">            F(i, j) = mesh.index(v);</div>
<div class="line">            j++;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">for</span> (; j &lt; F.cols(); ++j) <span class="comment">// remaining vertices set to -1</span></div>
<div class="line">            F(i, j ) = -1;</div>
<div class="line">        ++i; <span class="comment">// go to next face/row</span></div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> F;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Vect, FaceMeshConcept MeshType&gt;</div>
<div class="line">Vect faceSizesVector(<span class="keyword">const</span> MeshType&amp; mesh)</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_function" href="namespacevcl.html#ae5e94dd9b89e9bc4fb21701af6e788ca">vcl::requireVertexContainerCompactness</a>(mesh);</div>
<div class="line"> </div>
<div class="line">    Vect F(mesh.faceNumber());</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_typedef" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> i = 0;</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; f : mesh.faces()){</div>
<div class="line">        F(i) = f.vertexNumber();</div>
<div class="line">        ++i;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> F;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="ttc" id="anamespacevcl_html_ae5e94dd9b89e9bc4fb21701af6e788ca"><div class="ttname"><a href="namespacevcl.html#ae5e94dd9b89e9bc4fb21701af6e788ca">vcl::requireVertexContainerCompactness</a></div><div class="ttdeci">void requireVertexContainerCompactness(const MeshType &amp;m)</div><div class="ttdef"><b>Definition:</b> vertex_requirements.h:164</div></div>
</div><!-- fragment --><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classvcl_1_1MissingCompactnessException.html">vcl::MissingCompactnessException</a></td><td>if the vertex container is not compact.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function does not guarantee that the rows of the matrix correspond to the edge indices of the mesh. This scenario is possible when the mesh has deleted edges. To be sure to have a direct correspondence, compact the edge container before calling this function.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Matrix</td><td>type of the matrix to be returned, it must satisfy the MatrixConcept. </td></tr>
    <tr><td class="paramname">MeshType</td><td>type of the input mesh, it must satisfy the EdgeMeshConcept.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>input mesh </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>#E*2 matrix of integers (edge indices) </dd></dl>

</div>
</div>
<a id="add776c0c02e7ef2d7657fce701c437e7" name="add776c0c02e7ef2d7657fce701c437e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add776c0c02e7ef2d7657fce701c437e7">&#9670;&#160;</a></span>elementColorsMatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> ELEM_ID, MatrixConcept Matrix, MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Matrix vcl::elementColorsMatrix </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a #E*4 Matrix of integers containing the colors of the elements identified by <code>ELEM_ID</code> of a <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>. The function is templated on the Matrix itself. </p>
<p>This function works with every Matrix type that satisfies the MatrixConcept, and requires that the mesh has per-element colors.</p>
<p>Usage example with Eigen Matrix:</p>
<div class="fragment"><div class="line">Eigen::MatrixX4i EC =</div>
<div class="line">    vcl::elementColorsMatrix&lt;VERTEX, Eigen::MatrixX4i&gt;(myMesh);</div>
</div><!-- fragment --><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classvcl_1_1MissingComponentException.html">vcl::MissingComponentException</a></td><td>if the mesh does not have per-element colors available.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function does not guarantee that the rows of the matrix correspond to the element indices of the mesh. This scenario is possible when the mesh has deleted elements. To be sure to have a direct correspondence, compact the element container before calling this function.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ELEM_ID</td><td>the ID of the element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>input mesh </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>#E*4 matrix of integers (element colors) </dd></dl>

</div>
</div>
<a id="a9b16b64a5d64ed8cf8ef24f9a0639562" name="a9b16b64a5d64ed8cf8ef24f9a0639562"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b16b64a5d64ed8cf8ef24f9a0639562">&#9670;&#160;</a></span>elementEnumString()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> ELEM_ID&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char * vcl::elementEnumString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0aeda48720e2d34688e56a6ab79b7600" name="a0aeda48720e2d34688e56a6ab79b7600"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0aeda48720e2d34688e56a6ab79b7600">&#9670;&#160;</a></span>elementNormalsMatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> ELEM_ID, MatrixConcept Matrix, MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Matrix vcl::elementNormalsMatrix </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a #E <a class="el" href="classvcl_1_1Vector.html" title="The Vector class is a generic container of objects of type T, that could have fixed or dynamic size,...">Vector</a> of booleans (or integers) containing the selection status of the elements identified by <code>ELEM_ID</code> of a <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>. The function is templated on the <a class="el" href="classvcl_1_1Vector.html" title="The Vector class is a generic container of objects of type T, that could have fixed or dynamic size,...">Vector</a> itself. </p>
<p>This function works with every <a class="el" href="classvcl_1_1Vector.html" title="The Vector class is a generic container of objects of type T, that could have fixed or dynamic size,...">Vector</a> type that has a constructor with a size_t argument and an operator[uint].</p>
<p>Usage example with Eigen <a class="el" href="classvcl_1_1Vector.html" title="The Vector class is a generic container of objects of type T, that could have fixed or dynamic size,...">Vector</a>:</p>
<div class="fragment"><div class="line">   Eigen::VectorXi S =</div>
<div class="line">       vcl::elementSelectionVector&lt;VERTEX, Eigen::VectorXi&gt;(myMesh);</div>
<div class="line">   <span class="keyword">@end</span><span class="keywordflow">if</span></div>
<div class="line">  </div>
<div class="line">   @note This function does not guarantee that the rows of the vector</div>
<div class="line">   correspond to the element indices of the mesh. This scenario is possible</div>
<div class="line">   when the mesh has deleted elements. To be sure to have a direct</div>
<div class="line">   correspondence, compact the element container before calling <span class="keyword">this</span> function.</div>
<div class="line">  </div>
<div class="line">   @tparam ELEM_ID: the ID of the element.</div>
<div class="line">   @tparam Vect: type of the vector to be returned.</div>
<div class="line">   @tparam MeshType: type of the input mesh, it must satisfy the MeshConcept.</div>
<div class="line">  </div>
<div class="line">   @param[in] mesh: input mesh</div>
<div class="line">   @<span class="keywordflow">return</span> #E vector of booleans or integers (element selection)</div>
<div class="line">  /</div>
<div class="line"><span class="keyword">template</span>&lt;u<span class="keywordtype">int</span> ELEM_ID, <span class="keyword">typename</span> Vect, MeshConcept MeshType&gt;</div>
<div class="line">Vect elementSelectionVector(<span class="keyword">const</span> MeshType&amp; mesh)</div>
<div class="line">{</div>
<div class="line">    Vect S(mesh.template number&lt;ELEM_ID&gt;());</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_typedef" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> i = 0;</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; e : mesh.template elements&lt;ELEM_ID&gt;())</div>
<div class="line">        S[i] = e.selected();</div>
<div class="line">    <span class="keywordflow">return</span> S;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Vect, MeshConcept MeshType&gt;</div>
<div class="line">Vect vertexSelectionVector(<span class="keyword">const</span> MeshType&amp; mesh)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> elementSelectionVector&lt;VERTEX, Vect&gt;(mesh);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Vect, FaceMeshConcept MeshType&gt;</div>
<div class="line">Vect faceSelectionVector(<span class="keyword">const</span> MeshType&amp; mesh)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> elementSelectionVector&lt;FACE, Vect&gt;(mesh);</div>
<div class="line">}</div>
<div class="line"> </div>
</div><!-- fragment --><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classvcl_1_1MissingComponentException.html">vcl::MissingComponentException</a></td><td>if the mesh does not have per-element normals available.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function does not guarantee that the rows of the matrix correspond to the element indices of the mesh. This scenario is possible when the mesh has deleted elements. To be sure to have a direct correspondence, compact the element container before calling this function.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ELEM_ID</td><td>the ID of the element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>input mesh </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>#E*3 matrix of scalars (element normals) </dd></dl>

</div>
</div>
<a id="a8e07fcb626e0c670f8f92e930d0b2c46" name="a8e07fcb626e0c670f8f92e930d0b2c46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e07fcb626e0c670f8f92e930d0b2c46">&#9670;&#160;</a></span>elementQualityVector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> ELEM_ID, typename Vect , MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Vect vcl::elementQualityVector </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a #E <a class="el" href="classvcl_1_1Vector.html" title="The Vector class is a generic container of objects of type T, that could have fixed or dynamic size,...">Vector</a> of scalars containing the quality of the elements identified by <code>ELEM_ID</code> of a <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>. The function is templated on the <a class="el" href="classvcl_1_1Vector.html" title="The Vector class is a generic container of objects of type T, that could have fixed or dynamic size,...">Vector</a> itself. </p>
<p>This function works with every <a class="el" href="classvcl_1_1Vector.html" title="The Vector class is a generic container of objects of type T, that could have fixed or dynamic size,...">Vector</a> type that has a constructor with a size_t argument and an operator[uint], and requires that the mesh has per-element quality.</p>
<p>Usage example with Eigen <a class="el" href="classvcl_1_1Vector.html" title="The Vector class is a generic container of objects of type T, that could have fixed or dynamic size,...">Vector</a>:</p>
<div class="fragment"><div class="line">Eigen::VectorXd EQ =</div>
<div class="line">    vcl::elementQualityVector&lt;VERTEX, Eigen::VectorXd&gt;(myMesh);</div>
</div><!-- fragment --><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classvcl_1_1MissingComponentException.html">vcl::MissingComponentException</a></td><td>if the mesh does not have per-element quality available.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function does not guarantee that the rows of the vector correspond to the element indices of the mesh. This scenario is possible when the mesh has deleted elements. To be sure to have a direct correspondence, compact the element container before calling this function.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ELEM_ID</td><td>the ID of the element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>input mesh </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>#V vector of scalars (element quality) </dd></dl>

</div>
</div>
<a id="a617cf756eac51fcf6b566ce5d4c09393" name="a617cf756eac51fcf6b566ce5d4c09393"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a617cf756eac51fcf6b566ce5d4c09393">&#9670;&#160;</a></span>enableIfPerVertexAdjacentFacesOptional()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool vcl::enableIfPerVertexAdjacentFacesOptional </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6e15c93274d1207f45bb0673fce3ba8a" name="a6e15c93274d1207f45bb0673fce3ba8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e15c93274d1207f45bb0673fce3ba8a">&#9670;&#160;</a></span>enableIfPerVertexAdjacentVerticesOptional()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool vcl::enableIfPerVertexAdjacentVerticesOptional </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a802d56a620a24d04972ba5d483a2730a" name="a802d56a620a24d04972ba5d483a2730a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a802d56a620a24d04972ba5d483a2730a">&#9670;&#160;</a></span>enableIfPerVertexColorOptional()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool vcl::enableIfPerVertexColorOptional </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a64bde18cc07f8804c0c96e5def984f26" name="a64bde18cc07f8804c0c96e5def984f26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64bde18cc07f8804c0c96e5def984f26">&#9670;&#160;</a></span>enableIfPerVertexMarkOptional()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool vcl::enableIfPerVertexMarkOptional </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af4a7a739d6f30a2e4768b7b12c663418" name="af4a7a739d6f30a2e4768b7b12c663418"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4a7a739d6f30a2e4768b7b12c663418">&#9670;&#160;</a></span>enableIfPerVertexNormalOptional()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool vcl::enableIfPerVertexNormalOptional </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a579b161f8a4132e5106608bebc70e363" name="a579b161f8a4132e5106608bebc70e363"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a579b161f8a4132e5106608bebc70e363">&#9670;&#160;</a></span>enableIfPerVertexPrincipalCurvatureOptional()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool vcl::enableIfPerVertexPrincipalCurvatureOptional </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa9eb68875b4658e81e104725173df6fd" name="aa9eb68875b4658e81e104725173df6fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9eb68875b4658e81e104725173df6fd">&#9670;&#160;</a></span>enableIfPerVertexQualityOptional()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool vcl::enableIfPerVertexQualityOptional </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a369d2067cce035b7b4a710c5b364a28c" name="a369d2067cce035b7b4a710c5b364a28c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a369d2067cce035b7b4a710c5b364a28c">&#9670;&#160;</a></span>enableIfPerVertexTexCoordOptional()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool vcl::enableIfPerVertexTexCoordOptional </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5f449c33787533e7b85070de82f5d78d" name="a5f449c33787533e7b85070de82f5d78d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f449c33787533e7b85070de82f5d78d">&#9670;&#160;</a></span>epsilonCompare()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool vcl::epsilonCompare </td>
          <td>(</td>
          <td class="paramtype">Scalar&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Scalar&#160;</td>
          <td class="paramname"><em>p2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Scalar&#160;</td>
          <td class="paramname"><em>epsilon</em> = <code>std::numeric_limits&lt;Scalar&gt;::epsilon()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a12529598a32a7b21eac27744b3578600" name="a12529598a32a7b21eac27744b3578600"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12529598a32a7b21eac27744b3578600">&#9670;&#160;</a></span>faceAngleOnVertexRad()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceConcept FaceType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto vcl::faceAngleOnVertexRad </td>
          <td>(</td>
          <td class="paramtype">const FaceType &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a>&#160;</td>
          <td class="paramname"><em>vi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the internal angle (in radians) of the vi-th vertex of the face. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FaceType</td><td>the type of the face that satisfies the FaceConcept.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>the input face. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vi</td><td>the index of the vertex in the face on which calculate the angle </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the angle in radians at the vi-th vertex. </dd></dl>

</div>
</div>
<a id="a9fc3b9cae851d7a729f40dc2f4ebe824" name="a9fc3b9cae851d7a729f40dc2f4ebe824"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fc3b9cae851d7a729f40dc2f4ebe824">&#9670;&#160;</a></span>faceArea()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceConcept FaceType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto vcl::faceArea </td>
          <td>(</td>
          <td class="paramtype">const FaceType &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the area of a face. Works both for triangle and polygonal faces, and it is optimized in case of triangle faces. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FaceType</td><td>the type of the face that satisfies the FaceConcept.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>the input face. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the area of the face. </dd></dl>

</div>
</div>
<a id="a53b4f63db0979e578ebfa4b9e8b41f8a" name="a53b4f63db0979e578ebfa4b9e8b41f8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53b4f63db0979e578ebfa4b9e8b41f8a">&#9670;&#160;</a></span>faceBarycenter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceConcept FaceType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">FaceType::VertexType::CoordType vcl::faceBarycenter </td>
          <td>(</td>
          <td class="paramtype">const FaceType &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the barycenter of a face. Works both for triangle and polygonal faces, and it is optimized in case of triangle faces. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FaceType</td><td>the type of the face that satisfies the FaceConcept.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>the input face. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the barycenter of the face. </dd></dl>

</div>
</div>
<a id="abb99398069d243b6bb7b09e55a279792" name="abb99398069d243b6bb7b09e55a279792"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb99398069d243b6bb7b09e55a279792">&#9670;&#160;</a></span>faceBoxIntersect()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceConcept FaceType, PointConcept PointType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool vcl::faceBoxIntersect </td>
          <td>(</td>
          <td class="paramtype">const FaceType &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvcl_1_1Box.html">Box</a>&lt; PointType &gt; &amp;&#160;</td>
          <td class="paramname"><em>box</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a480cf1413039e05d9065485c52076ce9" name="a480cf1413039e05d9065485c52076ce9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a480cf1413039e05d9065485c52076ce9">&#9670;&#160;</a></span>faceColorsMatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MatrixConcept Matrix, FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Matrix vcl::faceColorsMatrix </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a #F*4 Matrix of integers containing the colors of the faces of a <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>. The function is templated on the Matrix itself. </p>
<p>This function works with every Matrix type that satisfies the MatrixConcept, and requires that the mesh has per-face colors.</p>
<p>Usage example with Eigen Matrix:</p>
<div class="fragment"><div class="line">Eigen::MatrixX4i FC = vcl::faceColorsMatrix&lt;Eigen::MatrixX4i&gt;(myMesh);</div>
</div><!-- fragment --><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classvcl_1_1MissingComponentException.html">vcl::MissingComponentException</a></td><td>if the mesh does not have per-face colors available.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function does not guarantee that the rows of the matrix correspond to the face indices of the mesh. This scenario is possible when the mesh has deleted faces. To be sure to have a direct correspondence, compact the face container before calling this function.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>input mesh </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>#F*4 matrix of integers (face colors) </dd></dl>

</div>
</div>
<a id="a2177afd92cfc4dbe6468aa05892b016f" name="a2177afd92cfc4dbe6468aa05892b016f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2177afd92cfc4dbe6468aa05892b016f">&#9670;&#160;</a></span>faceDihedralAngleOnEdge()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceConcept FaceType&gt; <br />
requires comp::HasAdjacentFaces&lt;FaceType&gt;</div>
      <table class="memname">
        <tr>
          <td class="memname">auto vcl::faceDihedralAngleOnEdge </td>
          <td>(</td>
          <td class="paramtype">const FaceType &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a>&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the signed dihedral angle between the normals of the given face and its adjacent face on the edge <code>e</code>. </p>
<p>*</p>
<p>The angle between the normal is signed according to the concavity/convexity of the dihedral angle: negative if the edge shared between the two faces is concave, positive otherwise. The surface it is assumend to be oriented. It simply use the projection of the opposite vertex onto the plane of the other one. It does not assume anything on face normals.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FaceType</td><td>the type of the face that satisfies the FaceConcept.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>The face for which to compute the dihedral angle on an edge. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">e</td><td>The index of the edge shared between the two faces. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The signed dihedral angle between the normals of the given face and its adjacent face on the edge e. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classvcl_1_1MissingComponentException.html">vcl::MissingComponentException</a></td><td>If the "AdjacentFaces" component is not available on <code>f</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a711865422c63688724ec6328b4e7c4cd" name="a711865422c63688724ec6328b4e7c4cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a711865422c63688724ec6328b4e7c4cd">&#9670;&#160;</a></span>faceEdgesOnBorderNumber()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceConcept FaceType&gt; <br />
requires comp::HasAdjacentFaces&lt;FaceType&gt;</div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> vcl::faceEdgesOnBorderNumber </td>
          <td>(</td>
          <td class="paramtype">const FaceType &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of edges that are on border (no adjacent faces) on the given face. </p>
<p>This function requires AdjacentFaces component, that must be available and computed before calling this function.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classvcl_1_1MissingComponentException.html">vcl::MissingComponentException</a></td><td>if the "AdjacentFaces" component is not available on <code>f</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FaceType</td><td>the type of the face that satisfies the FaceConcept.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>The face to check for border edges. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of edges on the border of the face. </dd></dl>

</div>
</div>
<a id="a350d3edc324e0bef955a2c2ef8e20859" name="a350d3edc324e0bef955a2c2ef8e20859"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a350d3edc324e0bef955a2c2ef8e20859">&#9670;&#160;</a></span>faceNormal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceConcept FaceType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">FaceType::VertexType::CoordType vcl::faceNormal </td>
          <td>(</td>
          <td class="paramtype">const FaceType &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the normal of a face, without modifying the face. Works both for triangle and polygonal faces, and it is optimized in case of triangle faces. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FaceType</td><td>the type of the face that satisfies the FaceConcept.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>the input face. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the normal of the face. </dd></dl>

</div>
</div>
<a id="a6bc50612a1185ec7d1add143f93eb0ec" name="a6bc50612a1185ec7d1add143f93eb0ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bc50612a1185ec7d1add143f93eb0ec">&#9670;&#160;</a></span>faceNormalsMatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MatrixConcept Matrix, FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Matrix vcl::faceNormalsMatrix </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a #F*3 Matrix of scalars containing the normals of the faces of a <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>. The function is templated on the Matrix itself. </p>
<p>This function works with every Matrix type that satisfies the MatrixConcept, and requires that the mesh has per-face normals.</p>
<p>Usage example with Eigen Matrix:</p>
<div class="fragment"><div class="line">Eigen::MatrixX3d FN = vcl::faceNormalsMatrix&lt;Eigen::MatrixX3d&gt;(myMesh);</div>
</div><!-- fragment --><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classvcl_1_1MissingComponentException.html">vcl::MissingComponentException</a></td><td>if the mesh does not have per-face normals available.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function does not guarantee that the rows of the matrix correspond to the face indices of the mesh. This scenario is possible when the mesh has deleted faces. To be sure to have a direct correspondence, compact the face container before calling this function.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>input mesh </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>#F*3 matrix of scalars (face normals) </dd></dl>

</div>
</div>
<a id="a1dccfede16e36e5ded5213fb13643943" name="a1dccfede16e36e5ded5213fb13643943"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dccfede16e36e5ded5213fb13643943">&#9670;&#160;</a></span>facePerimeter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceConcept FaceType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto vcl::facePerimeter </td>
          <td>(</td>
          <td class="paramtype">const FaceType &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the perimeter of a face. Works both for triangle and polygonal faces, and it is optimized in case of triangle faces. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FaceType</td><td>the type of the face that satisfies the FaceConcept.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>the input face. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the perimeter of the face. </dd></dl>

</div>
</div>
<a id="a4cdee5764b3aa8dbc91ff6a114e9bfc1" name="a4cdee5764b3aa8dbc91ff6a114e9bfc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cdee5764b3aa8dbc91ff6a114e9bfc1">&#9670;&#160;</a></span>faceQualityAverage()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto vcl::faceQualityAverage </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a scalar that is the average of the face quality. </p>
<p>Requirements:</p><ul>
<li><a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>:<ul>
<li>Faces:<ul>
<li>Quality</li>
</ul>
</li>
</ul>
</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>the input <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a> on which compute the average of the quality. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The average of the face quality of the given mesh. </dd></dl>

</div>
</div>
<a id="af44349f8534585f6e0cef128edb98ca0" name="af44349f8534585f6e0cef128edb98ca0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af44349f8534585f6e0cef128edb98ca0">&#9670;&#160;</a></span>faceQualityHistogram()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType, typename HScalar  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Histogram.html">Histogram</a>&lt; HScalar &gt; vcl::faceQualityHistogram </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>selectionOnly</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a>&#160;</td>
          <td class="paramname"><em>histSize</em> = <code>10000</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a42145b026908d9eafadd429eba4fa0be" name="a42145b026908d9eafadd429eba4fa0be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42145b026908d9eafadd429eba4fa0be">&#9670;&#160;</a></span>faceQualityMinMax()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto vcl::faceQualityMinMax </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a pair containing the min and the maximum face quality. </p>
<p>Requirements:</p><ul>
<li><a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>:<ul>
<li>Faces:<ul>
<li>Quality</li>
</ul>
</li>
</ul>
</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>the input <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a> on which compute the minimum and the maximum quality. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code>std::pair</code> having as first element the minimum, and as second element the maximum quality. </dd></dl>

</div>
</div>
<a id="a7afddefac9fc869e5cb82367856f19e9" name="a7afddefac9fc869e5cb82367856f19e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7afddefac9fc869e5cb82367856f19e9">&#9670;&#160;</a></span>faceQualityVector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Vect , FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Vect vcl::faceQualityVector </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a #F <a class="el" href="classvcl_1_1Vector.html" title="The Vector class is a generic container of objects of type T, that could have fixed or dynamic size,...">Vector</a> of scalars containing the quality of the faces of a <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>. The function is templated on the <a class="el" href="classvcl_1_1Vector.html" title="The Vector class is a generic container of objects of type T, that could have fixed or dynamic size,...">Vector</a> itself. </p>
<p>This function works with every <a class="el" href="classvcl_1_1Vector.html" title="The Vector class is a generic container of objects of type T, that could have fixed or dynamic size,...">Vector</a> type that has a constructor with a size_t argument and an operator(uint), and requires that the mesh has per-face quality.</p>
<p>Usage example with Eigen <a class="el" href="classvcl_1_1Vector.html" title="The Vector class is a generic container of objects of type T, that could have fixed or dynamic size,...">Vector</a>:</p>
<div class="fragment"><div class="line">Eigen::VectorXd FQ = vcl::faceQualityVector&lt;Eigen::VectorXd&gt;(myMesh);</div>
</div><!-- fragment --><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classvcl_1_1MissingComponentException.html">vcl::MissingComponentException</a></td><td>if the mesh does not have per-face quality available.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function does not guarantee that the rows of the vector correspond to the face indices of the mesh. This scenario is possible when the mesh has deleted faces. To be sure to have a direct correspondence, compact the face container before calling this function.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>input mesh </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>#F vector of scalars (face quality) </dd></dl>

</div>
</div>
<a id="a5585995167e0f9338ebb153314c0067b" name="a5585995167e0f9338ebb153314c0067b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5585995167e0f9338ebb153314c0067b">&#9670;&#160;</a></span>faceSelectionNumber()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> vcl::faceSelectionNumber </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9a74b10bc09834d0a2d787336a5f7823" name="a9a74b10bc09834d0a2d787336a5f7823"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a74b10bc09834d0a2d787336a5f7823">&#9670;&#160;</a></span>faceSphereItersect() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceConcept FaceType, typename SScalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool vcl::faceSphereItersect </td>
          <td>(</td>
          <td class="paramtype">const FaceType &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvcl_1_1Sphere.html">Sphere</a>&lt; SScalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>sphere</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the intersection between a sphere and a face, that may be also polygonal. </p>
<p>If the face is a triangle, the triangleSphereIntersect function will be used. If the face is polygonal, the face is first triangulated using an earcut algorithm, and then for each triangle, the triangleSphereIntersect is computed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>the input face </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sphere</td><td>the input sphere </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true iff there is an intersection between the sphere and the face </dd></dl>

</div>
</div>
<a id="a0cec6eee8e30eefd8783a997a48127fa" name="a0cec6eee8e30eefd8783a997a48127fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cec6eee8e30eefd8783a997a48127fa">&#9670;&#160;</a></span>faceSphereItersect() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceConcept FaceType, PointConcept PointType, typename SScalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool vcl::faceSphereItersect </td>
          <td>(</td>
          <td class="paramtype">const FaceType &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvcl_1_1Sphere.html">Sphere</a>&lt; SScalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>sphere</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PointType &amp;&#160;</td>
          <td class="paramname"><em>witness</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::pair&lt; SScalar, SScalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>res</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the intersection between a sphere and a face, that may be also polygonal. </p>
<p>If the face is a triangle, the triangleSphereIntersect function will be used. If the face is polygonal, the face is first triangulated using an earcut algorithm, and then for each triangle, the triangleSphereIntersect is computed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>the input face </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sphere</td><td>the input sphere </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">witness</td><td>the point on the triangle nearest to the center of the sphere (even when there isn't intersection) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">res</td><td>if not null, in the first item is stored the minimum distance between the face and the sphere, while in the second item is stored the penetration depth </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true iff there is an intersection between the sphere and the face </dd></dl>

</div>
</div>
<a id="ae41a0dea61c2ea301966406de57ae461" name="ae41a0dea61c2ea301966406de57ae461"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae41a0dea61c2ea301966406de57ae461">&#9670;&#160;</a></span>fillAndShuffleFaceIndexVector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> &gt; vcl::fillAndShuffleFaceIndexVector </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>deterministic</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab9b1a38c4fad92ad74bbc461e64f1c08" name="ab9b1a38c4fad92ad74bbc461e64f1c08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9b1a38c4fad92ad74bbc461e64f1c08">&#9670;&#160;</a></span>fillAndShuffleFacePointerVector() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; const typename MeshType::FaceType * &gt; vcl::fillAndShuffleFacePointerVector </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>deterministic</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad656a119fe2eb1573d28a28e6576d41d" name="ad656a119fe2eb1573d28a28e6576d41d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad656a119fe2eb1573d28a28e6576d41d">&#9670;&#160;</a></span>fillAndShuffleFacePointerVector() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; typename MeshType::FaceType * &gt; vcl::fillAndShuffleFacePointerVector </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>deterministic</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac9667638a4f4f3faea6994a61ce7119e" name="ac9667638a4f4f3faea6994a61ce7119e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9667638a4f4f3faea6994a61ce7119e">&#9670;&#160;</a></span>fillAndShuffleVertexIndexVector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> &gt; vcl::fillAndShuffleVertexIndexVector </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>deterministic</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa78e0576d6ad4f8e4af89367f38dabe5" name="aa78e0576d6ad4f8e4af89367f38dabe5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa78e0576d6ad4f8e4af89367f38dabe5">&#9670;&#160;</a></span>fillAndShuffleVertexPointerVector() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; const typename MeshType::VertexType * &gt; vcl::fillAndShuffleVertexPointerVector </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>deterministic</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1d6bf09841cfbbaaa328de2d552fc090" name="a1d6bf09841cfbbaaa328de2d552fc090"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d6bf09841cfbbaaa328de2d552fc090">&#9670;&#160;</a></span>fillAndShuffleVertexPointerVector() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; typename MeshType::VertexType * &gt; vcl::fillAndShuffleVertexPointerVector </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>deterministic</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a66a5b3121ca08d3686ae7637a9e30cf7" name="a66a5b3121ca08d3686ae7637a9e30cf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66a5b3121ca08d3686ae7637a9e30cf7">&#9670;&#160;</a></span>fillAndSortMeshEdgeUtilVector() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classvcl_1_1ConstMeshEdgeUtil.html">ConstMeshEdgeUtil</a>&lt; MeshType &gt; &gt; vcl::fillAndSortMeshEdgeUtilVector </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>includeFauxEdges</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8ff4adce6cdd2cc82aec090338c4ccfe" name="a8ff4adce6cdd2cc82aec090338c4ccfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ff4adce6cdd2cc82aec090338c4ccfe">&#9670;&#160;</a></span>fillAndSortMeshEdgeUtilVector() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classvcl_1_1MeshEdgeUtil.html">MeshEdgeUtil</a>&lt; MeshType &gt; &gt; vcl::fillAndSortMeshEdgeUtilVector </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>includeFauxEdges</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abbf2dd04b5f4477ba07ab217dd603d14" name="abbf2dd04b5f4477ba07ab217dd603d14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbf2dd04b5f4477ba07ab217dd603d14">&#9670;&#160;</a></span>fitPlaneToPointCloud()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Plane.html">Plane</a>&lt; Scalar &gt; vcl::fitPlaneToPointCloud </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="group__space.html#ga13f2718b0763def563b8bd9f65982833">Point3</a>&lt; Scalar &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>pointVec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the plane best fitting a set of points The algorithm used is the classical Covariance matrix eigenvector approach. </p>

</div>
</div>
<a id="af8d724d35f1e65a0966e980fc544364f" name="af8d724d35f1e65a0966e980fc544364f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8d724d35f1e65a0966e980fc544364f">&#9670;&#160;</a></span>fitPlaneToWeightedPointCloud()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Plane.html">Plane</a>&lt; Scalar &gt; vcl::fitPlaneToWeightedPointCloud </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="group__space.html#ga13f2718b0763def563b8bd9f65982833">Point3</a>&lt; Scalar &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>pointVec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the plane best fitting a wighted set of points The algorithm used is the wighted Covariance matrix eigenvector approach. </p>

</div>
</div>
<a id="aeb189433c1c9d7bf52a96ff359f364ec" name="aeb189433c1c9d7bf52a96ff359f364ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb189433c1c9d7bf52a96ff359f364ec">&#9670;&#160;</a></span>hashCombine()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... Rest&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::hashCombine </td>
          <td>(</td>
          <td class="paramtype">std::size_t &amp;&#160;</td>
          <td class="paramname"><em>seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Rest &amp;...&#160;</td>
          <td class="paramname"><em>rest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starting from a seed, computes the hash of a series of objects. </p>
<p><a href="https://stackoverflow.com/a/57595105/5851101">https://stackoverflow.com/a/57595105/5851101</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">[in/out]</td><td>seed: input seed and output hash </td></tr>
    <tr><td class="paramname">v</td><td>first argument object </td></tr>
    <tr><td class="paramname">rest</td><td>rest of the argument objects </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9082710ebf39cdd11a256086220d007a" name="a9082710ebf39cdd11a256086220d007a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9082710ebf39cdd11a256086220d007a">&#9670;&#160;</a></span>hausdorffDistance()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType1, MeshConcept MeshType2, LoggerConcept LogType = NullLogger&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvcl_1_1HausdorffDistResult.html">HausdorffDistResult</a> vcl::hausdorffDistance </td>
          <td>(</td>
          <td class="paramtype">const MeshType1 &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MeshType2 &amp;&#160;</td>
          <td class="paramname"><em>m2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LogType &amp;&#160;</td>
          <td class="paramname"><em>log</em> = <code><a class="el" href="group__miscellaneous.html#ga3377e3c875ec245e90ac5a395105ce99">nullLogger</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacevcl.html#a5a4e8376b2d47797f9167f2a8dd6fb0e">HausdorffSamplingMethod</a>&#160;</td>
          <td class="paramname"><em>sampMethod</em> = <code><a class="el" href="namespacevcl.html#a5a4e8376b2d47797f9167f2a8dd6fb0ea33aad0431cadce18cad82201cb732f49">HAUSDORFF_VERTEX_UNIFORM</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a>&#160;</td>
          <td class="paramname"><em>nSamples</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>deterministic</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9bdac4366b8757c10172f6e1ad61976d" name="a9bdac4366b8757c10172f6e1ad61976d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bdac4366b8757c10172f6e1ad61976d">&#9670;&#160;</a></span>importEdgeColorsFromMatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;EdgeMeshConcept MeshType, MatrixConcept ECMatrix&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::importEdgeColorsFromMatrix </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ECMatrix &amp;&#160;</td>
          <td class="paramname"><em>edgeColors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abd8cc56f370e2fca77dc3da2a248d1f5" name="abd8cc56f370e2fca77dc3da2a248d1f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd8cc56f370e2fca77dc3da2a248d1f5">&#9670;&#160;</a></span>importEdgesFromMatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;EdgeMeshConcept MeshType, MatrixConcept EMatrix&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::importEdgesFromMatrix </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const EMatrix &amp;&#160;</td>
          <td class="paramname"><em>edges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>clearBeforeSet</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a909af3aba8fff954b61d9c98f7470eab" name="a909af3aba8fff954b61d9c98f7470eab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a909af3aba8fff954b61d9c98f7470eab">&#9670;&#160;</a></span>importFaceColorsFromMatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType, MatrixConcept FCMatrix&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::importFaceColorsFromMatrix </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FCMatrix &amp;&#160;</td>
          <td class="paramname"><em>faceColors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab91626832747d82bfe051ffc6a9d8619" name="ab91626832747d82bfe051ffc6a9d8619"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab91626832747d82bfe051ffc6a9d8619">&#9670;&#160;</a></span>importFaceNormalsFromMatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType, MatrixConcept FNMatrix&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::importFaceNormalsFromMatrix </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FNMatrix &amp;&#160;</td>
          <td class="paramname"><em>faceNormals</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a41c8a076bfadd5ab22ebd08eab05237d" name="a41c8a076bfadd5ab22ebd08eab05237d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41c8a076bfadd5ab22ebd08eab05237d">&#9670;&#160;</a></span>importFacesFromMatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType, MatrixConcept FMatrix&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::importFacesFromMatrix </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FMatrix &amp;&#160;</td>
          <td class="paramname"><em>faces</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>clearBeforeSet</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af39dbdcb3c98584459fdb4b3e87e3332" name="af39dbdcb3c98584459fdb4b3e87e3332"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af39dbdcb3c98584459fdb4b3e87e3332">&#9670;&#160;</a></span>importMeshFromMatrices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType, MatrixConcept VMatrix, MatrixConcept FMatrix = Eigen::MatrixX3i, MatrixConcept EMatrix = Eigen::MatrixX2i, MatrixConcept VNMatrix = Eigen::MatrixX3d, MatrixConcept FNMatrix = Eigen::MatrixX3d&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::importMeshFromMatrices </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VMatrix &amp;&#160;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FMatrix &amp;&#160;</td>
          <td class="paramname"><em>faces</em> = <code>FMatrix()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const EMatrix &amp;&#160;</td>
          <td class="paramname"><em>edges</em> = <code>EMatrix()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VNMatrix &amp;&#160;</td>
          <td class="paramname"><em>vertexNormals</em> = <code>VNMatrix()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FNMatrix &amp;&#160;</td>
          <td class="paramname"><em>faceNormals</em> = <code>FNMatrix()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the given input <code>mesh</code> from the input vertex matrix, and the other matrices that are given as arguments. </p>
<p>The function accepts several input matrices/vectors, that are used only if their number of rows is different from zero. It tries to fill all the data contained in the non-empty input matrices into the <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>:</p><ul>
<li>if a <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a> is not able to store same data, the relative input matrix is ignored. For example, if the <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a> has no faces, the function will ignore the input face matrix, also if that is not empty.</li>
<li>if a <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a> is able to store some data and the relative input matrix is not empty, the data will be stored in the <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>. If the matrix has not the expected size, an exception is thrown.</li>
</ul>
<p>The mesh is cleared and all the optional components are disabled before adding the data from the input matrices.</p>
<dl class="section note"><dt>Note</dt><dd>If the <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a> is not able to store some data from the matrices, that data will be ignored. For example, if the <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a> has no faces, the function will ignore the input face matrix, also if that is not empty.</dd>
<dd>
Only the optional components having their corresponding input matrix not empty will be enabled and filled. All the other optional components will be left disabled.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classvcl_1_1WrongSizeException.html">vcl::WrongSizeException</a></td><td>if the sizes of the non-empty input matrices have not the expected sizes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MeshType</td><td>the type of the mesh to be created. It must satisfy the MeshConcept. </td></tr>
    <tr><td class="paramname">VMatrix</td><td>the type of the input vertex matrix. It must satisfy the MatrixConcept. </td></tr>
    <tr><td class="paramname">FMatrix</td><td>the type of the input face matrix. It must satisfy the MatrixConcept. </td></tr>
    <tr><td class="paramname">EMatrix</td><td>the type of the input edge matrix. It must satisfy the MatrixConcept. </td></tr>
    <tr><td class="paramname">VNMatrix</td><td>the type of the input vertex normal matrix. It must satisfy the MatrixConcept. </td></tr>
    <tr><td class="paramname">FNMatrix</td><td>the type of the input face normal matrix. It must satisfy the MatrixConcept.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>the mesh on which import all the input data from the matrices. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vertices</td><td>a #V*3 matrix containing the coordinates of the vertices of the mesh. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">faces</td><td>a #F*3 matrix containing the indices of the vertices of the faces of the mesh. If the number of rows of this matrix is zero, the function will not add faces to the mesh. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">edges</td><td>a #E*2 matrix containing the indices of the vertices of the edges of the mesh. If the number of rows of this matrix is zero, the function will not add edges to the mesh. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vertexNormals</td><td>a #V*3 matrix containing the normals of the vertices of the mesh. If the number of rows of this matrix is zero, the function will not add vertex normals to the mesh. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">faceNormals</td><td>a #F*3 matrix containing the normals of the faces of the mesh. If the number of rows of this matrix is zero, the function will not add face normals to the mesh. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9fbae29299b52ac6270efba384a7ee62" name="a9fbae29299b52ac6270efba384a7ee62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fbae29299b52ac6270efba384a7ee62">&#9670;&#160;</a></span>importMeshFromVCGMesh()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType, typename VCGMeshType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::importMeshFromVCGMesh </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VCGMeshType &amp;&#160;</td>
          <td class="paramname"><em>vcgMesh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac0b73844d3c33491eb38e6e34017eb98" name="ac0b73844d3c33491eb38e6e34017eb98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0b73844d3c33491eb38e6e34017eb98">&#9670;&#160;</a></span>importVertexColorsFromMatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType, MatrixConcept VCMatrix&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::importVertexColorsFromMatrix </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VCMatrix &amp;&#160;</td>
          <td class="paramname"><em>vertexColors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a255e7edcea02d432b2aa8a1c46dae3e5" name="a255e7edcea02d432b2aa8a1c46dae3e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a255e7edcea02d432b2aa8a1c46dae3e5">&#9670;&#160;</a></span>importVertexNormalsFromMatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType, MatrixConcept VNMatrix&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::importVertexNormalsFromMatrix </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VNMatrix &amp;&#160;</td>
          <td class="paramname"><em>vertexNormals</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a02ca8fdd4a9b050d0f0ac4d5e1c13bde" name="a02ca8fdd4a9b050d0f0ac4d5e1c13bde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02ca8fdd4a9b050d0f0ac4d5e1c13bde">&#9670;&#160;</a></span>importVerticesFromMatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType, MatrixConcept VMatrix&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::importVerticesFromMatrix </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VMatrix &amp;&#160;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>clearBeforeSet</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the vertices of the given input <code>mesh</code> from the input vertex matrix. </p>
<p>If the argument <code>clearBeforeSet</code> is set to <code>true</code> (default), the function container of the mesh and then adds a number of vertices that depends on the number of rows of the input vertex matrix. In this scenario, all the other components of the vertices stored in the mesh before calling this function are lost.</p>
<p>If the argument <code>clearBeforeSet</code> is set to <code>false</code>, the function checks that the number of rows of the input vertex matrix is equal to the number of vertices of the mesh. If this is not the case, an exception is thrown. Then, the function sets the coordinates of the vertices of the mesh from the input vertex matrix. In this scenario, all the other components of the vertices stored in the mesh before calling this function are preserved.</p>
<p>All the other containers of the mesh and the optional components of vertices are left as they are. Pointers to vertices stored in the mesh are still valid (if the number of vertices and their index in the container is not changed).</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classvcl_1_1WrongSizeException.html">vcl::WrongSizeException</a></td><td>if the sizes of the input matrix are not valid (e.g. columns != 3 or rows != mesh.vertexNumber()).</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MeshType</td><td>the type of the mesh to be filled. It must satisfy the MeshConcept. </td></tr>
    <tr><td class="paramname">VMatrix</td><td>the type of the input vertex matrix. It must satisfy the MatrixConcept.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>the mesh on which import the input vertices. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vertices</td><td>a #V*3 matrix containing the coordinates of the vertices of the mesh. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">clearBeforeSet</td><td>if <code>true</code>, the function clears the container of the vertices of the mesh before adding the vertices from the input matrix. If <code>false</code>, the function sets the coordinates in the input matrix to the vertices of the mesh, leaving all the other components untouched. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae01694fdca8b252384be3296f82fa946" name="ae01694fdca8b252384be3296f82fa946"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae01694fdca8b252384be3296f82fa946">&#9670;&#160;</a></span>indexInTypePack() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename... Us&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> vcl::indexInTypePack </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac398b3cd16575f92ffc3e6cfd6ba1669" name="ac398b3cd16575f92ffc3e6cfd6ba1669"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac398b3cd16575f92ffc3e6cfd6ba1669">&#9670;&#160;</a></span>indexInTypePack() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename U , typename... Us&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> vcl::indexInTypePack </td>
          <td>(</td>
          <td class="paramtype">std::type_index&#160;</td>
          <td class="paramname"><em>ti</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad6ce6ce1ca6a9813f3437aa0aeee2d94" name="ad6ce6ce1ca6a9813f3437aa0aeee2d94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6ce6ce1ca6a9813f3437aa0aeee2d94">&#9670;&#160;</a></span>indexInTypePack() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> vcl::indexInTypePack </td>
          <td>(</td>
          <td class="paramtype">std::type_index&#160;</td>
          <td class="paramname"><em>ti</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvcl_1_1TypeWrapper.html">TypeWrapper</a>&lt; Args... &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a33948b0cb8e44bec17d4b0dfef8bd254" name="a33948b0cb8e44bec17d4b0dfef8bd254"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33948b0cb8e44bec17d4b0dfef8bd254">&#9670;&#160;</a></span>isDegenerate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool vcl::isDegenerate </td>
          <td>(</td>
          <td class="paramtype">Scalar&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af888cb13421f6fb92d776927f302518b" name="af888cb13421f6fb92d776927f302518b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af888cb13421f6fb92d776927f302518b">&#9670;&#160;</a></span>isFaceEdgeOnBorder()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceConcept FaceType&gt; <br />
requires comp::HasAdjacentFaces&lt;FaceType&gt;</div>
      <table class="memname">
        <tr>
          <td class="memname">bool vcl::isFaceEdgeOnBorder </td>
          <td>(</td>
          <td class="paramtype">const FaceType &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a>&#160;</td>
          <td class="paramname"><em>edge</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if an edge in the given face is on the border. </p>
<p>An edge is considered to be on the border if it is not shared by another face.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classvcl_1_1MissingComponentException.html">vcl::MissingComponentException</a></td><td>If the "AdjacentFaces" component is not available on <code>f</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FaceType</td><td>the type of the face that satisfies the FaceConcept.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>The face to check. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">edge</td><td>The index of the edge to check.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the edge is on the border, false otherwise. </dd></dl>

</div>
</div>
<a id="a25a86f4bcf104c60099849828d71e06f" name="a25a86f4bcf104c60099849828d71e06f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25a86f4bcf104c60099849828d71e06f">&#9670;&#160;</a></span>isFaceManifoldOnEdge()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceConcept FaceType&gt; <br />
requires comp::HasAdjacentFaces&lt;FaceType&gt;</div>
      <table class="memname">
        <tr>
          <td class="memname">bool vcl::isFaceManifoldOnEdge </td>
          <td>(</td>
          <td class="paramtype">const FaceType &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a>&#160;</td>
          <td class="paramname"><em>edge</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if an edge in the given face is manifold. </p>
<p>An edge is considered manifold if it is either a boundary edge or if it is shared by exactly two faces.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classvcl_1_1MissingComponentException.html">vcl::MissingComponentException</a></td><td>If the "AdjacentFaces" component is not available on <code>f</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FaceType</td><td>the type of the face that satisfies the FaceConcept.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>The face to check. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">edge</td><td>The index of the edge to check.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the edge is manifold, false otherwise. </dd></dl>

</div>
</div>
<a id="a9692d4f1afe48a370a2fe551d5ea55d4" name="a9692d4f1afe48a370a2fe551d5ea55d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9692d4f1afe48a370a2fe551d5ea55d4">&#9670;&#160;</a></span>isLoggerValid()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;LoggerConcept T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool vcl::isLoggerValid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The <a class="el" href="namespacevcl.html#a9692d4f1afe48a370a2fe551d5ea55d4" title="The isLoggerValid() function returns true if the type T is not the NullLogger type.">isLoggerValid()</a> function returns true if the type T is not the <a class="el" href="classvcl_1_1NullLogger.html" title="The NullLogger class is an empty class that is used as default type in all the library functions that...">NullLogger</a> type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the type to test if is a valid <a class="el" href="classvcl_1_1Logger.html">Logger</a>. It must satisfy the LoggerConcept.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true it T is a valid <a class="el" href="classvcl_1_1Logger.html">Logger</a> type. </dd></dl>

</div>
</div>
<a id="a3e568fca42924a53fde391597ff4e560" name="a3e568fca42924a53fde391597ff4e560"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e568fca42924a53fde391597ff4e560">&#9670;&#160;</a></span>isPerVertexAdjacentFacesAvailable()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool vcl::isPerVertexAdjacentFacesAvailable </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a84a2badab79a21f537f854257457ae8e" name="a84a2badab79a21f537f854257457ae8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84a2badab79a21f537f854257457ae8e">&#9670;&#160;</a></span>isPerVertexAdjacentVerticesAvailable()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool vcl::isPerVertexAdjacentVerticesAvailable </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac805cc3d735ee5883647218cdd1ee7e0" name="ac805cc3d735ee5883647218cdd1ee7e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac805cc3d735ee5883647218cdd1ee7e0">&#9670;&#160;</a></span>isPerVertexColorAvailable()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool vcl::isPerVertexColorAvailable </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7dc8c6d96d74cceffb34a1a480864563" name="a7dc8c6d96d74cceffb34a1a480864563"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dc8c6d96d74cceffb34a1a480864563">&#9670;&#160;</a></span>isPerVertexMarkAvailable()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool vcl::isPerVertexMarkAvailable </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af37173d6ec6aa5b11580217057aa6e24" name="af37173d6ec6aa5b11580217057aa6e24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af37173d6ec6aa5b11580217057aa6e24">&#9670;&#160;</a></span>isPerVertexNormalAvailable()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool vcl::isPerVertexNormalAvailable </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aeba9629e5f1c2363b2b35bc865f9d11e" name="aeba9629e5f1c2363b2b35bc865f9d11e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeba9629e5f1c2363b2b35bc865f9d11e">&#9670;&#160;</a></span>isPerVertexPrincipalCurvatureAvailable()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool vcl::isPerVertexPrincipalCurvatureAvailable </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a09449154647e40fd0a3c1e965a91bf49" name="a09449154647e40fd0a3c1e965a91bf49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09449154647e40fd0a3c1e965a91bf49">&#9670;&#160;</a></span>isPerVertexQualityAvailable()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool vcl::isPerVertexQualityAvailable </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a91da20c5938a63be8d206b547892a205" name="a91da20c5938a63be8d206b547892a205"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91da20c5938a63be8d206b547892a205">&#9670;&#160;</a></span>isPerVertexTexCoordAvailable()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool vcl::isPerVertexTexCoordAvailable </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab7606be147f292f38e1e22a709708a19" name="ab7606be147f292f38e1e22a709708a19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7606be147f292f38e1e22a709708a19">&#9670;&#160;</a></span>KDTree() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1KDTree.html">vcl::KDTree</a> </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td> -&gt;  <a class="el" href="classvcl_1_1KDTree.html">KDTree</a>&lt; typename MeshType::VertexType::CoordType &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab1ec171b583b3872ae8b1b5e6a513b49" name="ab1ec171b583b3872ae8b1b5e6a513b49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1ec171b583b3872ae8b1b5e6a513b49">&#9670;&#160;</a></span>KDTree() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1KDTree.html">vcl::KDTree</a> </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a>&#160;</td>
          <td class="paramname"><em>pointsPerCell</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  <a class="el" href="classvcl_1_1KDTree.html">KDTree</a>&lt; typename MeshType::VertexType::CoordType &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae5c4a6423ece2f30e5d81a3f5b0026b9" name="ae5c4a6423ece2f30e5d81a3f5b0026b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5c4a6423ece2f30e5d81a3f5b0026b9">&#9670;&#160;</a></span>KDTree() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1KDTree.html">vcl::KDTree</a> </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a>&#160;</td>
          <td class="paramname"><em>pointsPerCell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a>&#160;</td>
          <td class="paramname"><em>maxDepth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  <a class="el" href="classvcl_1_1KDTree.html">KDTree</a>&lt; typename MeshType::VertexType::CoordType &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae9e8e92d81c40489de3567c10b3db44c" name="ae9e8e92d81c40489de3567c10b3db44c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9e8e92d81c40489de3567c10b3db44c">&#9670;&#160;</a></span>KDTree() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1KDTree.html">vcl::KDTree</a> </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a>&#160;</td>
          <td class="paramname"><em>pointsPerCell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a>&#160;</td>
          <td class="paramname"><em>maxDepth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>balanced</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  <a class="el" href="classvcl_1_1KDTree.html">KDTree</a>&lt; typename MeshType::VertexType::CoordType &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6effb8d19dc6c62592f8f2cfff8a6854" name="a6effb8d19dc6c62592f8f2cfff8a6854"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6effb8d19dc6c62592f8f2cfff8a6854">&#9670;&#160;</a></span>laplacianSmoothing()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::laplacianSmoothing </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a>&#160;</td>
          <td class="paramname"><em>step</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>smoothSelected</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>cotangentWeight</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>vertexCoordLaplacianSmoothing the classical Laplacian smoothing. Each vertex is moved onto the average of the adjacent vertices. </p>
<p>Requirements:</p><ul>
<li><a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>:<ul>
<li>Vertices</li>
<li>Faces</li>
</ul>
</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>the mesh that will be smoothed </td></tr>
    <tr><td class="paramname">step</td><td></td></tr>
    <tr><td class="paramname">smoothSelected</td><td></td></tr>
    <tr><td class="paramname">cotangentWeight</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa6613e39304926dee856b8b9770b3be5" name="aa6613e39304926dee856b8b9770b3be5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6613e39304926dee856b8b9770b3be5">&#9670;&#160;</a></span>lnOfFactorial()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double vcl::lnOfFactorial </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes and caches the result of the natural logarithm of n! </p>
<p>If n &gt; 1024, uses the Stirling approximation. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a212fbf643d263ad106507f7aa462cf46" name="a212fbf643d263ad106507f7aa462cf46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a212fbf643d263ad106507f7aa462cf46">&#9670;&#160;</a></span>max() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Head , typename... Tail&gt; <br />
requires (sizeof...(tail) &gt; 0)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto vcl::max </td>
          <td>(</td>
          <td class="paramtype">const Head &amp;&#160;</td>
          <td class="paramname"><em>head0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Head &amp;&#160;</td>
          <td class="paramname"><em>head1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Tail &amp;...&#160;</td>
          <td class="paramname"><em>tail</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a49a9bdba85989ec5842081c5c84d4fc7" name="a49a9bdba85989ec5842081c5c84d4fc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49a9bdba85989ec5842081c5c84d4fc7">&#9670;&#160;</a></span>max() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;PointConcept PointType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto vcl::max </td>
          <td>(</td>
          <td class="paramtype">const PointType &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PointType &amp;&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a69cc63a5ad2974d082145ed1dee7846b" name="a69cc63a5ad2974d082145ed1dee7846b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69cc63a5ad2974d082145ed1dee7846b">&#9670;&#160;</a></span>max() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto vcl::max </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>el1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>el2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae60ae8879b69a995723ada3f73422606" name="ae60ae8879b69a995723ada3f73422606"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae60ae8879b69a995723ada3f73422606">&#9670;&#160;</a></span>meshFromMatrices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType, MatrixConcept VMatrix, MatrixConcept FMatrix = Eigen::MatrixX3i, MatrixConcept VNMatrix = Eigen::MatrixX3d, MatrixConcept FNMatrix = Eigen::MatrixX3d&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">MeshType vcl::meshFromMatrices </td>
          <td>(</td>
          <td class="paramtype">const VMatrix &amp;&#160;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FMatrix &amp;&#160;</td>
          <td class="paramname"><em>faces</em> = <code>FMatrix()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VNMatrix &amp;&#160;</td>
          <td class="paramname"><em>vertexNormals</em> = <code>VNMatrix()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FNMatrix &amp;&#160;</td>
          <td class="paramname"><em>faceNormals</em> = <code>FNMatrix()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates and returns a new mesh from the input vertex and face (if any) matrices, and the other matrices that are given as arguments. </p>
<p>The function accepts several input matrices/vectors, that are used only if their number of rows is different from zero. It tries to fill all the data contained in the non-empty input matrices into the <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>:</p><ul>
<li>if a <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a> is not able to store same data, the relative input matrix is ignored. For example, if the <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a> has no faces, the function will ignore the input face matrix, also if that is not empty.</li>
<li>if a <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a> is able to store some data and the relative input matrix is not empty, the data will be stored in the <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>. If the matrix has not the expected size, an exception is thrown.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>All the disabled optional components will be enabled if their corresponding input matrix is not empty.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classvcl_1_1WrongSizeException.html">vcl::WrongSizeException</a></td><td>if the sizes of the non-empty input matrices have not the expected sizes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MeshType</td><td>the type of the mesh to be created. It must satisfy the MeshConcept. </td></tr>
    <tr><td class="paramname">VMatrix</td><td>the type of the input vertex matrix. It must satisfy the MatrixConcept. </td></tr>
    <tr><td class="paramname">FMatrix</td><td>the type of the input face matrix. It must satisfy the MatrixConcept. </td></tr>
    <tr><td class="paramname">VNMatrix</td><td>the type of the input vertex normal matrix. It must satisfy the MatrixConcept. </td></tr>
    <tr><td class="paramname">FNMatrix</td><td>the type of the input face normal matrix. It must satisfy the MatrixConcept.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vertices</td><td>a #V*3 matrix containing the coordinates of the vertices of the mesh. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">faces</td><td>a #F*3 matrix containing the indices of the vertices of the faces of the mesh. If the number of rows of this matrix is zero, the function will not add faces to the mesh. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vertexNormals</td><td>a #V*3 matrix containing the normals of the vertices of the mesh. If the number of rows of this matrix is zero, the function will not add vertex normals to the mesh. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">faceNormals</td><td>a #F*3 matrix containing the normals of the faces of the mesh. If the number of rows of this matrix is zero, the function will not add face normals to the mesh.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new mesh containing the data passed as argument. </dd></dl>

</div>
</div>
<a id="a4af4652c16670bfb54752b13ef259554" name="a4af4652c16670bfb54752b13ef259554"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4af4652c16670bfb54752b13ef259554">&#9670;&#160;</a></span>meshFromVCGMesh()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType, typename VCGMeshType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">MeshType vcl::meshFromVCGMesh </td>
          <td>(</td>
          <td class="paramtype">const VCGMeshType &amp;&#160;</td>
          <td class="paramname"><em>vcgMesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="adac28fe9c51f808b6120eb2d9387484b" name="adac28fe9c51f808b6120eb2d9387484b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adac28fe9c51f808b6120eb2d9387484b">&#9670;&#160;</a></span>meshPlaneIntersection()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;EdgeMeshConcept EdgeMesh, FaceMeshConcept MeshType, PlaneConcept PlaneType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacevcl.html#aadd5d4f0adc881097d2c62b003a449cc">EdgeMesh</a> vcl::meshPlaneIntersection </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlaneType &amp;&#160;</td>
          <td class="paramname"><em>pl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Takes a mesh and a plane as inputs and computes the intersection between the mesh and the plane. It creates a new EdgeMesh to represent the intersection edges. </p>
<p>First, for each vertex in the original mesh, it computes its distance to the plane and stores it in a vector. Then, for each face in the original mesh, it checks each of its edges to see if they intersect the plane. If an edge intersects the plane, the intersection point is computed and added to a vector of intersection points. If the edge lies exactly on the plane, its vertices are added to the intersection points.</p>
<p>Once all intersection points have been computed, the function creates a new edge mesh and adds an edge between each pair of consecutive intersection points that forms a line segment on the plane. If the original mesh has per-vertex normals, the function also computes and stores the normal at each intersection point.</p>
<p>Requirements:</p><ul>
<li>EdgeMesh:<ul>
<li>Vertices<ul>
<li>Normals (optional)</li>
</ul>
</li>
<li>Edges</li>
</ul>
</li>
<li>MeshType:<ul>
<li>Vertices<ul>
<li>Normals (optional)</li>
</ul>
</li>
<li>Faces</li>
</ul>
</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td></td></tr>
    <tr><td class="paramname">pl</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the intersection between the original mesh and the plane as a collection of line segments with optional normal vectors. </dd></dl>

</div>
</div>
<a id="a5da120ef4b6039bf54902d14cb8b7519" name="a5da120ef4b6039bf54902d14cb8b7519"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5da120ef4b6039bf54902d14cb8b7519">&#9670;&#160;</a></span>meshSphereIntersection() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType, typename SScalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">MeshType vcl::meshSphereIntersection </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvcl_1_1Sphere.html">vcl::Sphere</a>&lt; SScalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>sphere</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as meshSphereIntersection(MeshType, Sphere, double);. </p>
<p>The tolerance is set as 1/10^5*2*pi*radius. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td></td></tr>
    <tr><td class="paramname">sphere</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a1e4c155f781f7c3e6fca2b922398fb82" name="a1e4c155f781f7c3e6fca2b922398fb82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e4c155f781f7c3e6fca2b922398fb82">&#9670;&#160;</a></span>meshSphereIntersection() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType, typename SScalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">MeshType vcl::meshSphereIntersection </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvcl_1_1Sphere.html">vcl::Sphere</a>&lt; SScalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>sphere</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the intersection between a mesh and a ball. </p>
<p>given a mesh return a new mesh made by a copy of all the faces entirely includeded in the ball plus new faces created by refining the ones intersected by the ball border. It works by recursively splitting the triangles that cross the border, as long as their area is greater than a given value tol. NOTE: the returned mesh is a triangle soup</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td></td></tr>
    <tr><td class="paramname">sphere</td><td></td></tr>
    <tr><td class="paramname">tol</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a9c1835cef3addd7dbae2b21a43523f3a" name="a9c1835cef3addd7dbae2b21a43523f3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c1835cef3addd7dbae2b21a43523f3a">&#9670;&#160;</a></span>min() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Head , typename... Tail&gt; <br />
requires (sizeof...(tail) &gt; 0)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto vcl::min </td>
          <td>(</td>
          <td class="paramtype">const Head &amp;&#160;</td>
          <td class="paramname"><em>head0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Head &amp;&#160;</td>
          <td class="paramname"><em>head1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Tail &amp;...&#160;</td>
          <td class="paramname"><em>tail</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac11460526cb6d79733a8dfe0e15614f4" name="ac11460526cb6d79733a8dfe0e15614f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac11460526cb6d79733a8dfe0e15614f4">&#9670;&#160;</a></span>min() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;PointConcept PointType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto vcl::min </td>
          <td>(</td>
          <td class="paramtype">const PointType &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PointType &amp;&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3edcb561672a6be17e9453bd1ea446d5" name="a3edcb561672a6be17e9453bd1ea446d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3edcb561672a6be17e9453bd1ea446d5">&#9670;&#160;</a></span>min() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto vcl::min </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>el1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>el2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a520f83d5e0afa947767dffe36fb77661" name="a520f83d5e0afa947767dffe36fb77661"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a520f83d5e0afa947767dffe36fb77661">&#9670;&#160;</a></span>multiplyPerFaceNormalsByMatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType, typename MScalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::multiplyPerFaceNormalsByMatrix </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacevcl.html#ad82a126b390f21b2e9658c73e7a795ee">vcl::Matrix44</a>&lt; MScalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>removeScalingFromMatrix</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiplies the <a class="el" href="classvcl_1_1Face.html" title="The Face class represents an Face element of the vcl::Mesh class.">Face</a> Normals by the given TRS 4x4 Matrix. By default, the scale component is removed from the matrix. </p>
<p>Requirements:</p><ul>
<li><a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>:<ul>
<li>Faces<ul>
<li>Normal</li>
</ul>
</li>
</ul>
</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">mesh</td><td>the mesh on which multiply the face normals. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mat</td><td>the 4x4 TRS matrix that is multiplied to the normals. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">removeScalingFromMatrix</td><td>if true (default), the scale component is removed from the matrix. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abce848dfdb8667d516f4738b3b8925a7" name="abce848dfdb8667d516f4738b3b8925a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abce848dfdb8667d516f4738b3b8925a7">&#9670;&#160;</a></span>multiplyPerVertexNormalsByMatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType, typename MScalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::multiplyPerVertexNormalsByMatrix </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacevcl.html#ad82a126b390f21b2e9658c73e7a795ee">vcl::Matrix44</a>&lt; MScalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>removeScalingFromMatrix</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiplies the <a class="el" href="classvcl_1_1Vertex.html" title="The Vertex class represents an Vertex element of the vcl::Mesh class.">Vertex</a> Normals by the given TRS 4x4 Matrix. By default, the scale component is removed from the matrix. </p>
<p>Requirements:</p><ul>
<li><a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>:<ul>
<li>Vertices:<ul>
<li>Normal</li>
</ul>
</li>
</ul>
</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">mesh</td><td>the mesh on which multiply the vertex normals. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mat</td><td>the 4x4 TRS matrix that is multiplied to the normals. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">removeScalingFromMatrix</td><td>if true (default), the scale component is removed from the matrix. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae3ccefcbb94fc15319e388a1183f3925" name="ae3ccefcbb94fc15319e388a1183f3925"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3ccefcbb94fc15319e388a1183f3925">&#9670;&#160;</a></span>normalizePerFaceNormals()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::normalizePerFaceNormals </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Normalizes the length of the face normals. </p>
<p>Requirements:</p><ul>
<li><a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>:<ul>
<li>Faces:<ul>
<li>Normal</li>
</ul>
</li>
</ul>
</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">m</td><td>the mesh on which normalize the face normals. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a607cbcdaf24e6dd7cec3e23a28fb450f" name="a607cbcdaf24e6dd7cec3e23a28fb450f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a607cbcdaf24e6dd7cec3e23a28fb450f">&#9670;&#160;</a></span>normalizePerFaceQuality()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::normalizePerFaceQuality </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename MeshType::FaceType::QualityType&#160;</td>
          <td class="paramname"><em>minS</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename MeshType::FaceType::QualityType&#160;</td>
          <td class="paramname"><em>maxS</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Normalizes the face quality of a mesh in a given interval (default [0, 1]). </p>
<p>Requirements:</p><ul>
<li><a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>:<ul>
<li>Faces:<ul>
<li>Quality</li>
</ul>
</li>
</ul>
</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">m</td><td>mesh on which normalize the face quality </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">minS</td><td>minimum value of the normalizing interval </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxS</td><td>maximum value of the normalizing interval </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0c7590577a9732afcd1dc3639b3965b6" name="a0c7590577a9732afcd1dc3639b3965b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c7590577a9732afcd1dc3639b3965b6">&#9670;&#160;</a></span>normalizePerVertexNormals()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::normalizePerVertexNormals </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Normalizes the length of the vertex normals. </p>
<p>Requirements:</p><ul>
<li><a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>:<ul>
<li>Vertices:<ul>
<li>Normal</li>
</ul>
</li>
</ul>
</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">m</td><td>the mesh on which normalize the vertex normals. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad1a6ca42d06d208218a4aa820f220696" name="ad1a6ca42d06d208218a4aa820f220696"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1a6ca42d06d208218a4aa820f220696">&#9670;&#160;</a></span>normalizePerVertexQuality()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::normalizePerVertexQuality </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename MeshType::VertexType::QualityType&#160;</td>
          <td class="paramname"><em>minS</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename MeshType::VertexType::QualityType&#160;</td>
          <td class="paramname"><em>maxS</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Normalizes the vertex quality of a mesh in a given interval (default [0, 1]). </p>
<p>Requirements:</p><ul>
<li><a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>:<ul>
<li>Vertices:<ul>
<li>Quality</li>
</ul>
</li>
</ul>
</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">m</td><td>mesh on which normalize the vertex quality </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">minS</td><td>minimum value of the normalizing interval </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxS</td><td>maximum value of the normalizing interval </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a25bd91133ba21843329a21218fa52069" name="a25bd91133ba21843329a21218fa52069"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25bd91133ba21843329a21218fa52069">&#9670;&#160;</a></span>operator*()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;EigenMatrixConcept MatrixType, PointConcept PointType&gt; <br />
requires ( MatrixType::RowsAtCompileTime == PointType::DIM &amp;&amp; MatrixType::ColsAtCompileTime == PointType::DIM)</div>
      <table class="memname">
        <tr>
          <td class="memname">PointType vcl::operator* </td>
          <td>(</td>
          <td class="paramtype">const MatrixType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PointType &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiplies a matrix and a point. </p>
<p>This function multiplies a matrix and a point and returns the resulting point.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MatrixType</td><td>A type that satisfies the EigenMatrixConcept </td></tr>
    <tr><td class="paramname">PointType</td><td>A type that satisfies the PointConcept</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>The matrix to be multiplied with the point </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>The point to be multiplied with the matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting point after multiplying the matrix and point</dd></dl>
<p>@requires MatrixType::RowsAtCompileTime == PointType::DIM &amp;&amp; MatrixType::ColsAtCompileTime == PointType::DIM </p>

</div>
</div>
<a id="a10783cb155a40826adff62ef42123efe" name="a10783cb155a40826adff62ef42123efe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10783cb155a40826adff62ef42123efe">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; vcl::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvcl_1_1Array.html">Array</a>&lt; Scalar, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a05dd102880d029a4ce6a952207559088" name="a05dd102880d029a4ce6a952207559088"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05dd102880d029a4ce6a952207559088">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; vcl::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvcl_1_1Color.html">Color</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overload of stream operator to allow a pretty print of a <a class="el" href="classvcl_1_1Color.html" title="The Color class represents a RGBA color.">vcl::Color</a>. </p>

</div>
</div>
<a id="aa2b5fc956b8e7b0ed2fe7f1846a6a74d" name="aa2b5fc956b8e7b0ed2fe7f1846a6a74d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2b5fc956b8e7b0ed2fe7f1846a6a74d">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar , <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; vcl::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvcl_1_1Point.html">Point</a>&lt; Scalar, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>p1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes this point to an output stream. </p>
<p>This operator writes this point to an output stream and returns the output stream. The point is written as a column vector of its coordinates.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">out</td><td>The output stream to write to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p1</td><td>The point to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The output stream after the point is written. </dd></dl>

</div>
</div>
<a id="ac74faed2021a2b157f5b80757ee694d8" name="ac74faed2021a2b157f5b80757ee694d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac74faed2021a2b157f5b80757ee694d8">&#9670;&#160;</a></span>parallelFor() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator , typename Lambda &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::parallelFor </td>
          <td>(</td>
          <td class="paramtype">const Iterator &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Iterator &amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Lambda &amp;&amp;&#160;</td>
          <td class="paramname"><em>F</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function executes a parallel for over the elements iterated between <code>begin</code> and <code>end</code> iterators, if parallel requirements have been found in the system. </p>
<p>Example of usage on a <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">vcl::Mesh</a>, iterating over vertices:</p>
<div class="fragment"><div class="line"><a class="code hl_function" href="namespacevcl.html#abde6b767fa0b116a5fd8b2a5fa0af488">vcl::parallelFor</a>(m.vertices().begin(), m.vertices().end(),</div>
<div class="line">    [&amp;](VertexType&amp; v) {</div>
<div class="line">        <span class="comment">// make some computing on v</span></div>
<div class="line">    });</div>
<div class="ttc" id="anamespacevcl_html_abde6b767fa0b116a5fd8b2a5fa0af488"><div class="ttname"><a href="namespacevcl.html#abde6b767fa0b116a5fd8b2a5fa0af488">vcl::parallelFor</a></div><div class="ttdeci">void parallelFor(Iterator &amp;&amp;begin, Iterator &amp;&amp;end, Lambda &amp;&amp;F)</div><div class="ttdoc">This function executes a parallel for over the elements iterated between begin and end iterators,...</div><div class="ttdef"><b>Definition:</b> parallel.h:81</div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">begin</td><td>iterator of the first element to iterate </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">end</td><td>iterator of the end of the iterated container </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>lambda function that takes the iterated type as input </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad43b0e6c5acf9f903daf25853361a24c" name="ad43b0e6c5acf9f903daf25853361a24c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad43b0e6c5acf9f903daf25853361a24c">&#9670;&#160;</a></span>parallelFor() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="conceptvcl_1_1Range.html">vcl::Range</a> Rng, typename Lambda &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::parallelFor </td>
          <td>(</td>
          <td class="paramtype">const Rng &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Lambda &amp;&amp;&#160;</td>
          <td class="paramname"><em>F</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function executes a parallel for over a range if parallel requirements have been found in the system. </p>
<p>Example of usage on a <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">vcl::Mesh</a>, iterating over vertices:</p>
<div class="fragment"><div class="line"><a class="code hl_function" href="namespacevcl.html#abde6b767fa0b116a5fd8b2a5fa0af488">vcl::parallelFor</a>(m.vertices(), [&amp;](VertexType&amp; v) {</div>
<div class="line">    <span class="comment">// make some computing on v</span></div>
<div class="line">});</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">r</td><td>a range having begin() and end() functions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>lambda function that takes the iterated type as input </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abde6b767fa0b116a5fd8b2a5fa0af488" name="abde6b767fa0b116a5fd8b2a5fa0af488"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abde6b767fa0b116a5fd8b2a5fa0af488">&#9670;&#160;</a></span>parallelFor() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator , typename Lambda &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::parallelFor </td>
          <td>(</td>
          <td class="paramtype">Iterator &amp;&amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator &amp;&amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Lambda &amp;&amp;&#160;</td>
          <td class="paramname"><em>F</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function executes a parallel for over the elements iterated between <code>begin</code> and <code>end</code> iterators, if parallel requirements have been found in the system. </p>
<p>Example of usage on a <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">vcl::Mesh</a>, iterating over vertices:</p>
<div class="fragment"><div class="line"><a class="code hl_function" href="namespacevcl.html#abde6b767fa0b116a5fd8b2a5fa0af488">vcl::parallelFor</a>(m.vertices().begin(), m.vertices().end(),</div>
<div class="line">    [&amp;](VertexType&amp; v) {</div>
<div class="line">        <span class="comment">// make some computing on v</span></div>
<div class="line">    });</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">begin</td><td>iterator of the first element to iterate </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">end</td><td>iterator of the end of the iterated container </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>lambda function that takes the iterated type as input </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0bbb25a5a74276bc05a251ab860a286d" name="a0bbb25a5a74276bc05a251ab860a286d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bbb25a5a74276bc05a251ab860a286d">&#9670;&#160;</a></span>parallelFor() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="conceptvcl_1_1Range.html">vcl::Range</a> Rng, typename Lambda &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::parallelFor </td>
          <td>(</td>
          <td class="paramtype">Rng &amp;&amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Lambda &amp;&amp;&#160;</td>
          <td class="paramname"><em>F</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function executes a parallel for over a range if parallel requirements have been found in the system. </p>
<p>Example of usage on a <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">vcl::Mesh</a>, iterating over vertices:</p>
<div class="fragment"><div class="line"><a class="code hl_function" href="namespacevcl.html#abde6b767fa0b116a5fd8b2a5fa0af488">vcl::parallelFor</a>(m.vertices(), [&amp;](VertexType&amp; v) {</div>
<div class="line">    <span class="comment">// make some computing on v</span></div>
<div class="line">});</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">r</td><td>a range having begin() and end() functions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>lambda function that takes the iterated type as input </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ace4273fd5df9842c19d335bcab94d287" name="ace4273fd5df9842c19d335bcab94d287"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace4273fd5df9842c19d335bcab94d287">&#9670;&#160;</a></span>perFaceMeshFilter() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept InMeshType, FaceMeshConcept OutMeshType = InMeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OutMeshType vcl::perFaceMeshFilter </td>
          <td>(</td>
          <td class="paramtype">const InMeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Range auto &amp;&amp;&#160;</td>
          <td class="paramname"><em>faceFilterRng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>saveBirthIndicesInCustomComponent</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates and returns a new mesh that is composed of the faces of the input mesh <code>m</code> filtered using the <code>faceFilterRng</code> range. Only vertices belonging to the imported faces will be imported in the output mesh. </p>
<p>Only the faces having the corresponding boolean in <code>faceFilterRng</code> evaluated to <code>true</code> and their vertices will be put in the output mesh. The order of the faces and vertices in the output mesh is preserved.</p>
<p>By default, the type of the output mesh will be the same of the input mesh type.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">InMeshType</td><td>type of the input mesh. It must satisfy the <code>FaceMeshConcept</code>. </td></tr>
    <tr><td class="paramname">OutMeshType</td><td>type of the output mesh. It must satisfy the <code>FaceMeshConcept</code>. By default, it is the same of the input mesh type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>input mesh </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">faceFilterRng</td><td>range of values that are evaluated as booleans, one for each face of the input mesh. Its type must satisfy the <code>Range</code> concept. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">saveBirthIndicesInCustomComponent</td><td>if <code>true</code> (default), and if the output mesh type has the per vertex and/or per face CustomComponents component, will set a per vertex/per face custom component of type <code>uint</code> in the output mesh telling, for each vertex/face, the index of its birth vertex/birth face in the input mesh. The names of the custom components are <code>"birthVertex"</code> and <code>"birthFace"</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a> created by filtering the faces of the input mesh <code>m</code>. </dd></dl>

</div>
</div>
<a id="a72f6132dc1f37d4790e34ef4e42e6d15" name="a72f6132dc1f37d4790e34ef4e42e6d15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72f6132dc1f37d4790e34ef4e42e6d15">&#9670;&#160;</a></span>perFaceMeshFilter() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept InMeshType, FaceMeshConcept OutMeshType = InMeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OutMeshType vcl::perFaceMeshFilter </td>
          <td>(</td>
          <td class="paramtype">const InMeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; bool(const typename InMeshType::FaceType &amp;)&gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>faceFilter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>saveBirthIndicesInCustomComponent</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates and returns a new mesh that is composed of the faces of the input mesh <code>m</code> filtered using the <code>faceFilter</code> function. Only vertices belonging to the imported faces will be imported in the output mesh. </p>
<p>Only the faces for which the <code>faceFilter</code> function returns true` and their vertices will be put in the output mesh. The order of the faces and vertices in the output mesh is preserved.</p>
<p>By default, the type of the output mesh will be the same of the input mesh type.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">InMeshType</td><td>type of the input mesh. It must satisfy the <code>FaceMeshConcept</code>. </td></tr>
    <tr><td class="paramname">OutMeshType</td><td>type of the output mesh. It must satisfy the <code>FaceMeshConcept</code>. By default, it is the same of the input mesh type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>input mesh </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">faceFilter</td><td>a function that takes a face as input and returns a boolean value that tells whether the face should be imported in the output mesh or not. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">saveBirthIndicesInCustomComponent</td><td>if <code>true</code> (default), and if the output mesh type has the per vertex and/or per face CustomComponents component, will set a per vertex/per face custom component of type <code>uint</code> in the output mesh telling, for each vertex/face, the index of its birth vertex/birth face in the input mesh. The names of the custom components are <code>"birthVertex"</code> and <code>"birthFace"</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a> created by filtering the faces of the input mesh <code>m</code>. </dd></dl>

</div>
</div>
<a id="afc2f93864498c3b143e13c1b0009bdc4" name="afc2f93864498c3b143e13c1b0009bdc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc2f93864498c3b143e13c1b0009bdc4">&#9670;&#160;</a></span>perlinNoise()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double vcl::perlinNoise </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>3D Perlin noise, returns a value in the [-1,1] range with period 255 </p>
<p>based on the java reference implementation published on <a href="http://mrl.nyu.edu/~perlin/noise/">http://mrl.nyu.edu/~perlin/noise/</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td></td></tr>
    <tr><td class="paramname">y</td><td></td></tr>
    <tr><td class="paramname">z</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a8d3830ce96c420a6f11c93650c709fa6" name="a8d3830ce96c420a6f11c93650c709fa6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d3830ce96c420a6f11c93650c709fa6">&#9670;&#160;</a></span>perVertexMeshFilter() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept InMeshType, MeshConcept OutMeshType = InMeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OutMeshType vcl::perVertexMeshFilter </td>
          <td>(</td>
          <td class="paramtype">const InMeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Range auto &amp;&amp;&#160;</td>
          <td class="paramname"><em>vertexFilterRng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>saveBirthIndicesInCustomComponent</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates and returns a new mesh that is composed of the vertices of the input mesh <code>m</code> filtered using the <code>vertexFilterRng</code> range. </p>
<p>Only the vertices having the corresponding boolean in <code>vertexFilterRng</code> evaluated to <code>true</code> will be put in the output mesh. The order of the vertices in the output mesh is preserved.</p>
<p>By default, the type of the output mesh will be the same of the input mesh type.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">InMeshType</td><td>type of the input mesh. It must satisfy the <code>MeshConcept</code>. </td></tr>
    <tr><td class="paramname">OutMeshType</td><td>type of the output mesh. It must satisfy the <code>MeshConcept</code>. By default, it is the same of the input mesh type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>input mesh </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vertexFilterRng</td><td>range of values that are evaluated as booleans, one for each vertex of the input mesh. Its type must satisfy the <code>Range</code> concept. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">saveBirthIndicesInCustomComponent</td><td>if <code>true</code> (default), and if the output mesh type has the per vertex CustomComponents component, will set a per vertex custom component of type <code>uint</code> in the output mesh telling, for each vertex, the index of its birth vertex in the input mesh. The name of the custom component is <code>"birthVertex"</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a> created by filtering the vertices of the input mesh <code>m</code>. </dd></dl>

</div>
</div>
<a id="a1c4c7b512ed2781bd919b794fe63c1eb" name="a1c4c7b512ed2781bd919b794fe63c1eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c4c7b512ed2781bd919b794fe63c1eb">&#9670;&#160;</a></span>perVertexMeshFilter() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept InMeshType, MeshConcept OutMeshType = InMeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OutMeshType vcl::perVertexMeshFilter </td>
          <td>(</td>
          <td class="paramtype">const InMeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; bool(const typename InMeshType::VertexType &amp;)&gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>vertexFilter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>saveBirthIndicesInCustomComponent</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates and returns a new mesh that is composed of the vertices of the input mesh <code>m</code> filtered using the <code>vertexFilter</code> function. </p>
<p>Only the vertices for which the <code>vertexFilter</code> returns <code>true</code> will be put in the output mesh. The order of the vertices in the output mesh is preserved.</p>
<p>By default, the type of the output mesh will be the same of the input mesh type.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">InMeshType</td><td>type of the input mesh. It must satisfy the <code>MeshConcept</code>. </td></tr>
    <tr><td class="paramname">OutMeshType</td><td>type of the output mesh. It must satisfy the <code>MeshConcept</code>. By default, it is the same of the input mesh type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>input mesh </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vertexFilter</td><td>a function that takes a vertex as input and returns a boolean value that tells whether the vertex should be put in the output mesh. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">saveBirthIndicesInCustomComponent</td><td>if <code>true</code> (default), and if the output mesh type has the per vertex CustomComponents component, will set a per vertex custom component of type <code>uint</code> in the output mesh telling, for each vertex, the index of its birth vertex in the input mesh. The name of the custom component is <code>"birthVertex"</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a> created by filtering the vertices of the input mesh <code>m</code>. </dd></dl>

</div>
</div>
<a id="a27474522dfcc3be4ce96d6a8b44fcc09" name="a27474522dfcc3be4ce96d6a8b44fcc09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27474522dfcc3be4ce96d6a8b44fcc09">&#9670;&#160;</a></span>planeBoxIntersect()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;PlaneConcept PlaneType, Box3Concept BoxType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool vcl::planeBoxIntersect </td>
          <td>(</td>
          <td class="paramtype">const PlaneType &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BoxType &amp;&#160;</td>
          <td class="paramname"><em>box</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if a plane intersects with a box. </p>
<p>Uses the algorithm from <a href="https://gdbooks.gitbooks.io/3dcollisions/content/Chapter2/static_aabb_plane.html">https://gdbooks.gitbooks.io/3dcollisions/content/Chapter2/static_aabb_plane.html</a></p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">PlaneType</td><td>The type of plane used in the intersection check </td></tr>
    <tr><td class="paramname">BoxType</td><td>The type of box used in the intersection check, must satisfy the Box3Concept</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>The plane to check intersection with </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">box</td><td>The box to check intersection with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the plane intersects with the box, false otherwise </dd></dl>

</div>
</div>
<a id="a5603e96ba08d11993828c0e47f2657b2" name="a5603e96ba08d11993828c0e47f2657b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5603e96ba08d11993828c0e47f2657b2">&#9670;&#160;</a></span>planeSegmentIntersect() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;PlaneConcept PlaneType, Segment3Concept SegmentType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool vcl::planeSegmentIntersect </td>
          <td>(</td>
          <td class="paramtype">const PlaneType &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SegmentType &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function computes the intersection between a plane and a 3D segment. If the intersection exists, it returns true, otherwise, it returns false. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>the plane to compute the intersection with. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>the 3D segment to compute the intersection with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A boolean value indicating whether an intersection was found or not. </dd></dl>

</div>
</div>
<a id="a095d688d385405cbf305d7f501f672a6" name="a095d688d385405cbf305d7f501f672a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a095d688d385405cbf305d7f501f672a6">&#9670;&#160;</a></span>planeSegmentIntersect() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;PlaneConcept PlaneType, Segment3Concept SegmentType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool vcl::planeSegmentIntersect </td>
          <td>(</td>
          <td class="paramtype">const PlaneType &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SegmentType &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename SegmentType::PointType &amp;&#160;</td>
          <td class="paramname"><em>intersection</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function computes the intersection between a plane and a 3D segment. If the intersection exists, it returns true and stores the intersection point in the output parameter intersection, otherwise, it returns false. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>the plane to compute the intersection with. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>the 3D segment to compute the intersection with. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">intersection</td><td>A reference to the point that stores the resulting intersection between the plane and the segment. This parameter is only written to if the function returns true. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A boolean value indicating whether an intersection was found or not. </dd></dl>

</div>
</div>
<a id="aaf860b9816e4dc7fc87d0bf27aaa0670" name="aaf860b9816e4dc7fc87d0bf27aaa0670"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf860b9816e4dc7fc87d0bf27aaa0670">&#9670;&#160;</a></span>Point()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename S , typename... Scalars&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Point.html">vcl::Point</a> </td>
          <td>(</td>
          <td class="paramtype">S&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Scalars...&#160;</td>
          <td class="paramname"><em>scalars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  <a class="el" href="classvcl_1_1Point.html">Point</a>&lt; S, sizeof...(Scalars)+1 &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa433f6d104a81e917270cca3d9ed26ed" name="aa433f6d104a81e917270cca3d9ed26ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa433f6d104a81e917270cca3d9ed26ed">&#9670;&#160;</a></span>pointCloudMeshFromMatrices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType, MatrixConcept VMatrix, MatrixConcept VNMatrix = Eigen::MatrixX3d&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">MeshType vcl::pointCloudMeshFromMatrices </td>
          <td>(</td>
          <td class="paramtype">const VMatrix &amp;&#160;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VNMatrix &amp;&#160;</td>
          <td class="paramname"><em>vertexNormals</em> = <code>VNMatrix()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates and returns a new point cloud mesh from the input vertex matrix and the other matrices that are given as arguments. </p>
<p>The function accepts several input matrices/vectors, that are used only if their number of rows is different from zero. It tries to fill all the data contained in the non-empty input matrices into the <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>:</p><ul>
<li>if a <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a> is not able to store same data, the relative input matrix is ignored. For example, if the <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a> has no per <a class="el" href="classvcl_1_1Vertex.html" title="The Vertex class represents an Vertex element of the vcl::Mesh class.">Vertex</a> Normals, the function will ignore the input vertex normals matrix, also if that is not empty.</li>
<li>if a <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a> is able to store some data and the relative input matrix is not empty, the data will be stored in the <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>. If the matrix has not the expected size, an exception is thrown.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>All the disabled optional components will be enabled if their corresponding input matrix is not empty.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classvcl_1_1WrongSizeException.html">vcl::WrongSizeException</a></td><td>if the sizes of the non-empty input matrices have not the expected sizes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MeshType</td><td>the type of the mesh to be created. It must satisfy the MeshConcept. </td></tr>
    <tr><td class="paramname">VMatrix</td><td>the type of the input vertex matrix. It must satisfy the MatrixConcept. </td></tr>
    <tr><td class="paramname">VNMatrix</td><td>the type of the input vertex normal matrix. It must satisfy the MatrixConcept.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vertices</td><td>a #V*3 matrix containing the coordinates of the vertices of the mesh. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vertexNormals</td><td>a #V*3 matrix containing the normals of the vertices of the mesh. If the number of rows of this matrix is zero, the function will not add vertex normals to the mesh.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new point cloud mesh containing the data passed as argument. </dd></dl>

</div>
</div>
<a id="a8efd5f55775e66de7f1f69b35bd1561a" name="a8efd5f55775e66de7f1f69b35bd1561a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8efd5f55775e66de7f1f69b35bd1561a">&#9670;&#160;</a></span>pointFaceDistance() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Point3Concept PointType, FaceConcept FaceType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto vcl::pointFaceDistance </td>
          <td>(</td>
          <td class="paramtype">const PointType &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FaceType &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>signedDist</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the distance between a 3D point and a 3D triangle face. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">PointType</td><td>The type of point. Must satisfy the Point3Concept. </td></tr>
    <tr><td class="paramname">FaceType</td><td>The type of face. Must satisfy the FaceConcept.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>The point to calculate the distance from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>The face to calculate the distance to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">signedDist</td><td>Whether to calculate the signed distance. Default is false. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The distance between the point and the face. </dd></dl>

</div>
</div>
<a id="a02f5dd6bd231e193440d954eee9d3aef" name="a02f5dd6bd231e193440d954eee9d3aef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02f5dd6bd231e193440d954eee9d3aef">&#9670;&#160;</a></span>pointFaceDistance() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Point3Concept PointType, FaceConcept FaceType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto vcl::pointFaceDistance </td>
          <td>(</td>
          <td class="paramtype">const PointType &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FaceType &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PointType &amp;&#160;</td>
          <td class="paramname"><em>closest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>signedDist</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3a294ad7cda738cd64d09b432874830c" name="a3a294ad7cda738cd64d09b432874830c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a294ad7cda738cd64d09b432874830c">&#9670;&#160;</a></span>pointFaceDistance() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Point3Concept PointType, FaceConcept FaceType, typename ScalarType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto vcl::pointFaceDistance </td>
          <td>(</td>
          <td class="paramtype">const PointType &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FaceType &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScalarType&#160;</td>
          <td class="paramname"><em>maxDist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>signedDist</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9abd2d46a87cb3d18987a37e11ed6ccc" name="a9abd2d46a87cb3d18987a37e11ed6ccc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9abd2d46a87cb3d18987a37e11ed6ccc">&#9670;&#160;</a></span>pointFaceDistance() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Point3Concept PointType, FaceConcept FaceType, typename ScalarType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto vcl::pointFaceDistance </td>
          <td>(</td>
          <td class="paramtype">const PointType &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FaceType &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScalarType&#160;</td>
          <td class="paramname"><em>maxDist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PointType &amp;&#160;</td>
          <td class="paramname"><em>closest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>signedDist</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the distance between a 3D point and a 3D triangle face. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">PointType</td><td>The type of point. Must satisfy the Point3Concept. </td></tr>
    <tr><td class="paramname">FaceType</td><td>The type of face. Must satisfy the FaceConcept.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>The point to calculate the distance from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>The face to calculate the distance to. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">closest</td><td>The closest point on the triangle to the given point. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">signedDist</td><td>Whether to calculate the signed distance. Default is false. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The distance between the point and the face. </dd></dl>

</div>
</div>
<a id="a1826187003e1e307765b32879a69b748" name="a1826187003e1e307765b32879a69b748"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1826187003e1e307765b32879a69b748">&#9670;&#160;</a></span>pointPlaneDistance()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Point3Concept PointType, PlaneConcept PlaneType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto vcl::pointPlaneDistance </td>
          <td>(</td>
          <td class="paramtype">const PointType &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlaneType &amp;&#160;</td>
          <td class="paramname"><em>plane</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>signedDist</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7e95f3d99f53e335c7e17af14b42f991" name="a7e95f3d99f53e335c7e17af14b42f991"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e95f3d99f53e335c7e17af14b42f991">&#9670;&#160;</a></span>pointSegmentDistance() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;PointConcept PointType, SegmentConcept SegmentType&gt; <br />
requires (PointType::DIM == SegmentType::DIM)</div>
      <table class="memname">
        <tr>
          <td class="memname">auto vcl::pointSegmentDistance </td>
          <td>(</td>
          <td class="paramtype">const PointType &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SegmentType &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1d8430571d9a6027e6d7e3bac4816b95" name="a1d8430571d9a6027e6d7e3bac4816b95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d8430571d9a6027e6d7e3bac4816b95">&#9670;&#160;</a></span>pointSegmentDistance() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;PointConcept PointType, SegmentConcept SegmentType&gt; <br />
requires (PointType::DIM == SegmentType::DIM)</div>
      <table class="memname">
        <tr>
          <td class="memname">auto vcl::pointSegmentDistance </td>
          <td>(</td>
          <td class="paramtype">const PointType &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SegmentType &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PointType &amp;&#160;</td>
          <td class="paramname"><em>closest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aee130ece16518760ce1f2c1a9da3a6e1" name="aee130ece16518760ce1f2c1a9da3a6e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee130ece16518760ce1f2c1a9da3a6e1">&#9670;&#160;</a></span>poissonRandomNumber() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int vcl::poissonRandomNumber </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lambda</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a212c052ae1efd3426a5ea49051f8011c" name="a212c052ae1efd3426a5ea49051f8011c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a212c052ae1efd3426a5ea49051f8011c">&#9670;&#160;</a></span>poissonRandomNumber() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int vcl::poissonRandomNumber </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::mt19937 &amp;&#160;</td>
          <td class="paramname"><em>gen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>algorithm poisson random number (Knuth): init: Let L  e^, k  0 and p  1. do: k  k + 1. Generate uniform random number u in [0,1] and let p  p  u. while p &gt; L. return k  1. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lambda</td><td></td></tr>
    <tr><td class="paramname">gen</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="aef13acb79205bb8fe990f66e1fa203f3" name="aef13acb79205bb8fe990f66e1fa203f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef13acb79205bb8fe990f66e1fa203f3">&#9670;&#160;</a></span>poissonRatioOfUniformsInteger() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int vcl::poissonRatioOfUniformsInteger </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>L</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2cc1884dbb897a34716178c7b06e7bb2" name="a2cc1884dbb897a34716178c7b06e7bb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cc1884dbb897a34716178c7b06e7bb2">&#9670;&#160;</a></span>poissonRatioOfUniformsInteger() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int vcl::poissonRatioOfUniformsInteger </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::mt19937 &amp;&#160;</td>
          <td class="paramname"><em>gen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This subfunction generates a integer with the poisson distribution using the ratio-of-uniforms rejection method (PRUAt). This approach is STABLE even for large L (e.g. it does not suffer from the overflow limit of the classical Knuth implementation) Execution time does not depend on L, except that it matters whether is within the range where ln(n!) is tabulated. </p>
<p>Reference:</p>
<p>E. Stadlober "The ratio of uniforms approach for generating discrete random variates". Journal of Computational and Applied Mathematics, vol. 31, no. 1, 1990, pp. 181-189.</p>
<p>Partially adapted/inspired from some subfunctions of the Agner Fog stocc library ( www.agner.org/random ) Same licensing scheme.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">L</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a3d0305c02567d29d5bc48a0cdbaacda3" name="a3d0305c02567d29d5bc48a0cdbaacda3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d0305c02567d29d5bc48a0cdbaacda3">&#9670;&#160;</a></span>randomPolygonBarycentricCoordinate() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ScalarType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; ScalarType &gt; vcl::randomPolygonBarycentricCoordinate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a>&#160;</td>
          <td class="paramname"><em>polySize</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7c7c00f108bb07302bfb7643c66f3ef4" name="a7c7c00f108bb07302bfb7643c66f3ef4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c7c00f108bb07302bfb7643c66f3ef4">&#9670;&#160;</a></span>randomPolygonBarycentricCoordinate() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ScalarType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; ScalarType &gt; vcl::randomPolygonBarycentricCoordinate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a>&#160;</td>
          <td class="paramname"><em>polySize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::mt19937 &amp;&#160;</td>
          <td class="paramname"><em>gen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad7b855bdab068b3fee59bc40914436e2" name="ad7b855bdab068b3fee59bc40914436e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7b855bdab068b3fee59bc40914436e2">&#9670;&#160;</a></span>randomTriangleBarycentricCoordinate() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ScalarType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__space.html#ga13f2718b0763def563b8bd9f65982833">vcl::Point3</a>&lt; ScalarType &gt; vcl::randomTriangleBarycentricCoordinate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a06f5b66d996c91397fab66781fc73402" name="a06f5b66d996c91397fab66781fc73402"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06f5b66d996c91397fab66781fc73402">&#9670;&#160;</a></span>randomTriangleBarycentricCoordinate() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ScalarType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__space.html#ga13f2718b0763def563b8bd9f65982833">vcl::Point3</a>&lt; ScalarType &gt; vcl::randomTriangleBarycentricCoordinate </td>
          <td>(</td>
          <td class="paramtype">std::mt19937 &amp;&#160;</td>
          <td class="paramname"><em>gen</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate the barycentric coords of a random point over a triangle, with a uniform distribution over the triangle. It uses the parallelogram folding trick. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gen</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a1420d0b9ba83dea9e692db635533f46c" name="a1420d0b9ba83dea9e692db635533f46c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1420d0b9ba83dea9e692db635533f46c">&#9670;&#160;</a></span>RegularGrid()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;PointConcept PointType, typename D &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1RegularGrid.html">vcl::RegularGrid</a> </td>
          <td>(</td>
          <td class="paramtype">PointType&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PointType&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">D&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  <a class="el" href="classvcl_1_1RegularGrid.html">RegularGrid</a>&lt; typename PointType::ScalarType, PointType::DIM &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1f6666a7b9cd7293ab07aaf6cbc1dc4c" name="a1f6666a7b9cd7293ab07aaf6cbc1dc4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f6666a7b9cd7293ab07aaf6cbc1dc4c">&#9670;&#160;</a></span>requirePerVertexAdjacentFaces()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MeshType &gt; <br />
requires HasPerVertexAdjacentFaces&lt;MeshType&gt;</div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::requirePerVertexAdjacentFaces </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a224534742afebeedf036df597231c700" name="a224534742afebeedf036df597231c700"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a224534742afebeedf036df597231c700">&#9670;&#160;</a></span>requirePerVertexAdjacentVertices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MeshType &gt; <br />
requires HasPerVertexAdjacentVertices&lt;MeshType&gt;</div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::requirePerVertexAdjacentVertices </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3fc65a005474dd6f983d5f9b235b5387" name="a3fc65a005474dd6f983d5f9b235b5387"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fc65a005474dd6f983d5f9b235b5387">&#9670;&#160;</a></span>requirePerVertexColor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MeshType &gt; <br />
requires HasPerVertexColor&lt;MeshType&gt;</div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::requirePerVertexColor </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad1b0cb92a48a555d7084bb6fb94ef359" name="ad1b0cb92a48a555d7084bb6fb94ef359"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1b0cb92a48a555d7084bb6fb94ef359">&#9670;&#160;</a></span>requirePerVertexMark()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MeshType &gt; <br />
requires HasPerVertexMark&lt;MeshType&gt;</div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::requirePerVertexMark </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab43f884f6ca679c8f57255e11ddaa768" name="ab43f884f6ca679c8f57255e11ddaa768"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab43f884f6ca679c8f57255e11ddaa768">&#9670;&#160;</a></span>requirePerVertexNormal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MeshType &gt; <br />
requires HasPerVertexNormal&lt;MeshType&gt;</div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::requirePerVertexNormal </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af330a765b2c7772ff85378f617ade27b" name="af330a765b2c7772ff85378f617ade27b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af330a765b2c7772ff85378f617ade27b">&#9670;&#160;</a></span>requirePerVertexPrincipalCurvature()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MeshType &gt; <br />
requires HasPerVertexPrincipalCurvature&lt;MeshType&gt;</div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::requirePerVertexPrincipalCurvature </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a49287ff6e3778f10a280b1166006dff9" name="a49287ff6e3778f10a280b1166006dff9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49287ff6e3778f10a280b1166006dff9">&#9670;&#160;</a></span>requirePerVertexQuality()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MeshType &gt; <br />
requires HasPerVertexQuality&lt;MeshType&gt;</div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::requirePerVertexQuality </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5f20fd534d1bb822fe5b13f2515025ee" name="a5f20fd534d1bb822fe5b13f2515025ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f20fd534d1bb822fe5b13f2515025ee">&#9670;&#160;</a></span>requirePerVertexTexCoord()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MeshType &gt; <br />
requires HasPerVertexTexCoord&lt;MeshType&gt;</div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::requirePerVertexTexCoord </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae5e94dd9b89e9bc4fb21701af6e788ca" name="ae5e94dd9b89e9bc4fb21701af6e788ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5e94dd9b89e9bc4fb21701af6e788ca">&#9670;&#160;</a></span>requireVertexContainerCompactness()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::requireVertexContainerCompactness </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aefa0051d67bdf4a551140929a2cc0b2f" name="aefa0051d67bdf4a551140929a2cc0b2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefa0051d67bdf4a551140929a2cc0b2f">&#9670;&#160;</a></span>rotationMatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType , PointConcept PointType, typename ScalarType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">MatrixType vcl::rotationMatrix </td>
          <td>(</td>
          <td class="paramtype">const PointType &amp;&#160;</td>
          <td class="paramname"><em>axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ScalarType &amp;&#160;</td>
          <td class="paramname"><em>angleRad</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given an 3D axis and an angle expressed in randiants, returns a transform matrix that represents the rotation matrix of the given axis/angle. </p>
<p>The MatrixType must be at least a 3x3 matrix having the setIdentity() member function. If the matrix is a higher than 3x3 (e.g. 4x4), only the 3x3 submatrix will be set, leaving the identity values in the other cells of the matrix.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">axis</td><td></td></tr>
    <tr><td class="paramname">angleRad</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a7f6b127154a5e14946cb66492d214de8" name="a7f6b127154a5e14946cb66492d214de8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f6b127154a5e14946cb66492d214de8">&#9670;&#160;</a></span>rotationMatrixDeg()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType , PointConcept PointType, typename ScalarType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">MatrixType vcl::rotationMatrixDeg </td>
          <td>(</td>
          <td class="paramtype">const PointType &amp;&#160;</td>
          <td class="paramname"><em>axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ScalarType &amp;&#160;</td>
          <td class="paramname"><em>angleDeg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given an 3D axis and an angle expressed in degrees, fills the given matrix with a transform matrix that represents the rotation matrix of the given axis/angle. </p>
<p>The given matrix must be at least a 3x3 matrix. If the matrix is a higher than 3x3 (e.g. 4x4), only the 3x3 submatrix will be set, leaving unchanged the other values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">axis</td><td></td></tr>
    <tr><td class="paramname">angleDeg</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="ab8f881fa3253b964c05b23dae03a2462" name="ab8f881fa3253b964c05b23dae03a2462"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8f881fa3253b964c05b23dae03a2462">&#9670;&#160;</a></span>save() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::save </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>binary</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="adf8b67aa014b0f1d2b3b127da5daec21" name="adf8b67aa014b0f1d2b3b127da5daec21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf8b67aa014b0f1d2b3b127da5daec21">&#9670;&#160;</a></span>save() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType, LoggerConcept LogType = NullLogger&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::save </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvcl_1_1MeshInfo.html">MeshInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LogType &amp;&#160;</td>
          <td class="paramname"><em>log</em> = <code><a class="el" href="group__miscellaneous.html#ga3377e3c875ec245e90ac5a395105ce99">nullLogger</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>binary</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae45340d675bbb087090142215fd76da4" name="ae45340d675bbb087090142215fd76da4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae45340d675bbb087090142215fd76da4">&#9670;&#160;</a></span>save() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType, LoggerConcept LogType = NullLogger&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::save </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LogType &amp;&#160;</td>
          <td class="paramname"><em>log</em> = <code><a class="el" href="group__miscellaneous.html#ga3377e3c875ec245e90ac5a395105ce99">nullLogger</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>binary</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a63bff22265d64d974b4fe4267b6dbac0" name="a63bff22265d64d974b4fe4267b6dbac0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63bff22265d64d974b4fe4267b6dbac0">&#9670;&#160;</a></span>scalarWeightedBarycenter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">MeshType::VertexType::CoordType vcl::scalarWeightedBarycenter </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the barycenter of the mesh weighted on the per vertex quality values. </p>
<p>The output baryceter is computed as a weighted average of the vertices of the mesh, using the per <a class="el" href="classvcl_1_1Vertex.html" title="The Vertex class represents an Vertex element of the vcl::Mesh class.">Vertex</a> Quality values as weights.</p>
<p>Requirements:</p><ul>
<li><a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>:<ul>
<li>Vertices:<ul>
<li>Quality</li>
</ul>
</li>
</ul>
</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>input mesh on which compute the barycenter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The barycenter weighted on the per vertex quality. </dd></dl>

</div>
</div>
<a id="a5217f309d49911db6e36a4f6d31acdaa" name="a5217f309d49911db6e36a4f6d31acdaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5217f309d49911db6e36a4f6d31acdaa">&#9670;&#160;</a></span>scale() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType, PointConcept PointType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::scale </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PointType &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad7f4da00ff716cc6e58e2e9ade275d6a" name="ad7f4da00ff716cc6e58e2e9ade275d6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7f4da00ff716cc6e58e2e9ade275d6a">&#9670;&#160;</a></span>scale() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType, typename Scalar  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::scale </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scalar &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aaec6c356404a0bf3eb24a29e867004df" name="aaec6c356404a0bf3eb24a29e867004df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaec6c356404a0bf3eb24a29e867004df">&#9670;&#160;</a></span>selectNonManifoldVertices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::selectNonManifoldVertices </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>clearSelectionFirst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa949e95f7bfb9d8dedc0f7e15e5d3ab9" name="aa949e95f7bfb9d8dedc0f7e15e5d3ab9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa949e95f7bfb9d8dedc0f7e15e5d3ab9">&#9670;&#160;</a></span>setPerFaceQuality()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::setPerFaceQuality </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename MeshType::FaceType::QualityType&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets a constant value to all the face quality of the mesh. </p>
<p>Requirements:</p><ul>
<li><a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>:<ul>
<li>Faces:<ul>
<li>Quality</li>
</ul>
</li>
</ul>
</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">m</td><td>mesh on which set the face quality </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>quality value to set </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab9e9aa9515cb4086de430109e361cfde" name="ab9e9aa9515cb4086de430109e361cfde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9e9aa9515cb4086de430109e361cfde">&#9670;&#160;</a></span>setPerFaceQualityFromFaceArea()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::setPerFaceQualityFromFaceArea </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assign to the face quality of the mesh the area of each face. </p>
<p>Requirements:</p><ul>
<li><a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>:<ul>
<li>Faces<ul>
<li>Quality</li>
</ul>
</li>
</ul>
</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">m</td><td>mesh on which set the face quality to the face area </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a745a7eed34f93850095b2c81f127d9f6" name="a745a7eed34f93850095b2c81f127d9f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a745a7eed34f93850095b2c81f127d9f6">&#9670;&#160;</a></span>setPerVertexQuality()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::setPerVertexQuality </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename MeshType::VertexType::QualityType&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets a constant value to all the vertex quality of the mesh. </p>
<p>Requirements:</p><ul>
<li><a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>:<ul>
<li>Vertices:<ul>
<li>Quality</li>
</ul>
</li>
</ul>
</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">m</td><td>mesh on which set the vertex quality </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>quality value to set </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4120bcf201dd0de7e75bbd2e39a658df" name="a4120bcf201dd0de7e75bbd2e39a658df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4120bcf201dd0de7e75bbd2e39a658df">&#9670;&#160;</a></span>setPerVertexQualityFromPrincipalCurvatureCurvedness()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::setPerVertexQualityFromPrincipalCurvatureCurvedness </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the Curvedness C from the Principal Curvature, as defined by [Koenderink 1992] and stores it in the per-vertex quality. </p>
<p>C = Sqrt((k1*k1+k2*k2)/2.0)</p>
<p>J. Koenderink and A. van Doorn. Surface shape and curvature scales. <a class="el" href="classvcl_1_1Image.html" title="The Image class stores an Image in 8 bit RGBA format.">Image</a> and vision computing, 10(8):557565, 1992. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2b31235ba7d846238e202713eaaa0495" name="a2b31235ba7d846238e202713eaaa0495"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b31235ba7d846238e202713eaaa0495">&#9670;&#160;</a></span>setPerVertexQualityFromPrincipalCurvatureGaussian()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::setPerVertexQualityFromPrincipalCurvatureGaussian </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7b1d34773ec1878660fe407a4768b67b" name="a7b1d34773ec1878660fe407a4768b67b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b1d34773ec1878660fe407a4768b67b">&#9670;&#160;</a></span>setPerVertexQualityFromPrincipalCurvatureMaxValue()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::setPerVertexQualityFromPrincipalCurvatureMaxValue </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a88a3a13cc9462bac2a7e1e578cddf540" name="a88a3a13cc9462bac2a7e1e578cddf540"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88a3a13cc9462bac2a7e1e578cddf540">&#9670;&#160;</a></span>setPerVertexQualityFromPrincipalCurvatureMean()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::setPerVertexQualityFromPrincipalCurvatureMean </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a88daff53e6272feb2b26432246c0f848" name="a88daff53e6272feb2b26432246c0f848"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88daff53e6272feb2b26432246c0f848">&#9670;&#160;</a></span>setPerVertexQualityFromPrincipalCurvatureMinValue()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::setPerVertexQualityFromPrincipalCurvatureMinValue </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2fa908d1710912a11715aedca11ecb76" name="a2fa908d1710912a11715aedca11ecb76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fa908d1710912a11715aedca11ecb76">&#9670;&#160;</a></span>setPerVertexQualityFromPrincipalCurvatureShapeIndex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::setPerVertexQualityFromPrincipalCurvatureShapeIndex </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the Shape Index S from the Principal Curvature, as defined by [Koenderink 1992] and stores it in the per-vertex quality. </p>
<p>S = 2/pi atan(k1+k2/k1-k2)</p>
<p>J. Koenderink and A. van Doorn. Surface shape and curvature scales. <a class="el" href="classvcl_1_1Image.html" title="The Image class stores an Image in 8 bit RGBA format.">Image</a> and vision computing, 10(8):557565, 1992. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af8b71c44c2c2e9adcc6bad8e278e7010" name="af8b71c44c2c2e9adcc6bad8e278e7010"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8b71c44c2c2e9adcc6bad8e278e7010">&#9670;&#160;</a></span>setPerVertexQualityFromVertexValence()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::setPerVertexQualityFromVertexValence </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assign to the vertex quality of the mesh the valence of each vertex, that is the number of adjacent faces of the vertex. </p>
<p>Requirements:</p><ul>
<li><a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>:<ul>
<li>Vertices:<ul>
<li>Quality</li>
</ul>
</li>
<li>Faces</li>
</ul>
</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">m</td><td>mesh on which set the vertex quality to the vertex valence </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a24901186f1a77f31a23d64f30f0b0dc3" name="a24901186f1a77f31a23d64f30f0b0dc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24901186f1a77f31a23d64f30f0b0dc3">&#9670;&#160;</a></span>setTransformMatrixRotation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType , PointConcept PointType, typename ScalarType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::setTransformMatrixRotation </td>
          <td>(</td>
          <td class="paramtype">MatrixType &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PointType&#160;</td>
          <td class="paramname"><em>axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ScalarType &amp;&#160;</td>
          <td class="paramname"><em>angleRad</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given an 3D axis and an angle expressed in randiants, fills the given matrix with a transform matrix that represents the rotation matrix of the given axis/angle. </p>
<p>The given matrix must be at least a 3x3 matrix. If the matrix is a higher than 3x3 (e.g. 4x4), only the 3x3 submatrix will be set, leaving unchanged the other values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix</td><td></td></tr>
    <tr><td class="paramname">axis</td><td></td></tr>
    <tr><td class="paramname">angleRad</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="abd5d95d87600e42a0da835735e35ea99" name="abd5d95d87600e42a0da835735e35ea99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd5d95d87600e42a0da835735e35ea99">&#9670;&#160;</a></span>setTransformMatrixRotationDeg()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType , PointConcept PointType, typename ScalarType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::setTransformMatrixRotationDeg </td>
          <td>(</td>
          <td class="paramtype">MatrixType &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PointType&#160;</td>
          <td class="paramname"><em>axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ScalarType &amp;&#160;</td>
          <td class="paramname"><em>angleDeg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given an 3D axis and an angle expressed in degrees, fills the given matrix with a transform matrix that represents the rotation matrix of the given axis/angle. </p>
<p>The given matrix must be at least a 3x3 matrix. If the matrix is a higher than 3x3 (e.g. 4x4), only the 3x3 submatrix will be set, leaving unchanged the other values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix</td><td></td></tr>
    <tr><td class="paramname">axis</td><td></td></tr>
    <tr><td class="paramname">angleDeg</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="af5a78d0411b7f20298f45618c3e2aff5" name="af5a78d0411b7f20298f45618c3e2aff5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5a78d0411b7f20298f45618c3e2aff5">&#9670;&#160;</a></span>setTrasformMatrixScale()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ScalarType , PointConcept PointType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::setTrasformMatrixScale </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacevcl.html#ad82a126b390f21b2e9658c73e7a795ee">Matrix44</a>&lt; ScalarType &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PointType &amp;&#160;</td>
          <td class="paramname"><em>scale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="adbb9f1401057fda582e6b0cda2a36b18" name="adbb9f1401057fda582e6b0cda2a36b18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbb9f1401057fda582e6b0cda2a36b18">&#9670;&#160;</a></span>setTrasformMatrixTranslation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ScalarType , PointConcept PointType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::setTrasformMatrixTranslation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacevcl.html#ad82a126b390f21b2e9658c73e7a795ee">Matrix44</a>&lt; ScalarType &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PointType &amp;&#160;</td>
          <td class="paramname"><em>translation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aecc52dfd02e09e49a5dd1612183a2cb8" name="aecc52dfd02e09e49a5dd1612183a2cb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecc52dfd02e09e49a5dd1612183a2cb8">&#9670;&#160;</a></span>shellBarycenter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">MeshType::VertexType::CoordType vcl::shellBarycenter </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the barycenter of the surface thin-shell. E.g. it assume a 'empty' model where all the mass is located on the surface and compute the barycenter of that thinshell. Works for any polygonal model (no problem with open, nonmanifold selfintersecting models). Useful for computing the barycenter of 2D planar figures. </p>
<p>Requirements:</p><ul>
<li><a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>:<ul>
<li>Vertices</li>
<li>Faces</li>
</ul>
</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a33f84f8e28d1adf77369c920bb0e46b5" name="a33f84f8e28d1adf77369c920bb0e46b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33f84f8e28d1adf77369c920bb0e46b5">&#9670;&#160;</a></span>smoothPerVertexNormalsPointCloud() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType, PointConcept PointType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::smoothPerVertexNormalsPointCloud </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvcl_1_1KDTree.html">KDTree</a>&lt; PointType &gt; &amp;&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a>&#160;</td>
          <td class="paramname"><em>neighborNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a>&#160;</td>
          <td class="paramname"><em>iterNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>smoothPerVertexNormalsPointCloud </p>
<p>Requirements:</p><ul>
<li><a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>:<ul>
<li>Vertices:<ul>
<li>Normal</li>
</ul>
</li>
</ul>
</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td></td></tr>
    <tr><td class="paramname">tree</td><td></td></tr>
    <tr><td class="paramname">neighborNum</td><td></td></tr>
    <tr><td class="paramname">iterNum</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9a2005cb82322d607914a2e2dcd63e66" name="a9a2005cb82322d607914a2e2dcd63e66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a2005cb82322d607914a2e2dcd63e66">&#9670;&#160;</a></span>smoothPerVertexNormalsPointCloud() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::smoothPerVertexNormalsPointCloud </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a>&#160;</td>
          <td class="paramname"><em>neighborNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a>&#160;</td>
          <td class="paramname"><em>iterNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>smoothPerVertexNormalsPointCloud </p>
<p>Requirements:</p><ul>
<li><a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>:<ul>
<li>Vertices:<ul>
<li>Normal</li>
</ul>
</li>
</ul>
</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td></td></tr>
    <tr><td class="paramname">neighborNum</td><td></td></tr>
    <tr><td class="paramname">iterNum</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0a1a624c7abe7c703618b7f512c33039" name="a0a1a624c7abe7c703618b7f512c33039"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a1a624c7abe7c703618b7f512c33039">&#9670;&#160;</a></span>Sphere()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Point3Concept P, typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Sphere.html">vcl::Sphere</a> </td>
          <td>(</td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  <a class="el" href="classvcl_1_1Sphere.html">Sphere</a>&lt; typename P::ScalarType &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9349b9ea771a0058a9cb4a57eedd624b" name="a9349b9ea771a0058a9cb4a57eedd624b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9349b9ea771a0058a9cb4a57eedd624b">&#9670;&#160;</a></span>sphereBoxIntersect()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SphereConcept SphereType, Box3Concept BoxType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool vcl::sphereBoxIntersect </td>
          <td>(</td>
          <td class="paramtype">const SphereType &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BoxType &amp;&#160;</td>
          <td class="paramname"><em>box</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks if a sphere intersects with a box in 3D space.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SphereType</td><td>A type that satisfies the SphereConcept concept. </td></tr>
    <tr><td class="paramname">BoxType</td><td>A type that satisfies the Box3Concept concept.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>The sphere to check for intersection. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">box</td><td>The box to check for intersection. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the sphere intersects with the box, false otherwise. </dd></dl>

</div>
</div>
<a id="a438da980623645640c78105766bde287" name="a438da980623645640c78105766bde287"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a438da980623645640c78105766bde287">&#9670;&#160;</a></span>sphericalFibonacciPointSet()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Point3Concept PointType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; PointType &gt; vcl::sphericalFibonacciPointSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a>&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a vector of <code>n</code> points distributed in a unit sphere. </p>
<p>This function returns a vector of <code>n</code> points that are uniformly distributed on a unit sphere, using the Spherical Fibonacci <a class="el" href="classvcl_1_1Point.html" title="The Point class represents an N-dimensional point containing N scalar values.">Point</a> Sets algorithm described in the paper "Spherical Fibonacci
Mapping" by Benjamin Keinert, Matthias Innmann, Michael Sanger, and Marc Stamminger (TOG 2015).</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">PointType</td><td>The type of the point to generate. This type must satisfy the <code>Point3Concept</code> concept.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>The number of points to generate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of <code>n</code> points distributed in a unit sphere. </dd></dl>

</div>
</div>
<a id="ab1f5ecc820f6ab64fb437ba12296601c" name="ab1f5ecc820f6ab64fb437ba12296601c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1f5ecc820f6ab64fb437ba12296601c">&#9670;&#160;</a></span>StaticGrid() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;PointIteratorConcept It&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1StaticGrid.html">vcl::StaticGrid</a> </td>
          <td>(</td>
          <td class="paramtype">It&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">It&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  <a class="el" href="classvcl_1_1StaticGrid.html">StaticGrid</a>&lt; <a class="el" href="classvcl_1_1RegularGrid.html">RegularGrid</a>&lt; typename It::value_type, It::value_type::DIM &gt;, typename It::value_type::ScalarType &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7586ced2cedb8cd2aa668c8136b24603" name="a7586ced2cedb8cd2aa668c8136b24603"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7586ced2cedb8cd2aa668c8136b24603">&#9670;&#160;</a></span>StaticGrid() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;PointIteratorConcept It, typename F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1StaticGrid.html">vcl::StaticGrid</a> </td>
          <td>(</td>
          <td class="paramtype">It&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">It&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  <a class="el" href="classvcl_1_1StaticGrid.html">StaticGrid</a>&lt; <a class="el" href="classvcl_1_1RegularGrid.html">RegularGrid</a>&lt; typename It::value_type, It::value_type::DIM &gt;, typename It::value_type::ScalarType &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae6d4557abc45cc5daf2fe2e389b91ce9" name="ae6d4557abc45cc5daf2fe2e389b91ce9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6d4557abc45cc5daf2fe2e389b91ce9">&#9670;&#160;</a></span>StaticGrid() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;VertexPointerRangeConcept Rng&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1StaticGrid.html">vcl::StaticGrid</a> </td>
          <td>(</td>
          <td class="paramtype">Rng&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt;  <a class="el" href="classvcl_1_1StaticGrid.html">StaticGrid</a>&lt; <a class="el" href="classvcl_1_1RegularGrid.html">RegularGrid</a>&lt; typename std::remove_pointer_t&lt; typename std::ranges::iterator_t&lt; Rng &gt;::value_type &gt;::CoordType::ScalarType, 3 &gt;, typename std::ranges::iterator_t&lt; Rng &gt;::value_type &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6cc79547db9d6b6a15264fc004fec4dc" name="a6cc79547db9d6b6a15264fc004fec4dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cc79547db9d6b6a15264fc004fec4dc">&#9670;&#160;</a></span>stratifiedMontecarloPointSampling()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SamplerConcept SamplerType, FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">SamplerType vcl::stratifiedMontecarloPointSampling </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a>&#160;</td>
          <td class="paramname"><em>nSamples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>deterministic</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5dfa8d4e30b457c12c3e5e21b4fc123a" name="a5dfa8d4e30b457c12c3e5e21b4fc123a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5dfa8d4e30b457c12c3e5e21b4fc123a">&#9670;&#160;</a></span>surfaceArea()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double vcl::surfaceArea </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the surface area of the given <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>, that is the sum of the areas of each face of the mesh. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>mesh on which compute the surface area. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The surface area of the given mesh. </dd></dl>

</div>
</div>
<a id="a7d1a7878d6acec093a915b11413984aa" name="a7d1a7878d6acec093a915b11413984aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d1a7878d6acec093a915b11413984aa">&#9670;&#160;</a></span>taubinSmoothing()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::taubinSmoothing </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a>&#160;</td>
          <td class="paramname"><em>step</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>smoothSelected</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1578b48cbfdb04c6675ac5a3b535bb83" name="a1578b48cbfdb04c6675ac5a3b535bb83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1578b48cbfdb04c6675ac5a3b535bb83">&#9670;&#160;</a></span>toDeg()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Scalar vcl::toDeg </td>
          <td>(</td>
          <td class="paramtype">const Scalar &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a53f705e848cce98dd23542a2d109e55b" name="a53f705e848cce98dd23542a2d109e55b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53f705e848cce98dd23542a2d109e55b">&#9670;&#160;</a></span>toRad()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Scalar vcl::toRad </td>
          <td>(</td>
          <td class="paramtype">const Scalar &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7c4a60eeed3ddead3611508975cb6045" name="a7c4a60eeed3ddead3611508975cb6045"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c4a60eeed3ddead3611508975cb6045">&#9670;&#160;</a></span>translate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType, PointConcept PointType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::translate </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PointType &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9b3c4b3e9c618082e4fbd063afafccb4" name="a9b3c4b3e9c618082e4fbd063afafccb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b3c4b3e9c618082e4fbd063afafccb4">&#9670;&#160;</a></span>triangleBoxIntersect()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ConstTriangle3Concept TriangleType, Box3Concept BoxType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool vcl::triangleBoxIntersect </td>
          <td>(</td>
          <td class="paramtype">const TriangleType &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BoxType &amp;&#160;</td>
          <td class="paramname"><em>box</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if a triangle intersects with a box. <a href="https://gist.github.com/jflipts/fc68d4eeacfcc04fbdb2bf38e0911850">https://gist.github.com/jflipts/fc68d4eeacfcc04fbdb2bf38e0911850</a>. </p>

</div>
</div>
<a id="ab78be5dc0d03ed32cde7a2262b506c74" name="ab78be5dc0d03ed32cde7a2262b506c74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab78be5dc0d03ed32cde7a2262b506c74">&#9670;&#160;</a></span>trianglePointIntersect()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ConstTriangle2Concept TriangleType, Point2Concept PointType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool vcl::trianglePointIntersect </td>
          <td>(</td>
          <td class="paramtype">const TriangleType &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PointType &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks if a 2D point intersects with/is inside a given 2D triangle having its points in counterclockwise order.</p>
<p>The function checks if a point lies within a given triangle using barycentric coordinates. It first calculates the area of the triangle, and then calculates the barycentric coordinates of the point with respect to the triangle. If the barycentric coordinates satisfy certain conditions, then the point is considered to intersect with the triangle.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TriangleType</td><td>A type that satisfies the ConstTriangle2Concept concept. </td></tr>
    <tr><td class="paramname">PointType</td><td>A type that satisfies the Point2Concept concept.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tr</td><td>The triangle to test for intersection. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>The point to test for intersection with the triangle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the point intersects with/is inside the triangle, false otherwise.</dd></dl>
<p>Checks if a 3D point intersects/is inside a 3D triangle having its points in counterclockwise order.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TriangleType</td><td>A type that satisfies the ConstTriangle3Concept concept. </td></tr>
    <tr><td class="paramname">PointType</td><td>A type that satisfies the Point3Concept concept.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>The triangle to test for intersection. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>The point to test for intersection with the triangle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the point intersects with/is inside the triangle, false otherwise. </dd></dl>

</div>
</div>
<a id="af510b267910115525d77a6b4539ca3cd" name="af510b267910115525d77a6b4539ca3cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af510b267910115525d77a6b4539ca3cd">&#9670;&#160;</a></span>triangleSphereItersect() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ConstTriangle3Concept TriangleType, SphereConcept SphereType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool vcl::triangleSphereItersect </td>
          <td>(</td>
          <td class="paramtype">const TriangleType &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SphereType &amp;&#160;</td>
          <td class="paramname"><em>sphere</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the intersection between a sphere and a triangle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>the 3D input triangle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sphere</td><td>the input sphere </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true iff there is an intersection between the sphere and the triangle </dd></dl>

</div>
</div>
<a id="afef4c14e85563ae0db11815309e9a5cc" name="afef4c14e85563ae0db11815309e9a5cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afef4c14e85563ae0db11815309e9a5cc">&#9670;&#160;</a></span>triangleSphereItersect() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ConstTriangle3Concept TriangleType, SphereConcept SphereType, Point3Concept PointType, typename ScalarType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool vcl::triangleSphereItersect </td>
          <td>(</td>
          <td class="paramtype">const TriangleType &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SphereType &amp;&#160;</td>
          <td class="paramname"><em>sphere</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PointType &amp;&#160;</td>
          <td class="paramname"><em>witness</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::pair&lt; ScalarType, ScalarType &gt; &amp;&#160;</td>
          <td class="paramname"><em>res</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the intersection between a sphere and a triangle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>the 3D input triangle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sphere</td><td>the input sphere </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">witness</td><td>the point on the triangle nearest to the center of the sphere (even when there isn't intersection) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">res</td><td>if not null, in the first item is stored the minimum distance between the triangle and the sphere, while in the second item is stored the penetration depth </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true iff there is an intersection between the sphere and the triangle </dd></dl>

</div>
</div>
<a id="a08ddfb40632cb38ec4750610e0e2ebaa" name="a08ddfb40632cb38ec4750610e0e2ebaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08ddfb40632cb38ec4750610e0e2ebaa">&#9670;&#160;</a></span>tupleIndexByType()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename... Us&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> vcl::tupleIndexByType </td>
          <td>(</td>
          <td class="paramtype">const std::tuple&lt; U, Us... &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the index of a type T in a std::tuple&lt;U, Us...&gt; passed as parameter; Returns UINT_NULL if the type T is not found in the tuple. </p>

</div>
</div>
<a id="a359b253b8af6d1ae3ac24625e8ac7a56" name="a359b253b8af6d1ae3ac24625e8ac7a56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a359b253b8af6d1ae3ac24625e8ac7a56">&#9670;&#160;</a></span>updateBorder()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::updateBorder </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes per-face border flags without requiring any kind of topology info. </p>
<p>Requirements:</p><ul>
<li><a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>:<ul>
<li>Vertices</li>
<li>Faces</li>
</ul>
</li>
</ul>
<p>Complexity: O(NF log (NF))</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>the mesh on which the border flags will be updated </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3db69fc234fc8072747aabf1724f9b92" name="a3db69fc234fc8072747aabf1724f9b92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3db69fc234fc8072747aabf1724f9b92">&#9670;&#160;</a></span>updatePerFaceAdjacentFaces()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::updatePerFaceAdjacentFaces </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates the per face adjacent face component. </p>
<p>All the faces that does not have an adjacent face (border) will have the adjacent face set to nullptr.</p>
<p>If there are non-manifold edges (edges on which there are more than two incident faces), then a chain-link composed of all the incident faces is built.</p>
<p>Assuming that we have 3 faces f0, f1 and f2 on the same edge composed of vi and vj, we can define the edge indices in the three faces as:</p>
<div class="fragment"><div class="line">e0 = f0.indexOfEdge(vi, vj);</div>
<div class="line">e1 = f1.indexOfEdge(vi, vj);</div>
<div class="line">e2 = f2.indexOfEdge(vi, vj);</div>
</div><!-- fragment --><p>The adjacencies will cycle like:</p>
<div class="fragment"><div class="line">f0-&gt;adjFace(e0) == f1;</div>
<div class="line">f1-&gt;adjFace(e1) == f2;</div>
<div class="line">f2-&gt;adjFace(e2) == f0;</div>
</div><!-- fragment --><p>or a similar permutation of the faces.</p>
<p>In general, an edge is non-manifold if it is true the expression:</p>
<div class="fragment"><div class="line">fj = fi-&gt;adjFace(ei);</div>
<div class="line">fj-&gt;adjFace(ej) != fi; <span class="comment">// if true, the edge is non-manifold</span></div>
</div><!-- fragment --><p>Requirements:</p><ul>
<li><a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>:<ul>
<li>Faces:<ul>
<li>AdjacentFaces</li>
</ul>
</li>
</ul>
</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>the mesh on which update the per face adjacent faces. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8dd9800cb5538e0eb47613be82daaf44" name="a8dd9800cb5538e0eb47613be82daaf44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8dd9800cb5538e0eb47613be82daaf44">&#9670;&#160;</a></span>updatePerFaceNormals()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::updatePerFaceNormals </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>normalize</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>updatePerFaceNormals </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">m</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">normalize</td><td>if true (default), normals are normalized after computation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af3ecae45cc9e58f948dc04178fd6669b" name="af3ecae45cc9e58f948dc04178fd6669b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3ecae45cc9e58f948dc04178fd6669b">&#9670;&#160;</a></span>updatePerVertexAdjacentFaces()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::updatePerVertexAdjacentFaces </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates the adjacent faces of each vertex of the mesh. </p>
<p>Requirements:</p><ul>
<li><a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>:<ul>
<li>Vertices:<ul>
<li>AdjacentFaces</li>
</ul>
</li>
<li>Faces</li>
</ul>
</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>the mesh on which update the per vertex adjacent faces. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6b6e8d46b2b867729d95c72ab1925df2" name="a6b6e8d46b2b867729d95c72ab1925df2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b6e8d46b2b867729d95c72ab1925df2">&#9670;&#160;</a></span>updatePerVertexAdjacentVertices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::updatePerVertexAdjacentVertices </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates the adjacent vertices of each vertex of the mesh. </p>
<p>Requirements:</p><ul>
<li><a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>:<ul>
<li>Vertices:<ul>
<li>AdjacentVertices</li>
</ul>
</li>
<li>Faces</li>
</ul>
</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>the mesh on which update the per vertex adjacent faces. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aea3bc3d2b03bb9e985c9977023b0fb9f" name="aea3bc3d2b03bb9e985c9977023b0fb9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea3bc3d2b03bb9e985c9977023b0fb9f">&#9670;&#160;</a></span>updatePerVertexNormals()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::updatePerVertexNormals </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>normalize</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the vertex normal as the classic area weighted average. </p>
<p>This function does not need or exploit current face normals. Unreferenced vertex normals are left unchanged.</p>
<p>Requirements:</p><ul>
<li><a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>:<ul>
<li>Vertices:<ul>
<li>Normal</li>
</ul>
</li>
<li>Faces</li>
</ul>
</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">m</td><td>the mesh on which compute the vertex normals. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">normalize</td><td>if true (default), normals are normalized after computation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1b7d63fc38670dac30d1dd1dadf4ef8c" name="a1b7d63fc38670dac30d1dd1dadf4ef8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b7d63fc38670dac30d1dd1dadf4ef8c">&#9670;&#160;</a></span>updatePerVertexNormalsAngleWeighted()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::updatePerVertexNormalsAngleWeighted </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>normalize</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the vertex normal as an angle weighted average. </p>
<p>The normal of a vertex <code>v</code> computed as a weighted sum the incident face normals. The weight is simlply the angle of the involved wedge. Described in:</p>
<div class="fragment"><div class="line">G. Thurmer, C. A. Wuthrich</div>
<div class="line">  <span class="stringliteral">&quot;Computing vertex normals from polygonal facets&quot;</span></div>
<div class="line">  Journal of Graphics Tools, 1998</div>
</div><!-- fragment --><p>This function does not need or exploit current face normals. Unreferenced vertex normals are left unchanged.</p>
<p>Requirements:</p><ul>
<li><a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>:<ul>
<li>Vertices:<ul>
<li>Normal</li>
</ul>
</li>
<li>Faces</li>
</ul>
</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">m</td><td>the mesh on which compute the angle weighted vertex normals. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">normalize</td><td>if true (default), normals are normalized after computation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afafcf64d1f3086a907da247132369ca2" name="afafcf64d1f3086a907da247132369ca2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afafcf64d1f3086a907da247132369ca2">&#9670;&#160;</a></span>updatePerVertexNormalsFromFaceNormals()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::updatePerVertexNormalsFromFaceNormals </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>normalize</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the vertex normal as the sum of the adjacent faces normals. </p>
<p>Unreferenced vertex normals are left unchanged.</p>
<p>Requirements:</p><ul>
<li><a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>:<ul>
<li>Vertices:<ul>
<li>Normal</li>
</ul>
</li>
<li>Faces<ul>
<li>Normal</li>
</ul>
</li>
</ul>
</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">m</td><td>the mesh on which compute the vertex normals. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">normalize</td><td>if true (default), normals are normalized after computation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5fdde9d989eeac7117c4f2fd26f3456b" name="a5fdde9d989eeac7117c4f2fd26f3456b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fdde9d989eeac7117c4f2fd26f3456b">&#9670;&#160;</a></span>updatePerVertexNormalsNelsonMaxWeighted()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::updatePerVertexNormalsNelsonMaxWeighted </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>normalize</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the vertex normal using the Max et al. weighting scheme. </p>
<p>The normal of a vertex v is computed according to the formula described in:</p>
<div class="fragment"><div class="line">Max, N.,</div>
<div class="line">  <span class="stringliteral">&quot;Weights for Computing Vertex Normals from Facet Normals&quot;</span>,</div>
<div class="line">  Journal of Graphics Tools, 4(2) (1999)</div>
</div><!-- fragment --><p>The weight for each wedge is the cross product of the two edge over the product of the square of the two edge lengths. According to the original paper it is perfect only for spherical surface, but it should perform well...</p>
<p>This function does not need or exploit current face normals. Unreferenced vertex normals are left unchanged.</p>
<p>Requirements:</p><ul>
<li><a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>:<ul>
<li>Vertices:<ul>
<li>Normal</li>
</ul>
</li>
<li>Faces</li>
</ul>
</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">m</td><td>the mesh on which compute the Max et al. weighted vertex normals. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">normalize</td><td>if true (default), normals are normalized after computation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3c1237fab955f1bf4329842c6d3ed51a" name="a3c1237fab955f1bf4329842c6d3ed51a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c1237fab955f1bf4329842c6d3ed51a">&#9670;&#160;</a></span>updatePrincipalCurvature() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType, LoggerConcept LogType = NullLogger&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::updatePrincipalCurvature </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LogType &amp;&#160;</td>
          <td class="paramname"><em>log</em> = <code><a class="el" href="group__miscellaneous.html#ga3377e3c875ec245e90ac5a395105ce99">nullLogger</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8b3ad75679b446aabe75e8f1701bce67" name="a8b3ad75679b446aabe75e8f1701bce67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b3ad75679b446aabe75e8f1701bce67">&#9670;&#160;</a></span>updatePrincipalCurvature() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType, LoggerConcept LogType = NullLogger&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::updatePrincipalCurvature </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacevcl.html#aaca879a6bfd47ff8429d6b2f6cfa9440">VCLibPrincipalCurvatureAlgorithm</a>&#160;</td>
          <td class="paramname"><em>alg</em> = <code><a class="el" href="namespacevcl.html#aaca879a6bfd47ff8429d6b2f6cfa9440a16e818963316b0b43fcbdec6d75f25ed">VCL_PRINCIPAL_CURVATURE_TAUBIN95</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LogType &amp;&#160;</td>
          <td class="paramname"><em>log</em> = <code><a class="el" href="group__miscellaneous.html#ga3377e3c875ec245e90ac5a395105ce99">nullLogger</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac053ed0caa29edc306e54201f0bf6123" name="ac053ed0caa29edc306e54201f0bf6123"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac053ed0caa29edc306e54201f0bf6123">&#9670;&#160;</a></span>updatePrincipalCurvaturePCA()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType, LoggerConcept LogType = NullLogger&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::updatePrincipalCurvaturePCA </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename MeshType::VertexType::CoordType::ScalarType&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>montecarloSampling</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LogType &amp;&#160;</td>
          <td class="paramname"><em>log</em> = <code><a class="el" href="group__miscellaneous.html#ga3377e3c875ec245e90ac5a395105ce99">nullLogger</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the Principal Curvature meseaure as described in the paper: Robust principal curvatures on Multiple Scales, Yong-Liang Yang, Yu-Kun Lai, Shi-Min Hu Helmut Pottmann SGP 2004. If montecarloSampling==true the covariance is computed by montecarlo sampling on the mesh (faster); If montecarloSampling==false the covariance is computed by (analytic)integration over the surface (slower). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td></td></tr>
    <tr><td class="paramname">radius</td><td></td></tr>
    <tr><td class="paramname">montecarloSampling</td><td></td></tr>
    <tr><td class="paramname">log</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0953cccb4f94dded63edb630530e2197" name="a0953cccb4f94dded63edb630530e2197"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0953cccb4f94dded63edb630530e2197">&#9670;&#160;</a></span>updatePrincipalCurvatureTaubin95()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType, LoggerConcept LogType = NullLogger&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::updatePrincipalCurvatureTaubin95 </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LogType &amp;&#160;</td>
          <td class="paramname"><em>log</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a01810ffdfe2df3aa87e9de9c783a32a6" name="a01810ffdfe2df3aa87e9de9c783a32a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01810ffdfe2df3aa87e9de9c783a32a6">&#9670;&#160;</a></span>vertexColorsMatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MatrixConcept Matrix, MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Matrix vcl::vertexColorsMatrix </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a #V*4 Matrix of integers containing the colors of the vertices of a <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>. The function is templated on the Matrix itself. </p>
<p>This function works with every Matrix type that satisfies the MatrixConcept, and requires that the mesh has per-vertex colors.</p>
<p>Usage example with Eigen Matrix:</p>
<div class="fragment"><div class="line">Eigen::MatrixX4i VC = vcl::vertexColorsMatrix&lt;Eigen::MatrixX4i&gt;(myMesh);</div>
</div><!-- fragment --><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classvcl_1_1MissingComponentException.html">vcl::MissingComponentException</a></td><td>if the mesh does not have per-vertex colors available.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function does not guarantee that the rows of the matrix correspond to the vertex indices of the mesh. This scenario is possible when the mesh has deleted vertices. To be sure to have a direct correspondence, compact the vertex container before calling this function.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>input mesh </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>#V*4 matrix of integers (vertex colors) </dd></dl>

</div>
</div>
<a id="aed0e167ce00c4dd8cf2b6400ceb24da3" name="aed0e167ce00c4dd8cf2b6400ceb24da3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed0e167ce00c4dd8cf2b6400ceb24da3">&#9670;&#160;</a></span>vertexNormalsMatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MatrixConcept Matrix, MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Matrix vcl::vertexNormalsMatrix </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a #V*3 Matrix of scalars containing the normals of the vertices of a <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>. The function is templated on the Matrix itself. </p>
<p>This function works with every Matrix type that satisfies the MatrixConcept, and requires that the mesh has per-vertex normals.</p>
<p>Usage example with Eigen Matrix:</p>
<div class="fragment"><div class="line">Eigen::MatrixX3d VN = vcl::vertexNormalsMatrix&lt;Eigen::MatrixX3d&gt;(myMesh);</div>
</div><!-- fragment --><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classvcl_1_1MissingComponentException.html">vcl::MissingComponentException</a></td><td>if the mesh does not have per-vertex normals available.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function does not guarantee that the rows of the matrix correspond to the vertex indices of the mesh. This scenario is possible when the mesh has deleted vertices. To be sure to have a direct correspondence, compact the vertex container before calling this function.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>input mesh </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>#V*3 matrix of scalars (vertex normals) </dd></dl>

</div>
</div>
<a id="a9ed4ecc783b58f5327f0a6b68c071727" name="a9ed4ecc783b58f5327f0a6b68c071727"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ed4ecc783b58f5327f0a6b68c071727">&#9670;&#160;</a></span>vertexQualityAverage()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto vcl::vertexQualityAverage </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a scalar that is the average of the vertex quality. </p>
<p>Requirements:</p><ul>
<li><a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>:<ul>
<li>Vertices:<ul>
<li>Quality</li>
</ul>
</li>
</ul>
</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>the input <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a> on which compute the average of the quality. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The average of the vertex quality of the given mesh. </dd></dl>

</div>
</div>
<a id="a7cbfad9340b842c1bf68c7faf4ff9dc7" name="a7cbfad9340b842c1bf68c7faf4ff9dc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cbfad9340b842c1bf68c7faf4ff9dc7">&#9670;&#160;</a></span>vertexQualityHistogram()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType, typename HScalar  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Histogram.html">Histogram</a>&lt; HScalar &gt; vcl::vertexQualityHistogram </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>selectionOnly</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a>&#160;</td>
          <td class="paramname"><em>histSize</em> = <code>10000</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae2972300f527bd1cce6182dde8b76c41" name="ae2972300f527bd1cce6182dde8b76c41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2972300f527bd1cce6182dde8b76c41">&#9670;&#160;</a></span>vertexQualityMinMax()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto vcl::vertexQualityMinMax </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a pair containing the min and the maximum vertex quality. </p>
<p>Requirements:</p><ul>
<li><a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>:<ul>
<li>Vertices:<ul>
<li>Quality</li>
</ul>
</li>
</ul>
</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>the input <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a> on which compute the minimum and the maximum quality. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code>std::pair</code> having as first element the minimum, and as second element the maximum quality. </dd></dl>

</div>
</div>
<a id="a04201da836f3c6bc6eb9444319f7b492" name="a04201da836f3c6bc6eb9444319f7b492"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04201da836f3c6bc6eb9444319f7b492">&#9670;&#160;</a></span>vertexQualityVector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Vect , MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Vect vcl::vertexQualityVector </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a #V <a class="el" href="classvcl_1_1Vector.html" title="The Vector class is a generic container of objects of type T, that could have fixed or dynamic size,...">Vector</a> of scalars containing the quality of the vertices of a <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>. The function is templated on the <a class="el" href="classvcl_1_1Vector.html" title="The Vector class is a generic container of objects of type T, that could have fixed or dynamic size,...">Vector</a> itself. </p>
<p>This function works with every <a class="el" href="classvcl_1_1Vector.html" title="The Vector class is a generic container of objects of type T, that could have fixed or dynamic size,...">Vector</a> type that has a constructor with a size_t argument and an operator(uint), and requires that the mesh has per-vertex quality.</p>
<p>Usage example with Eigen <a class="el" href="classvcl_1_1Vector.html" title="The Vector class is a generic container of objects of type T, that could have fixed or dynamic size,...">Vector</a>:</p>
<div class="fragment"><div class="line">Eigen::VectorXd VQ = vcl::vertexQualityVector&lt;Eigen::VectorXd&gt;(myMesh);</div>
</div><!-- fragment --><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classvcl_1_1MissingComponentException.html">vcl::MissingComponentException</a></td><td>if the mesh does not have per-vertex quality available.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function does not guarantee that the rows of the vector correspond to the vertex indices of the mesh. This scenario is possible when the mesh has deleted vertices. To be sure to have a direct correspondence, compact the vertex container before calling this function.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>input mesh </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>#V vector of scalars (vertex quality) </dd></dl>

</div>
</div>
<a id="ac6617580fead9a30c7c8db2e236e2a7a" name="ac6617580fead9a30c7c8db2e236e2a7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6617580fead9a30c7c8db2e236e2a7a">&#9670;&#160;</a></span>vertexQualityWeightedMontecarloPointSampling()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SamplerConcept SamplerType, FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">SamplerType vcl::vertexQualityWeightedMontecarloPointSampling </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a>&#160;</td>
          <td class="paramname"><em>nSamples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>variance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>deterministic</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa8a8d81401816c73db39eeae352e95bc" name="aa8a8d81401816c73db39eeae352e95bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8a8d81401816c73db39eeae352e95bc">&#9670;&#160;</a></span>vertexRadiusFromQuality()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; typename MeshType::VertexType::QualityType &gt; vcl::vertexRadiusFromQuality </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>diskRadius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>radiusVariance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>invert</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>When performing an adptive pruning for each sample we expect a varying radius to be removed. The radius is a PerVertex attribute that we compute from the current per vertex quality component. The expected radius of the sample is computed so that it linearly maps the quality between diskradius and diskradius*variance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td></td></tr>
    <tr><td class="paramname">diskRadius</td><td></td></tr>
    <tr><td class="paramname">radiusVariance</td><td></td></tr>
    <tr><td class="paramname">invert</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a598979803f34d74d1c4c9d4599d01eb8" name="a598979803f34d74d1c4c9d4599d01eb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a598979803f34d74d1c4c9d4599d01eb8">&#9670;&#160;</a></span>vertexRadiusFromWeights()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType, typename ScalarType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; ScalarType &gt; vcl::vertexRadiusFromWeights </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; ScalarType &gt; &amp;&#160;</td>
          <td class="paramname"><em>weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>diskRadius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>radiusVariance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>invert</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>When performing an adptive pruning for each sample we expect a varying radius to be removed. The radius is a PerVertex attribute that we compute from the current per vertex weights given as argument. The expected radius of the sample is computed so that it linearly maps the quality between diskradius and diskradius*variance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td></td></tr>
    <tr><td class="paramname">weights</td><td></td></tr>
    <tr><td class="paramname">diskRadius</td><td></td></tr>
    <tr><td class="paramname">radiusVariance</td><td></td></tr>
    <tr><td class="paramname">invert</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a7ebad55b87f91b27b05663d9ce7ad406" name="a7ebad55b87f91b27b05663d9ce7ad406"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ebad55b87f91b27b05663d9ce7ad406">&#9670;&#160;</a></span>vertexSelectionNumber()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> vcl::vertexSelectionNumber </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a29eebb11ad214c9832b49f81417aae34" name="a29eebb11ad214c9832b49f81417aae34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29eebb11ad214c9832b49f81417aae34">&#9670;&#160;</a></span>vertexWeightedMontecarloPointSampling()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SamplerConcept SamplerType, FaceMeshConcept MeshType, typename ScalarType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">SamplerType vcl::vertexWeightedMontecarloPointSampling </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; ScalarType &gt; &amp;&#160;</td>
          <td class="paramname"><em>weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a>&#160;</td>
          <td class="paramname"><em>nSamples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>variance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>deterministic</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9a3eb7aeb0da02be51ca136620616b43" name="a9a3eb7aeb0da02be51ca136620616b43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a3eb7aeb0da02be51ca136620616b43">&#9670;&#160;</a></span>volume()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double vcl::volume </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the volume of a closed surface <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>. Returned value is meaningful only if the input mesh is watertight. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>closed mesh on which compute the volume. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The volume of the given mesh. </dd></dl>

</div>
</div>
<a id="abe0d3154bb94af5fb7d34bd186eba0b3" name="abe0d3154bb94af5fb7d34bd186eba0b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe0d3154bb94af5fb7d34bd186eba0b3">&#9670;&#160;</a></span>weightedCovarianceMatrixOfPointCloud()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;PointConcept PointType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto vcl::weightedCovarianceMatrixOfPointCloud </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; PointType &gt; &amp;&#160;</td>
          <td class="paramname"><em>pointVec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; typename PointType::ScalarType &gt; &amp;&#160;</td>
          <td class="paramname"><em>weights</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the weighted covariance matrix of a set of points. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pointVec</td><td></td></tr>
    <tr><td class="paramname">weights</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ade68ad454a7ebe0c36e50f8db6191baa" name="ade68ad454a7ebe0c36e50f8db6191baa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade68ad454a7ebe0c36e50f8db6191baa">&#9670;&#160;</a></span>COMPONENT_ENUM_STRINGS</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* vcl::COMPONENT_ENUM_STRINGS[<a class="el" href="namespacevcl.html#aeb0898aa5c2f881895bf9bb13782ca7a">COMPONENTS_NUMBER</a>]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">    {</div>
<div class="line">        <span class="stringliteral">&quot;BitFlags&quot;</span>,</div>
<div class="line">        <span class="stringliteral">&quot;Coordinate&quot;</span>,</div>
<div class="line">        <span class="stringliteral">&quot;Normal&quot;</span>,</div>
<div class="line">        <span class="stringliteral">&quot;Color&quot;</span>,</div>
<div class="line">        <span class="stringliteral">&quot;Quality&quot;</span>,</div>
<div class="line">        <span class="stringliteral">&quot;Mark&quot;</span>,</div>
<div class="line">        <span class="stringliteral">&quot;PrincipalCurvature&quot;</span>,</div>
<div class="line">        <span class="stringliteral">&quot;TexCoord&quot;</span>,</div>
<div class="line">        <span class="stringliteral">&quot;VertexPointers&quot;</span>,</div>
<div class="line">        <span class="stringliteral">&quot;AdjacentEdges&quot;</span>,</div>
<div class="line">        <span class="stringliteral">&quot;AdjacentFaces&quot;</span>,</div>
<div class="line">        <span class="stringliteral">&quot;AdjacentVertices&quot;</span>,</div>
<div class="line">        <span class="stringliteral">&quot;WedgeColors&quot;</span>,</div>
<div class="line">        <span class="stringliteral">&quot;WedgeTexCoords&quot;</span>,</div>
<div class="line">        <span class="stringliteral">&quot;BoundingBox&quot;</span>,</div>
<div class="line">        <span class="stringliteral">&quot;Name&quot;</span>,</div>
<div class="line">        <span class="stringliteral">&quot;TexturePaths&quot;</span>,</div>
<div class="line">        <span class="stringliteral">&quot;TransformMatrix&quot;</span>,</div>
<div class="line">        <span class="stringliteral">&quot;CustomComponents&quot;</span>,</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a id="aeb0898aa5c2f881895bf9bb13782ca7a" name="aeb0898aa5c2f881895bf9bb13782ca7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb0898aa5c2f881895bf9bb13782ca7a">&#9670;&#160;</a></span>COMPONENTS_NUMBER</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> vcl::COMPONENTS_NUMBER = 19</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a53b0be19fd1313a6d531a0fd1ce629f0" name="a53b0be19fd1313a6d531a0fd1ce629f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53b0be19fd1313a6d531a0fd1ce629f0">&#9670;&#160;</a></span>ELEMENT_ENUM_STRINGS</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* vcl::ELEMENT_ENUM_STRINGS[<a class="el" href="namespacevcl.html#aa3223af8226ed14333c89406bcc16693">ELEMENTS_NUMBER</a>]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {</div>
<div class="line">    <span class="stringliteral">&quot;Vertex&quot;</span>,</div>
<div class="line">    <span class="stringliteral">&quot;Face&quot;</span>,</div>
<div class="line">    <span class="stringliteral">&quot;Edge&quot;</span>,</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a id="aa3223af8226ed14333c89406bcc16693" name="aa3223af8226ed14333c89406bcc16693"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3223af8226ed14333c89406bcc16693">&#9670;&#160;</a></span>ELEMENTS_NUMBER</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> vcl::ELEMENTS_NUMBER = 3</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a519b68bed74d2385e33a29e725601002" name="a519b68bed74d2385e33a29e725601002"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a519b68bed74d2385e33a29e725601002">&#9670;&#160;</a></span>UINT_NULL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> vcl::UINT_NULL = std::numeric_limits&lt;<a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a>&gt;<a class="el" href="namespacevcl.html#a69cc63a5ad2974d082145ed1dee7846b">::max</a>()</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacevcl.html">vcl</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6 </li>
  </ul>
</div>
</body>
</html>
