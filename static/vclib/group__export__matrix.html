<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Visual Computing Library: Export Mesh to Matrix Algorithms</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
       <script type="text/javascript">
           DoxygenAwesomeDarkModeToggle.init()
       </script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Visual Computing Library
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group__export__matrix.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Export Mesh to Matrix Algorithms<div class="ingroups"><a class="el" href="group__algorithms__mesh.html">Mesh Algorithms</a> &raquo; <a class="el" href="group__import__export.html">Import/Export Mesh Algorithms</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>List Export Mesh to Matrix algorithms.  
<a href="#details">More...</a></p>
<div class="dynheader">
Collaboration diagram for Export Mesh to Matrix Algorithms:</div>
<div class="dyncontent">
<div class="center"><img src="group__export__matrix.png" border="0" usemap="#agroup____export____matrix" alt=""/></div>
<map name="agroup____export____matrix" id="agroup____export____matrix">
<area shape="rect" title="List Export Mesh to Matrix algorithms." alt="" coords="204,5,371,45"/>
<area shape="rect" href="group__import__export.html" title="List of Import/Export Mesh algorithms." alt="" coords="5,5,156,45"/>
</map>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga3917c0aef05622f0db7d4edf19749054" id="r_ga3917c0aef05622f0db7d4edf19749054"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classvcl_1_1Box.html">typename</a> <a class="el" href="classvcl_1_1Box.html">Vect</a> , FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga3917c0aef05622f0db7d4edf19749054"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Box.html">Vect</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__export__matrix.html#ga3917c0aef05622f0db7d4edf19749054">vcl::faceIndicesVector</a> (<a class="el" href="classvcl_1_1Box.html">const</a> MeshType &amp;mesh)</td></tr>
<tr class="memdesc:ga3917c0aef05622f0db7d4edf19749054"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a #V*3 <a class="el" href="classvcl_1_1Matrix.html">Matrix</a> of scalars containing the coordinates of the vertices of a <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>. The function is templated on the <a class="el" href="classvcl_1_1Matrix.html">Matrix</a> itself.  <br /></td></tr>
<tr class="separator:ga3917c0aef05622f0db7d4edf19749054"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab109a95781aefe3adf66cfba17163673" id="r_gab109a95781aefe3adf66cfba17163673"><td class="memTemplParams" colspan="2">template&lt;MatrixConcept Matrix, EdgeMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:gab109a95781aefe3adf66cfba17163673"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">Matrix</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__export__matrix.html#gab109a95781aefe3adf66cfba17163673">vcl::edgeIndicesMatrix</a> (<a class="el" href="classvcl_1_1Box.html">const</a> MeshType &amp;mesh)</td></tr>
<tr class="memdesc:gab109a95781aefe3adf66cfba17163673"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a #F*max(size(F)) <a class="el" href="classvcl_1_1Matrix.html">Matrix</a> of integers containing the vertex indices for each face of a <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>.  <br /></td></tr>
<tr class="separator:gab109a95781aefe3adf66cfba17163673"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0aeda48720e2d34688e56a6ab79b7600" id="r_ga0aeda48720e2d34688e56a6ab79b7600"><td class="memTemplParams" colspan="2">template&lt;uint ELEM_ID, MatrixConcept Matrix, MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga0aeda48720e2d34688e56a6ab79b7600"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">Matrix</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__export__matrix.html#ga0aeda48720e2d34688e56a6ab79b7600">vcl::elementNormalsMatrix</a> (<a class="el" href="classvcl_1_1Box.html">const</a> MeshType &amp;mesh)</td></tr>
<tr class="memdesc:ga0aeda48720e2d34688e56a6ab79b7600"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a #E <a class="el" href="classvcl_1_1Vector.html" title="The Vector class is a generic container of objects of type T, that could have fixed or dynamic size,...">Vector</a> of booleans (or integers) containing the selection status of the elements identified by <code>ELEM_ID</code> of a <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>. The function is templated on the <a class="el" href="classvcl_1_1Vector.html" title="The Vector class is a generic container of objects of type T, that could have fixed or dynamic size,...">Vector</a> itself.  <br /></td></tr>
<tr class="separator:ga0aeda48720e2d34688e56a6ab79b7600"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed0e167ce00c4dd8cf2b6400ceb24da3" id="r_gaed0e167ce00c4dd8cf2b6400ceb24da3"><td class="memTemplParams" colspan="2">template&lt;MatrixConcept Matrix, MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:gaed0e167ce00c4dd8cf2b6400ceb24da3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">Matrix</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__export__matrix.html#gaed0e167ce00c4dd8cf2b6400ceb24da3">vcl::vertexNormalsMatrix</a> (<a class="el" href="classvcl_1_1Box.html">const</a> MeshType &amp;mesh)</td></tr>
<tr class="memdesc:gaed0e167ce00c4dd8cf2b6400ceb24da3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a #V*3 <a class="el" href="classvcl_1_1Matrix.html">Matrix</a> of scalars containing the normals of the vertices of a <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>. The function is templated on the <a class="el" href="classvcl_1_1Matrix.html">Matrix</a> itself.  <br /></td></tr>
<tr class="separator:gaed0e167ce00c4dd8cf2b6400ceb24da3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6bc50612a1185ec7d1add143f93eb0ec" id="r_ga6bc50612a1185ec7d1add143f93eb0ec"><td class="memTemplParams" colspan="2">template&lt;MatrixConcept Matrix, FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga6bc50612a1185ec7d1add143f93eb0ec"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">Matrix</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__export__matrix.html#ga6bc50612a1185ec7d1add143f93eb0ec">vcl::faceNormalsMatrix</a> (<a class="el" href="classvcl_1_1Box.html">const</a> MeshType &amp;mesh)</td></tr>
<tr class="memdesc:ga6bc50612a1185ec7d1add143f93eb0ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a #F*3 <a class="el" href="classvcl_1_1Matrix.html">Matrix</a> of scalars containing the normals of the faces of a <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>. The function is templated on the <a class="el" href="classvcl_1_1Matrix.html">Matrix</a> itself.  <br /></td></tr>
<tr class="separator:ga6bc50612a1185ec7d1add143f93eb0ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd776c0c02e7ef2d7657fce701c437e7" id="r_gadd776c0c02e7ef2d7657fce701c437e7"><td class="memTemplParams" colspan="2">template&lt;uint ELEM_ID, MatrixConcept Matrix, MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:gadd776c0c02e7ef2d7657fce701c437e7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">Matrix</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__export__matrix.html#gadd776c0c02e7ef2d7657fce701c437e7">vcl::elementColorsMatrix</a> (<a class="el" href="classvcl_1_1Box.html">const</a> MeshType &amp;mesh)</td></tr>
<tr class="memdesc:gadd776c0c02e7ef2d7657fce701c437e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a #E*4 <a class="el" href="classvcl_1_1Matrix.html">Matrix</a> of integers containing the colors of the elements identified by <code>ELEM_ID</code> of a <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>. The function is templated on the <a class="el" href="classvcl_1_1Matrix.html">Matrix</a> itself.  <br /></td></tr>
<tr class="separator:gadd776c0c02e7ef2d7657fce701c437e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab107c808ed2cd7096e95a4ddbe1c4496" id="r_gab107c808ed2cd7096e95a4ddbe1c4496"><td class="memTemplParams" colspan="2">template&lt;uint ELEM_ID, <a class="el" href="classvcl_1_1Box.html">typename</a> <a class="el" href="classvcl_1_1Box.html">Vect</a> , MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:gab107c808ed2cd7096e95a4ddbe1c4496"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Box.html">Vect</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__export__matrix.html#gab107c808ed2cd7096e95a4ddbe1c4496">vcl::elementColorsVector</a> (<a class="el" href="classvcl_1_1Box.html">const</a> MeshType &amp;mesh, <a class="el" href="classvcl_1_1Color.html#a51d1c2a5b8ce06d43362026194a14523">Color::Format</a> <a class="el" href="classvcl_1_1Box.html">colorFormat</a>)</td></tr>
<tr class="memdesc:gab107c808ed2cd7096e95a4ddbe1c4496"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a #E <a class="el" href="classvcl_1_1Vector.html" title="The Vector class is a generic container of objects of type T, that could have fixed or dynamic size,...">Vector</a> of integers containing the colors of the elements identified by <code>ELEM_ID</code> of a <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>. The function is templated on the <a class="el" href="classvcl_1_1Vector.html" title="The Vector class is a generic container of objects of type T, that could have fixed or dynamic size,...">Vector</a> itself. The color is packed in a single 32 bit value using the provided format.  <br /></td></tr>
<tr class="separator:gab107c808ed2cd7096e95a4ddbe1c4496"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga01810ffdfe2df3aa87e9de9c783a32a6" id="r_ga01810ffdfe2df3aa87e9de9c783a32a6"><td class="memTemplParams" colspan="2">template&lt;MatrixConcept Matrix, MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga01810ffdfe2df3aa87e9de9c783a32a6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">Matrix</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__export__matrix.html#ga01810ffdfe2df3aa87e9de9c783a32a6">vcl::vertexColorsMatrix</a> (<a class="el" href="classvcl_1_1Box.html">const</a> MeshType &amp;mesh)</td></tr>
<tr class="memdesc:ga01810ffdfe2df3aa87e9de9c783a32a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a #V*4 <a class="el" href="classvcl_1_1Matrix.html">Matrix</a> of integers containing the colors of the vertices of a <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>. The function is templated on the <a class="el" href="classvcl_1_1Matrix.html">Matrix</a> itself.  <br /></td></tr>
<tr class="separator:ga01810ffdfe2df3aa87e9de9c783a32a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga22784c31db9993ca111a35f4894d2b85" id="r_ga22784c31db9993ca111a35f4894d2b85"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classvcl_1_1Box.html">typename</a> <a class="el" href="classvcl_1_1Box.html">Vect</a> , MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga22784c31db9993ca111a35f4894d2b85"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Box.html">Vect</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__export__matrix.html#ga22784c31db9993ca111a35f4894d2b85">vcl::vertexColorsVector</a> (<a class="el" href="classvcl_1_1Box.html">const</a> MeshType &amp;mesh, <a class="el" href="classvcl_1_1Color.html#a51d1c2a5b8ce06d43362026194a14523">Color::Format</a> <a class="el" href="classvcl_1_1Box.html">colorFormat</a>)</td></tr>
<tr class="memdesc:ga22784c31db9993ca111a35f4894d2b85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a #V <a class="el" href="classvcl_1_1Vector.html" title="The Vector class is a generic container of objects of type T, that could have fixed or dynamic size,...">Vector</a> of integers containing the colors of the vertices of a <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>. The function is templated on the <a class="el" href="classvcl_1_1Vector.html" title="The Vector class is a generic container of objects of type T, that could have fixed or dynamic size,...">Vector</a> itself. The color is packed in a single 32 bit value using the provided format.  <br /></td></tr>
<tr class="separator:ga22784c31db9993ca111a35f4894d2b85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga480cf1413039e05d9065485c52076ce9" id="r_ga480cf1413039e05d9065485c52076ce9"><td class="memTemplParams" colspan="2">template&lt;MatrixConcept Matrix, FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga480cf1413039e05d9065485c52076ce9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Matrix.html">Matrix</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__export__matrix.html#ga480cf1413039e05d9065485c52076ce9">vcl::faceColorsMatrix</a> (<a class="el" href="classvcl_1_1Box.html">const</a> MeshType &amp;mesh)</td></tr>
<tr class="memdesc:ga480cf1413039e05d9065485c52076ce9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a #F*4 <a class="el" href="classvcl_1_1Matrix.html">Matrix</a> of integers containing the colors of the faces of a <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>. The function is templated on the <a class="el" href="classvcl_1_1Matrix.html">Matrix</a> itself.  <br /></td></tr>
<tr class="separator:ga480cf1413039e05d9065485c52076ce9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf27b75ea1f14a088de88c200552296f4" id="r_gaf27b75ea1f14a088de88c200552296f4"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classvcl_1_1Box.html">typename</a> <a class="el" href="classvcl_1_1Box.html">Vect</a> , MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:gaf27b75ea1f14a088de88c200552296f4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Box.html">Vect</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__export__matrix.html#gaf27b75ea1f14a088de88c200552296f4">vcl::faceColorsVector</a> (<a class="el" href="classvcl_1_1Box.html">const</a> MeshType &amp;mesh, <a class="el" href="classvcl_1_1Color.html#a51d1c2a5b8ce06d43362026194a14523">Color::Format</a> <a class="el" href="classvcl_1_1Box.html">colorFormat</a>)</td></tr>
<tr class="memdesc:gaf27b75ea1f14a088de88c200552296f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a #F <a class="el" href="classvcl_1_1Vector.html" title="The Vector class is a generic container of objects of type T, that could have fixed or dynamic size,...">Vector</a> of integers containing the colors of the faces of a <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>. The function is templated on the <a class="el" href="classvcl_1_1Vector.html" title="The Vector class is a generic container of objects of type T, that could have fixed or dynamic size,...">Vector</a> itself. The color is packed in a single 32 bit value using the provided format.  <br /></td></tr>
<tr class="separator:gaf27b75ea1f14a088de88c200552296f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e07fcb626e0c670f8f92e930d0b2c46" id="r_ga8e07fcb626e0c670f8f92e930d0b2c46"><td class="memTemplParams" colspan="2">template&lt;uint ELEM_ID, <a class="el" href="classvcl_1_1Box.html">typename</a> <a class="el" href="classvcl_1_1Box.html">Vect</a> , MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga8e07fcb626e0c670f8f92e930d0b2c46"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Box.html">Vect</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__export__matrix.html#ga8e07fcb626e0c670f8f92e930d0b2c46">vcl::elementQualityVector</a> (<a class="el" href="classvcl_1_1Box.html">const</a> MeshType &amp;mesh)</td></tr>
<tr class="memdesc:ga8e07fcb626e0c670f8f92e930d0b2c46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a #E <a class="el" href="classvcl_1_1Vector.html" title="The Vector class is a generic container of objects of type T, that could have fixed or dynamic size,...">Vector</a> of scalars containing the quality of the elements identified by <code>ELEM_ID</code> of a <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>. The function is templated on the <a class="el" href="classvcl_1_1Vector.html" title="The Vector class is a generic container of objects of type T, that could have fixed or dynamic size,...">Vector</a> itself.  <br /></td></tr>
<tr class="separator:ga8e07fcb626e0c670f8f92e930d0b2c46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga04201da836f3c6bc6eb9444319f7b492" id="r_ga04201da836f3c6bc6eb9444319f7b492"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classvcl_1_1Box.html">typename</a> <a class="el" href="classvcl_1_1Box.html">Vect</a> , MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga04201da836f3c6bc6eb9444319f7b492"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Box.html">Vect</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__export__matrix.html#ga04201da836f3c6bc6eb9444319f7b492">vcl::vertexQualityVector</a> (<a class="el" href="classvcl_1_1Box.html">const</a> MeshType &amp;mesh)</td></tr>
<tr class="memdesc:ga04201da836f3c6bc6eb9444319f7b492"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a #V <a class="el" href="classvcl_1_1Vector.html" title="The Vector class is a generic container of objects of type T, that could have fixed or dynamic size,...">Vector</a> of scalars containing the quality of the vertices of a <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>. The function is templated on the <a class="el" href="classvcl_1_1Vector.html" title="The Vector class is a generic container of objects of type T, that could have fixed or dynamic size,...">Vector</a> itself.  <br /></td></tr>
<tr class="separator:ga04201da836f3c6bc6eb9444319f7b492"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7afddefac9fc869e5cb82367856f19e9" id="r_ga7afddefac9fc869e5cb82367856f19e9"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classvcl_1_1Box.html">typename</a> <a class="el" href="classvcl_1_1Box.html">Vect</a> , FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga7afddefac9fc869e5cb82367856f19e9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Box.html">Vect</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__export__matrix.html#ga7afddefac9fc869e5cb82367856f19e9">vcl::faceQualityVector</a> (<a class="el" href="classvcl_1_1Box.html">const</a> MeshType &amp;mesh)</td></tr>
<tr class="memdesc:ga7afddefac9fc869e5cb82367856f19e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a #F <a class="el" href="classvcl_1_1Vector.html" title="The Vector class is a generic container of objects of type T, that could have fixed or dynamic size,...">Vector</a> of scalars containing the quality of the faces of a <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>. The function is templated on the <a class="el" href="classvcl_1_1Vector.html" title="The Vector class is a generic container of objects of type T, that could have fixed or dynamic size,...">Vector</a> itself.  <br /></td></tr>
<tr class="separator:ga7afddefac9fc869e5cb82367856f19e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>List Export Mesh to Matrix algorithms. </p>
<p>They allow to export mesh data to matrices.</p>
<p>You can access these algorithms by including <code>#include &lt;<a class="el" href="import__export_8h_source.html">vclib/algorithms/mesh/import_export.h</a>&gt;</code> </p>
<h2 class="groupheader">Function Documentation</h2>
<a id="gab109a95781aefe3adf66cfba17163673" name="gab109a95781aefe3adf66cfba17163673"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab109a95781aefe3adf66cfba17163673">&#9670;&#160;</a></span>edgeIndicesMatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MatrixConcept Matrix, EdgeMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">Matrix</a> vcl::edgeIndicesMatrix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">const</a> MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a #F*max(size(F)) <a class="el" href="classvcl_1_1Matrix.html">Matrix</a> of integers containing the vertex indices for each face of a <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>. </p>
<p>If the mesh is polygonal, the matrix will have a number of rows equal to the greatest polygon of the mesh, and unused values will be set to -1.</p>
<p>This function works with every <a class="el" href="classvcl_1_1Matrix.html">Matrix</a> type that satisfies the MatrixConcept.</p>
<p>Usage example with Eigen <a class="el" href="classvcl_1_1Matrix.html">Matrix</a>:</p>
<div class="fragment"><div class="line">   Eigen::MatrixXi F = <a class="code hl_class" href="classvcl_1_1Box.html">vcl::faceMatrix&lt;Eigen::MatrixXi&gt;</a>(<a class="code hl_class" href="classvcl_1_1Box.html">myMesh</a>);</div>
<div class="line">   <span class="keyword">@end</span><span class="keywordflow">if</span></div>
<div class="line">  </div>
<div class="line">   <span class="keyword">@throw</span>s <a class="code hl_class" href="classvcl_1_1MissingCompactnessException.html">vcl::MissingCompactnessException</a> <span class="keywordflow">if</span> the vertex container is not</div>
<div class="line">   compact.</div>
<div class="line">  </div>
<div class="line">   @note This function does not guarantee that the rows of the matrix</div>
<div class="line">   correspond to the face indices of the mesh. This scenario is possible</div>
<div class="line">   when the mesh has deleted faces. To be sure to have a direct</div>
<div class="line">   correspondence, compact the face container before calling <span class="keyword">this</span> function.</div>
<div class="line">  </div>
<div class="line">   @tparam Matrix: type of the matrix to be returned, it must satisfy the</div>
<div class="line">   MatrixConcept.</div>
<div class="line">   @tparam MeshType: type of the input mesh, it must satisfy the</div>
<div class="line">   FaceMeshConcept.</div>
<div class="line">  </div>
<div class="line">   @param[in] mesh: input mesh</div>
<div class="line">   @<span class="keywordflow">return</span> \#F*<a class="code hl_function" href="group__math.html#ga45d99c06ee2cb1cd9434fd0e86a1a413">max</a>(size(F)) matrix of vertex indices</div>
<div class="line">  </div>
<div class="line">   @ingroup export_matrix</div>
<div class="line">  /</div>
<div class="line"><span class="keyword">template</span>&lt;MatrixConcept Matrix, FaceMeshConcept MeshType&gt;</div>
<div class="line">Matrix faceIndicesMatrix(<span class="keyword">const</span> MeshType&amp; mesh)</div>
<div class="line">{</div>
<div class="line">    requireVertexContainerCompactness(mesh);</div>
<div class="line"> </div>
<div class="line">    uint fMaxSize = largestFaceSize(mesh);</div>
<div class="line"> </div>
<div class="line">    Matrix fM(mesh.faceNumber(), fMaxSize);</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_enumeration" href="group__types.html#ga16a1bfbea022f6766d2f3ebbf69a3b52">MatrixStorageType</a> stg = MatrixStorageType::ROW_MAJOR;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Eigen matrices can be column major</span></div>
<div class="line">    <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (EigenMatrixConcept&lt;Matrix&gt;) {</div>
<div class="line">        <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (!Matrix::IsRowMajor) {</div>
<div class="line">            stg = MatrixStorageType::COLUMN_MAJOR;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_function" href="group__export__buffer.html#ga4d8d20f3cc27e22f326932cd22843fa5">faceIndicesToBuffer</a>(mesh, fM.data(), fMaxSize, stg);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> fM;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="ttc" id="aclassvcl_1_1Box_html"><div class="ttname"><a href="classvcl_1_1Box.html">vcl::Box</a></div><div class="ttdoc">A class representing a box in N-dimensional space.</div><div class="ttdef"><b>Definition</b> box.h:49</div></div>
<div class="ttc" id="aclassvcl_1_1MissingCompactnessException_html"><div class="ttname"><a href="classvcl_1_1MissingCompactnessException.html">vcl::MissingCompactnessException</a></div><div class="ttdoc">Exception thrown when the mesh is not compact.</div><div class="ttdef"><b>Definition</b> mesh.h:81</div></div>
<div class="ttc" id="agroup__export__buffer_html_ga4d8d20f3cc27e22f326932cd22843fa5"><div class="ttname"><a href="group__export__buffer.html#ga4d8d20f3cc27e22f326932cd22843fa5">vcl::faceIndicesToBuffer</a></div><div class="ttdeci">void faceIndicesToBuffer(const MeshType &amp;mesh, auto *buffer, bool getIndicesAsIfContainerCompact=true)</div><div class="ttdoc">Export into a buffer the vertex indices for each face of a Mesh. Faces can be polygons.</div><div class="ttdef"><b>Definition</b> export_buffer.h:272</div></div>
<div class="ttc" id="agroup__math_html_ga45d99c06ee2cb1cd9434fd0e86a1a413"><div class="ttname"><a href="group__math.html#ga45d99c06ee2cb1cd9434fd0e86a1a413">vcl::max</a></div><div class="ttdeci">constexpr auto max(const T &amp;p1, const T &amp;p2)</div><div class="ttdoc">Returns the maximum between the two parameters.</div><div class="ttdef"><b>Definition</b> min_max.h:83</div></div>
<div class="ttc" id="agroup__types_html_ga16a1bfbea022f6766d2f3ebbf69a3b52"><div class="ttname"><a href="group__types.html#ga16a1bfbea022f6766d2f3ebbf69a3b52">vcl::MatrixStorageType</a></div><div class="ttdeci">MatrixStorageType</div><div class="ttdoc">A simple type that enumerates the main storage types for matrices (row or column major).</div><div class="ttdef"><b>Definition</b> base.h:76</div></div>
</div><!-- fragment --><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classvcl_1_1MissingCompactnessException.html" title="Exception thrown when the mesh is not compact.">vcl::MissingCompactnessException</a></td><td>if the vertex container is not compact.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function does not guarantee that the rows of the matrix correspond to the edge indices of the mesh. This scenario is possible when the mesh has deleted edges. To be sure to have a direct correspondence, compact the edge container before calling this function.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="el" href="classvcl_1_1Matrix.html">Matrix</a></td><td>type of the matrix to be returned, it must satisfy the MatrixConcept. </td></tr>
    <tr><td class="paramname">MeshType</td><td>type of the input mesh, it must satisfy the EdgeMeshConcept.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>input mesh </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>#E*2 matrix of integers (edge indices) </dd></dl>

</div>
</div>
<a id="gadd776c0c02e7ef2d7657fce701c437e7" name="gadd776c0c02e7ef2d7657fce701c437e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadd776c0c02e7ef2d7657fce701c437e7">&#9670;&#160;</a></span>elementColorsMatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;uint ELEM_ID, MatrixConcept Matrix, MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">Matrix</a> vcl::elementColorsMatrix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">const</a> MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a #E*4 <a class="el" href="classvcl_1_1Matrix.html">Matrix</a> of integers containing the colors of the elements identified by <code>ELEM_ID</code> of a <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>. The function is templated on the <a class="el" href="classvcl_1_1Matrix.html">Matrix</a> itself. </p>
<p>This function works with every <a class="el" href="classvcl_1_1Matrix.html">Matrix</a> type that satisfies the MatrixConcept, and requires that the mesh has per-element colors.</p>
<p>Usage example with Eigen <a class="el" href="classvcl_1_1Matrix.html">Matrix</a>:</p>
<div class="fragment"><div class="line">Eigen::MatrixX4i <a class="code hl_class" href="classvcl_1_1Box.html">EC</a> =</div>
<div class="line">    <a class="code hl_class" href="classvcl_1_1Box.html">vcl::elementColorsMatrix&lt;ElemId::VERTEX, Eigen::MatrixX4i&gt;</a>(<a class="code hl_class" href="classvcl_1_1Box.html">myMesh</a>);</div>
</div><!-- fragment --><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classvcl_1_1MissingComponentException.html" title="Exception thrown when a mesh/element component is missing (not enabled).">vcl::MissingComponentException</a></td><td>if the mesh does not have per-element colors available.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function does not guarantee that the rows of the matrix correspond to the element indices of the mesh. This scenario is possible when the mesh has deleted elements. To be sure to have a direct correspondence, compact the element container before calling this function.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ELEM_ID</td><td>the ID of the element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>input mesh </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>#E*4 matrix of integers (element colors) </dd></dl>

</div>
</div>
<a id="gab107c808ed2cd7096e95a4ddbe1c4496" name="gab107c808ed2cd7096e95a4ddbe1c4496"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab107c808ed2cd7096e95a4ddbe1c4496">&#9670;&#160;</a></span>elementColorsVector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;uint ELEM_ID, <a class="el" href="classvcl_1_1Box.html">typename</a> <a class="el" href="classvcl_1_1Box.html">Vect</a> , MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Box.html">Vect</a> vcl::elementColorsVector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">const</a> MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Color.html#a51d1c2a5b8ce06d43362026194a14523">Color::Format</a>&#160;</td>
          <td class="paramname"><em>colorFormat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a #E <a class="el" href="classvcl_1_1Vector.html" title="The Vector class is a generic container of objects of type T, that could have fixed or dynamic size,...">Vector</a> of integers containing the colors of the elements identified by <code>ELEM_ID</code> of a <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>. The function is templated on the <a class="el" href="classvcl_1_1Vector.html" title="The Vector class is a generic container of objects of type T, that could have fixed or dynamic size,...">Vector</a> itself. The color is packed in a single 32 bit value using the provided format. </p>
<p>This function works with every <a class="el" href="classvcl_1_1Vector.html" title="The Vector class is a generic container of objects of type T, that could have fixed or dynamic size,...">Vector</a> type that has a constructor with a size_t argument and an operator[uint], and requires that the mesh has per-element colors.</p>
<p>Usage example with Eigen <a class="el" href="classvcl_1_1Vector.html" title="The Vector class is a generic container of objects of type T, that could have fixed or dynamic size,...">Vector</a>:</p>
<div class="fragment"><div class="line">Eigen::VectorXi <a class="code hl_class" href="classvcl_1_1Box.html">EC</a> =</div>
<div class="line">    <a class="code hl_class" href="classvcl_1_1Box.html">vcl::elementColorsVector&lt;ElemId::VERTEX, Eigen::VectorXi&gt;</a>(</div>
<div class="line">        <a class="code hl_class" href="classvcl_1_1Box.html">myMesh</a>, Color::Format::RGBA);</div>
</div><!-- fragment --><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classvcl_1_1MissingComponentException.html" title="Exception thrown when a mesh/element component is missing (not enabled).">vcl::MissingComponentException</a></td><td>if the mesh does not have per-element colors available.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function does not guarantee that the rows of the vector correspond to the element indices of the mesh. This scenario is possible when the mesh has deleted elements. To be sure to have a direct correspondence, compact the element container before calling this function.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ELEM_ID</td><td>the ID of the element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>input mesh </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>#E vector of integers (element colors) </dd></dl>

</div>
</div>
<a id="ga0aeda48720e2d34688e56a6ab79b7600" name="ga0aeda48720e2d34688e56a6ab79b7600"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0aeda48720e2d34688e56a6ab79b7600">&#9670;&#160;</a></span>elementNormalsMatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;uint ELEM_ID, MatrixConcept Matrix, MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">Matrix</a> vcl::elementNormalsMatrix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">const</a> MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a #E <a class="el" href="classvcl_1_1Vector.html" title="The Vector class is a generic container of objects of type T, that could have fixed or dynamic size,...">Vector</a> of booleans (or integers) containing the selection status of the elements identified by <code>ELEM_ID</code> of a <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>. The function is templated on the <a class="el" href="classvcl_1_1Vector.html" title="The Vector class is a generic container of objects of type T, that could have fixed or dynamic size,...">Vector</a> itself. </p>
<p>This function works with every <a class="el" href="classvcl_1_1Vector.html" title="The Vector class is a generic container of objects of type T, that could have fixed or dynamic size,...">Vector</a> type that has a constructor with a size_t argument and an operator[uint].</p>
<p>Usage example with Eigen <a class="el" href="classvcl_1_1Vector.html" title="The Vector class is a generic container of objects of type T, that could have fixed or dynamic size,...">Vector</a>:</p>
<div class="fragment"><div class="line">   Eigen::VectorXi S =</div>
<div class="line">       <a class="code hl_class" href="classvcl_1_1Box.html">vcl::elementSelectionVector&lt;ElemId::VERTEX, Eigen::VectorXi&gt;</a>(<a class="code hl_class" href="classvcl_1_1Box.html">myMesh</a>);</div>
<div class="line">   <span class="keyword">@end</span><span class="keywordflow">if</span></div>
<div class="line">  </div>
<div class="line">   @note This function does not guarantee that the rows of the vector</div>
<div class="line">   correspond to the element indices of the mesh. This scenario is possible</div>
<div class="line">   when the mesh has deleted elements. To be sure to have a direct</div>
<div class="line">   correspondence, compact the element container before calling <span class="keyword">this</span> function.</div>
<div class="line">  </div>
<div class="line">   @tparam ELEM_ID: the ID of the element.</div>
<div class="line">   @tparam Vect: type of the vector to be returned.</div>
<div class="line">   @tparam MeshType: type of the input mesh, it must satisfy the MeshConcept.</div>
<div class="line">  </div>
<div class="line">   @param[in] mesh: input mesh</div>
<div class="line">   @<span class="keywordflow">return</span> \#E vector of booleans or integers (element selection)</div>
<div class="line">  </div>
<div class="line">   @ingroup export_matrix</div>
<div class="line">  /</div>
<div class="line"><span class="keyword">template</span>&lt;u<span class="keywordtype">int</span> ELEM_ID, <span class="keyword">typename</span> Vect, MeshConcept MeshType&gt;</div>
<div class="line">Vect elementSelectionVector(<span class="keyword">const</span> MeshType&amp; mesh)</div>
<div class="line">{</div>
<div class="line">    Vect sV(mesh.template number&lt;ELEM_ID&gt;());</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_class" href="classvcl_1_1Box.html">vcl::elementSelectionToBuffer&lt;ELEM_ID&gt;</a>(mesh, sV.data());</div>
<div class="line">    <span class="keywordflow">return</span> sV;</div>
<div class="line">}</div>
<div class="line"> </div>
</div><!-- fragment --><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classvcl_1_1MissingComponentException.html" title="Exception thrown when a mesh/element component is missing (not enabled).">vcl::MissingComponentException</a></td><td>if the mesh does not have per-element normals available.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function does not guarantee that the rows of the matrix correspond to the element indices of the mesh. This scenario is possible when the mesh has deleted elements. To be sure to have a direct correspondence, compact the element container before calling this function.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ELEM_ID</td><td>the ID of the element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>input mesh </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>#E*3 matrix of scalars (element normals) </dd></dl>

</div>
</div>
<a id="ga8e07fcb626e0c670f8f92e930d0b2c46" name="ga8e07fcb626e0c670f8f92e930d0b2c46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8e07fcb626e0c670f8f92e930d0b2c46">&#9670;&#160;</a></span>elementQualityVector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;uint ELEM_ID, <a class="el" href="classvcl_1_1Box.html">typename</a> <a class="el" href="classvcl_1_1Box.html">Vect</a> , MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Box.html">Vect</a> vcl::elementQualityVector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">const</a> MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a #E <a class="el" href="classvcl_1_1Vector.html" title="The Vector class is a generic container of objects of type T, that could have fixed or dynamic size,...">Vector</a> of scalars containing the quality of the elements identified by <code>ELEM_ID</code> of a <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>. The function is templated on the <a class="el" href="classvcl_1_1Vector.html" title="The Vector class is a generic container of objects of type T, that could have fixed or dynamic size,...">Vector</a> itself. </p>
<p>This function works with every <a class="el" href="classvcl_1_1Vector.html" title="The Vector class is a generic container of objects of type T, that could have fixed or dynamic size,...">Vector</a> type that has a constructor with a size_t argument and an operator[uint], and requires that the mesh has per-element quality.</p>
<p>Usage example with Eigen <a class="el" href="classvcl_1_1Vector.html" title="The Vector class is a generic container of objects of type T, that could have fixed or dynamic size,...">Vector</a>:</p>
<div class="fragment"><div class="line">Eigen::VectorXd <a class="code hl_class" href="classvcl_1_1Box.html">EQ</a> =</div>
<div class="line">    <a class="code hl_class" href="classvcl_1_1Box.html">vcl::elementQualityVector&lt;ElemId::VERTEX, Eigen::VectorXd&gt;</a>(<a class="code hl_class" href="classvcl_1_1Box.html">myMesh</a>);</div>
</div><!-- fragment --><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classvcl_1_1MissingComponentException.html" title="Exception thrown when a mesh/element component is missing (not enabled).">vcl::MissingComponentException</a></td><td>if the mesh does not have per-element quality available.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function does not guarantee that the rows of the vector correspond to the element indices of the mesh. This scenario is possible when the mesh has deleted elements. To be sure to have a direct correspondence, compact the element container before calling this function.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ELEM_ID</td><td>the ID of the element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>input mesh </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>#E vector of scalars (element quality) </dd></dl>

</div>
</div>
<a id="ga480cf1413039e05d9065485c52076ce9" name="ga480cf1413039e05d9065485c52076ce9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga480cf1413039e05d9065485c52076ce9">&#9670;&#160;</a></span>faceColorsMatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MatrixConcept Matrix, FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">Matrix</a> vcl::faceColorsMatrix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">const</a> MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a #F*4 <a class="el" href="classvcl_1_1Matrix.html">Matrix</a> of integers containing the colors of the faces of a <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>. The function is templated on the <a class="el" href="classvcl_1_1Matrix.html">Matrix</a> itself. </p>
<p>This function works with every <a class="el" href="classvcl_1_1Matrix.html">Matrix</a> type that satisfies the MatrixConcept, and requires that the mesh has per-face colors.</p>
<p>Usage example with Eigen <a class="el" href="classvcl_1_1Matrix.html">Matrix</a>:</p>
<div class="fragment"><div class="line">Eigen::MatrixX4i <a class="code hl_class" href="classvcl_1_1Box.html">FC</a> = <a class="code hl_class" href="classvcl_1_1Box.html">vcl::faceColorsMatrix&lt;Eigen::MatrixX4i&gt;</a>(<a class="code hl_class" href="classvcl_1_1Box.html">myMesh</a>);</div>
</div><!-- fragment --><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classvcl_1_1MissingComponentException.html" title="Exception thrown when a mesh/element component is missing (not enabled).">vcl::MissingComponentException</a></td><td>if the mesh does not have per-face colors available.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function does not guarantee that the rows of the matrix correspond to the face indices of the mesh. This scenario is possible when the mesh has deleted faces. To be sure to have a direct correspondence, compact the face container before calling this function.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>input mesh </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>#F*4 matrix of integers (face colors) </dd></dl>

</div>
</div>
<a id="gaf27b75ea1f14a088de88c200552296f4" name="gaf27b75ea1f14a088de88c200552296f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf27b75ea1f14a088de88c200552296f4">&#9670;&#160;</a></span>faceColorsVector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classvcl_1_1Box.html">typename</a> <a class="el" href="classvcl_1_1Box.html">Vect</a> , MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Box.html">Vect</a> vcl::faceColorsVector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">const</a> MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Color.html#a51d1c2a5b8ce06d43362026194a14523">Color::Format</a>&#160;</td>
          <td class="paramname"><em>colorFormat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a #F <a class="el" href="classvcl_1_1Vector.html" title="The Vector class is a generic container of objects of type T, that could have fixed or dynamic size,...">Vector</a> of integers containing the colors of the faces of a <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>. The function is templated on the <a class="el" href="classvcl_1_1Vector.html" title="The Vector class is a generic container of objects of type T, that could have fixed or dynamic size,...">Vector</a> itself. The color is packed in a single 32 bit value using the provided format. </p>
<p>This function works with every <a class="el" href="classvcl_1_1Vector.html" title="The Vector class is a generic container of objects of type T, that could have fixed or dynamic size,...">Vector</a> type that has a constructor with a size_t argument and an operator[uint], and requires that the mesh has per-vertex colors.</p>
<p>Usage example with Eigen <a class="el" href="classvcl_1_1Vector.html" title="The Vector class is a generic container of objects of type T, that could have fixed or dynamic size,...">Vector</a>:</p>
<div class="fragment"><div class="line">Eigen::VectorXi <a class="code hl_class" href="classvcl_1_1Box.html">FC</a> =</div>
<div class="line">    <a class="code hl_class" href="classvcl_1_1Box.html">vcl::faceColorsVector&lt;Eigen::VectorXi&gt;</a>(</div>
<div class="line">        <a class="code hl_class" href="classvcl_1_1Box.html">myMesh</a>, Color::Format::RGBA);</div>
</div><!-- fragment --><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classvcl_1_1MissingComponentException.html" title="Exception thrown when a mesh/element component is missing (not enabled).">vcl::MissingComponentException</a></td><td>if the mesh does not have per-face colors available.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function does not guarantee that the rows of the vector correspond to the face indices of the mesh. This scenario is possible when the mesh has deleted faces. To be sure to have a direct correspondence, compact the face container before calling this function.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>input mesh </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>#F vector of integers (face colors) </dd></dl>

</div>
</div>
<a id="ga3917c0aef05622f0db7d4edf19749054" name="ga3917c0aef05622f0db7d4edf19749054"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3917c0aef05622f0db7d4edf19749054">&#9670;&#160;</a></span>faceIndicesVector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classvcl_1_1Box.html">typename</a> <a class="el" href="classvcl_1_1Box.html">Vect</a> , FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Box.html">Vect</a> vcl::faceIndicesVector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">const</a> MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a #V*3 <a class="el" href="classvcl_1_1Matrix.html">Matrix</a> of scalars containing the coordinates of the vertices of a <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>. The function is templated on the <a class="el" href="classvcl_1_1Matrix.html">Matrix</a> itself. </p>
<p>This function works with every <a class="el" href="classvcl_1_1Matrix.html">Matrix</a> type that satisfies the MatrixConcept.</p>
<p>Usage example with an Eigen <a class="el" href="classvcl_1_1Matrix.html">Matrix</a>:</p>
<div class="fragment"><div class="line">   Eigen::MatrixX3d V = <a class="code hl_class" href="classvcl_1_1Box.html">vcl::vertexCoordsMatrix&lt;Eigen::MatrixX3d&gt;</a>(<a class="code hl_class" href="classvcl_1_1Box.html">myMesh</a>);</div>
<div class="line">   <span class="keyword">@end</span><span class="keywordflow">if</span></div>
<div class="line">  </div>
<div class="line">   @note This function does not guarantee that the rows of the matrix</div>
<div class="line">   correspond to the vertex indices of the mesh. This scenario is possible</div>
<div class="line">   when the mesh has deleted vertices. To be sure to have a direct</div>
<div class="line">   correspondence, compact the vertex container before calling <span class="keyword">this</span> function.</div>
<div class="line">  </div>
<div class="line">   @tparam Matrix: type of the matrix to be returned, it must satisfy the</div>
<div class="line">   MatrixConcept.</div>
<div class="line">   @tparam MeshType: type of the input mesh, it must satisfy the MeshConcept.</div>
<div class="line">  </div>
<div class="line">   @param[in] mesh: input mesh</div>
<div class="line">   @<span class="keywordflow">return</span> \#V*3 matrix of scalars (vertex coordinates)</div>
<div class="line">  </div>
<div class="line">   @ingroup export_matrix</div>
<div class="line">  /</div>
<div class="line"><span class="keyword">template</span>&lt;MatrixConcept Matrix, MeshConcept MeshType&gt;</div>
<div class="line">Matrix vertexCoordsMatrix(<span class="keyword">const</span> MeshType&amp; mesh)</div>
<div class="line">{</div>
<div class="line">    Matrix vM(mesh.vertexNumber(), 3);</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_enumeration" href="group__types.html#ga16a1bfbea022f6766d2f3ebbf69a3b52">MatrixStorageType</a> stg = MatrixStorageType::ROW_MAJOR;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Eigen matrices can be column major</span></div>
<div class="line">    <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (EigenMatrixConcept&lt;Matrix&gt;) {</div>
<div class="line">        <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (!Matrix::IsRowMajor) {</div>
<div class="line">            stg = MatrixStorageType::COLUMN_MAJOR;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_function" href="group__export__buffer.html#gadd65e2cf3ef4cbfcac92c9f2a25607e2">vertexCoordsToBuffer</a>(mesh, vM.data(), stg);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> vM;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="ttc" id="agroup__export__buffer_html_gadd65e2cf3ef4cbfcac92c9f2a25607e2"><div class="ttname"><a href="group__export__buffer.html#gadd65e2cf3ef4cbfcac92c9f2a25607e2">vcl::vertexCoordsToBuffer</a></div><div class="ttdeci">void vertexCoordsToBuffer(const MeshType &amp;mesh, auto *buffer, MatrixStorageType storage=MatrixStorageType::ROW_MAJOR)</div><div class="ttdoc">Export the vertex coordinates of a mesh to a buffer.</div><div class="ttdef"><b>Definition</b> export_buffer.h:99</div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>input mesh </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>#(sum of face sizes) vector of vertex indices </dd></dl>

</div>
</div>
<a id="ga6bc50612a1185ec7d1add143f93eb0ec" name="ga6bc50612a1185ec7d1add143f93eb0ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6bc50612a1185ec7d1add143f93eb0ec">&#9670;&#160;</a></span>faceNormalsMatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MatrixConcept Matrix, FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">Matrix</a> vcl::faceNormalsMatrix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">const</a> MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a #F*3 <a class="el" href="classvcl_1_1Matrix.html">Matrix</a> of scalars containing the normals of the faces of a <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>. The function is templated on the <a class="el" href="classvcl_1_1Matrix.html">Matrix</a> itself. </p>
<p>This function works with every <a class="el" href="classvcl_1_1Matrix.html">Matrix</a> type that satisfies the MatrixConcept, and requires that the mesh has per-face normals.</p>
<p>Usage example with Eigen <a class="el" href="classvcl_1_1Matrix.html">Matrix</a>:</p>
<div class="fragment"><div class="line">Eigen::MatrixX3d <a class="code hl_class" href="classvcl_1_1Box.html">FN</a> = <a class="code hl_class" href="classvcl_1_1Box.html">vcl::faceNormalsMatrix&lt;Eigen::MatrixX3d&gt;</a>(<a class="code hl_class" href="classvcl_1_1Box.html">myMesh</a>);</div>
</div><!-- fragment --><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classvcl_1_1MissingComponentException.html" title="Exception thrown when a mesh/element component is missing (not enabled).">vcl::MissingComponentException</a></td><td>if the mesh does not have per-face normals available.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function does not guarantee that the rows of the matrix correspond to the face indices of the mesh. This scenario is possible when the mesh has deleted faces. To be sure to have a direct correspondence, compact the face container before calling this function.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>input mesh </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>#F*3 matrix of scalars (face normals) </dd></dl>

</div>
</div>
<a id="ga7afddefac9fc869e5cb82367856f19e9" name="ga7afddefac9fc869e5cb82367856f19e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7afddefac9fc869e5cb82367856f19e9">&#9670;&#160;</a></span>faceQualityVector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classvcl_1_1Box.html">typename</a> <a class="el" href="classvcl_1_1Box.html">Vect</a> , FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Box.html">Vect</a> vcl::faceQualityVector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">const</a> MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a #F <a class="el" href="classvcl_1_1Vector.html" title="The Vector class is a generic container of objects of type T, that could have fixed or dynamic size,...">Vector</a> of scalars containing the quality of the faces of a <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>. The function is templated on the <a class="el" href="classvcl_1_1Vector.html" title="The Vector class is a generic container of objects of type T, that could have fixed or dynamic size,...">Vector</a> itself. </p>
<p>This function works with every <a class="el" href="classvcl_1_1Vector.html" title="The Vector class is a generic container of objects of type T, that could have fixed or dynamic size,...">Vector</a> type that has a constructor with a size_t argument and an operator(uint), and requires that the mesh has per-face quality.</p>
<p>Usage example with Eigen <a class="el" href="classvcl_1_1Vector.html" title="The Vector class is a generic container of objects of type T, that could have fixed or dynamic size,...">Vector</a>:</p>
<div class="fragment"><div class="line">Eigen::VectorXd <a class="code hl_class" href="classvcl_1_1Box.html">FQ</a> = <a class="code hl_class" href="classvcl_1_1Box.html">vcl::faceQualityVector&lt;Eigen::VectorXd&gt;</a>(<a class="code hl_class" href="classvcl_1_1Box.html">myMesh</a>);</div>
</div><!-- fragment --><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classvcl_1_1MissingComponentException.html" title="Exception thrown when a mesh/element component is missing (not enabled).">vcl::MissingComponentException</a></td><td>if the mesh does not have per-face quality available.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function does not guarantee that the rows of the vector correspond to the face indices of the mesh. This scenario is possible when the mesh has deleted faces. To be sure to have a direct correspondence, compact the face container before calling this function.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>input mesh </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>#F vector of scalars (face quality) </dd></dl>

</div>
</div>
<a id="ga01810ffdfe2df3aa87e9de9c783a32a6" name="ga01810ffdfe2df3aa87e9de9c783a32a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga01810ffdfe2df3aa87e9de9c783a32a6">&#9670;&#160;</a></span>vertexColorsMatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MatrixConcept Matrix, MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">Matrix</a> vcl::vertexColorsMatrix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">const</a> MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a #V*4 <a class="el" href="classvcl_1_1Matrix.html">Matrix</a> of integers containing the colors of the vertices of a <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>. The function is templated on the <a class="el" href="classvcl_1_1Matrix.html">Matrix</a> itself. </p>
<p>This function works with every <a class="el" href="classvcl_1_1Matrix.html">Matrix</a> type that satisfies the MatrixConcept, and requires that the mesh has per-vertex colors.</p>
<p>Usage example with Eigen <a class="el" href="classvcl_1_1Matrix.html">Matrix</a>:</p>
<div class="fragment"><div class="line">Eigen::MatrixX4i <a class="code hl_class" href="classvcl_1_1Box.html">VC</a> = <a class="code hl_class" href="classvcl_1_1Box.html">vcl::vertexColorsMatrix&lt;Eigen::MatrixX4i&gt;</a>(<a class="code hl_class" href="classvcl_1_1Box.html">myMesh</a>);</div>
</div><!-- fragment --><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classvcl_1_1MissingComponentException.html" title="Exception thrown when a mesh/element component is missing (not enabled).">vcl::MissingComponentException</a></td><td>if the mesh does not have per-vertex colors available.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function does not guarantee that the rows of the matrix correspond to the vertex indices of the mesh. This scenario is possible when the mesh has deleted vertices. To be sure to have a direct correspondence, compact the vertex container before calling this function.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>input mesh </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>#V*4 matrix of integers (vertex colors) </dd></dl>

</div>
</div>
<a id="ga22784c31db9993ca111a35f4894d2b85" name="ga22784c31db9993ca111a35f4894d2b85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga22784c31db9993ca111a35f4894d2b85">&#9670;&#160;</a></span>vertexColorsVector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classvcl_1_1Box.html">typename</a> <a class="el" href="classvcl_1_1Box.html">Vect</a> , MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Box.html">Vect</a> vcl::vertexColorsVector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">const</a> MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Color.html#a51d1c2a5b8ce06d43362026194a14523">Color::Format</a>&#160;</td>
          <td class="paramname"><em>colorFormat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a #V <a class="el" href="classvcl_1_1Vector.html" title="The Vector class is a generic container of objects of type T, that could have fixed or dynamic size,...">Vector</a> of integers containing the colors of the vertices of a <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>. The function is templated on the <a class="el" href="classvcl_1_1Vector.html" title="The Vector class is a generic container of objects of type T, that could have fixed or dynamic size,...">Vector</a> itself. The color is packed in a single 32 bit value using the provided format. </p>
<p>This function works with every <a class="el" href="classvcl_1_1Vector.html" title="The Vector class is a generic container of objects of type T, that could have fixed or dynamic size,...">Vector</a> type that has a constructor with a size_t argument and an operator[uint], and requires that the mesh has per-vertex colors.</p>
<p>Usage example with Eigen <a class="el" href="classvcl_1_1Vector.html" title="The Vector class is a generic container of objects of type T, that could have fixed or dynamic size,...">Vector</a>:</p>
<div class="fragment"><div class="line">Eigen::VectorXi <a class="code hl_class" href="classvcl_1_1Box.html">VC</a> =</div>
<div class="line">    <a class="code hl_class" href="classvcl_1_1Box.html">vcl::vertexColorsVector&lt;Eigen::VectorXi&gt;</a>(</div>
<div class="line">        <a class="code hl_class" href="classvcl_1_1Box.html">myMesh</a>, Color::Format::RGBA);</div>
</div><!-- fragment --><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classvcl_1_1MissingComponentException.html" title="Exception thrown when a mesh/element component is missing (not enabled).">vcl::MissingComponentException</a></td><td>if the mesh does not have per-vertex colors available.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function does not guarantee that the rows of the vector correspond to the vertex indices of the mesh. This scenario is possible when the mesh has deleted vertices. To be sure to have a direct correspondence, compact the vertex container before calling this function.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>input mesh </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>#V vector of integers (vertex colors) </dd></dl>

</div>
</div>
<a id="gaed0e167ce00c4dd8cf2b6400ceb24da3" name="gaed0e167ce00c4dd8cf2b6400ceb24da3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaed0e167ce00c4dd8cf2b6400ceb24da3">&#9670;&#160;</a></span>vertexNormalsMatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MatrixConcept Matrix, MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Matrix.html">Matrix</a> vcl::vertexNormalsMatrix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">const</a> MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a #V*3 <a class="el" href="classvcl_1_1Matrix.html">Matrix</a> of scalars containing the normals of the vertices of a <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>. The function is templated on the <a class="el" href="classvcl_1_1Matrix.html">Matrix</a> itself. </p>
<p>This function works with every <a class="el" href="classvcl_1_1Matrix.html">Matrix</a> type that satisfies the MatrixConcept, and requires that the mesh has per-vertex normals.</p>
<p>Usage example with Eigen <a class="el" href="classvcl_1_1Matrix.html">Matrix</a>:</p>
<div class="fragment"><div class="line">Eigen::MatrixX3d <a class="code hl_class" href="classvcl_1_1Box.html">VN</a> = <a class="code hl_class" href="classvcl_1_1Box.html">vcl::vertexNormalsMatrix&lt;Eigen::MatrixX3d&gt;</a>(<a class="code hl_class" href="classvcl_1_1Box.html">myMesh</a>);</div>
</div><!-- fragment --><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classvcl_1_1MissingComponentException.html" title="Exception thrown when a mesh/element component is missing (not enabled).">vcl::MissingComponentException</a></td><td>if the mesh does not have per-vertex normals available.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function does not guarantee that the rows of the matrix correspond to the vertex indices of the mesh. This scenario is possible when the mesh has deleted vertices. To be sure to have a direct correspondence, compact the vertex container before calling this function.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>input mesh </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>#V*3 matrix of scalars (vertex normals) </dd></dl>

</div>
</div>
<a id="ga04201da836f3c6bc6eb9444319f7b492" name="ga04201da836f3c6bc6eb9444319f7b492"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga04201da836f3c6bc6eb9444319f7b492">&#9670;&#160;</a></span>vertexQualityVector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classvcl_1_1Box.html">typename</a> <a class="el" href="classvcl_1_1Box.html">Vect</a> , MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Box.html">Vect</a> vcl::vertexQualityVector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">const</a> MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a #V <a class="el" href="classvcl_1_1Vector.html" title="The Vector class is a generic container of objects of type T, that could have fixed or dynamic size,...">Vector</a> of scalars containing the quality of the vertices of a <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>. The function is templated on the <a class="el" href="classvcl_1_1Vector.html" title="The Vector class is a generic container of objects of type T, that could have fixed or dynamic size,...">Vector</a> itself. </p>
<p>This function works with every <a class="el" href="classvcl_1_1Vector.html" title="The Vector class is a generic container of objects of type T, that could have fixed or dynamic size,...">Vector</a> type that has a constructor with a size_t argument and an operator(uint), and requires that the mesh has per-vertex quality.</p>
<p>Usage example with Eigen <a class="el" href="classvcl_1_1Vector.html" title="The Vector class is a generic container of objects of type T, that could have fixed or dynamic size,...">Vector</a>:</p>
<div class="fragment"><div class="line">Eigen::VectorXd <a class="code hl_class" href="classvcl_1_1Box.html">VQ</a> = <a class="code hl_class" href="classvcl_1_1Box.html">vcl::vertexQualityVector&lt;Eigen::VectorXd&gt;</a>(<a class="code hl_class" href="classvcl_1_1Box.html">myMesh</a>);</div>
</div><!-- fragment --><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classvcl_1_1MissingComponentException.html" title="Exception thrown when a mesh/element component is missing (not enabled).">vcl::MissingComponentException</a></td><td>if the mesh does not have per-vertex quality available.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function does not guarantee that the rows of the vector correspond to the vertex indices of the mesh. This scenario is possible when the mesh has deleted vertices. To be sure to have a direct correspondence, compact the vertex container before calling this function.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>input mesh </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>#V vector of scalars (vertex quality) </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
