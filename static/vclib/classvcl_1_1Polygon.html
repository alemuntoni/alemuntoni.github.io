<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Visual Computing Library: vcl::Polygon&lt; PointT &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
       <script type="text/javascript">
           DoxygenAwesomeDarkModeToggle.init()
       </script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Visual Computing Library
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classvcl_1_1Polygon.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="classvcl_1_1Polygon-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">vcl::Polygon&lt; PointT &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="space_2polygon_8h_source.html">vclib/space/polygon.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a0d1d6548476986381b6a233b7f024680"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1Polygon.html#a0d1d6548476986381b6a233b7f024680">ScalarType</a> = typename PointT::ScalarType</td></tr>
<tr class="separator:a0d1d6548476986381b6a233b7f024680"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a848028ffd06ddd245c1b83e07909e490"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1Polygon.html#a848028ffd06ddd245c1b83e07909e490">PointType</a> = PointT</td></tr>
<tr class="separator:a848028ffd06ddd245c1b83e07909e490"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:acf3da0614d075542e6f8f19f8e0ae6de"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1Polygon.html#acf3da0614d075542e6f8f19f8e0ae6de">Polygon</a> ()</td></tr>
<tr class="separator:acf3da0614d075542e6f8f19f8e0ae6de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13c475e2e5dd71cd2b78cac8c374f8ef"><td class="memTemplParams" colspan="2">template&lt;typename Iterator &gt; <br />
requires (std::is_same_v&lt;typename Iterator::value_type, PointT&gt;)</td></tr>
<tr class="memitem:a13c475e2e5dd71cd2b78cac8c374f8ef"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvcl_1_1Polygon.html#a13c475e2e5dd71cd2b78cac8c374f8ef">Polygon</a> (Iterator begin, Iterator end)</td></tr>
<tr class="separator:a13c475e2e5dd71cd2b78cac8c374f8ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a050d2409a41e0dbfbfaa9601a6ddda3d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1Polygon.html#a050d2409a41e0dbfbfaa9601a6ddda3d">size</a> () const</td></tr>
<tr class="separator:a050d2409a41e0dbfbfaa9601a6ddda3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a937aa2df891580a9021bf93693943c13"><td class="memItemLeft" align="right" valign="top">PointT &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1Polygon.html#a937aa2df891580a9021bf93693943c13">point</a> (<a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> i)</td></tr>
<tr class="separator:a937aa2df891580a9021bf93693943c13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa67cb95b60bc9c12173071f4304bdcbe"><td class="memItemLeft" align="right" valign="top">const PointT &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1Polygon.html#aa67cb95b60bc9c12173071f4304bdcbe">point</a> (<a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> i) const</td></tr>
<tr class="separator:aa67cb95b60bc9c12173071f4304bdcbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c2dc2c01a2da8041bba9a6d08a76461"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Polygon.html#a0d1d6548476986381b6a233b7f024680">ScalarType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1Polygon.html#a6c2dc2c01a2da8041bba9a6d08a76461">sideLength</a> (<a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> i) const</td></tr>
<tr class="separator:a6c2dc2c01a2da8041bba9a6d08a76461"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1682137a9e9d27da0544591a46e50fd8"><td class="memItemLeft" align="right" valign="top">PointT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1Polygon.html#a1682137a9e9d27da0544591a46e50fd8">normal</a> () const</td></tr>
<tr class="separator:a1682137a9e9d27da0544591a46e50fd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78df2129a24b0d596ba49d4ec6b1d307"><td class="memItemLeft" align="right" valign="top">PointT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1Polygon.html#a78df2129a24b0d596ba49d4ec6b1d307">barycenter</a> () const</td></tr>
<tr class="separator:a78df2129a24b0d596ba49d4ec6b1d307"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83655fe0d73b63024108d3e2086e4b99"><td class="memTemplParams" colspan="2">template&lt;typename WIterator &gt; </td></tr>
<tr class="memitem:a83655fe0d73b63024108d3e2086e4b99"><td class="memTemplItemLeft" align="right" valign="top">PointT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvcl_1_1Polygon.html#a83655fe0d73b63024108d3e2086e4b99">weightedBarycenter</a> (WIterator wbegin) const</td></tr>
<tr class="separator:a83655fe0d73b63024108d3e2086e4b99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7715a8aa84bdbc8c0f2dc11d4c2e2f9f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Polygon.html#a0d1d6548476986381b6a233b7f024680">ScalarType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1Polygon.html#a7715a8aa84bdbc8c0f2dc11d4c2e2f9f">perimeter</a> () const</td></tr>
<tr class="separator:a7715a8aa84bdbc8c0f2dc11d4c2e2f9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c8dc76fbba3e08759c64076d31d50ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Polygon.html#a0d1d6548476986381b6a233b7f024680">ScalarType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1Polygon.html#a4c8dc76fbba3e08759c64076d31d50ed">area</a> () const</td></tr>
<tr class="separator:a4c8dc76fbba3e08759c64076d31d50ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add1c3a25f128a5ef6d5a4d0ac8cbee7a"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1Polygon.html#add1c3a25f128a5ef6d5a4d0ac8cbee7a">earCut</a> () const</td></tr>
<tr class="separator:add1c3a25f128a5ef6d5a4d0ac8cbee7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00d68614a016883d67ebbc5101739276"><td class="memTemplParams" colspan="2">template&lt;typename Iterator &gt; <br />
requires (std::is_same_v&lt;typename Iterator::value_type, PointT&gt;)</td></tr>
<tr class="memitem:a00d68614a016883d67ebbc5101739276"><td class="memTemplItemLeft" align="right" valign="top">PointT::ScalarType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvcl_1_1Polygon.html#a00d68614a016883d67ebbc5101739276">perimeter</a> (Iterator begin, Iterator end)</td></tr>
<tr class="memdesc:a00d68614a016883d67ebbc5101739276"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the perimeter of a polygon defined by a range of points.  <br /></td></tr>
<tr class="separator:a00d68614a016883d67ebbc5101739276"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9694ad75ff51633c3cb79a5bc3d2d0b8"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="conceptvcl_1_1Range.html">vcl::Range</a> R&gt; </td></tr>
<tr class="memitem:a9694ad75ff51633c3cb79a5bc3d2d0b8"><td class="memTemplItemLeft" align="right" valign="top">PointT::ScalarType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvcl_1_1Polygon.html#a9694ad75ff51633c3cb79a5bc3d2d0b8">perimeter</a> (R &amp;&amp;range)</td></tr>
<tr class="separator:a9694ad75ff51633c3cb79a5bc3d2d0b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0244932c07dd3686a1f2d2a84caee5f7"><td class="memTemplParams" colspan="2">template&lt;typename Iterator &gt; <br />
requires (std::is_same_v&lt;typename Iterator::value_type, PointT&gt;)</td></tr>
<tr class="memitem:a0244932c07dd3686a1f2d2a84caee5f7"><td class="memTemplItemLeft" align="right" valign="top">PointT::ScalarType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvcl_1_1Polygon.html#a0244932c07dd3686a1f2d2a84caee5f7">area</a> (Iterator begin, Iterator end)</td></tr>
<tr class="memdesc:a0244932c07dd3686a1f2d2a84caee5f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the area of a polygon. This function works also with simple triangles, but it is less efficient thant the function "Triangle&lt;PointT&gt;::area()".  <br /></td></tr>
<tr class="separator:a0244932c07dd3686a1f2d2a84caee5f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85fd4b139f5220e79d368280a3a17192"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="conceptvcl_1_1Range.html">vcl::Range</a> R&gt; </td></tr>
<tr class="memitem:a85fd4b139f5220e79d368280a3a17192"><td class="memTemplItemLeft" align="right" valign="top">PointT::ScalarType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvcl_1_1Polygon.html#a85fd4b139f5220e79d368280a3a17192">area</a> (R &amp;&amp;range)</td></tr>
<tr class="separator:a85fd4b139f5220e79d368280a3a17192"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:aa744fe07266e55937d149a2df8171a60"><td class="memTemplParams" colspan="2">template&lt;typename Iterator &gt; <br />
requires (std::is_same_v&lt;typename Iterator::value_type, PointT&gt; &amp;&amp; PointT::DIM == 3)</td></tr>
<tr class="memitem:aa744fe07266e55937d149a2df8171a60"><td class="memTemplItemLeft" align="right" valign="top">static PointT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvcl_1_1Polygon.html#aa744fe07266e55937d149a2df8171a60">normal</a> (Iterator begin, Iterator end)</td></tr>
<tr class="memdesc:aa744fe07266e55937d149a2df8171a60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the normal of a container of 3D points iterated between the iterators begin and end, listed in counterclockwise order, representing a polygon.  <br /></td></tr>
<tr class="separator:aa744fe07266e55937d149a2df8171a60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6ab9cd4b0d48cd3c536703bc70500a7"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="conceptvcl_1_1Range.html">vcl::Range</a> R&gt; </td></tr>
<tr class="memitem:af6ab9cd4b0d48cd3c536703bc70500a7"><td class="memTemplItemLeft" align="right" valign="top">static PointT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvcl_1_1Polygon.html#af6ab9cd4b0d48cd3c536703bc70500a7">normal</a> (R &amp;&amp;range)</td></tr>
<tr class="separator:af6ab9cd4b0d48cd3c536703bc70500a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6de7c9923f70ce1700c8f3e5475376b"><td class="memTemplParams" colspan="2">template&lt;typename Iterator &gt; <br />
requires (std::is_same_v&lt;typename Iterator::value_type, PointT&gt;)</td></tr>
<tr class="memitem:ad6de7c9923f70ce1700c8f3e5475376b"><td class="memTemplItemLeft" align="right" valign="top">static PointT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvcl_1_1Polygon.html#ad6de7c9923f70ce1700c8f3e5475376b">barycenter</a> (Iterator begin, Iterator end)</td></tr>
<tr class="memdesc:ad6de7c9923f70ce1700c8f3e5475376b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the barycenter of a container of points iterated between the iterators begin and end, listed in counterclockwise order, representing a polygon.  <br /></td></tr>
<tr class="separator:ad6de7c9923f70ce1700c8f3e5475376b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9a7b0a4ade094d933a949b8bec786ca"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="conceptvcl_1_1Range.html">vcl::Range</a> R&gt; </td></tr>
<tr class="memitem:ae9a7b0a4ade094d933a949b8bec786ca"><td class="memTemplItemLeft" align="right" valign="top">static PointT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvcl_1_1Polygon.html#ae9a7b0a4ade094d933a949b8bec786ca">barycenter</a> (R &amp;&amp;range)</td></tr>
<tr class="separator:ae9a7b0a4ade094d933a949b8bec786ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7337dc78515f839e42e12a8d8fa606d"><td class="memTemplParams" colspan="2">template&lt;typename Iterator , typename WIterator &gt; <br />
requires (std::is_same_v&lt;typename Iterator::value_type, PointT&gt;)</td></tr>
<tr class="memitem:ac7337dc78515f839e42e12a8d8fa606d"><td class="memTemplItemLeft" align="right" valign="top">static PointT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvcl_1_1Polygon.html#ac7337dc78515f839e42e12a8d8fa606d">weightedBarycenter</a> (Iterator begin, Iterator end, WIterator wbegin)</td></tr>
<tr class="memdesc:ac7337dc78515f839e42e12a8d8fa606d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the weighted barycenter of a container of 3D points iterated between the iterators begin and end, listed in counterclockwise order, representing a polygon. Weights are iterated by another iterator wbegin, which iterates to a container of the same size of the polygon container.  <br /></td></tr>
<tr class="separator:ac7337dc78515f839e42e12a8d8fa606d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b6b0eee15b9ac6e80fda7846ff5e82e"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="conceptvcl_1_1Range.html">vcl::Range</a> Rp, <a class="el" href="conceptvcl_1_1Range.html">vcl::Range</a> Rw&gt; </td></tr>
<tr class="memitem:a5b6b0eee15b9ac6e80fda7846ff5e82e"><td class="memTemplItemLeft" align="right" valign="top">static PointT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvcl_1_1Polygon.html#a5b6b0eee15b9ac6e80fda7846ff5e82e">weightedBarycenter</a> (Rp &amp;&amp;rPolygon, Rw &amp;&amp;rWeights)</td></tr>
<tr class="separator:a5b6b0eee15b9ac6e80fda7846ff5e82e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd33f3286b47237e1ca42da5eb07daa9"><td class="memTemplParams" colspan="2">template&lt;typename Iterator &gt; <br />
requires (std::is_same_v&lt;typename Iterator::value_type, PointT&gt;)</td></tr>
<tr class="memitem:abd33f3286b47237e1ca42da5eb07daa9"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classvcl_1_1Polygon.html#a0d1d6548476986381b6a233b7f024680">ScalarType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvcl_1_1Polygon.html#abd33f3286b47237e1ca42da5eb07daa9">perimeter</a> (Iterator begin, Iterator end)</td></tr>
<tr class="separator:abd33f3286b47237e1ca42da5eb07daa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11dbf16c9623beba55324bc4fa980674"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="conceptvcl_1_1Range.html">vcl::Range</a> R&gt; </td></tr>
<tr class="memitem:a11dbf16c9623beba55324bc4fa980674"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classvcl_1_1Polygon.html#a0d1d6548476986381b6a233b7f024680">ScalarType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvcl_1_1Polygon.html#a11dbf16c9623beba55324bc4fa980674">perimeter</a> (R &amp;&amp;range)</td></tr>
<tr class="separator:a11dbf16c9623beba55324bc4fa980674"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3839929a3d13beb958707cea2590eb2e"><td class="memTemplParams" colspan="2">template&lt;typename Iterator &gt; <br />
requires (std::is_same_v&lt;typename Iterator::value_type, PointT&gt;)</td></tr>
<tr class="memitem:a3839929a3d13beb958707cea2590eb2e"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classvcl_1_1Polygon.html#a0d1d6548476986381b6a233b7f024680">ScalarType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvcl_1_1Polygon.html#a3839929a3d13beb958707cea2590eb2e">area</a> (Iterator begin, Iterator end)</td></tr>
<tr class="separator:a3839929a3d13beb958707cea2590eb2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad57560e117e6c027169dee1967691b5c"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="conceptvcl_1_1Range.html">vcl::Range</a> R&gt; </td></tr>
<tr class="memitem:ad57560e117e6c027169dee1967691b5c"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classvcl_1_1Polygon.html#a0d1d6548476986381b6a233b7f024680">ScalarType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvcl_1_1Polygon.html#ad57560e117e6c027169dee1967691b5c">area</a> (R &amp;&amp;range)</td></tr>
<tr class="separator:ad57560e117e6c027169dee1967691b5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bfbb8e486c1c93f932b59fe32f44313"><td class="memTemplParams" colspan="2">template&lt;typename Iterator &gt; <br />
requires (std::is_same_v&lt;typename Iterator::value_type, PointT&gt; &amp;&amp; PointT::DIM == 2)</td></tr>
<tr class="memitem:a2bfbb8e486c1c93f932b59fe32f44313"><td class="memTemplItemLeft" align="right" valign="top">static std::vector&lt; <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvcl_1_1Polygon.html#a2bfbb8e486c1c93f932b59fe32f44313">earCut</a> (Iterator begin, Iterator end)</td></tr>
<tr class="memdesc:a2bfbb8e486c1c93f932b59fe32f44313"><td class="mdescLeft">&#160;</td><td class="mdescRight">Triangulates a simple polygon with no holes using the ear-cutting algorithm.  <br /></td></tr>
<tr class="separator:a2bfbb8e486c1c93f932b59fe32f44313"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a676f2c0c3f084e3d915ed44725af3ad9"><td class="memTemplParams" colspan="2">template&lt;typename Iterator &gt; <br />
requires (std::is_same_v&lt;typename Iterator::value_type, PointT&gt; &amp;&amp; PointT::DIM == 3)</td></tr>
<tr class="memitem:a676f2c0c3f084e3d915ed44725af3ad9"><td class="memTemplItemLeft" align="right" valign="top">static std::vector&lt; <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvcl_1_1Polygon.html#a676f2c0c3f084e3d915ed44725af3ad9">earCut</a> (Iterator begin, Iterator end)</td></tr>
<tr class="separator:a676f2c0c3f084e3d915ed44725af3ad9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9b8be77a5cdd8cdafd8c712c185b0ec"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="conceptvcl_1_1Range.html">vcl::Range</a> R&gt; </td></tr>
<tr class="memitem:ae9b8be77a5cdd8cdafd8c712c185b0ec"><td class="memTemplItemLeft" align="right" valign="top">static std::vector&lt; <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvcl_1_1Polygon.html#ae9b8be77a5cdd8cdafd8c712c185b0ec">earCut</a> (R &amp;&amp;range)</td></tr>
<tr class="separator:ae9b8be77a5cdd8cdafd8c712c185b0ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:add10001ada05a465daf633b6aba52f9f"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1Polygon.html#add10001ada05a465daf633b6aba52f9f">DIM</a> = PointT::DIM</td></tr>
<tr class="separator:add10001ada05a465daf633b6aba52f9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a848028ffd06ddd245c1b83e07909e490" name="a848028ffd06ddd245c1b83e07909e490"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a848028ffd06ddd245c1b83e07909e490">&#9670;&#160;</a></span>PointType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;PointConcept PointT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classvcl_1_1Polygon.html">vcl::Polygon</a>&lt; PointT &gt;::PointType =  PointT</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0d1d6548476986381b6a233b7f024680" name="a0d1d6548476986381b6a233b7f024680"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d1d6548476986381b6a233b7f024680">&#9670;&#160;</a></span>ScalarType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;PointConcept PointT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classvcl_1_1Polygon.html">vcl::Polygon</a>&lt; PointT &gt;::ScalarType =  typename PointT::ScalarType</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="acf3da0614d075542e6f8f19f8e0ae6de" name="acf3da0614d075542e6f8f19f8e0ae6de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf3da0614d075542e6f8f19f8e0ae6de">&#9670;&#160;</a></span>Polygon() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;PointConcept PointT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Polygon.html">vcl::Polygon</a>&lt; PointT &gt;::Polygon</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a13c475e2e5dd71cd2b78cac8c374f8ef" name="a13c475e2e5dd71cd2b78cac8c374f8ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13c475e2e5dd71cd2b78cac8c374f8ef">&#9670;&#160;</a></span>Polygon() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;PointConcept PointT&gt; <br />
requires (std::is_same_v&lt;typename Iterator::value_type, PointT&gt;)</div>
<div class="memtemplate">
template&lt;typename Iterator &gt; <br />
requires (std::is_same_v&lt;typename Iterator::value_type, PointT&gt;)</div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Polygon.html">vcl::Polygon</a>&lt; PointT &gt;::Polygon </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a4c8dc76fbba3e08759c64076d31d50ed" name="a4c8dc76fbba3e08759c64076d31d50ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c8dc76fbba3e08759c64076d31d50ed">&#9670;&#160;</a></span>area() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;PointConcept PointT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Polygon.html">Polygon</a>&lt; PointT &gt;<a class="el" href="classvcl_1_1Polygon.html#a0d1d6548476986381b6a233b7f024680">::ScalarType</a> <a class="el" href="classvcl_1_1Polygon.html">vcl::Polygon</a>&lt; PointT &gt;::area</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0244932c07dd3686a1f2d2a84caee5f7" name="a0244932c07dd3686a1f2d2a84caee5f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0244932c07dd3686a1f2d2a84caee5f7">&#9670;&#160;</a></span>area() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;PointConcept PointT&gt; </div>
<div class="memtemplate">
template&lt;typename Iterator &gt; <br />
requires (std::is_same_v&lt;typename Iterator::value_type, PointT&gt;)</div>
      <table class="memname">
        <tr>
          <td class="memname">PointT::ScalarType <a class="el" href="classvcl_1_1Polygon.html">vcl::Polygon</a>&lt; PointT &gt;::area </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the area of a polygon. This function works also with simple triangles, but it is less efficient thant the function "Triangle&lt;PointT&gt;::area()". </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Iterator</td><td>an iterator which points to a type that satiesfies the PointConcept.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">begin</td><td>an iterator pointing to the first point in the polygon </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">end</td><td>an iterator pointing past the last point in the polygon </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the area of the polygon</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The points in the polygon must have a scalar type, and must satisfy the PointConcept concept. </dd>
<dd>
The polygon must be simple, i.e., it cannot intersect itself. </dd></dl>

</div>
</div>
<a id="a3839929a3d13beb958707cea2590eb2e" name="a3839929a3d13beb958707cea2590eb2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3839929a3d13beb958707cea2590eb2e">&#9670;&#160;</a></span>area() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;PointConcept PointT&gt; </div>
<div class="memtemplate">
template&lt;typename Iterator &gt; <br />
requires (std::is_same_v&lt;typename Iterator::value_type, PointT&gt;)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classvcl_1_1Polygon.html#a0d1d6548476986381b6a233b7f024680">ScalarType</a> <a class="el" href="classvcl_1_1Polygon.html">vcl::Polygon</a>&lt; PointT &gt;::area </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a85fd4b139f5220e79d368280a3a17192" name="a85fd4b139f5220e79d368280a3a17192"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85fd4b139f5220e79d368280a3a17192">&#9670;&#160;</a></span>area() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;PointConcept PointT&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="conceptvcl_1_1Range.html">vcl::Range</a> R&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">PointT::ScalarType <a class="el" href="classvcl_1_1Polygon.html">vcl::Polygon</a>&lt; PointT &gt;::area </td>
          <td>(</td>
          <td class="paramtype">R &amp;&amp;&#160;</td>
          <td class="paramname"><em>range</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad57560e117e6c027169dee1967691b5c" name="ad57560e117e6c027169dee1967691b5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad57560e117e6c027169dee1967691b5c">&#9670;&#160;</a></span>area() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;PointConcept PointT&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="conceptvcl_1_1Range.html">vcl::Range</a> R&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classvcl_1_1Polygon.html#a0d1d6548476986381b6a233b7f024680">ScalarType</a> <a class="el" href="classvcl_1_1Polygon.html">vcl::Polygon</a>&lt; PointT &gt;::area </td>
          <td>(</td>
          <td class="paramtype">R &amp;&amp;&#160;</td>
          <td class="paramname"><em>range</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a78df2129a24b0d596ba49d4ec6b1d307" name="a78df2129a24b0d596ba49d4ec6b1d307"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78df2129a24b0d596ba49d4ec6b1d307">&#9670;&#160;</a></span>barycenter() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;PointConcept PointT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">PointT <a class="el" href="classvcl_1_1Polygon.html">vcl::Polygon</a>&lt; PointT &gt;::barycenter</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad6de7c9923f70ce1700c8f3e5475376b" name="ad6de7c9923f70ce1700c8f3e5475376b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6de7c9923f70ce1700c8f3e5475376b">&#9670;&#160;</a></span>barycenter() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;PointConcept PointT&gt; <br />
requires (std::is_same_v&lt;typename Iterator::value_type, PointT&gt;)</div>
<div class="memtemplate">
template&lt;typename Iterator &gt; <br />
requires (std::is_same_v&lt;typename Iterator::value_type, PointT&gt;)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PointT <a class="el" href="classvcl_1_1Polygon.html">vcl::Polygon</a>&lt; PointT &gt;::barycenter </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the barycenter of a container of points iterated between the iterators begin and end, listed in counterclockwise order, representing a polygon. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Iterator</td><td>an iterator which points to a type that satiesfies the PointConcept.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">begin</td><td>iterator pointing to the first point of the polygon. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">end</td><td>end iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The barycenter of the polygon. </dd></dl>

</div>
</div>
<a id="ae9a7b0a4ade094d933a949b8bec786ca" name="ae9a7b0a4ade094d933a949b8bec786ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9a7b0a4ade094d933a949b8bec786ca">&#9670;&#160;</a></span>barycenter() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;PointConcept PointT&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="conceptvcl_1_1Range.html">vcl::Range</a> R&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PointT <a class="el" href="classvcl_1_1Polygon.html">vcl::Polygon</a>&lt; PointT &gt;::barycenter </td>
          <td>(</td>
          <td class="paramtype">R &amp;&amp;&#160;</td>
          <td class="paramname"><em>range</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="add1c3a25f128a5ef6d5a4d0ac8cbee7a" name="add1c3a25f128a5ef6d5a4d0ac8cbee7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add1c3a25f128a5ef6d5a4d0ac8cbee7a">&#9670;&#160;</a></span>earCut() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;PointConcept PointT&gt; <br />
requires (PointT::DIM == 2 || PointT::DIM == 3)</div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> &gt; <a class="el" href="classvcl_1_1Polygon.html">vcl::Polygon</a>&lt; PointT &gt;::earCut</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2bfbb8e486c1c93f932b59fe32f44313" name="a2bfbb8e486c1c93f932b59fe32f44313"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bfbb8e486c1c93f932b59fe32f44313">&#9670;&#160;</a></span>earCut() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;PointConcept PointT&gt; <br />
requires (std::is_same_v&lt;typename Iterator::value_type, PointT&gt; &amp;&amp; PointT::DIM == 2)</div>
<div class="memtemplate">
template&lt;typename Iterator &gt; <br />
requires (std::is_same_v&lt;typename Iterator::value_type, PointT&gt; &amp;&amp; PointT::DIM == 2)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> &gt; <a class="el" href="classvcl_1_1Polygon.html">vcl::Polygon</a>&lt; PointT &gt;::earCut </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Triangulates a simple polygon with no holes using the ear-cutting algorithm. </p>
<p>Triangulates a simple polygon with no holes in 3D space by projecting it onto a 2D plane and applying the ear-cutting algorithm.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Iterator</td><td>The type of iterator used to represent the vertices of the polygon. It must satisfy the Point2Concept requirement. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">begin</td><td>An iterator pointing to the first vertex of the polygon. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">end</td><td>An iterator pointing to one past the last vertex of the polygon. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector containing the indices of the vertices that form triangles in the triangulated polygon. Each group of three indices represents the vertices of a single triangle, and the indices are ordered in a counter-clockwise direction. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>If the polygon is not simple or has holes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>This function uses the ear-cutting algorithm to triangulate a simple polygon with no holes. The polygon is represented as a sequence of vertices, where each vertex is a two-dimensional point. The function returns a vector containing the indices of the vertices that form triangles in the triangulated polygon. The indices are ordered in a counter-clockwise direction, and each group of three indices represents the vertices of a single triangle. The function requires that the type of iterator used to represent the vertices of the polygon satisfies the Point2Concept requirement, which means that it must have a value_type that is a Point2 object with a ScalarType member representing the scalar type used to represent the coordinates of the point. If the polygon is not simple or has holes, the function throws a std::logic_error.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Iterator</td><td>The type of iterator used to represent the vertices of the polygon. It must satisfy the Point3Concept requirement. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">begin</td><td>An iterator pointing to the first vertex of the polygon. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">end</td><td>An iterator pointing to one past the last vertex of the polygon. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector containing the indices of the vertices that form triangles in the triangulated polygon. Each group of three indices represents the vertices of a single triangle, and the indices are ordered in a counter-clockwise direction. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>If the polygon is not simple or has holes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>This function triangulates a simple polygon with no holes in 3D space by projecting it onto a 2D plane and applying the ear-cutting algorithm. The polygon is represented as a sequence of vertices, where each vertex is a three-dimensional point. The function first calculates the normal vector of the polygon and an orthonormal basis for the plane containing the polygon. It then projects each vertex onto the plane and triangulates the resulting 2D polygon using the ear-cutting algorithm. The function returns a vector containing the indices of the vertices that form triangles in the triangulated polygon. The indices are ordered in a counter-clockwise direction, and each group of three indices represents the vertices of a single triangle. The function requires that the type of iterator used to represent the vertices of the polygon satisfies the Point3Concept requirement, which means that it must have a value_type that is a Point3 object with a ScalarType member representing the scalar type used to represent the coordinates of the point. If the polygon is not simple or has holes, the function throws a std::logic_error. </dd></dl>

</div>
</div>
<a id="a676f2c0c3f084e3d915ed44725af3ad9" name="a676f2c0c3f084e3d915ed44725af3ad9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a676f2c0c3f084e3d915ed44725af3ad9">&#9670;&#160;</a></span>earCut() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;PointConcept PointT&gt; </div>
<div class="memtemplate">
template&lt;typename Iterator &gt; <br />
requires (std::is_same_v&lt;typename Iterator::value_type, PointT&gt; &amp;&amp; PointT::DIM == 3)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::vector&lt; <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> &gt; <a class="el" href="classvcl_1_1Polygon.html">vcl::Polygon</a>&lt; PointT &gt;::earCut </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae9b8be77a5cdd8cdafd8c712c185b0ec" name="ae9b8be77a5cdd8cdafd8c712c185b0ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9b8be77a5cdd8cdafd8c712c185b0ec">&#9670;&#160;</a></span>earCut() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;PointConcept PointT&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="conceptvcl_1_1Range.html">vcl::Range</a> R&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> &gt; <a class="el" href="classvcl_1_1Polygon.html">vcl::Polygon</a>&lt; PointT &gt;::earCut </td>
          <td>(</td>
          <td class="paramtype">R &amp;&amp;&#160;</td>
          <td class="paramname"><em>range</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1682137a9e9d27da0544591a46e50fd8" name="a1682137a9e9d27da0544591a46e50fd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1682137a9e9d27da0544591a46e50fd8">&#9670;&#160;</a></span>normal() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;PointConcept PointT&gt; <br />
requires (PointT::DIM == 3)</div>
      <table class="memname">
        <tr>
          <td class="memname">PointT <a class="el" href="classvcl_1_1Polygon.html">vcl::Polygon</a>&lt; PointT &gt;::normal</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa744fe07266e55937d149a2df8171a60" name="aa744fe07266e55937d149a2df8171a60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa744fe07266e55937d149a2df8171a60">&#9670;&#160;</a></span>normal() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;PointConcept PointT&gt; <br />
requires (std::is_same_v&lt;typename Iterator::value_type, PointT&gt; &amp;&amp; PointT::DIM == 3)</div>
<div class="memtemplate">
template&lt;typename Iterator &gt; <br />
requires (std::is_same_v&lt;typename Iterator::value_type, PointT&gt; &amp;&amp; PointT::DIM == 3)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PointT <a class="el" href="classvcl_1_1Polygon.html">vcl::Polygon</a>&lt; PointT &gt;::normal </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the normal of a container of 3D points iterated between the iterators begin and end, listed in counterclockwise order, representing a polygon. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Iterator</td><td>an iterator which points to a type that satiesfies the PointConcept. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">begin</td><td>iterator pointing to the first point of the polygon. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">end</td><td>end iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The normal of the polygon. </dd></dl>

</div>
</div>
<a id="af6ab9cd4b0d48cd3c536703bc70500a7" name="af6ab9cd4b0d48cd3c536703bc70500a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6ab9cd4b0d48cd3c536703bc70500a7">&#9670;&#160;</a></span>normal() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;PointConcept PointT&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="conceptvcl_1_1Range.html">vcl::Range</a> R&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PointT <a class="el" href="classvcl_1_1Polygon.html">vcl::Polygon</a>&lt; PointT &gt;::normal </td>
          <td>(</td>
          <td class="paramtype">R &amp;&amp;&#160;</td>
          <td class="paramname"><em>range</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7715a8aa84bdbc8c0f2dc11d4c2e2f9f" name="a7715a8aa84bdbc8c0f2dc11d4c2e2f9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7715a8aa84bdbc8c0f2dc11d4c2e2f9f">&#9670;&#160;</a></span>perimeter() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;PointConcept PointT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Polygon.html">Polygon</a>&lt; PointT &gt;<a class="el" href="classvcl_1_1Polygon.html#a0d1d6548476986381b6a233b7f024680">::ScalarType</a> <a class="el" href="classvcl_1_1Polygon.html">vcl::Polygon</a>&lt; PointT &gt;::perimeter</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a00d68614a016883d67ebbc5101739276" name="a00d68614a016883d67ebbc5101739276"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00d68614a016883d67ebbc5101739276">&#9670;&#160;</a></span>perimeter() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;PointConcept PointT&gt; </div>
<div class="memtemplate">
template&lt;typename Iterator &gt; <br />
requires (std::is_same_v&lt;typename Iterator::value_type, PointT&gt;)</div>
      <table class="memname">
        <tr>
          <td class="memname">PointT::ScalarType <a class="el" href="classvcl_1_1Polygon.html">vcl::Polygon</a>&lt; PointT &gt;::perimeter </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the perimeter of a polygon defined by a range of points. </p>
<p>The polygonPerimeter function calculates the perimeter of a polygon defined by a range of points. The function takes two iterators as input, representing the beginning and end of the range of points. The points in the range must satisfy the PointConcept, which is a concept that requires the point type to have a ScalarType and a dist() function that calculates the distance between two points.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Iterator</td><td>an iterator which points to a type that satiesfies the PointConcept.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">begin</td><td>An iterator pointing to the first point in the range. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">end</td><td>An iterator pointing to one past the last point in the range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The perimeter of the polygon defined by the range of points. </dd></dl>

</div>
</div>
<a id="abd33f3286b47237e1ca42da5eb07daa9" name="abd33f3286b47237e1ca42da5eb07daa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd33f3286b47237e1ca42da5eb07daa9">&#9670;&#160;</a></span>perimeter() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;PointConcept PointT&gt; </div>
<div class="memtemplate">
template&lt;typename Iterator &gt; <br />
requires (std::is_same_v&lt;typename Iterator::value_type, PointT&gt;)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classvcl_1_1Polygon.html#a0d1d6548476986381b6a233b7f024680">ScalarType</a> <a class="el" href="classvcl_1_1Polygon.html">vcl::Polygon</a>&lt; PointT &gt;::perimeter </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9694ad75ff51633c3cb79a5bc3d2d0b8" name="a9694ad75ff51633c3cb79a5bc3d2d0b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9694ad75ff51633c3cb79a5bc3d2d0b8">&#9670;&#160;</a></span>perimeter() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;PointConcept PointT&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="conceptvcl_1_1Range.html">vcl::Range</a> R&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">PointT::ScalarType <a class="el" href="classvcl_1_1Polygon.html">vcl::Polygon</a>&lt; PointT &gt;::perimeter </td>
          <td>(</td>
          <td class="paramtype">R &amp;&amp;&#160;</td>
          <td class="paramname"><em>range</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a11dbf16c9623beba55324bc4fa980674" name="a11dbf16c9623beba55324bc4fa980674"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11dbf16c9623beba55324bc4fa980674">&#9670;&#160;</a></span>perimeter() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;PointConcept PointT&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="conceptvcl_1_1Range.html">vcl::Range</a> R&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classvcl_1_1Polygon.html#a0d1d6548476986381b6a233b7f024680">ScalarType</a> <a class="el" href="classvcl_1_1Polygon.html">vcl::Polygon</a>&lt; PointT &gt;::perimeter </td>
          <td>(</td>
          <td class="paramtype">R &amp;&amp;&#160;</td>
          <td class="paramname"><em>range</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a937aa2df891580a9021bf93693943c13" name="a937aa2df891580a9021bf93693943c13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a937aa2df891580a9021bf93693943c13">&#9670;&#160;</a></span>point() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;PointConcept PointT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">PointT &amp; <a class="el" href="classvcl_1_1Polygon.html">vcl::Polygon</a>&lt; PointT &gt;::point </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa67cb95b60bc9c12173071f4304bdcbe" name="aa67cb95b60bc9c12173071f4304bdcbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa67cb95b60bc9c12173071f4304bdcbe">&#9670;&#160;</a></span>point() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;PointConcept PointT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const PointT &amp; <a class="el" href="classvcl_1_1Polygon.html">vcl::Polygon</a>&lt; PointT &gt;::point </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6c2dc2c01a2da8041bba9a6d08a76461" name="a6c2dc2c01a2da8041bba9a6d08a76461"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c2dc2c01a2da8041bba9a6d08a76461">&#9670;&#160;</a></span>sideLength()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;PointConcept PointT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Polygon.html">Polygon</a>&lt; PointT &gt;<a class="el" href="classvcl_1_1Polygon.html#a0d1d6548476986381b6a233b7f024680">::ScalarType</a> <a class="el" href="classvcl_1_1Polygon.html">vcl::Polygon</a>&lt; PointT &gt;::sideLength </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a050d2409a41e0dbfbfaa9601a6ddda3d" name="a050d2409a41e0dbfbfaa9601a6ddda3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a050d2409a41e0dbfbfaa9601a6ddda3d">&#9670;&#160;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;PointConcept PointT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> <a class="el" href="classvcl_1_1Polygon.html">vcl::Polygon</a>&lt; PointT &gt;::size</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac7337dc78515f839e42e12a8d8fa606d" name="ac7337dc78515f839e42e12a8d8fa606d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7337dc78515f839e42e12a8d8fa606d">&#9670;&#160;</a></span>weightedBarycenter() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;PointConcept PointT&gt; <br />
requires (std::is_same_v&lt;typename Iterator::value_type, PointT&gt;)</div>
<div class="memtemplate">
template&lt;typename Iterator , typename WIterator &gt; <br />
requires (std::is_same_v&lt;typename Iterator::value_type, PointT&gt;)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PointT <a class="el" href="classvcl_1_1Polygon.html">vcl::Polygon</a>&lt; PointT &gt;::weightedBarycenter </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WIterator&#160;</td>
          <td class="paramname"><em>wbegin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the weighted barycenter of a container of 3D points iterated between the iterators begin and end, listed in counterclockwise order, representing a polygon. Weights are iterated by another iterator wbegin, which iterates to a container of the same size of the polygon container. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Iterator</td><td>an iterator which points to a type that satiesfies the PointConcept. </td></tr>
    <tr><td class="paramname">WIterator</td><td>an iterator which points to a scalar type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">begin</td><td>iterator pointing to the first point of the polygon. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">end</td><td>end iterator of the polygon container. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wbegin</td><td>iterator pointing to the first weight associated to the fist polygon point. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The weighted barycenter of the polygon. </dd></dl>

</div>
</div>
<a id="a5b6b0eee15b9ac6e80fda7846ff5e82e" name="a5b6b0eee15b9ac6e80fda7846ff5e82e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b6b0eee15b9ac6e80fda7846ff5e82e">&#9670;&#160;</a></span>weightedBarycenter() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;PointConcept PointT&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="conceptvcl_1_1Range.html">vcl::Range</a> Rp, <a class="el" href="conceptvcl_1_1Range.html">vcl::Range</a> Rw&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PointT <a class="el" href="classvcl_1_1Polygon.html">vcl::Polygon</a>&lt; PointT &gt;::weightedBarycenter </td>
          <td>(</td>
          <td class="paramtype">Rp &amp;&amp;&#160;</td>
          <td class="paramname"><em>rPolygon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Rw &amp;&amp;&#160;</td>
          <td class="paramname"><em>rWeights</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a83655fe0d73b63024108d3e2086e4b99" name="a83655fe0d73b63024108d3e2086e4b99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83655fe0d73b63024108d3e2086e4b99">&#9670;&#160;</a></span>weightedBarycenter() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;PointConcept PointT&gt; </div>
<div class="memtemplate">
template&lt;typename WIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">PointT <a class="el" href="classvcl_1_1Polygon.html">vcl::Polygon</a>&lt; PointT &gt;::weightedBarycenter </td>
          <td>(</td>
          <td class="paramtype">WIterator&#160;</td>
          <td class="paramname"><em>wbegin</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="add10001ada05a465daf633b6aba52f9f" name="add10001ada05a465daf633b6aba52f9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add10001ada05a465daf633b6aba52f9f">&#9670;&#160;</a></span>DIM</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;PointConcept PointT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> <a class="el" href="classvcl_1_1Polygon.html">vcl::Polygon</a>&lt; PointT &gt;::DIM = PointT::DIM</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/runner/work/vclib/vclib/include/vclib/space/<a class="el" href="space_2polygon_8h_source.html">polygon.h</a></li>
<li>/home/runner/work/vclib/vclib/include/vclib/space/<a class="el" href="polygon_8cpp.html">polygon.cpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacevcl.html">vcl</a></li><li class="navelem"><a class="el" href="classvcl_1_1Polygon.html">Polygon</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6 </li>
  </ul>
</div>
</body>
</html>
