<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Visual Computing Library: Mesh Update Algorithms</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
       <script type="text/javascript">
           DoxygenAwesomeDarkModeToggle.init()
       </script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Visual Computing Library
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group__update.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Mesh Update Algorithms<div class="ingroups"><a class="el" href="group__algorithms.html">Algorithms</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>List of Mesh Update algorithms.  
<a href="#details">More...</a></p>
<div class="dynheader">
Collaboration diagram for Mesh Update Algorithms:</div>
<div class="dyncontent">
<div class="center"><img src="group__update.png" border="0" usemap="#agroup____update" alt=""/></div>
<map name="agroup____update" id="agroup____update">
<area shape="rect" href="group__algorithms.html" title="List of function algorithms of VCLib." alt="" coords="5,5,99,31"/>
<area shape="rect" title="List of Mesh Update algorithms." alt="" coords="147,5,329,31"/>
</map>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga8ecd18a495232ac86d4c81913a1ad3f7"><td class="memTemplParams" colspan="2">template&lt;HasBoundingBox MeshType&gt; </td></tr>
<tr class="memitem:ga8ecd18a495232ac86d4c81913a1ad3f7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__update.html#ga8ecd18a495232ac86d4c81913a1ad3f7">vcl::updateBoundingBox</a> (MeshType &amp;m)</td></tr>
<tr class="memdesc:ga8ecd18a495232ac86d4c81913a1ad3f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the bounding box of the mesh.  <br /></td></tr>
<tr class="separator:ga8ecd18a495232ac86d4c81913a1ad3f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga38b37b1e8291340239554140dd07bcf2"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga38b37b1e8291340239554140dd07bcf2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__update.html#ga38b37b1e8291340239554140dd07bcf2">vcl::setPerVertexColor</a> (MeshType &amp;m, <a class="el" href="classvcl_1_1Color.html">vcl::Color</a> c=<a class="el" href="classvcl_1_1Color.html#afab49834d923b1e26589efe2eef9a135a933a633d2d20cec2e05a97a403dcd1d4">vcl::Color::White</a>, bool onlySelected=false)</td></tr>
<tr class="memdesc:ga38b37b1e8291340239554140dd07bcf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the color of the vertices. If the <code>onlySelected</code> flag is set to <code>true</code>, only the color of the selected vertices will be set. Otherwise, all the vertices will have the same color.  <br /></td></tr>
<tr class="separator:ga38b37b1e8291340239554140dd07bcf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd40b9510ebcbbc885f2b251eff19c85"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:gafd40b9510ebcbbc885f2b251eff19c85"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__update.html#gafd40b9510ebcbbc885f2b251eff19c85">vcl::setPerFaceColor</a> (MeshType &amp;m, <a class="el" href="classvcl_1_1Color.html">vcl::Color</a> c=<a class="el" href="classvcl_1_1Color.html#afab49834d923b1e26589efe2eef9a135a933a633d2d20cec2e05a97a403dcd1d4">vcl::Color::White</a>, bool onlySelected=false)</td></tr>
<tr class="memdesc:gafd40b9510ebcbbc885f2b251eff19c85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the color of the faces. If the <code>onlySelected</code> flag is set to <code>true</code>, only the color of the selected faces will be set. Otherwise, all the faces will have the same color.  <br /></td></tr>
<tr class="separator:gafd40b9510ebcbbc885f2b251eff19c85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa7a7bdb880ed18451dbad7b220ad708"><td class="memTemplParams" colspan="2">template&lt;HasColor MeshType&gt; </td></tr>
<tr class="memitem:gafa7a7bdb880ed18451dbad7b220ad708"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__update.html#gafa7a7bdb880ed18451dbad7b220ad708">vcl::setMeshColor</a> (MeshType &amp;m, <a class="el" href="classvcl_1_1Color.html">vcl::Color</a> c=<a class="el" href="classvcl_1_1Color.html#afab49834d923b1e26589efe2eef9a135a933a633d2d20cec2e05a97a403dcd1d4">vcl::Color::White</a>)</td></tr>
<tr class="memdesc:gafa7a7bdb880ed18451dbad7b220ad708"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the color component of a mesh.  <br /></td></tr>
<tr class="separator:gafa7a7bdb880ed18451dbad7b220ad708"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga003227edc01710ea2a42c6e326b34698"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga003227edc01710ea2a42c6e326b34698"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__update.html#ga003227edc01710ea2a42c6e326b34698">vcl::setPerVertexColorFromFaceColor</a> (MeshType &amp;m)</td></tr>
<tr class="memdesc:ga003227edc01710ea2a42c6e326b34698"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the vertex colors from its incident face colors, computing a plain average of the face colors.  <br /></td></tr>
<tr class="separator:ga003227edc01710ea2a42c6e326b34698"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga698e981e0c5fd646f3401579735e7825"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga698e981e0c5fd646f3401579735e7825"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__update.html#ga698e981e0c5fd646f3401579735e7825">vcl::setPerFaceColorFromVertexColor</a> (MeshType &amp;m)</td></tr>
<tr class="memdesc:ga698e981e0c5fd646f3401579735e7825"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the face colors from its incident vertex colors, computing a plain average of the vertex colors.  <br /></td></tr>
<tr class="separator:ga698e981e0c5fd646f3401579735e7825"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga213cbe42a2c49bda6686e5dee548941f"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga213cbe42a2c49bda6686e5dee548941f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__update.html#ga213cbe42a2c49bda6686e5dee548941f">vcl::setPerVertexColorFromQuality</a> (MeshType &amp;m, <a class="el" href="classvcl_1_1Color.html#a32ace7bd7fccf742b39f6cd83042a10f">vcl::Color::ColorMap</a> colorMap=<a class="el" href="classvcl_1_1Color.html#a32ace7bd7fccf742b39f6cd83042a10fab41395ae78ccecdb7c2a311a4bb25130">vcl::Color::RedBlue</a>, typename MeshType::VertexType::QualityType minQuality=0, typename MeshType::VertexType::QualityType maxQuality=0)</td></tr>
<tr class="memdesc:ga213cbe42a2c49bda6686e5dee548941f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the vertex colors from the quality values by computing a shading in the given color map (default is Red to Blue color map), in the given interval [minQuality, maxQuality].  <br /></td></tr>
<tr class="separator:ga213cbe42a2c49bda6686e5dee548941f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad1237f614680030ae7d2bdc13b2877b6"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:gad1237f614680030ae7d2bdc13b2877b6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__update.html#gad1237f614680030ae7d2bdc13b2877b6">vcl::setPerFaceColorFromQuality</a> (MeshType &amp;m, <a class="el" href="classvcl_1_1Color.html#a32ace7bd7fccf742b39f6cd83042a10f">vcl::Color::ColorMap</a> colorMap=<a class="el" href="classvcl_1_1Color.html#a32ace7bd7fccf742b39f6cd83042a10fab41395ae78ccecdb7c2a311a4bb25130">vcl::Color::RedBlue</a>, typename MeshType::FaceType::QualityType minQuality=0, typename MeshType::FaceType::QualityType maxQuality=0)</td></tr>
<tr class="memdesc:gad1237f614680030ae7d2bdc13b2877b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the face colors from the quality values by computing a shading in the given color map (default is Red to Blue color map), in the given interval [minQuality, maxQuality].  <br /></td></tr>
<tr class="separator:gad1237f614680030ae7d2bdc13b2877b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb208445ca45b8758d9522c420694f38"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:gadb208445ca45b8758d9522c420694f38"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__update.html#gadb208445ca45b8758d9522c420694f38">vcl::setPerVertexColorFromFaceBorderFlag</a> (MeshType &amp;m, <a class="el" href="classvcl_1_1Color.html">Color</a> borderColor=<a class="el" href="classvcl_1_1Color.html#afab49834d923b1e26589efe2eef9a135af54d29d341201c1ef87b86671a29b28e">vcl::Color::Blue</a>, <a class="el" href="classvcl_1_1Color.html">Color</a> internalColor=<a class="el" href="classvcl_1_1Color.html#afab49834d923b1e26589efe2eef9a135a933a633d2d20cec2e05a97a403dcd1d4">vcl::Color::White</a>, <a class="el" href="classvcl_1_1Color.html">Color</a> mixColor=<a class="el" href="classvcl_1_1Color.html#afab49834d923b1e26589efe2eef9a135aa70f19981682325e9f47020f45097ab3">vcl::Color::Cyan</a>)</td></tr>
<tr class="memdesc:gadb208445ca45b8758d9522c420694f38"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classvcl_1_1Color.html" title="The Color class represents a RGBA color.">Color</a> the vertices of the mesh that are on border, using the border flags of the faces.  <br /></td></tr>
<tr class="separator:gadb208445ca45b8758d9522c420694f38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaefda81ff00c7e8d3b5ff19c9e90c03bf"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:gaefda81ff00c7e8d3b5ff19c9e90c03bf"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__update.html#gaefda81ff00c7e8d3b5ff19c9e90c03bf">vcl::setPerFaceColorFromConnectedComponents</a> (MeshType &amp;m, const std::vector&lt; std::set&lt; <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> &gt; &gt; &amp;<a class="el" href="group__clean.html#ga774f9a47e9cef107d59b97d0434177f7">connectedComponents</a>)</td></tr>
<tr class="memdesc:gaefda81ff00c7e8d3b5ff19c9e90c03bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an already computed vector of sets of connected components (see vcl::connectedComponents(m) in <code><a class="el" href="clean_8h.html">vclib/algorithms/clean.h</a></code>), sets face colors according from connected components of the mesh. Each connected component will have a different per face color.  <br /></td></tr>
<tr class="separator:gaefda81ff00c7e8d3b5ff19c9e90c03bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga39a8c9027a5e7c936518969bda799f71"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga39a8c9027a5e7c936518969bda799f71"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__update.html#ga39a8c9027a5e7c936518969bda799f71">vcl::setPerFaceColorFromConnectedComponents</a> (MeshType &amp;m)</td></tr>
<tr class="memdesc:ga39a8c9027a5e7c936518969bda799f71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets face colors according from connected components of the mesh. Each connected component will have a different per face color. Since this function will need to compute connected components of the mesh, also per <a class="el" href="classvcl_1_1Face.html" title="The Face class represents an Face element of the vcl::Mesh class.">Face</a> AdjacentFaces component is required.  <br /></td></tr>
<tr class="separator:ga39a8c9027a5e7c936518969bda799f71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga318a121ea66deb73b4d95ca0ec311290"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga318a121ea66deb73b4d95ca0ec311290"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__update.html#ga318a121ea66deb73b4d95ca0ec311290">vcl::setPerFaceColorScattering</a> (MeshType &amp;m, <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> nColors=50, bool checkFauxEdges=true)</td></tr>
<tr class="memdesc:ga318a121ea66deb73b4d95ca0ec311290"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function colors each face of the mesh using a given number of scattering colors (default number is 50). By default, colors uniformely adjacent faces having faux edges in common. This check is made only if the option <code>checkFauxEdges</code> is set to true, and if the per <a class="el" href="classvcl_1_1Face.html" title="The Face class represents an Face element of the vcl::Mesh class.">Face</a> AdjacentFaces component is available in the mesh.  <br /></td></tr>
<tr class="separator:ga318a121ea66deb73b4d95ca0ec311290"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga37b2b7fbbfce106c039cb86ad7994335"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType, PointConcept PointType&gt; </td></tr>
<tr class="memitem:ga37b2b7fbbfce106c039cb86ad7994335"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__update.html#ga37b2b7fbbfce106c039cb86ad7994335">vcl::setPerVertexColorPerlinNoise</a> (MeshType &amp;m, PointType period, PointType offset=PointType(0, 0, 0), bool onSelected=false)</td></tr>
<tr class="memdesc:ga37b2b7fbbfce106c039cb86ad7994335"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the vertex color according to a perlin noise computed on the vertex coordinates.  <br /></td></tr>
<tr class="separator:ga37b2b7fbbfce106c039cb86ad7994335"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga48d79f5a79d36e16d20272ccdb3f56e5"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType, PointConcept PointType&gt; </td></tr>
<tr class="memitem:ga48d79f5a79d36e16d20272ccdb3f56e5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__update.html#ga48d79f5a79d36e16d20272ccdb3f56e5">vcl::setPerVertexPerlinColor</a> (MeshType &amp;m, double period, PointType offset=PointType(0, 0, 0), <a class="el" href="classvcl_1_1Color.html">Color</a> color1=<a class="el" href="classvcl_1_1Color.html#afab49834d923b1e26589efe2eef9a135a5777c5f96e2970090b99598c215292f7">Color::Black</a>, <a class="el" href="classvcl_1_1Color.html">Color</a> color2=<a class="el" href="classvcl_1_1Color.html#afab49834d923b1e26589efe2eef9a135a933a633d2d20cec2e05a97a403dcd1d4">Color::White</a>, bool onSelected=false)</td></tr>
<tr class="memdesc:ga48d79f5a79d36e16d20272ccdb3f56e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple Perlin color mixing. <code>color1</code> and <code>color2</code> are mixed according the perlin noise function, with <code>period</code> and <code>offset</code>.  <br /></td></tr>
<tr class="separator:ga48d79f5a79d36e16d20272ccdb3f56e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>List of Mesh Update algorithms. </p>
<p>They allow to update components and properties of a mesh.</p>
<p>You can access these algorithms by including <code>#include &lt;<a class="el" href="update_8h.html">vclib/algorithms/update.h</a>&gt;</code> </p>
<h2 class="groupheader">Function Documentation</h2>
<a id="gafa7a7bdb880ed18451dbad7b220ad708" name="gafa7a7bdb880ed18451dbad7b220ad708"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafa7a7bdb880ed18451dbad7b220ad708">&#9670;&#160;</a></span>setMeshColor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;HasColor MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::setMeshColor </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Color.html">vcl::Color</a>&#160;</td>
          <td class="paramname"><em>c</em> = <code><a class="el" href="classvcl_1_1Color.html#afab49834d923b1e26589efe2eef9a135a933a633d2d20cec2e05a97a403dcd1d4">vcl::Color::White</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the color component of a mesh. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MeshType</td><td>type of the input mesh. It must satisfy the HasColor concept.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">m</td><td>the mesh on which set the color. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>the color to set to the mesh. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gafd40b9510ebcbbc885f2b251eff19c85" name="gafd40b9510ebcbbc885f2b251eff19c85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafd40b9510ebcbbc885f2b251eff19c85">&#9670;&#160;</a></span>setPerFaceColor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::setPerFaceColor </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Color.html">vcl::Color</a>&#160;</td>
          <td class="paramname"><em>c</em> = <code><a class="el" href="classvcl_1_1Color.html#afab49834d923b1e26589efe2eef9a135a933a633d2d20cec2e05a97a403dcd1d4">vcl::Color::White</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>onlySelected</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the color of the faces. If the <code>onlySelected</code> flag is set to <code>true</code>, only the color of the selected faces will be set. Otherwise, all the faces will have the same color. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classvcl_1_1MissingComponentException.html">vcl::MissingComponentException</a></td><td>if the mesh does not have the per face color component available.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MeshType</td><td>type of the input mesh. It must satisfy the FaceMeshConcept.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">m</td><td>the mesh on which set the face color. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>the color to set to the faces of the mesh. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">onlySelected</td><td>if <code>true</code>, the color will be set just on the selected faces. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga39a8c9027a5e7c936518969bda799f71" name="ga39a8c9027a5e7c936518969bda799f71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga39a8c9027a5e7c936518969bda799f71">&#9670;&#160;</a></span>setPerFaceColorFromConnectedComponents() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::setPerFaceColorFromConnectedComponents </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets face colors according from connected components of the mesh. Each connected component will have a different per face color. Since this function will need to compute connected components of the mesh, also per <a class="el" href="classvcl_1_1Face.html" title="The Face class represents an Face element of the vcl::Mesh class.">Face</a> AdjacentFaces component is required. </p>
<p>Requirements:</p><ul>
<li><a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>:<ul>
<li>Faces:<ul>
<li>AdjacentFaces</li>
<li><a class="el" href="classvcl_1_1Color.html" title="The Color class represents a RGBA color.">Color</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">m</td><td>the mesh on which set the face colors according to its connected components. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaefda81ff00c7e8d3b5ff19c9e90c03bf" name="gaefda81ff00c7e8d3b5ff19c9e90c03bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaefda81ff00c7e8d3b5ff19c9e90c03bf">&#9670;&#160;</a></span>setPerFaceColorFromConnectedComponents() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::setPerFaceColorFromConnectedComponents </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::set&lt; <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>connectedComponents</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given an already computed vector of sets of connected components (see vcl::connectedComponents(m) in <code><a class="el" href="clean_8h.html">vclib/algorithms/clean.h</a></code>), sets face colors according from connected components of the mesh. Each connected component will have a different per face color. </p>
<p>Requirements:</p><ul>
<li><a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>:<ul>
<li>Faces:<ul>
<li><a class="el" href="classvcl_1_1Color.html" title="The Color class represents a RGBA color.">Color</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">m</td><td>the mesh on which set the face colors according to its connected components. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">connectedComponents</td><td>a vector of sets, each one of them containing the face ids of a connected component. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad1237f614680030ae7d2bdc13b2877b6" name="gad1237f614680030ae7d2bdc13b2877b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad1237f614680030ae7d2bdc13b2877b6">&#9670;&#160;</a></span>setPerFaceColorFromQuality()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::setPerFaceColorFromQuality </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Color.html#a32ace7bd7fccf742b39f6cd83042a10f">vcl::Color::ColorMap</a>&#160;</td>
          <td class="paramname"><em>colorMap</em> = <code><a class="el" href="classvcl_1_1Color.html#a32ace7bd7fccf742b39f6cd83042a10fab41395ae78ccecdb7c2a311a4bb25130">vcl::Color::RedBlue</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename MeshType::FaceType::QualityType&#160;</td>
          <td class="paramname"><em>minQuality</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename MeshType::FaceType::QualityType&#160;</td>
          <td class="paramname"><em>maxQuality</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the face colors from the quality values by computing a shading in the given color map (default is Red to Blue color map), in the given interval [minQuality, maxQuality]. </p>
<p>If minQuality and maxQuality are not set (or if they are equal), the range is automatically computed.</p>
<p>Requirements:</p><ul>
<li><a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>:<ul>
<li>Faces:<ul>
<li><a class="el" href="classvcl_1_1Color.html" title="The Color class represents a RGBA color.">Color</a></li>
<li>Quality</li>
</ul>
</li>
</ul>
</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">m</td><td>mesh on which compute the face color. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">colorMap</td><td>the colormap to use to color the faces of the mesh (default: RedBlue). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">minQuality</td><td>the minimum value of the range to use for coloring (default: 0). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxQuality</td><td>the maximum value of the range to use for coloring (default: 0). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga698e981e0c5fd646f3401579735e7825" name="ga698e981e0c5fd646f3401579735e7825"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga698e981e0c5fd646f3401579735e7825">&#9670;&#160;</a></span>setPerFaceColorFromVertexColor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::setPerFaceColorFromVertexColor </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the face colors from its incident vertex colors, computing a plain average of the vertex colors. </p>
<p>Requirements:</p><ul>
<li><a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>:<ul>
<li>Vertices:<ul>
<li><a class="el" href="classvcl_1_1Color.html" title="The Color class represents a RGBA color.">Color</a></li>
</ul>
</li>
<li>Faces:<ul>
<li><a class="el" href="classvcl_1_1Color.html" title="The Color class represents a RGBA color.">Color</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">m</td><td>mesh on which transfer the vertex color into the face color. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga318a121ea66deb73b4d95ca0ec311290" name="ga318a121ea66deb73b4d95ca0ec311290"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga318a121ea66deb73b4d95ca0ec311290">&#9670;&#160;</a></span>setPerFaceColorScattering()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::setPerFaceColorScattering </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a>&#160;</td>
          <td class="paramname"><em>nColors</em> = <code>50</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>checkFauxEdges</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function colors each face of the mesh using a given number of scattering colors (default number is 50). By default, colors uniformely adjacent faces having faux edges in common. This check is made only if the option <code>checkFauxEdges</code> is set to true, and if the per <a class="el" href="classvcl_1_1Face.html" title="The Face class represents an Face element of the vcl::Mesh class.">Face</a> AdjacentFaces component is available in the mesh. </p>
<p>Requirements:</p><ul>
<li><a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>:<ul>
<li>Faces:<ul>
<li><a class="el" href="classvcl_1_1Color.html" title="The Color class represents a RGBA color.">Color</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Optional:</p><ul>
<li><a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>:<ul>
<li>Faces:<ul>
<li>AdjacentFaces</li>
</ul>
</li>
</ul>
</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">m</td><td>mesh on which set the face colors. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nColors</td><td>number of colors used for the scattering (default 50). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">checkFauxEdges</td><td>if true, colors uniformely adjacent faces with faux edges (default <code>true</code>). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga38b37b1e8291340239554140dd07bcf2" name="ga38b37b1e8291340239554140dd07bcf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga38b37b1e8291340239554140dd07bcf2">&#9670;&#160;</a></span>setPerVertexColor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::setPerVertexColor </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Color.html">vcl::Color</a>&#160;</td>
          <td class="paramname"><em>c</em> = <code><a class="el" href="classvcl_1_1Color.html#afab49834d923b1e26589efe2eef9a135a933a633d2d20cec2e05a97a403dcd1d4">vcl::Color::White</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>onlySelected</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the color of the vertices. If the <code>onlySelected</code> flag is set to <code>true</code>, only the color of the selected vertices will be set. Otherwise, all the vertices will have the same color. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classvcl_1_1MissingComponentException.html">vcl::MissingComponentException</a></td><td>if the mesh does not have the per vertex color component available.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MeshType</td><td>type of the input mesh. It must satisfy the MeshConcept.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">m</td><td>the mesh on which set the vertex color. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>the color to set to the vertices of the mesh. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">onlySelected</td><td>if <code>true</code>, the color will be set just on the selected vertices. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gadb208445ca45b8758d9522c420694f38" name="gadb208445ca45b8758d9522c420694f38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadb208445ca45b8758d9522c420694f38">&#9670;&#160;</a></span>setPerVertexColorFromFaceBorderFlag()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::setPerVertexColorFromFaceBorderFlag </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Color.html">Color</a>&#160;</td>
          <td class="paramname"><em>borderColor</em> = <code><a class="el" href="classvcl_1_1Color.html#afab49834d923b1e26589efe2eef9a135af54d29d341201c1ef87b86671a29b28e">vcl::Color::Blue</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Color.html">Color</a>&#160;</td>
          <td class="paramname"><em>internalColor</em> = <code><a class="el" href="classvcl_1_1Color.html#afab49834d923b1e26589efe2eef9a135a933a633d2d20cec2e05a97a403dcd1d4">vcl::Color::White</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Color.html">Color</a>&#160;</td>
          <td class="paramname"><em>mixColor</em> = <code><a class="el" href="classvcl_1_1Color.html#afab49834d923b1e26589efe2eef9a135aa70f19981682325e9f47020f45097ab3">vcl::Color::Cyan</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classvcl_1_1Color.html" title="The Color class represents a RGBA color.">Color</a> the vertices of the mesh that are on border, using the border flags of the faces. </p>
<p>Before using this function, you should update the face border flags accordingly.</p>
<p>Requirements:</p><ul>
<li><a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>:<ul>
<li>Vertices:<ul>
<li><a class="el" href="classvcl_1_1Color.html" title="The Color class represents a RGBA color.">Color</a></li>
</ul>
</li>
<li>Faces:<ul>
<li>TriangleFlags/PolygonFlags</li>
</ul>
</li>
</ul>
</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">m</td><td>the mesh on which update the vertex color from the border face flags. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">borderColor</td><td>the color of the vertices that are part of edges that are all marked as on border. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">internalColor</td><td>the color of the vertices that are part of edges that are all marked as non on border. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mixColor</td><td>the color of vertices that are part of edges that are both on border and non on border. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga003227edc01710ea2a42c6e326b34698" name="ga003227edc01710ea2a42c6e326b34698"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga003227edc01710ea2a42c6e326b34698">&#9670;&#160;</a></span>setPerVertexColorFromFaceColor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::setPerVertexColorFromFaceColor </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the vertex colors from its incident face colors, computing a plain average of the face colors. </p>
<p>Requirements:</p><ul>
<li><a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>:<ul>
<li>Vertices:<ul>
<li><a class="el" href="classvcl_1_1Color.html" title="The Color class represents a RGBA color.">Color</a></li>
</ul>
</li>
<li>Faces:<ul>
<li><a class="el" href="classvcl_1_1Color.html" title="The Color class represents a RGBA color.">Color</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">m</td><td>mesh on which transfer the face color into the vertex color. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga213cbe42a2c49bda6686e5dee548941f" name="ga213cbe42a2c49bda6686e5dee548941f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga213cbe42a2c49bda6686e5dee548941f">&#9670;&#160;</a></span>setPerVertexColorFromQuality()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::setPerVertexColorFromQuality </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Color.html#a32ace7bd7fccf742b39f6cd83042a10f">vcl::Color::ColorMap</a>&#160;</td>
          <td class="paramname"><em>colorMap</em> = <code><a class="el" href="classvcl_1_1Color.html#a32ace7bd7fccf742b39f6cd83042a10fab41395ae78ccecdb7c2a311a4bb25130">vcl::Color::RedBlue</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename MeshType::VertexType::QualityType&#160;</td>
          <td class="paramname"><em>minQuality</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename MeshType::VertexType::QualityType&#160;</td>
          <td class="paramname"><em>maxQuality</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the vertex colors from the quality values by computing a shading in the given color map (default is Red to Blue color map), in the given interval [minQuality, maxQuality]. </p>
<p>If minQuality and maxQuality are not set (or if they are equal), the range is automatically computed.</p>
<p>Requirements:</p><ul>
<li><a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>:<ul>
<li>Vertices:<ul>
<li><a class="el" href="classvcl_1_1Color.html" title="The Color class represents a RGBA color.">Color</a></li>
<li>Quality</li>
</ul>
</li>
</ul>
</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">m</td><td>mesh on which compute the vertex color. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">colorMap</td><td>the colormap to use to color the vertices of the mesh (default: RedBlue). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">minQuality</td><td>the minimum value of the range to use for coloring (default: 0). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxQuality</td><td>the maximum value of the range to use for coloring (default: 0). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga37b2b7fbbfce106c039cb86ad7994335" name="ga37b2b7fbbfce106c039cb86ad7994335"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga37b2b7fbbfce106c039cb86ad7994335">&#9670;&#160;</a></span>setPerVertexColorPerlinNoise()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType, PointConcept PointType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::setPerVertexColorPerlinNoise </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PointType&#160;</td>
          <td class="paramname"><em>period</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PointType&#160;</td>
          <td class="paramname"><em>offset</em> = <code>PointType(0,&#160;0,&#160;0)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>onSelected</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the vertex color according to a perlin noise computed on the vertex coordinates. </p>
<p>To make things weirder each color band can have its own offset and frequency. Period is expressed in absolute terms. So as period it is meaningful could be to use something in the range of 1/10 of the bbox diag.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classvcl_1_1MissingComponentException.html">vcl::MissingComponentException</a></td><td>if the mesh does not have a per vertex color component.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MeshType</td><td>the type of the mesh. It must satisfy the MeshConcept.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td></td></tr>
    <tr><td class="paramname">period</td><td></td></tr>
    <tr><td class="paramname">offset</td><td></td></tr>
    <tr><td class="paramname">onSelected</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga48d79f5a79d36e16d20272ccdb3f56e5" name="ga48d79f5a79d36e16d20272ccdb3f56e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga48d79f5a79d36e16d20272ccdb3f56e5">&#9670;&#160;</a></span>setPerVertexPerlinColor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType, PointConcept PointType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::setPerVertexPerlinColor </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>period</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PointType&#160;</td>
          <td class="paramname"><em>offset</em> = <code>PointType(0,&#160;0,&#160;0)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Color.html">Color</a>&#160;</td>
          <td class="paramname"><em>color1</em> = <code><a class="el" href="classvcl_1_1Color.html#afab49834d923b1e26589efe2eef9a135a5777c5f96e2970090b99598c215292f7">Color::Black</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Color.html">Color</a>&#160;</td>
          <td class="paramname"><em>color2</em> = <code><a class="el" href="classvcl_1_1Color.html#afab49834d923b1e26589efe2eef9a135a933a633d2d20cec2e05a97a403dcd1d4">Color::White</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>onSelected</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Simple Perlin color mixing. <code>color1</code> and <code>color2</code> are mixed according the perlin noise function, with <code>period</code> and <code>offset</code>. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classvcl_1_1MissingComponentException.html">vcl::MissingComponentException</a></td><td>if the mesh does not have a per vertex color component.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MeshType</td><td>the type of the mesh. It must satisfy the MeshConcept.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td></td></tr>
    <tr><td class="paramname">period</td><td></td></tr>
    <tr><td class="paramname">offset</td><td></td></tr>
    <tr><td class="paramname">color1</td><td></td></tr>
    <tr><td class="paramname">color2</td><td></td></tr>
    <tr><td class="paramname">onSelected</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8ecd18a495232ac86d4c81913a1ad3f7" name="ga8ecd18a495232ac86d4c81913a1ad3f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8ecd18a495232ac86d4c81913a1ad3f7">&#9670;&#160;</a></span>updateBoundingBox()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;HasBoundingBox MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vcl::updateBoundingBox </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates the bounding box of the mesh. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MeshType</td><td>type of the input mesh. It must satisfy the HasBoundingBox concept.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>input mesh on which the bounding box is computed and updated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6 </li>
  </ul>
</div>
</body>
</html>
