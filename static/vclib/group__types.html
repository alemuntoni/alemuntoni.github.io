<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Visual Computing Library: VCLib Types Module</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
       <script type="text/javascript">
           DoxygenAwesomeDarkModeToggle.init()
       </script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Visual Computing Library
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group__types.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">VCLib Types Module</div></div>
</div><!--header-->
<div class="contents">

<p>The Types module defines all the utility definitions, types, classes and type traits that are common in the library.  
<a href="#details">More...</a></p>
<div class="dynheader">
Collaboration diagram for VCLib Types Module:</div>
<div class="dyncontent">
<div class="center"><img src="group__types.png" border="0" usemap="#agroup____types" alt=""/></div>
<map name="agroup____types" id="agroup____types">
<area shape="rect" title="The Types module defines all the utility definitions, types, classes and type traits that are common ..." alt="" coords="5,7,157,33"/>
<area shape="rect" href="group__views.html" title="List of range views of the library." alt="" coords="265,7,379,33"/>
</map>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1FakePointerWithValue.html">vcl::FakePointerWithValue&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple utility class to represent a pointer with a value.  <a href="classvcl_1_1FakePointerWithValue.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvcl_1_1MakeConstPointer.html">vcl::MakeConstPointer&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility type that makes possible to treat const pointers in a templated class that can treat a both const and non-const pointer type.  <a href="structvcl_1_1MakeConstPointer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvcl_1_1MakeConstPointer_3_01T_01_5_01_4.html">vcl::MakeConstPointer&lt; T * &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility type that makes possible to treat const pointers in a templated class that can treat a both const and non-const pointer type.    <a href="structvcl_1_1MakeConstPointer_3_01T_01_5_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvcl_1_1CompId.html">vcl::CompId</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="structvcl_1_1CompId.html" title="The CompId struct enumerates the components that can compose a element or a mesh.">CompId</a> struct enumerates the components that can compose a element or a mesh.  <a href="structvcl_1_1CompId.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvcl_1_1ComponentString.html">vcl::ComponentString&lt; COMP_ID &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="structvcl_1_1ComponentString.html" title="The ComponentString class is used to retrieve the string associated to a COMP_ID value,...">ComponentString</a> class is used to retrieve the string associated to a COMP_ID value, trough its member 'str'.  <a href="structvcl_1_1ComponentString.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvcl_1_1ElemId.html">vcl::ElemId</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="structvcl_1_1ElemId.html" title="The ElemId struct enumerates the elements that can compose a mesh.">ElemId</a> struct enumerates the elements that can compose a mesh.  <a href="structvcl_1_1ElemId.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvcl_1_1ElementString.html">vcl::ElementString&lt; ELEM_ID &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="structvcl_1_1ElementString.html" title="The ElementString class is used to retrieve the string associated to a ELEM_ID value,...">ElementString</a> class is used to retrieve the string associated to a ELEM_ID value, trough its member 'str'.  <a href="structvcl_1_1ElementString.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvcl_1_1TypeWrapper.html">vcl::TypeWrapper&lt; Args &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple structure that wraps a list of variadic templates, without instantiating anything. Useful when you need to wrap a list of types, and consider them as a single type.  <a href="structvcl_1_1TypeWrapper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvcl_1_1FirstType.html">vcl::FirstType&lt; Args &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the first type of a pack of types (variadic templates) or a <a class="el" href="structvcl_1_1TypeWrapper.html" title="A simple structure that wraps a list of variadic templates, without instantiating anything....">TypeWrapper</a>.  <a href="structvcl_1_1FirstType.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvcl_1_1FirstType_3_01TypeWrapper_3_01Args_8_8_8_01_4_01_4.html">vcl::FirstType&lt; TypeWrapper&lt; Args... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the first type of a pack of types (variadic templates) or a <a class="el" href="structvcl_1_1TypeWrapper.html" title="A simple structure that wraps a list of variadic templates, without instantiating anything....">TypeWrapper</a>.    <a href="structvcl_1_1FirstType_3_01TypeWrapper_3_01Args_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvcl_1_1ForEachType.html">vcl::ForEachType&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows to apply a function to each type in a variadic template pack.  <a href="structvcl_1_1ForEachType.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvcl_1_1FilterTypesByCondition.html">vcl::FilterTypesByCondition&lt; class,... &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all types that do not satisfy a condition, and get them as a tuple.  <a href="structvcl_1_1FilterTypesByCondition.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvcl_1_1FilterTypesByCondition_3_01Pred_00_01Head_00_01Tail_8_8_8_01_4.html">vcl::FilterTypesByCondition&lt; Pred, Head, Tail... &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all types that do not satisfy a condition, and get them as a tuple.    <a href="structvcl_1_1FilterTypesByCondition_3_01Pred_00_01Head_00_01Tail_8_8_8_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvcl_1_1FilterTypesByCondition_3_01Pred_00_01TypeWrapper_3_01Tail_8_8_8_01_4_01_4.html">vcl::FilterTypesByCondition&lt; Pred, TypeWrapper&lt; Tail... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all types that do not satisfy a condition, and get them as a tuple.    <a href="structvcl_1_1FilterTypesByCondition_3_01Pred_00_01TypeWrapper_3_01Tail_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvcl_1_1TypesSatisfyCondition.html">vcl::TypesSatisfyCondition&lt; Pred, Args &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Its value is set to true if there is at least one type in the given pack Args... that satisfies the given condition.  <a href="structvcl_1_1TypesSatisfyCondition.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvcl_1_1TypesSatisfyCondition_3_01Pred_00_01TypeWrapper_3_01Args_8_8_8_01_4_01_4.html">vcl::TypesSatisfyCondition&lt; Pred, TypeWrapper&lt; Args... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Its value is set to true if there is at least one type in the given pack Args... that satisfies the given condition.    <a href="structvcl_1_1TypesSatisfyCondition_3_01Pred_00_01TypeWrapper_3_01Args_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvcl_1_1GetTypeByCondition.html">vcl::GetTypeByCondition&lt; Pred, Args &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The the first type of a pack that satisfies the given condition.  <a href="structvcl_1_1GetTypeByCondition.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvcl_1_1GetTypeByCondition_3_01Pred_00_01TypeWrapper_3_01Args_8_8_8_01_4_01_4.html">vcl::GetTypeByCondition&lt; Pred, TypeWrapper&lt; Args... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The the first type of a pack that satisfies the given condition.    <a href="structvcl_1_1GetTypeByCondition_3_01Pred_00_01TypeWrapper_3_01Args_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1View.html">vcl::View&lt; It &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classvcl_1_1View.html" title="The View class is a simple class that stores and exposes two iterators begin and end.">View</a> class is a simple class that stores and exposes two iterators begin and end.  <a href="classvcl_1_1View.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gaacc96304be3365c944d0239dd550f74e" id="r_gaacc96304be3365c944d0239dd550f74e"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classvcl_1_1Box.html">typename</a> T &gt; </td></tr>
<tr class="memitem:gaacc96304be3365c944d0239dd550f74e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Box.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__types.html#gaacc96304be3365c944d0239dd550f74e">vcl::MakeConstPointerT</a> = <a class="el" href="classvcl_1_1Box.html">typename</a> <a class="el" href="structvcl_1_1MakeConstPointer.html">MakeConstPointer</a>&lt; T &gt;::type</td></tr>
<tr class="memdesc:gaacc96304be3365c944d0239dd550f74e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility alias for the <a class="el" href="structvcl_1_1MakeConstPointer.html" title="Utility type that makes possible to treat const pointers in a templated class that can treat a both c...">MakeConstPointer</a> type.  <br /></td></tr>
<tr class="separator:gaacc96304be3365c944d0239dd550f74e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a37fc3ccf3b54b062d37fe46900e112" id="r_ga8a37fc3ccf3b54b062d37fe46900e112"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classvcl_1_1Box.html">typename</a> derived , <a class="el" href="classvcl_1_1Box.html">template</a>&lt; typename... &gt; <a class="el" href="classvcl_1_1Box.html">class</a> base&gt; </td></tr>
<tr class="memitem:ga8a37fc3ccf3b54b062d37fe46900e112"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Box.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__types.html#ga8a37fc3ccf3b54b062d37fe46900e112">vcl::IsDerivedFromTemplateSpecialization</a> = std::invoke_result&lt; detail::IsDerivedFromImplementation&lt; <a class="el" href="classvcl_1_1Box.html">base</a> &gt;, <a class="el" href="classvcl_1_1Box.html">typename</a> std::remove_cv&lt; derived &gt;::type * &gt;::type</td></tr>
<tr class="memdesc:ga8a37fc3ccf3b54b062d37fe46900e112"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility class that allows to check if given class 'Derived' is derived from a specialization of a templated class.  <br /></td></tr>
<tr class="separator:ga8a37fc3ccf3b54b062d37fe46900e112"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25fc582d09d14f037e742c66fd58dbeb" id="r_ga25fc582d09d14f037e742c66fd58dbeb"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classvcl_1_1Box.html">typename</a> T &gt; </td></tr>
<tr class="memitem:ga25fc582d09d14f037e742c66fd58dbeb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Box.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__types.html#ga25fc582d09d14f037e742c66fd58dbeb">vcl::RemovePtr</a> = std::remove_pointer_t&lt; T &gt;</td></tr>
<tr class="memdesc:ga25fc582d09d14f037e742c66fd58dbeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility alias to get a type without the pointer. e.g. If T is int*, the resulting type is int.  <br /></td></tr>
<tr class="separator:ga25fc582d09d14f037e742c66fd58dbeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c494877e683bb96964551900501a466" id="r_ga5c494877e683bb96964551900501a466"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classvcl_1_1Box.html">typename</a> T &gt; </td></tr>
<tr class="memitem:ga5c494877e683bb96964551900501a466"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Box.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__types.html#ga5c494877e683bb96964551900501a466">vcl::RemoveRef</a> = std::remove_reference_t&lt; T &gt;</td></tr>
<tr class="memdesc:ga5c494877e683bb96964551900501a466"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility alias to get a type type without the reference. e.g. If T is int&amp;, the resulting type is int.  <br /></td></tr>
<tr class="separator:ga5c494877e683bb96964551900501a466"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa1938bcd17ca07bf32500695f422efeb" id="r_gaa1938bcd17ca07bf32500695f422efeb"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classvcl_1_1Box.html">typename</a> T &gt; </td></tr>
<tr class="memitem:gaa1938bcd17ca07bf32500695f422efeb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Box.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__types.html#gaa1938bcd17ca07bf32500695f422efeb">vcl::RemoveCVRefAndPointer</a> = std::remove_cvref_t&lt; <a class="el" href="group__types.html#ga25fc582d09d14f037e742c66fd58dbeb">RemovePtr</a>&lt; T &gt; &gt;</td></tr>
<tr class="memdesc:gaa1938bcd17ca07bf32500695f422efeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility alias to get clean type from an input type that could have a reference or a pointer.  <br /></td></tr>
<tr class="separator:gaa1938bcd17ca07bf32500695f422efeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacfdd7af0f9712ffc6b96c5d27be41965" id="r_gacfdd7af0f9712ffc6b96c5d27be41965"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classvcl_1_1Box.html">typename</a> T &gt; </td></tr>
<tr class="memitem:gacfdd7af0f9712ffc6b96c5d27be41965"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Box.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__types.html#gacfdd7af0f9712ffc6b96c5d27be41965">vcl::RemoveConstFromPointer</a> = std::conditional_t&lt; std::is_pointer_v&lt; T &gt;, std::add_pointer_t&lt; std::remove_cv_t&lt; <a class="el" href="group__types.html#ga25fc582d09d14f037e742c66fd58dbeb">RemovePtr</a>&lt; T &gt; &gt; &gt;, T &gt;</td></tr>
<tr class="memdesc:gacfdd7af0f9712ffc6b96c5d27be41965"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility alias to get a pointer type without the constness. e.g. If T is const int*, the resulting type is int* If the type is not a pointer, it is left as it was.  <br /></td></tr>
<tr class="separator:gacfdd7af0f9712ffc6b96c5d27be41965"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga38c527736a2d0a3d7af0493e228227e3" id="r_ga38c527736a2d0a3d7af0493e228227e3"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:ga38c527736a2d0a3d7af0493e228227e3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Box.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__types.html#ga38c527736a2d0a3d7af0493e228227e3">vcl::FirstTypeT</a> = <a class="el" href="classvcl_1_1Box.html">typename</a> <a class="el" href="structvcl_1_1FirstType.html">FirstType</a>&lt; Args... &gt;::type</td></tr>
<tr class="memdesc:ga38c527736a2d0a3d7af0493e228227e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for the type of the first type in a pack of types.  <br /></td></tr>
<tr class="separator:ga38c527736a2d0a3d7af0493e228227e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga35a36b617de9550e23e0c1426a783464" id="r_ga35a36b617de9550e23e0c1426a783464"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__types.html#ga35a36b617de9550e23e0c1426a783464">vcl::PrimitiveType</a> { <br />
&#160;&#160;<b>CHAR</b>
, <b>UCHAR</b>
, <b>SHORT</b>
, <b>USHORT</b>
, <br />
&#160;&#160;<b>INT</b>
, <b>UINT</b>
, <b>FLOAT</b>
, <b>DOUBLE</b>
, <br />
&#160;&#160;<b>NONE</b>
<br />
 }</td></tr>
<tr class="memdesc:ga35a36b617de9550e23e0c1426a783464"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple type that enumerates the main primitive types.  <a href="group__types.html#ga35a36b617de9550e23e0c1426a783464">More...</a><br /></td></tr>
<tr class="separator:ga35a36b617de9550e23e0c1426a783464"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga16a1bfbea022f6766d2f3ebbf69a3b52" id="r_ga16a1bfbea022f6766d2f3ebbf69a3b52"><td class="memItemLeft" align="right" valign="top"><a id="ga16a1bfbea022f6766d2f3ebbf69a3b52" name="ga16a1bfbea022f6766d2f3ebbf69a3b52"></a>enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__types.html#ga16a1bfbea022f6766d2f3ebbf69a3b52">vcl::MatrixStorageType</a> { <b>ROW_MAJOR</b>
, <b>COLUMN_MAJOR</b>
 }</td></tr>
<tr class="memdesc:ga16a1bfbea022f6766d2f3ebbf69a3b52"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple type that enumerates the main storage types for matrices (row or column major). <br /></td></tr>
<tr class="separator:ga16a1bfbea022f6766d2f3ebbf69a3b52"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga9ca8accd2e2b6881a3b2359e56396e77" id="r_ga9ca8accd2e2b6881a3b2359e56396e77"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classvcl_1_1Box.html">typename</a> T &gt; </td></tr>
<tr class="memitem:ga9ca8accd2e2b6881a3b2359e56396e77"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Box.html">constexpr</a> T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__types.html#ga9ca8accd2e2b6881a3b2359e56396e77">vcl::asConst</a> (<a class="el" href="classvcl_1_1Box.html">const</a> T &amp;value) <a class="el" href="classvcl_1_1Box.html">noexcept</a></td></tr>
<tr class="memdesc:ga9ca8accd2e2b6881a3b2359e56396e77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function that converts a const pointer/reference to a non-const pointer/reference.  <br /></td></tr>
<tr class="separator:ga9ca8accd2e2b6881a3b2359e56396e77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga943a3fda661e6e71d8fd7106f41dd878" id="r_ga943a3fda661e6e71d8fd7106f41dd878"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classvcl_1_1Box.html">typename</a> T &gt; </td></tr>
<tr class="memitem:ga943a3fda661e6e71d8fd7106f41dd878"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Box.html">constexpr</a> T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__types.html#ga943a3fda661e6e71d8fd7106f41dd878">vcl::asConst</a> (<a class="el" href="classvcl_1_1Box.html">const</a> T *value) <a class="el" href="classvcl_1_1Box.html">noexcept</a></td></tr>
<tr class="memdesc:ga943a3fda661e6e71d8fd7106f41dd878"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function that converts a const pointer/reference to a non-const pointer/reference.    <br /></td></tr>
<tr class="separator:ga943a3fda661e6e71d8fd7106f41dd878"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe5c457181ae725f99627c541993a3a8" id="r_gabe5c457181ae725f99627c541993a3a8"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classvcl_1_1Box.html">typename</a> T &gt; </td></tr>
<tr class="memitem:gabe5c457181ae725f99627c541993a3a8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Box.html">constexpr</a> T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__types.html#gabe5c457181ae725f99627c541993a3a8">vcl::asConst</a> (T *value) <a class="el" href="classvcl_1_1Box.html">noexcept</a></td></tr>
<tr class="memdesc:gabe5c457181ae725f99627c541993a3a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function that converts a const pointer/reference to a non-const pointer/reference.    <br /></td></tr>
<tr class="separator:gabe5c457181ae725f99627c541993a3a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga86d50e779d2b4fd59e31de5a48e6d112" id="r_ga86d50e779d2b4fd59e31de5a48e6d112"><td class="memTemplParams" colspan="2">template&lt;uint COMP_ID&gt; </td></tr>
<tr class="memitem:ga86d50e779d2b4fd59e31de5a48e6d112"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Box.html">constexpr</a> <a class="el" href="classvcl_1_1Box.html">const</a> <a class="el" href="classvcl_1_1Box.html">char</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__types.html#ga86d50e779d2b4fd59e31de5a48e6d112">vcl::componentEnumString</a> ()</td></tr>
<tr class="memdesc:ga86d50e779d2b4fd59e31de5a48e6d112"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the string associated to the COMP_ID value.  <br /></td></tr>
<tr class="separator:ga86d50e779d2b4fd59e31de5a48e6d112"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0068c984cb7a600004242ea341b506eb" id="r_ga0068c984cb7a600004242ea341b506eb"><td class="memTemplParams" colspan="2">template&lt;uint ELEM_ID&gt; </td></tr>
<tr class="memitem:ga0068c984cb7a600004242ea341b506eb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Box.html">constexpr</a> <a class="el" href="classvcl_1_1Box.html">const</a> <a class="el" href="classvcl_1_1Box.html">char</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__types.html#ga0068c984cb7a600004242ea341b506eb">vcl::elementEnumCString</a> ()</td></tr>
<tr class="memdesc:ga0068c984cb7a600004242ea341b506eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the string associated to the ELEM_ID value.  <br /></td></tr>
<tr class="separator:ga0068c984cb7a600004242ea341b506eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab2bbb176efb4243ea25469bbbd1c53af" id="r_gab2bbb176efb4243ea25469bbbd1c53af"><td class="memTemplParams" colspan="2">template&lt;uint ELEM_ID&gt; </td></tr>
<tr class="memitem:gab2bbb176efb4243ea25469bbbd1c53af"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Box.html">const</a> std::string &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__types.html#gab2bbb176efb4243ea25469bbbd1c53af">vcl::elementEnumString</a> ()</td></tr>
<tr class="memdesc:gab2bbb176efb4243ea25469bbbd1c53af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the string associated to the ELEM_ID value.  <br /></td></tr>
<tr class="separator:gab2bbb176efb4243ea25469bbbd1c53af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaada6c7f7d741d8f7885af287bcc6f746" id="r_gaada6c7f7d741d8f7885af287bcc6f746"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classvcl_1_1Box.html">typename</a> T &gt; </td></tr>
<tr class="memitem:gaada6c7f7d741d8f7885af287bcc6f746"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Box.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__types.html#gaada6c7f7d741d8f7885af287bcc6f746">vcl::dereferencePtr</a> (T &amp;&amp;<a class="el" href="classvcl_1_1Box.html">obj</a>)</td></tr>
<tr class="memdesc:gaada6c7f7d741d8f7885af287bcc6f746"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function that applies the unary operator '*' to the argument only if the object is a pointer.  <br /></td></tr>
<tr class="separator:gaada6c7f7d741d8f7885af287bcc6f746"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae32401c3c5edbdeead1769b4d6160f87" id="r_gae32401c3c5edbdeead1769b4d6160f87"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classvcl_1_1Box.html">typename</a> T &gt; </td></tr>
<tr class="memitem:gae32401c3c5edbdeead1769b4d6160f87"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Box.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__types.html#gae32401c3c5edbdeead1769b4d6160f87">vcl::addressOfObj</a> (T &amp;<a class="el" href="classvcl_1_1Box.html">obj</a>)</td></tr>
<tr class="memdesc:gae32401c3c5edbdeead1769b4d6160f87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function that applies the unary operator '&amp;' to the argument only if it is not a pointer.  <br /></td></tr>
<tr class="separator:gae32401c3c5edbdeead1769b4d6160f87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae01694fdca8b252384be3296f82fa946" id="r_gae01694fdca8b252384be3296f82fa946"><td class="memTemplParams" colspan="2"><a id="gae01694fdca8b252384be3296f82fa946" name="gae01694fdca8b252384be3296f82fa946"></a>
template&lt;<a class="el" href="classvcl_1_1Box.html">typename</a> T , <a class="el" href="classvcl_1_1Box.html">typename</a> U , typename... Us&gt; </td></tr>
<tr class="memitem:gae01694fdca8b252384be3296f82fa946"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Box.html">constexpr</a> uint&#160;</td><td class="memTemplItemRight" valign="bottom"><b>vcl::indexInTypePack</b> ()</td></tr>
<tr class="memdesc:gae01694fdca8b252384be3296f82fa946"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that returns the index of a Type T in a pack of types (variadic templates). The pack is composed of U and Us... <br /></td></tr>
<tr class="separator:gae01694fdca8b252384be3296f82fa946"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac398b3cd16575f92ffc3e6cfd6ba1669" id="r_gac398b3cd16575f92ffc3e6cfd6ba1669"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classvcl_1_1Box.html">typename</a> U , typename... Us&gt; </td></tr>
<tr class="memitem:gac398b3cd16575f92ffc3e6cfd6ba1669"><td class="memTemplItemLeft" align="right" valign="top">uint&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__types.html#gac398b3cd16575f92ffc3e6cfd6ba1669">vcl::indexInTypePack</a> (std::type_index <a class="el" href="classvcl_1_1Box.html">ti</a>)</td></tr>
<tr class="memdesc:gac398b3cd16575f92ffc3e6cfd6ba1669"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that returns the index of the type having the given type_index in a pack of types (variadic templates). The pack is composed of U and Us...  <br /></td></tr>
<tr class="separator:gac398b3cd16575f92ffc3e6cfd6ba1669"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga9ad8104cd9ccfa9352d33bc7e6ba47e6" id="r_ga9ad8104cd9ccfa9352d33bc7e6ba47e6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Box.html">constexpr</a> uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__types.html#ga9ad8104cd9ccfa9352d33bc7e6ba47e6">vcl::UINT_NULL</a> = std::numeric_limits&lt;uint&gt;<a class="el" href="group__math.html#ga45d99c06ee2cb1cd9434fd0e86a1a413">::max</a>()</td></tr>
<tr class="memdesc:ga9ad8104cd9ccfa9352d33bc7e6ba47e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The UINT_NULL value represent a null value of uint that is the maximum value that can be represented with unsigned int.  <br /></td></tr>
<tr class="separator:ga9ad8104cd9ccfa9352d33bc7e6ba47e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d7a7538a2f5867a00048a1b3f32eaa6" id="r_ga4d7a7538a2f5867a00048a1b3f32eaa6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Box.html">constexpr</a> <a class="el" href="classvcl_1_1Box.html">const</a> <a class="el" href="classvcl_1_1Box.html">char</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__types.html#ga4d7a7538a2f5867a00048a1b3f32eaa6">vcl::COMPONENT_ENUM_STRINGS</a> [CompId::COMPONENTS_NUMBER]</td></tr>
<tr class="memdesc:ga4d7a7538a2f5867a00048a1b3f32eaa6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The COMPONENT_ENUM_STRINGS array contains the string representation of the CompId::Enum values.  <br /></td></tr>
<tr class="separator:ga4d7a7538a2f5867a00048a1b3f32eaa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaead83eb7c9cee68431c31c3890cbb10f" id="r_gaead83eb7c9cee68431c31c3890cbb10f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Box.html">constexpr</a> <a class="el" href="classvcl_1_1Box.html">const</a> <a class="el" href="classvcl_1_1Box.html">char</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__types.html#gaead83eb7c9cee68431c31c3890cbb10f">vcl::ELEMENT_ENUM_STRINGS</a> [ElemId::ELEMENTS_NUMBER]</td></tr>
<tr class="memdesc:gaead83eb7c9cee68431c31c3890cbb10f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The ELEMENT_ENUM_STRINGS array contains the string representation of the elements that can compose a mesh.  <br /></td></tr>
<tr class="separator:gaead83eb7c9cee68431c31c3890cbb10f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>The Types module defines all the utility definitions, types, classes and type traits that are common in the library. </p>
<p>This module does not depend on any other module of the library, and it is used by all the other modules to define the types that are used in the library.</p>
<p>You can access all the types of VCLib by including <code>#include &lt;<a class="el" href="types_8h_source.html">vclib/types.h</a>&gt;</code> </p>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga38c527736a2d0a3d7af0493e228227e3" name="ga38c527736a2d0a3d7af0493e228227e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga38c527736a2d0a3d7af0493e228227e3">&#9670;&#160;</a></span>FirstTypeT</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Box.html">using</a> <a class="el" href="group__types.html#ga38c527736a2d0a3d7af0493e228227e3">vcl::FirstTypeT</a> = <a class="el" href="classvcl_1_1Box.html">typedef</a> <a class="el" href="classvcl_1_1Box.html">typename</a> <a class="el" href="structvcl_1_1FirstType.html">FirstType</a>&lt;Args...&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias for the type of the first type in a pack of types. </p>
<p>Usage: </p><div class="fragment"><div class="line"><span class="keyword">using </span><a class="code hl_class" href="classvcl_1_1Box.html">ResType</a> = <a class="code hl_class" href="classvcl_1_1Box.html">FirstTypeT&lt;int, float, double&gt;</a>;</div>
<div class="line"><span class="keyword">static_assert</span>(std::is_same&lt;ResType, int&gt;::value, <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="ttc" id="aclassvcl_1_1Box_html"><div class="ttname"><a href="classvcl_1_1Box.html">vcl::Box</a></div><div class="ttdoc">A class representing a box in N-dimensional space.</div><div class="ttdef"><b>Definition</b> box.h:49</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ga8a37fc3ccf3b54b062d37fe46900e112" name="ga8a37fc3ccf3b54b062d37fe46900e112"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8a37fc3ccf3b54b062d37fe46900e112">&#9670;&#160;</a></span>IsDerivedFromTemplateSpecialization</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classvcl_1_1Box.html">typename</a> derived , <a class="el" href="classvcl_1_1Box.html">template</a>&lt; typename... &gt; <a class="el" href="classvcl_1_1Box.html">class</a> base&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Box.html">using</a> <a class="el" href="group__types.html#ga8a37fc3ccf3b54b062d37fe46900e112">vcl::IsDerivedFromTemplateSpecialization</a> = <a class="el" href="classvcl_1_1Box.html">typedef</a> std::invoke_result&lt; detail::IsDerivedFromImplementation&lt;<a class="el" href="classvcl_1_1Box.html">base</a>&gt;, <a class="el" href="classvcl_1_1Box.html">typename</a> std::remove_cv&lt;derived&gt;::type*&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Utility class that allows to check if given class 'Derived' is derived from a specialization of a templated class. </p>
<p>Given a class X and a templated class C&lt;template T&gt;, it can be used in the following way:</p>
<div class="fragment"><div class="line"><span class="keyword">using </span><a class="code hl_class" href="classvcl_1_1Box.html">myCheck</a> = <a class="code hl_typedef" href="group__types.html#ga8a37fc3ccf3b54b062d37fe46900e112">vcl::IsDerivedFromTemplateSpecialization&lt;X, C&gt;::type</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> <span class="keyword">constexpr</span> (myCheck::value) { ... }</div>
<div class="ttc" id="agroup__types_html_ga8a37fc3ccf3b54b062d37fe46900e112"><div class="ttname"><a href="group__types.html#ga8a37fc3ccf3b54b062d37fe46900e112">vcl::IsDerivedFromTemplateSpecialization</a></div><div class="ttdeci">std::invoke_result&lt; detail::IsDerivedFromImplementation&lt; base &gt;, typename std::remove_cv&lt; derived &gt;::type * &gt;::type IsDerivedFromTemplateSpecialization</div><div class="ttdoc">Utility class that allows to check if given class 'Derived' is derived from a specialization of a tem...</div><div class="ttdef"><b>Definition</b> inheritance.h:69</div></div>
</div><!-- fragment --><p>and will return true if X derives from any specialization of C.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">derived</td><td>The class to be checked. </td></tr>
    <tr><td class="paramname">base</td><td>The templated class to be checked. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaacc96304be3365c944d0239dd550f74e" name="gaacc96304be3365c944d0239dd550f74e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaacc96304be3365c944d0239dd550f74e">&#9670;&#160;</a></span>MakeConstPointerT</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classvcl_1_1Box.html">typename</a> T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Box.html">using</a> <a class="el" href="group__types.html#gaacc96304be3365c944d0239dd550f74e">vcl::MakeConstPointerT</a> = <a class="el" href="classvcl_1_1Box.html">typedef</a> <a class="el" href="classvcl_1_1Box.html">typename</a> <a class="el" href="structvcl_1_1MakeConstPointer.html">MakeConstPointer</a>&lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Utility alias for the <a class="el" href="structvcl_1_1MakeConstPointer.html" title="Utility type that makes possible to treat const pointers in a templated class that can treat a both c...">MakeConstPointer</a> type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type to be converted to a const pointer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gacfdd7af0f9712ffc6b96c5d27be41965" name="gacfdd7af0f9712ffc6b96c5d27be41965"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacfdd7af0f9712ffc6b96c5d27be41965">&#9670;&#160;</a></span>RemoveConstFromPointer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classvcl_1_1Box.html">typename</a> T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Box.html">using</a> <a class="el" href="group__types.html#gacfdd7af0f9712ffc6b96c5d27be41965">vcl::RemoveConstFromPointer</a> = <a class="el" href="classvcl_1_1Box.html">typedef</a> std::conditional_t&lt; std::is_pointer_v&lt;T&gt;, std::add_pointer_t&lt;std::remove_cv_t&lt;<a class="el" href="group__types.html#ga25fc582d09d14f037e742c66fd58dbeb">RemovePtr</a>&lt;T&gt; &gt;&gt;, T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Utility alias to get a pointer type without the constness. e.g. If T is const int*, the resulting type is int* If the type is not a pointer, it is left as it was. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The input type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa1938bcd17ca07bf32500695f422efeb" name="gaa1938bcd17ca07bf32500695f422efeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa1938bcd17ca07bf32500695f422efeb">&#9670;&#160;</a></span>RemoveCVRefAndPointer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classvcl_1_1Box.html">typename</a> T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Box.html">using</a> <a class="el" href="group__types.html#gaa1938bcd17ca07bf32500695f422efeb">vcl::RemoveCVRefAndPointer</a> = <a class="el" href="classvcl_1_1Box.html">typedef</a> std::remove_cvref_t&lt;<a class="el" href="group__types.html#ga25fc582d09d14f037e742c66fd58dbeb">RemovePtr</a>&lt;T&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Utility alias to get clean type from an input type that could have a reference or a pointer. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The input type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga25fc582d09d14f037e742c66fd58dbeb" name="ga25fc582d09d14f037e742c66fd58dbeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga25fc582d09d14f037e742c66fd58dbeb">&#9670;&#160;</a></span>RemovePtr</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classvcl_1_1Box.html">typename</a> T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Box.html">using</a> <a class="el" href="group__types.html#ga25fc582d09d14f037e742c66fd58dbeb">vcl::RemovePtr</a> = <a class="el" href="classvcl_1_1Box.html">typedef</a> std::remove_pointer_t&lt;T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Utility alias to get a type without the pointer. e.g. If T is int*, the resulting type is int. </p>
<p>It corresponds to std::remove_pointer_t.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The input type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5c494877e683bb96964551900501a466" name="ga5c494877e683bb96964551900501a466"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5c494877e683bb96964551900501a466">&#9670;&#160;</a></span>RemoveRef</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classvcl_1_1Box.html">typename</a> T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Box.html">using</a> <a class="el" href="group__types.html#ga5c494877e683bb96964551900501a466">vcl::RemoveRef</a> = <a class="el" href="classvcl_1_1Box.html">typedef</a> std::remove_reference_t&lt;T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Utility alias to get a type type without the reference. e.g. If T is int&amp;, the resulting type is int. </p>
<p>It corresponds to std::remove_reference_t.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The input type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga35a36b617de9550e23e0c1426a783464" name="ga35a36b617de9550e23e0c1426a783464"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga35a36b617de9550e23e0c1426a783464">&#9670;&#160;</a></span>PrimitiveType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Box.html">enum</a> <a class="el" href="classvcl_1_1Box.html">class</a> <a class="el" href="group__types.html#ga35a36b617de9550e23e0c1426a783464">vcl::PrimitiveType</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A simple type that enumerates the main primitive types. </p>
<p>It is used mostly for I/O operations, but can be useful in any context where a type must be described in a variable at runtime. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gae32401c3c5edbdeead1769b4d6160f87" name="gae32401c3c5edbdeead1769b4d6160f87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae32401c3c5edbdeead1769b4d6160f87">&#9670;&#160;</a></span>addressOfObj()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classvcl_1_1Box.html">typename</a> T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Box.html">auto</a> vcl::addressOfObj </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Utility function that applies the unary operator '&amp;' to the argument only if it is not a pointer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the address of 'obj' if obj is not a pointer, or obj if it is a pointer. </dd></dl>

</div>
</div>
<a id="ga9ca8accd2e2b6881a3b2359e56396e77" name="ga9ca8accd2e2b6881a3b2359e56396e77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9ca8accd2e2b6881a3b2359e56396e77">&#9670;&#160;</a></span>asConst() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classvcl_1_1Box.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Box.html">constexpr</a> T &amp; vcl::asConst </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">const</a> T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Utility function that converts a const pointer/reference to a non-const pointer/reference. </p>
<p>It is useful when you need to re-use the same code for const and non-const member functions.</p>
<dl class="section warning"><dt>Warning</dt><dd>The function should be used only in contexts where the constness of the pointer/reference is guaranteed to be removed (see <a href="https://en.cppreference.com/w/cpp/language/const_cast">const_cast</a>).</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the pointer/reference. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The const pointer/reference to be const-casted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The non-const pointer/reference. </dd></dl>

</div>
</div>
<a id="ga943a3fda661e6e71d8fd7106f41dd878" name="ga943a3fda661e6e71d8fd7106f41dd878"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga943a3fda661e6e71d8fd7106f41dd878">&#9670;&#160;</a></span>asConst() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classvcl_1_1Box.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Box.html">constexpr</a> T * vcl::asConst </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">const</a> T *&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Utility function that converts a const pointer/reference to a non-const pointer/reference.   </p>
<p>It is useful when you need to re-use the same code for const and non-const member functions.</p>
<dl class="section warning"><dt>Warning</dt><dd>The function should be used only in contexts where the constness of the pointer/reference is guaranteed to be removed (see <a href="https://en.cppreference.com/w/cpp/language/const_cast">const_cast</a>).</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the pointer/reference. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The const pointer/reference to be const-casted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The non-const pointer/reference.   </dd></dl>

</div>
</div>
<a id="gabe5c457181ae725f99627c541993a3a8" name="gabe5c457181ae725f99627c541993a3a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabe5c457181ae725f99627c541993a3a8">&#9670;&#160;</a></span>asConst() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classvcl_1_1Box.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Box.html">constexpr</a> T * vcl::asConst </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Utility function that converts a const pointer/reference to a non-const pointer/reference.   </p>
<p>It is useful when you need to re-use the same code for const and non-const member functions.</p>
<dl class="section warning"><dt>Warning</dt><dd>The function should be used only in contexts where the constness of the pointer/reference is guaranteed to be removed (see <a href="https://en.cppreference.com/w/cpp/language/const_cast">const_cast</a>).</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the pointer/reference. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The const pointer/reference to be const-casted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The non-const pointer/reference.   </dd></dl>

</div>
</div>
<a id="ga86d50e779d2b4fd59e31de5a48e6d112" name="ga86d50e779d2b4fd59e31de5a48e6d112"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga86d50e779d2b4fd59e31de5a48e6d112">&#9670;&#160;</a></span>componentEnumString()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;uint COMP_ID&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Box.html">constexpr</a> <a class="el" href="classvcl_1_1Box.html">const</a> <a class="el" href="classvcl_1_1Box.html">char</a> * vcl::componentEnumString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the string associated to the COMP_ID value. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">COMP_ID</td><td>an unsigned integer that identifies the component. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The string associated to the COMP_ID value. </dd></dl>

</div>
</div>
<a id="gaada6c7f7d741d8f7885af287bcc6f746" name="gaada6c7f7d741d8f7885af287bcc6f746"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaada6c7f7d741d8f7885af287bcc6f746">&#9670;&#160;</a></span>dereferencePtr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classvcl_1_1Box.html">typename</a> T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Box.html">auto</a> vcl::dereferencePtr </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Utility function that applies the unary operator '*' to the argument only if the object is a pointer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>obj if it is not a pointer, or *obj if it is a pointer. </dd></dl>

</div>
</div>
<a id="ga0068c984cb7a600004242ea341b506eb" name="ga0068c984cb7a600004242ea341b506eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0068c984cb7a600004242ea341b506eb">&#9670;&#160;</a></span>elementEnumCString()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;uint ELEM_ID&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Box.html">constexpr</a> <a class="el" href="classvcl_1_1Box.html">const</a> <a class="el" href="classvcl_1_1Box.html">char</a> * vcl::elementEnumCString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the string associated to the ELEM_ID value. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ELEM_ID</td><td>an unsigned integer that identifies the element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The string associated to the ELEM_ID value. </dd></dl>

</div>
</div>
<a id="gab2bbb176efb4243ea25469bbbd1c53af" name="gab2bbb176efb4243ea25469bbbd1c53af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab2bbb176efb4243ea25469bbbd1c53af">&#9670;&#160;</a></span>elementEnumString()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;uint ELEM_ID&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Box.html">const</a> std::string &amp; vcl::elementEnumString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the string associated to the ELEM_ID value. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ELEM_ID</td><td>an unsigned integer that identifies the element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The string associated to the ELEM_ID value. </dd></dl>

</div>
</div>
<a id="gac398b3cd16575f92ffc3e6cfd6ba1669" name="gac398b3cd16575f92ffc3e6cfd6ba1669"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac398b3cd16575f92ffc3e6cfd6ba1669">&#9670;&#160;</a></span>indexInTypePack()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classvcl_1_1Box.html">typename</a> U , typename... Us&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">uint vcl::indexInTypePack </td>
          <td>(</td>
          <td class="paramtype">std::type_index&#160;</td>
          <td class="paramname"><em>ti</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that returns the index of the type having the given type_index in a pack of types (variadic templates). The pack is composed of U and Us... </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ti</td><td>the type_index of the type to search. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ga4d7a7538a2f5867a00048a1b3f32eaa6" name="ga4d7a7538a2f5867a00048a1b3f32eaa6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4d7a7538a2f5867a00048a1b3f32eaa6">&#9670;&#160;</a></span>COMPONENT_ENUM_STRINGS</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Box.html">constexpr</a> <a class="el" href="classvcl_1_1Box.html">const</a> <a class="el" href="classvcl_1_1Box.html">char</a>* vcl::COMPONENT_ENUM_STRINGS[CompId::COMPONENTS_NUMBER]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {</div>
<div class="line">    <span class="stringliteral">&quot;BitFlags&quot;</span>,</div>
<div class="line">    <span class="stringliteral">&quot;Coordinate&quot;</span>,</div>
<div class="line">    <span class="stringliteral">&quot;Normal&quot;</span>,</div>
<div class="line">    <span class="stringliteral">&quot;Color&quot;</span>,</div>
<div class="line">    <span class="stringliteral">&quot;Quality&quot;</span>,</div>
<div class="line">    <span class="stringliteral">&quot;Mark&quot;</span>,</div>
<div class="line">    <span class="stringliteral">&quot;PrincipalCurvature&quot;</span>,</div>
<div class="line">    <span class="stringliteral">&quot;TexCoord&quot;</span>,</div>
<div class="line">    <span class="stringliteral">&quot;VertexPointers&quot;</span>,</div>
<div class="line">    <span class="stringliteral">&quot;AdjacentEdges&quot;</span>,</div>
<div class="line">    <span class="stringliteral">&quot;AdjacentFaces&quot;</span>,</div>
<div class="line">    <span class="stringliteral">&quot;AdjacentVertices&quot;</span>,</div>
<div class="line">    <span class="stringliteral">&quot;WedgeColors&quot;</span>,</div>
<div class="line">    <span class="stringliteral">&quot;WedgeTexCoords&quot;</span>,</div>
<div class="line">    <span class="stringliteral">&quot;BoundingBox&quot;</span>,</div>
<div class="line">    <span class="stringliteral">&quot;Name&quot;</span>,</div>
<div class="line">    <span class="stringliteral">&quot;TextureImages&quot;</span>,</div>
<div class="line">    <span class="stringliteral">&quot;TexturePaths&quot;</span>,</div>
<div class="line">    <span class="stringliteral">&quot;TransformMatrix&quot;</span>,</div>
<div class="line">    <span class="stringliteral">&quot;CustomComponents&quot;</span>,</div>
<div class="line">}</div>
</div><!-- fragment -->
<p>The COMPONENT_ENUM_STRINGS array contains the string representation of the CompId::Enum values. </p>

</div>
</div>
<a id="gaead83eb7c9cee68431c31c3890cbb10f" name="gaead83eb7c9cee68431c31c3890cbb10f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaead83eb7c9cee68431c31c3890cbb10f">&#9670;&#160;</a></span>ELEMENT_ENUM_STRINGS</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Box.html">constexpr</a> <a class="el" href="classvcl_1_1Box.html">const</a> <a class="el" href="classvcl_1_1Box.html">char</a>* vcl::ELEMENT_ENUM_STRINGS[ElemId::ELEMENTS_NUMBER]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {</div>
<div class="line">    <span class="stringliteral">&quot;Vertex&quot;</span>,</div>
<div class="line">    <span class="stringliteral">&quot;Face&quot;</span>,</div>
<div class="line">    <span class="stringliteral">&quot;Edge&quot;</span>,</div>
<div class="line">}</div>
</div><!-- fragment -->
<p>The ELEMENT_ENUM_STRINGS array contains the string representation of the elements that can compose a mesh. </p>

</div>
</div>
<a id="ga9ad8104cd9ccfa9352d33bc7e6ba47e6" name="ga9ad8104cd9ccfa9352d33bc7e6ba47e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9ad8104cd9ccfa9352d33bc7e6ba47e6">&#9670;&#160;</a></span>UINT_NULL</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Box.html">constexpr</a> uint vcl::UINT_NULL = std::numeric_limits&lt;uint&gt;<a class="el" href="group__math.html#ga45d99c06ee2cb1cd9434fd0e86a1a413">::max</a>()</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The UINT_NULL value represent a null value of uint that is the maximum value that can be represented with unsigned int. </p>
<p>Allows to fully use all the possible values (except one) that can be represented in an unsigned int, but with the possibility to flag whether the value is not initialized or is set to null. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
