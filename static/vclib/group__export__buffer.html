<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Visual Computing Library: Export Mesh to Buffer Algorithms</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
       <script type="text/javascript">
           DoxygenAwesomeDarkModeToggle.init()
       </script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Visual Computing Library
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group__export__buffer.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Export Mesh to Buffer Algorithms<div class="ingroups"><a class="el" href="group__algorithms__mesh.html">Mesh Algorithms</a> &raquo; <a class="el" href="group__import__export.html">Import/Export Mesh Algorithms</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>List Export Mesh to Buffer algorithms.  
<a href="#details">More...</a></p>
<div class="dynheader">
Collaboration diagram for Export Mesh to Buffer Algorithms:</div>
<div class="dyncontent">
<div class="center"><img src="group__export__buffer.png" border="0" usemap="#agroup____export____buffer" alt=""/></div>
<map name="agroup____export____buffer" id="agroup____export____buffer">
<area shape="rect" title="List Export Mesh to Buffer algorithms." alt="" coords="204,5,367,45"/>
<area shape="rect" href="group__import__export.html" title="List of Import/Export Mesh algorithms." alt="" coords="5,5,156,45"/>
</map>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gadd65e2cf3ef4cbfcac92c9f2a25607e2" id="r_gadd65e2cf3ef4cbfcac92c9f2a25607e2"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:gadd65e2cf3ef4cbfcac92c9f2a25607e2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Box.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__export__buffer.html#gadd65e2cf3ef4cbfcac92c9f2a25607e2">vcl::vertexCoordsToBuffer</a> (<a class="el" href="classvcl_1_1Box.html">const</a> MeshType &amp;mesh, <a class="el" href="classvcl_1_1Box.html">auto</a> *buffer, <a class="el" href="group__types.html#ga16a1bfbea022f6766d2f3ebbf69a3b52">MatrixStorageType</a> <a class="el" href="classvcl_1_1Box.html">storage</a>=MatrixStorageType::ROW_MAJOR)</td></tr>
<tr class="memdesc:gadd65e2cf3ef4cbfcac92c9f2a25607e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Export the vertex coordinates of a mesh to a buffer.  <br /></td></tr>
<tr class="separator:gadd65e2cf3ef4cbfcac92c9f2a25607e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a15ad1e73eb0d8db710cef7826b0e8c" id="r_ga4a15ad1e73eb0d8db710cef7826b0e8c"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga4a15ad1e73eb0d8db710cef7826b0e8c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Box.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__export__buffer.html#ga4a15ad1e73eb0d8db710cef7826b0e8c">vcl::triangleIndicesToBuffer</a> (<a class="el" href="classvcl_1_1Box.html">const</a> MeshType &amp;mesh, <a class="el" href="classvcl_1_1Box.html">auto</a> *buffer, <a class="el" href="group__types.html#ga16a1bfbea022f6766d2f3ebbf69a3b52">MatrixStorageType</a> <a class="el" href="classvcl_1_1Box.html">storage</a>=MatrixStorageType::ROW_MAJOR, <a class="el" href="classvcl_1_1Box.html">bool</a> <a class="el" href="classvcl_1_1Box.html">getIndicesAsIfContainerCompact</a>=<a class="el" href="classvcl_1_1Box.html">true</a>)</td></tr>
<tr class="memdesc:ga4a15ad1e73eb0d8db710cef7826b0e8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Export into a buffer the vertex indices for each triangle of a <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>.  <br /></td></tr>
<tr class="separator:ga4a15ad1e73eb0d8db710cef7826b0e8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad458d46401c443ee325a7bc9200a578a" id="r_gad458d46401c443ee325a7bc9200a578a"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:gad458d46401c443ee325a7bc9200a578a"><td class="memTemplItemLeft" align="right" valign="top">uint&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__export__buffer.html#gad458d46401c443ee325a7bc9200a578a">vcl::faceSizesToBuffer</a> (<a class="el" href="classvcl_1_1Box.html">const</a> MeshType &amp;mesh, <a class="el" href="classvcl_1_1Box.html">auto</a> *buffer)</td></tr>
<tr class="memdesc:gad458d46401c443ee325a7bc9200a578a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Export into a buffer the sizes of the faces of a <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>, and return the sum of the sizes.  <br /></td></tr>
<tr class="separator:gad458d46401c443ee325a7bc9200a578a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d8d20f3cc27e22f326932cd22843fa5" id="r_ga4d8d20f3cc27e22f326932cd22843fa5"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga4d8d20f3cc27e22f326932cd22843fa5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Box.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__export__buffer.html#ga4d8d20f3cc27e22f326932cd22843fa5">vcl::faceIndicesToBuffer</a> (<a class="el" href="classvcl_1_1Box.html">const</a> MeshType &amp;mesh, <a class="el" href="classvcl_1_1Box.html">auto</a> *buffer, <a class="el" href="classvcl_1_1Box.html">bool</a> <a class="el" href="classvcl_1_1Box.html">getIndicesAsIfContainerCompact</a>=<a class="el" href="classvcl_1_1Box.html">true</a>)</td></tr>
<tr class="memdesc:ga4d8d20f3cc27e22f326932cd22843fa5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Export into a buffer the vertex indices for each face of a <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>. Faces can be polygons.  <br /></td></tr>
<tr class="separator:ga4d8d20f3cc27e22f326932cd22843fa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46dfedf23adf518c217dc56c8b8089d5" id="r_ga46dfedf23adf518c217dc56c8b8089d5"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga46dfedf23adf518c217dc56c8b8089d5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Box.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__export__buffer.html#ga46dfedf23adf518c217dc56c8b8089d5">vcl::faceIndicesToBuffer</a> (<a class="el" href="classvcl_1_1Box.html">const</a> MeshType &amp;mesh, <a class="el" href="classvcl_1_1Box.html">auto</a> *buffer, uint largestFaceSize, <a class="el" href="group__types.html#ga16a1bfbea022f6766d2f3ebbf69a3b52">MatrixStorageType</a> <a class="el" href="classvcl_1_1Box.html">storage</a>=MatrixStorageType::ROW_MAJOR, <a class="el" href="classvcl_1_1Box.html">bool</a> <a class="el" href="classvcl_1_1Box.html">getIndicesAsIfContainerCompact</a>=<a class="el" href="classvcl_1_1Box.html">true</a>)</td></tr>
<tr class="memdesc:ga46dfedf23adf518c217dc56c8b8089d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Export into a buffer the vertex indices for each face of a <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>. Faces can be polygons.  <br /></td></tr>
<tr class="separator:ga46dfedf23adf518c217dc56c8b8089d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1536428adc2a72c8eb60d3e92b0fce32" id="r_ga1536428adc2a72c8eb60d3e92b0fce32"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga1536428adc2a72c8eb60d3e92b0fce32"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Box.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__export__buffer.html#ga1536428adc2a72c8eb60d3e92b0fce32">vcl::triangulatedFaceIndicesToBuffer</a> (<a class="el" href="classvcl_1_1Box.html">const</a> MeshType &amp;mesh, <a class="el" href="classvcl_1_1Box.html">auto</a> *buffer, <a class="el" href="classvcl_1_1TriPolyIndexBiMap.html">TriPolyIndexBiMap</a> &amp;indexMap=detail::indexMap, <a class="el" href="group__types.html#ga16a1bfbea022f6766d2f3ebbf69a3b52">MatrixStorageType</a> <a class="el" href="classvcl_1_1Box.html">storage</a>=MatrixStorageType::ROW_MAJOR, uint <a class="el" href="classvcl_1_1Box.html">numTriangles</a>=<a class="el" href="group__types.html#ga9ad8104cd9ccfa9352d33bc7e6ba47e6">UINT_NULL</a>, <a class="el" href="classvcl_1_1Box.html">bool</a> <a class="el" href="classvcl_1_1Box.html">getIndicesAsIfContainerCompact</a>=<a class="el" href="classvcl_1_1Box.html">true</a>)</td></tr>
<tr class="memdesc:ga1536428adc2a72c8eb60d3e92b0fce32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Export into a buffer the vertex indices for each triangle computed by triangulating the faces of a <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>.  <br /></td></tr>
<tr class="separator:ga1536428adc2a72c8eb60d3e92b0fce32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1647baf4c196a36decbd605065ad1005" id="r_ga1647baf4c196a36decbd605065ad1005"><td class="memTemplParams" colspan="2">template&lt;EdgeMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga1647baf4c196a36decbd605065ad1005"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Box.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__export__buffer.html#ga1647baf4c196a36decbd605065ad1005">vcl::edgeIndicesToBuffer</a> (<a class="el" href="classvcl_1_1Box.html">const</a> MeshType &amp;mesh, <a class="el" href="classvcl_1_1Box.html">auto</a> *buffer, <a class="el" href="group__types.html#ga16a1bfbea022f6766d2f3ebbf69a3b52">MatrixStorageType</a> <a class="el" href="classvcl_1_1Box.html">storage</a>=MatrixStorageType::ROW_MAJOR, <a class="el" href="classvcl_1_1Box.html">bool</a> <a class="el" href="classvcl_1_1Box.html">getIndicesAsIfContainerCompact</a>=<a class="el" href="classvcl_1_1Box.html">true</a>)</td></tr>
<tr class="memdesc:ga1647baf4c196a36decbd605065ad1005"><td class="mdescLeft">&#160;</td><td class="mdescRight">Export into a buffer the vertex indices for each edge of a <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>.  <br /></td></tr>
<tr class="separator:ga1647baf4c196a36decbd605065ad1005"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>List Export Mesh to Buffer algorithms. </p>
<p>They allow to export mesh data to pre-allocated buffers.</p>
<p>You can access these algorithms by including <code>#include &lt;<a class="el" href="import__export_8h_source.html">vclib/algorithms/mesh/import_export.h</a>&gt;</code> </p>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga1647baf4c196a36decbd605065ad1005" name="ga1647baf4c196a36decbd605065ad1005"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1647baf4c196a36decbd605065ad1005">&#9670;&#160;</a></span>edgeIndicesToBuffer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;EdgeMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Box.html">void</a> vcl::edgeIndicesToBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">const</a> MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">auto</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga16a1bfbea022f6766d2f3ebbf69a3b52">MatrixStorageType</a>&#160;</td>
          <td class="paramname"><em>storage</em> = <code>MatrixStorageType::ROW_MAJOR</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">bool</a>&#160;</td>
          <td class="paramname"><em>getIndicesAsIfContainerCompact</em> = <code><a class="el" href="classvcl_1_1Box.html">true</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Export into a buffer the vertex indices for each edge of a <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>. </p>
<p>This function exports the vertex indices of the edges of a mesh to a buffer. Indices are stored following the order the edges appear in the mesh. The buffer must be preallocated with the correct size (number of edges times 2).</p>
<dl class="section note"><dt>Note</dt><dd>As a default behaviour (<code>getIndicesAsIfContainerCompact == true</code>) the function stores the vertex indices as if the vertex container of the mesh is compact. This means that, if the mesh has deleted vertices, the vertex indices stored in the buffer may not correspond to the vertex indices of the mesh. If you want to store the actual vertex indices in the input mesh, set <code>getIndicesAsIfContainerCompact</code> to false.</dd>
<dd>
This function does not guarantee that the rows of the matrix correspond to the edge indices of the mesh. This scenario is possible when the mesh has deleted edges. To be sure to have a direct correspondence, compact the edge container before calling this function.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>input mesh </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buffer</td><td>preallocated buffer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">storage</td><td>storage type of the matrix (row or column major) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">getIndicesAsIfContainerCompact</td><td>if true, the function will store the vertex indices as if the vertex container of the mesh is compact. If false, the actual vertex indices in the input mesh will be stored. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4d8d20f3cc27e22f326932cd22843fa5" name="ga4d8d20f3cc27e22f326932cd22843fa5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4d8d20f3cc27e22f326932cd22843fa5">&#9670;&#160;</a></span>faceIndicesToBuffer() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Box.html">void</a> vcl::faceIndicesToBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">const</a> MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">auto</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">bool</a>&#160;</td>
          <td class="paramname"><em>getIndicesAsIfContainerCompact</em> = <code><a class="el" href="classvcl_1_1Box.html">true</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Export into a buffer the vertex indices for each face of a <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>. Faces can be polygons. </p>
<p>This function exports the vertex indices of the polygonal faces of a mesh to a buffer. Indices are stored consecutively in the buffer, following the order the faces appear in the mesh. The buffer must be preallocated with the correct size (sum of the sizes of the faces).</p>
<p>You can use the function <a class="el" href="group__export__buffer.html#gad458d46401c443ee325a7bc9200a578a">vcl::faceSizesToBuffer</a> to get the sizes of the faces and allocate the buffer accordingly:</p>
<div class="fragment"><div class="line">std::vector&lt;uint&gt; <a class="code hl_class" href="classvcl_1_1Box.html">faceSizes</a>(<a class="code hl_class" href="classvcl_1_1Box.html">myMesh</a>.faceNumber());</div>
<div class="line">uint sum = <a class="code hl_function" href="group__export__buffer.html#gad458d46401c443ee325a7bc9200a578a">vcl::faceSizesToBuffer</a>(<a class="code hl_class" href="classvcl_1_1Box.html">myMesh</a>, <a class="code hl_class" href="classvcl_1_1Box.html">sizes</a>.data());</div>
<div class="line">std::vector&lt;uint&gt; <a class="code hl_class" href="classvcl_1_1Box.html">faceIndices</a>(sum);</div>
<div class="line"><a class="code hl_function" href="group__export__buffer.html#ga4d8d20f3cc27e22f326932cd22843fa5">vcl::faceIndicesToBuffer</a>(<a class="code hl_class" href="classvcl_1_1Box.html">myMesh</a>, <a class="code hl_class" href="classvcl_1_1Box.html">faceIndices</a>.data());</div>
<div class="line"> </div>
<div class="line"><span class="comment">// read indices for each face</span></div>
<div class="line">uint offset = 0;</div>
<div class="line"><span class="keywordflow">for</span> (uint <a class="code hl_class" href="classvcl_1_1Box.html">i</a> = 0; <a class="code hl_class" href="classvcl_1_1Box.html">i</a> &lt; <a class="code hl_class" href="classvcl_1_1Box.html">myMesh</a>.faceNumber(); ++<a class="code hl_class" href="classvcl_1_1Box.html">i</a>) {</div>
<div class="line">    uint size = <a class="code hl_class" href="classvcl_1_1Box.html">faceSizes</a>[<a class="code hl_class" href="classvcl_1_1Box.html">i</a>];</div>
<div class="line">    <span class="keywordflow">for</span> (uint <a class="code hl_class" href="classvcl_1_1Box.html">j</a> = 0; <a class="code hl_class" href="classvcl_1_1Box.html">j</a> &lt; size; ++<a class="code hl_class" href="classvcl_1_1Box.html">j</a>) {</div>
<div class="line">        uint <a class="code hl_class" href="classvcl_1_1Box.html">vIdx</a> = <a class="code hl_class" href="classvcl_1_1Box.html">faceIndices</a>[offset + <a class="code hl_class" href="classvcl_1_1Box.html">j</a>];</div>
<div class="line">        <span class="comment">// do something with the vertex index</span></div>
<div class="line">    }</div>
<div class="line">    offset += size;</div>
<div class="line">}</div>
<div class="ttc" id="aclassvcl_1_1Box_html"><div class="ttname"><a href="classvcl_1_1Box.html">vcl::Box</a></div><div class="ttdoc">A class representing a box in N-dimensional space.</div><div class="ttdef"><b>Definition</b> box.h:49</div></div>
<div class="ttc" id="agroup__export__buffer_html_ga4d8d20f3cc27e22f326932cd22843fa5"><div class="ttname"><a href="group__export__buffer.html#ga4d8d20f3cc27e22f326932cd22843fa5">vcl::faceIndicesToBuffer</a></div><div class="ttdeci">void faceIndicesToBuffer(const MeshType &amp;mesh, auto *buffer, bool getIndicesAsIfContainerCompact=true)</div><div class="ttdoc">Export into a buffer the vertex indices for each face of a Mesh. Faces can be polygons.</div><div class="ttdef"><b>Definition</b> export_buffer.h:272</div></div>
<div class="ttc" id="agroup__export__buffer_html_gad458d46401c443ee325a7bc9200a578a"><div class="ttname"><a href="group__export__buffer.html#gad458d46401c443ee325a7bc9200a578a">vcl::faceSizesToBuffer</a></div><div class="ttdeci">uint faceSizesToBuffer(const MeshType &amp;mesh, auto *buffer)</div><div class="ttdoc">Export into a buffer the sizes of the faces of a Mesh, and return the sum of the sizes.</div><div class="ttdef"><b>Definition</b> export_buffer.h:210</div></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>As a default behaviour (<code>getIndicesAsIfContainerCompact == true</code>) the function stores the vertex indices as if the vertex container of the mesh is compact. This means that, if the mesh has deleted vertices, the vertex indices stored in the buffer may not correspond to the vertex indices of the mesh. If you want to store the actual vertex indices in the input mesh, set <code>getIndicesAsIfContainerCompact</code> to false.</dd>
<dd>
This function does not guarantee that the rows of the matrix correspond to the face indices of the mesh. This scenario is possible when the mesh has deleted faces. To be sure to have a direct correspondence, compact the face container before calling this function.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>input mesh </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buffer</td><td>preallocated buffer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">getIndicesAsIfContainerCompact</td><td>if true, the function will store the vertex indices as if the vertex container of the mesh is compact. If false, the actual vertex indices in the input mesh will be stored. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga46dfedf23adf518c217dc56c8b8089d5" name="ga46dfedf23adf518c217dc56c8b8089d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga46dfedf23adf518c217dc56c8b8089d5">&#9670;&#160;</a></span>faceIndicesToBuffer() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Box.html">void</a> vcl::faceIndicesToBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">const</a> MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">auto</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>largestFaceSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga16a1bfbea022f6766d2f3ebbf69a3b52">MatrixStorageType</a>&#160;</td>
          <td class="paramname"><em>storage</em> = <code>MatrixStorageType::ROW_MAJOR</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">bool</a>&#160;</td>
          <td class="paramname"><em>getIndicesAsIfContainerCompact</em> = <code><a class="el" href="classvcl_1_1Box.html">true</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Export into a buffer the vertex indices for each face of a <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>. Faces can be polygons. </p>
<p>This function exports the vertex indices of the polygonal faces of a mesh to a buffer. Indices are stored following the order the faces appear in the mesh. The buffer must be preallocated with the correct size (number of faces times the size of the largest face size). For each face that has less vertices than the largest face size, the remaining indices are set to -1.</p>
<p>You can use the function vcl::largestFaceSize to get the largest face size and allocate the buffer accordingly:</p>
<div class="fragment"><div class="line">uint <a class="code hl_class" href="classvcl_1_1Box.html">lfs</a> = vcl::largestFaceSize(<a class="code hl_class" href="classvcl_1_1Box.html">myMesh</a>);</div>
<div class="line">Eigen::MatrixXi <a class="code hl_class" href="classvcl_1_1Box.html">faceIndices</a>(<a class="code hl_class" href="classvcl_1_1Box.html">myMesh</a>.faceNumber(), <a class="code hl_class" href="classvcl_1_1Box.html">lfs</a>);</div>
<div class="line"><a class="code hl_function" href="group__export__buffer.html#ga4d8d20f3cc27e22f326932cd22843fa5">vcl::faceIndicesToBuffer</a>(</div>
<div class="line">    <a class="code hl_class" href="classvcl_1_1Box.html">myMesh</a>, <a class="code hl_class" href="classvcl_1_1Box.html">faceIndices</a>.data(), <a class="code hl_class" href="classvcl_1_1Box.html">lfs</a>, MatrixStorageType::COLUMN_MAJOR);</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>As a default behaviour (<code>getIndicesAsIfContainerCompact == true</code>) the function stores the vertex indices as if the vertex container of the mesh is compact. This means that, if the mesh has deleted vertices, the vertex indices stored in the buffer may not correspond to the vertex indices of the mesh. If you want to store the actual vertex indices in the input mesh, set <code>getIndicesAsIfContainerCompact</code> to false.</dd>
<dd>
This function does not guarantee that the rows of the matrix correspond to the face indices of the mesh. This scenario is possible when the mesh has deleted faces. To be sure to have a direct correspondence, compact the face container before calling this function.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>input mesh </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buffer</td><td>preallocated buffer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">largestFaceSize</td><td>size of the largest face in the mesh </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">storage</td><td>storage type of the matrix (row or column major) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">getIndicesAsIfContainerCompact</td><td>if true, the function will store the vertex indices as if the vertex container of the mesh is compact. If false, the actual vertex indices in the input mesh will be stored. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad458d46401c443ee325a7bc9200a578a" name="gad458d46401c443ee325a7bc9200a578a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad458d46401c443ee325a7bc9200a578a">&#9670;&#160;</a></span>faceSizesToBuffer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">uint vcl::faceSizesToBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">const</a> MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">auto</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Export into a buffer the sizes of the faces of a <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>, and return the sum of the sizes. </p>
<p>This function could be useful when dealing with polygonal meshes: it exports the sizes of the faces of a mesh to a buffer. Sizes are stored following the order the faces appear in the mesh. The buffer must be preallocated with the correct size (number of faces).</p>
<p>The return value is the sum of the sizes of the faces. This value is useful when you need to allocate a buffer to store the vertex indices of the faces (its size is the sum of the face sizes).</p>
<dl class="section note"><dt>Note</dt><dd>This function does not guarantee that the rows of the matrix correspond to the face indices of the mesh. This scenario is possible when the mesh has deleted faces. To be sure to have a direct correspondence, compact the face container before calling this function.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>input mesh </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buffer</td><td>preallocated buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>sum of the sizes of the faces </dd></dl>

</div>
</div>
<a id="ga4a15ad1e73eb0d8db710cef7826b0e8c" name="ga4a15ad1e73eb0d8db710cef7826b0e8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4a15ad1e73eb0d8db710cef7826b0e8c">&#9670;&#160;</a></span>triangleIndicesToBuffer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Box.html">void</a> vcl::triangleIndicesToBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">const</a> MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">auto</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga16a1bfbea022f6766d2f3ebbf69a3b52">MatrixStorageType</a>&#160;</td>
          <td class="paramname"><em>storage</em> = <code>MatrixStorageType::ROW_MAJOR</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">bool</a>&#160;</td>
          <td class="paramname"><em>getIndicesAsIfContainerCompact</em> = <code><a class="el" href="classvcl_1_1Box.html">true</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Export into a buffer the vertex indices for each triangle of a <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>. </p>
<p>This function exports the vertex indices of the triangles of a mesh to a buffer. Indices are stored following the order the faces appear in the mesh. The buffer must be preallocated with the correct size (number of faces times 3). The function assumes that the input mesh is a triangle mesh (if there are polygonal faces, only the first three vertices are considered).</p>
<dl class="section note"><dt>Note</dt><dd>As a default behaviour (<code>getIndicesAsIfContainerCompact == true</code>) the function stores the vertex indices as if the vertex container of the mesh is compact. This means that, if the mesh has deleted vertices, the vertex indices stored in the buffer may not correspond to the vertex indices of the mesh. If you want to store the actual vertex indices in the input mesh, set <code>getIndicesAsIfContainerCompact</code> to false.</dd>
<dd>
This function does not guarantee that the rows of the matrix correspond to the face indices of the mesh. This scenario is possible when the mesh has deleted faces. To be sure to have a direct correspondence, compact the face container before calling this function.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>input mesh </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buffer</td><td>preallocated buffer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">storage</td><td>storage type of the matrix (row or column major) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">getIndicesAsIfContainerCompact</td><td>if true, the function will store the vertex indices as if the vertex container of the mesh is compact. If false, the actual vertex indices in the input mesh will be stored. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1536428adc2a72c8eb60d3e92b0fce32" name="ga1536428adc2a72c8eb60d3e92b0fce32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1536428adc2a72c8eb60d3e92b0fce32">&#9670;&#160;</a></span>triangulatedFaceIndicesToBuffer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Box.html">void</a> vcl::triangulatedFaceIndicesToBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">const</a> MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">auto</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1TriPolyIndexBiMap.html">TriPolyIndexBiMap</a> &amp;&#160;</td>
          <td class="paramname"><em>indexMap</em> = <code>detail::indexMap</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga16a1bfbea022f6766d2f3ebbf69a3b52">MatrixStorageType</a>&#160;</td>
          <td class="paramname"><em>storage</em> = <code>MatrixStorageType::ROW_MAJOR</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>numTriangles</em> = <code><a class="el" href="group__types.html#ga9ad8104cd9ccfa9352d33bc7e6ba47e6">UINT_NULL</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">bool</a>&#160;</td>
          <td class="paramname"><em>getIndicesAsIfContainerCompact</em> = <code><a class="el" href="classvcl_1_1Box.html">true</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Export into a buffer the vertex indices for each triangle computed by triangulating the faces of a <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>. </p>
<p>This function exports the vertex indices of the triangles computed by triangulating the faces of a mesh to a buffer. Indices are stored following the order the faces appear in the mesh. The buffer must be preallocated with the correct size (number of <em>resulting triangles</em> times 3).</p>
<p>You can use the function vcl::countTriangulatedTriangles to get the number of resulting triangles and allocate the buffer accordingly:</p>
<div class="fragment"><div class="line">uint <a class="code hl_class" href="classvcl_1_1Box.html">numTris</a> = vcl::countTriangulatedTriangles(<a class="code hl_class" href="classvcl_1_1Box.html">myMesh</a>);</div>
<div class="line">Eigen::MatrixXi <a class="code hl_class" href="classvcl_1_1Box.html">triIndices</a>(<a class="code hl_class" href="classvcl_1_1Box.html">numTris</a>, 3);</div>
<div class="line"><a class="code hl_class" href="classvcl_1_1TriPolyIndexBiMap.html">vcl::TriPolyIndexBiMap</a> indexMap;</div>
<div class="line"><a class="code hl_function" href="group__export__buffer.html#ga1536428adc2a72c8eb60d3e92b0fce32">vcl::triangulatedFaceIndicesToBuffer</a>(</div>
<div class="line">    <a class="code hl_class" href="classvcl_1_1Box.html">myMesh</a>, <a class="code hl_class" href="classvcl_1_1Box.html">triIndices</a>.data(), indexMap, MatrixStorageType::COLUMN_MAJOR,</div>
<div class="line">    <a class="code hl_class" href="classvcl_1_1Box.html">numTris</a>);</div>
<div class="ttc" id="aclassvcl_1_1TriPolyIndexBiMap_html"><div class="ttname"><a href="classvcl_1_1TriPolyIndexBiMap.html">vcl::TriPolyIndexBiMap</a></div><div class="ttdoc">The TriPolyIndexBiMap class allows to store a bidirectional mapping between a Polygon Mesh and a Tria...</div><div class="ttdef"><b>Definition</b> tri_poly_index_bimap.h:50</div></div>
<div class="ttc" id="agroup__export__buffer_html_ga1536428adc2a72c8eb60d3e92b0fce32"><div class="ttname"><a href="group__export__buffer.html#ga1536428adc2a72c8eb60d3e92b0fce32">vcl::triangulatedFaceIndicesToBuffer</a></div><div class="ttdeci">void triangulatedFaceIndicesToBuffer(const MeshType &amp;mesh, auto *buffer, TriPolyIndexBiMap &amp;indexMap=detail::indexMap, MatrixStorageType storage=MatrixStorageType::ROW_MAJOR, uint numTriangles=UINT_NULL, bool getIndicesAsIfContainerCompact=true)</div><div class="ttdoc">Export into a buffer the vertex indices for each triangle computed by triangulating the faces of a Me...</div><div class="ttdef"><b>Definition</b> export_buffer.h:417</div></div>
</div><!-- fragment --><p>The input indexMap is used to map each triangle to the face index. If the storage of the buffer is column major, the number of resulting triangles (that should be known when calling this function) should be given as input. If the number of resulting triangles is not given, the function will compute it again.</p>
<dl class="section note"><dt>Note</dt><dd>As a default behaviour (<code>getIndicesAsIfContainerCompact == true</code>) the function stores the vertex indices as if the vertex container of the mesh is compact. This means that, if the mesh has deleted vertices, the vertex indices stored in the buffer may not correspond to the vertex indices of the mesh. If you want to store the actual vertex indices in the input mesh, set <code>getIndicesAsIfContainerCompact</code> to false.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>input mesh </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buffer</td><td>preallocated buffer </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">indexMap</td><td>map from triangle index to face index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">storage</td><td>storage type of the matrix (row or column major) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numTriangles</td><td>number of resulting triangles (necessary only if the storage is column major) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">getIndicesAsIfContainerCompact</td><td>if true, the function will store the vertex indices as if the vertex container of the mesh is compact. If false, the actual vertex indices in the input mesh will be stored. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gadd65e2cf3ef4cbfcac92c9f2a25607e2" name="gadd65e2cf3ef4cbfcac92c9f2a25607e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadd65e2cf3ef4cbfcac92c9f2a25607e2">&#9670;&#160;</a></span>vertexCoordsToBuffer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Box.html">void</a> vcl::vertexCoordsToBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">const</a> MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">auto</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga16a1bfbea022f6766d2f3ebbf69a3b52">MatrixStorageType</a>&#160;</td>
          <td class="paramname"><em>storage</em> = <code>MatrixStorageType::ROW_MAJOR</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Export the vertex coordinates of a mesh to a buffer. </p>
<p>This function exports the vertex coordinates of a mesh to a buffer. Vertices are stored in the buffer following the order they appear in the mesh. The buffer must be preallocated with the correct size (number of vertices times the number of coordinates per vertex).</p>
<dl class="section note"><dt>Note</dt><dd>This function does not guarantee that the rows of the matrix correspond to the vertex indices of the mesh. This scenario is possible when the mesh has deleted vertices. To be sure to have a direct correspondence, compact the vertex container before calling this function.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>input mesh </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buffer</td><td>preallocated buffer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">storage</td><td>storage type of the matrix (row or column major) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
