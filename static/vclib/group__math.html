<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Visual Computing Library: Math</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
       <script type="text/javascript">
           DoxygenAwesomeDarkModeToggle.init()
       </script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Visual Computing Library
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group__math.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Math</div></div>
</div><!--header-->
<div class="contents">

<p>This module contains all the mathematical functions and utilities used in the library.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1Distribution.html">vcl::Distribution&lt; Scalar &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classvcl_1_1Distribution.html" title="The Distribution class allows to collect a set of values and then compute some statistics like averag...">Distribution</a> class allows to collect a set of values and then compute some statistics like average, variance, standardDeviation, and percentiles.  <a href="classvcl_1_1Distribution.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1Histogram.html">vcl::Histogram&lt; ScalarType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classvcl_1_1Histogram.html" title="The Histogram class allows to collect a set of values and then compute some statistics like average,...">Histogram</a> class allows to collect a set of values and then compute some statistics like average, variance, standardDeviation, and percentiles.  <a href="classvcl_1_1Histogram.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga7da4c4b0342d3a5f906db63db504bea7" id="r_ga7da4c4b0342d3a5f906db63db504bea7"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classvcl_1_1Box.html">typename</a> Scalar &gt; </td></tr>
<tr class="memitem:ga7da4c4b0342d3a5f906db63db504bea7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Box.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__math.html#ga7da4c4b0342d3a5f906db63db504bea7">vcl::isDegenerate</a> (Scalar number)</td></tr>
<tr class="memdesc:ga7da4c4b0342d3a5f906db63db504bea7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a floating point number is degenerate.  <br /></td></tr>
<tr class="separator:ga7da4c4b0342d3a5f906db63db504bea7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f9b74af8b9f8a827e760dce325b820c" id="r_ga2f9b74af8b9f8a827e760dce325b820c"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classvcl_1_1Box.html">typename</a> Scalar &gt; </td></tr>
<tr class="memitem:ga2f9b74af8b9f8a827e760dce325b820c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Box.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__math.html#ga2f9b74af8b9f8a827e760dce325b820c">vcl::epsilonEquals</a> (Scalar <a class="el" href="classvcl_1_1Box.html">n1</a>, Scalar <a class="el" href="classvcl_1_1Box.html">n2</a>, Scalar <a class="el" href="classvcl_1_1Box.html">epsilon</a>=std::numeric_limits&lt; Scalar &gt;::epsilon())</td></tr>
<tr class="memdesc:ga2f9b74af8b9f8a827e760dce325b820c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if two floating point numbers are equal within an epsilon value.  <br /></td></tr>
<tr class="separator:ga2f9b74af8b9f8a827e760dce325b820c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga47c44328e5dfdb6c7e872aaa04fd2eba" id="r_ga47c44328e5dfdb6c7e872aaa04fd2eba"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classvcl_1_1Box.html">typename</a> Scalar &gt; </td></tr>
<tr class="memitem:ga47c44328e5dfdb6c7e872aaa04fd2eba"><td class="memTemplItemLeft" align="right" valign="top">Scalar&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__math.html#ga47c44328e5dfdb6c7e872aaa04fd2eba">vcl::toRad</a> (<a class="el" href="classvcl_1_1Box.html">const</a> Scalar &amp;<a class="el" href="classvcl_1_1Box.html">deg</a>)</td></tr>
<tr class="memdesc:ga47c44328e5dfdb6c7e872aaa04fd2eba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an angle in degrees to radians.  <br /></td></tr>
<tr class="separator:ga47c44328e5dfdb6c7e872aaa04fd2eba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaef0e24c2e1f1179f14204b1a56c57d9" id="r_gaaef0e24c2e1f1179f14204b1a56c57d9"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classvcl_1_1Box.html">typename</a> Scalar &gt; </td></tr>
<tr class="memitem:gaaef0e24c2e1f1179f14204b1a56c57d9"><td class="memTemplItemLeft" align="right" valign="top">Scalar&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__math.html#gaaef0e24c2e1f1179f14204b1a56c57d9">vcl::toDeg</a> (<a class="el" href="classvcl_1_1Box.html">const</a> Scalar &amp;<a class="el" href="classvcl_1_1Box.html">rad</a>)</td></tr>
<tr class="memdesc:gaaef0e24c2e1f1179f14204b1a56c57d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an angle in radians to degrees.  <br /></td></tr>
<tr class="separator:gaaef0e24c2e1f1179f14204b1a56c57d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa6613e39304926dee856b8b9770b3be5" id="r_gaa6613e39304926dee856b8b9770b3be5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Box.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#gaa6613e39304926dee856b8b9770b3be5">vcl::lnOfFactorial</a> (<a class="el" href="classvcl_1_1Box.html">int</a> <a class="el" href="classvcl_1_1Box.html">n</a>)</td></tr>
<tr class="memdesc:gaa6613e39304926dee856b8b9770b3be5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes and caches the result of the natural logarithm of n!  <br /></td></tr>
<tr class="separator:gaa6613e39304926dee856b8b9770b3be5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga438da980623645640c78105766bde287" id="r_ga438da980623645640c78105766bde287"><td class="memTemplParams" colspan="2">template&lt;Point3Concept PointType&gt; </td></tr>
<tr class="memitem:ga438da980623645640c78105766bde287"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; PointType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__math.html#ga438da980623645640c78105766bde287">vcl::sphericalFibonacciPointSet</a> (uint <a class="el" href="classvcl_1_1Box.html">n</a>)</td></tr>
<tr class="memdesc:ga438da980623645640c78105766bde287"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector of <code>n</code> points distributed in a unit sphere.  <br /></td></tr>
<tr class="separator:ga438da980623645640c78105766bde287"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae6c5f005182de34972bb2430132acb8f" id="r_gae6c5f005182de34972bb2430132acb8f"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classvcl_1_1Box.html">typename</a> T &gt; </td></tr>
<tr class="memitem:gae6c5f005182de34972bb2430132acb8f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Box.html">constexpr</a> <a class="el" href="classvcl_1_1Box.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__math.html#gae6c5f005182de34972bb2430132acb8f">vcl::min</a> (<a class="el" href="classvcl_1_1Box.html">const</a> T &amp;p1, <a class="el" href="classvcl_1_1Box.html">const</a> T &amp;<a class="el" href="classvcl_1_1Box.html">p2</a>)</td></tr>
<tr class="memdesc:gae6c5f005182de34972bb2430132acb8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the minimum between the two parameters.  <br /></td></tr>
<tr class="separator:gae6c5f005182de34972bb2430132acb8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9c1835cef3addd7dbae2b21a43523f3a" id="r_ga9c1835cef3addd7dbae2b21a43523f3a"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classvcl_1_1Box.html">typename</a> <a class="el" href="classvcl_1_1Box.html">Head</a> , typename... Tail&gt; <br />
requires (sizeof...(<a class="el" href="classvcl_1_1Box.html">tail</a>) &gt; 0)</td></tr>
<tr class="memitem:ga9c1835cef3addd7dbae2b21a43523f3a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Box.html">constexpr</a> <a class="el" href="classvcl_1_1Box.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__math.html#ga9c1835cef3addd7dbae2b21a43523f3a">vcl::min</a> (<a class="el" href="classvcl_1_1Box.html">const</a> <a class="el" href="classvcl_1_1Box.html">Head</a> &amp;<a class="el" href="classvcl_1_1Box.html">head0</a>, <a class="el" href="classvcl_1_1Box.html">const</a> <a class="el" href="classvcl_1_1Box.html">Head</a> &amp;<a class="el" href="classvcl_1_1Box.html">head1</a>, <a class="el" href="classvcl_1_1Box.html">const</a> <a class="el" href="classvcl_1_1Box.html">Tail</a> &amp;... <a class="el" href="classvcl_1_1Box.html">tail</a>)</td></tr>
<tr class="memdesc:ga9c1835cef3addd7dbae2b21a43523f3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the minimum between several parameters.  <br /></td></tr>
<tr class="separator:ga9c1835cef3addd7dbae2b21a43523f3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45d99c06ee2cb1cd9434fd0e86a1a413" id="r_ga45d99c06ee2cb1cd9434fd0e86a1a413"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classvcl_1_1Box.html">typename</a> T &gt; </td></tr>
<tr class="memitem:ga45d99c06ee2cb1cd9434fd0e86a1a413"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Box.html">constexpr</a> <a class="el" href="classvcl_1_1Box.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__math.html#ga45d99c06ee2cb1cd9434fd0e86a1a413">vcl::max</a> (<a class="el" href="classvcl_1_1Box.html">const</a> T &amp;p1, <a class="el" href="classvcl_1_1Box.html">const</a> T &amp;<a class="el" href="classvcl_1_1Box.html">p2</a>)</td></tr>
<tr class="memdesc:ga45d99c06ee2cb1cd9434fd0e86a1a413"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum between the two parameters.  <br /></td></tr>
<tr class="separator:ga45d99c06ee2cb1cd9434fd0e86a1a413"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga212fbf643d263ad106507f7aa462cf46" id="r_ga212fbf643d263ad106507f7aa462cf46"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classvcl_1_1Box.html">typename</a> <a class="el" href="classvcl_1_1Box.html">Head</a> , typename... Tail&gt; <br />
requires (sizeof...(<a class="el" href="classvcl_1_1Box.html">tail</a>) &gt; 0)</td></tr>
<tr class="memitem:ga212fbf643d263ad106507f7aa462cf46"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Box.html">constexpr</a> <a class="el" href="classvcl_1_1Box.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__math.html#ga212fbf643d263ad106507f7aa462cf46">vcl::max</a> (<a class="el" href="classvcl_1_1Box.html">const</a> <a class="el" href="classvcl_1_1Box.html">Head</a> &amp;<a class="el" href="classvcl_1_1Box.html">head0</a>, <a class="el" href="classvcl_1_1Box.html">const</a> <a class="el" href="classvcl_1_1Box.html">Head</a> &amp;<a class="el" href="classvcl_1_1Box.html">head1</a>, <a class="el" href="classvcl_1_1Box.html">const</a> <a class="el" href="classvcl_1_1Box.html">Tail</a> &amp;... <a class="el" href="classvcl_1_1Box.html">tail</a>)</td></tr>
<tr class="memdesc:ga212fbf643d263ad106507f7aa462cf46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum between several parameters.  <br /></td></tr>
<tr class="separator:ga212fbf643d263ad106507f7aa462cf46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac11460526cb6d79733a8dfe0e15614f4" id="r_gac11460526cb6d79733a8dfe0e15614f4"><td class="memTemplParams" colspan="2">template&lt;PointConcept PointType&gt; </td></tr>
<tr class="memitem:gac11460526cb6d79733a8dfe0e15614f4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Box.html">constexpr</a> <a class="el" href="classvcl_1_1Box.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__math.html#gac11460526cb6d79733a8dfe0e15614f4">vcl::min</a> (<a class="el" href="classvcl_1_1Box.html">const</a> PointType &amp;p1, <a class="el" href="classvcl_1_1Box.html">const</a> PointType &amp;<a class="el" href="classvcl_1_1Box.html">p2</a>)</td></tr>
<tr class="memdesc:gac11460526cb6d79733a8dfe0e15614f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the minimum between two points.  <br /></td></tr>
<tr class="separator:gac11460526cb6d79733a8dfe0e15614f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga49a9bdba85989ec5842081c5c84d4fc7" id="r_ga49a9bdba85989ec5842081c5c84d4fc7"><td class="memTemplParams" colspan="2">template&lt;PointConcept PointType&gt; </td></tr>
<tr class="memitem:ga49a9bdba85989ec5842081c5c84d4fc7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Box.html">constexpr</a> <a class="el" href="classvcl_1_1Box.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__math.html#ga49a9bdba85989ec5842081c5c84d4fc7">vcl::max</a> (<a class="el" href="classvcl_1_1Box.html">const</a> PointType &amp;p1, <a class="el" href="classvcl_1_1Box.html">const</a> PointType &amp;<a class="el" href="classvcl_1_1Box.html">p2</a>)</td></tr>
<tr class="memdesc:ga49a9bdba85989ec5842081c5c84d4fc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum between two points.  <br /></td></tr>
<tr class="separator:ga49a9bdba85989ec5842081c5c84d4fc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2cc1884dbb897a34716178c7b06e7bb2" id="r_ga2cc1884dbb897a34716178c7b06e7bb2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Box.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#ga2cc1884dbb897a34716178c7b06e7bb2">vcl::poissonRatioOfUniformsInteger</a> (<a class="el" href="classvcl_1_1Box.html">double</a> L, std::mt19937 &amp;<a class="el" href="classvcl_1_1Box.html">gen</a>)</td></tr>
<tr class="memdesc:ga2cc1884dbb897a34716178c7b06e7bb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This subfunction generates a integer with the poisson distribution using the ratio-of-uniforms rejection method (PRUAt). This approach is STABLE even for large L (e.g. it does not suffer from the overflow limit of the classical Knuth implementation) Execution time does not depend on L, except that it matters whether is within the range where ln(n!) is tabulated.  <br /></td></tr>
<tr class="separator:ga2cc1884dbb897a34716178c7b06e7bb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga212c052ae1efd3426a5ea49051f8011c" id="r_ga212c052ae1efd3426a5ea49051f8011c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Box.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#ga212c052ae1efd3426a5ea49051f8011c">vcl::poissonRandomNumber</a> (<a class="el" href="classvcl_1_1Box.html">double</a> <a class="el" href="classvcl_1_1Box.html">lambda</a>, std::mt19937 &amp;<a class="el" href="classvcl_1_1Box.html">gen</a>)</td></tr>
<tr class="memdesc:ga212c052ae1efd3426a5ea49051f8011c"><td class="mdescLeft">&#160;</td><td class="mdescRight">algorithm poisson random number (Knuth): init: Let L ← e^−λ, k ← 0 and p ← 1. do: k ← k + 1. Generate uniform random number u in [0,1] and let p ← p × u. while p &gt; L. return k − 1.  <br /></td></tr>
<tr class="separator:ga212c052ae1efd3426a5ea49051f8011c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1928216d4ca321551feca3fc03054e03" id="r_ga1928216d4ca321551feca3fc03054e03"><td class="memTemplParams" colspan="2">template&lt;Point3Concept PointType&gt; </td></tr>
<tr class="memitem:ga1928216d4ca321551feca3fc03054e03"><td class="memTemplItemLeft" align="right" valign="top">PointType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__math.html#ga1928216d4ca321551feca3fc03054e03">vcl::randomTriangleBarycentricCoordinate</a> (std::mt19937 &amp;<a class="el" href="classvcl_1_1Box.html">gen</a>)</td></tr>
<tr class="memdesc:ga1928216d4ca321551feca3fc03054e03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate the barycentric coords of a random point over a triangle, with a uniform distribution over the triangle. It uses the parallelogram folding trick.  <br /></td></tr>
<tr class="separator:ga1928216d4ca321551feca3fc03054e03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24901186f1a77f31a23d64f30f0b0dc3" id="r_ga24901186f1a77f31a23d64f30f0b0dc3"><td class="memTemplParams" colspan="2">template&lt;MatrixConcept MatrixType, Point3Concept PointType, <a class="el" href="classvcl_1_1Box.html">typename</a> ScalarType &gt; </td></tr>
<tr class="memitem:ga24901186f1a77f31a23d64f30f0b0dc3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Box.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__math.html#ga24901186f1a77f31a23d64f30f0b0dc3">vcl::setTransformMatrixRotation</a> (MatrixType &amp;<a class="el" href="classvcl_1_1Box.html">matrix</a>, PointType axis, <a class="el" href="classvcl_1_1Box.html">const</a> ScalarType &amp;<a class="el" href="classvcl_1_1Box.html">angleRad</a>)</td></tr>
<tr class="memdesc:ga24901186f1a77f31a23d64f30f0b0dc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an 3D axis and an angle expressed in radiants, fills the given matrix with a transform matrix that represents the rotation matrix of the given axis/angle.  <br /></td></tr>
<tr class="separator:ga24901186f1a77f31a23d64f30f0b0dc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd5d95d87600e42a0da835735e35ea99" id="r_gabd5d95d87600e42a0da835735e35ea99"><td class="memTemplParams" colspan="2">template&lt;MatrixConcept MatrixType, Point3Concept PointType, <a class="el" href="classvcl_1_1Box.html">typename</a> ScalarType &gt; </td></tr>
<tr class="memitem:gabd5d95d87600e42a0da835735e35ea99"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Box.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__math.html#gabd5d95d87600e42a0da835735e35ea99">vcl::setTransformMatrixRotationDeg</a> (MatrixType &amp;<a class="el" href="classvcl_1_1Box.html">matrix</a>, PointType axis, <a class="el" href="classvcl_1_1Box.html">const</a> ScalarType &amp;<a class="el" href="classvcl_1_1Box.html">angleDeg</a>)</td></tr>
<tr class="memdesc:gabd5d95d87600e42a0da835735e35ea99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an 3D axis and an angle expressed in degrees, fills the given matrix with a transform matrix that represents the rotation matrix of the given axis/angle.  <br /></td></tr>
<tr class="separator:gabd5d95d87600e42a0da835735e35ea99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeae3bed7ce8fef5657452d857cf87bed" id="r_gaeae3bed7ce8fef5657452d857cf87bed"><td class="memTemplParams" colspan="2">template&lt;MatrixConcept MatrixType, Point3Concept PointType&gt; </td></tr>
<tr class="memitem:gaeae3bed7ce8fef5657452d857cf87bed"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Box.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__math.html#gaeae3bed7ce8fef5657452d857cf87bed">vcl::setTransformMatrixRotation</a> (MatrixType &amp;<a class="el" href="classvcl_1_1Box.html">matrix</a>, <a class="el" href="classvcl_1_1Box.html">const</a> PointType &amp;<a class="el" href="classvcl_1_1Box.html">fromVector</a>, <a class="el" href="classvcl_1_1Box.html">const</a> PointType &amp;<a class="el" href="classvcl_1_1Box.html">toVector</a>)</td></tr>
<tr class="memdesc:gaeae3bed7ce8fef5657452d857cf87bed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given two 3D vectors, fills the given matrix with a transform matrix that represents the rotation matrix from the first vector to the second vector.  <br /></td></tr>
<tr class="separator:gaeae3bed7ce8fef5657452d857cf87bed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaefa0051d67bdf4a551140929a2cc0b2f" id="r_gaefa0051d67bdf4a551140929a2cc0b2f"><td class="memTemplParams" colspan="2">template&lt;MatrixConcept MatrixType, Point3Concept PointType, <a class="el" href="classvcl_1_1Box.html">typename</a> ScalarType &gt; </td></tr>
<tr class="memitem:gaefa0051d67bdf4a551140929a2cc0b2f"><td class="memTemplItemLeft" align="right" valign="top">MatrixType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__math.html#gaefa0051d67bdf4a551140929a2cc0b2f">vcl::rotationMatrix</a> (<a class="el" href="classvcl_1_1Box.html">const</a> PointType &amp;axis, <a class="el" href="classvcl_1_1Box.html">const</a> ScalarType &amp;<a class="el" href="classvcl_1_1Box.html">angleRad</a>)</td></tr>
<tr class="memdesc:gaefa0051d67bdf4a551140929a2cc0b2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an 3D axis and an angle expressed in radiants, returns a transform matrix that represents the rotation matrix of the given axis/angle.  <br /></td></tr>
<tr class="separator:gaefa0051d67bdf4a551140929a2cc0b2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f6b127154a5e14946cb66492d214de8" id="r_ga7f6b127154a5e14946cb66492d214de8"><td class="memTemplParams" colspan="2">template&lt;MatrixConcept MatrixType, Point3Concept PointType, <a class="el" href="classvcl_1_1Box.html">typename</a> ScalarType &gt; </td></tr>
<tr class="memitem:ga7f6b127154a5e14946cb66492d214de8"><td class="memTemplItemLeft" align="right" valign="top">MatrixType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__math.html#ga7f6b127154a5e14946cb66492d214de8">vcl::rotationMatrixDeg</a> (<a class="el" href="classvcl_1_1Box.html">const</a> PointType &amp;axis, <a class="el" href="classvcl_1_1Box.html">const</a> ScalarType &amp;<a class="el" href="classvcl_1_1Box.html">angleDeg</a>)</td></tr>
<tr class="memdesc:ga7f6b127154a5e14946cb66492d214de8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an 3D axis and an angle expressed in degrees, fills the given matrix with a transform matrix that represents the rotation matrix of the given axis/angle.  <br /></td></tr>
<tr class="separator:ga7f6b127154a5e14946cb66492d214de8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4870ee93dae22bb750da059cefa6d9f2" id="r_ga4870ee93dae22bb750da059cefa6d9f2"><td class="memTemplParams" colspan="2">template&lt;MatrixConcept MatrixType, Point3Concept PointType&gt; </td></tr>
<tr class="memitem:ga4870ee93dae22bb750da059cefa6d9f2"><td class="memTemplItemLeft" align="right" valign="top">MatrixType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__math.html#ga4870ee93dae22bb750da059cefa6d9f2">vcl::rotationMatrix</a> (<a class="el" href="classvcl_1_1Box.html">const</a> PointType &amp;<a class="el" href="classvcl_1_1Box.html">fromVector</a>, <a class="el" href="classvcl_1_1Box.html">const</a> PointType &amp;<a class="el" href="classvcl_1_1Box.html">toVector</a>)</td></tr>
<tr class="memdesc:ga4870ee93dae22bb750da059cefa6d9f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given two 3D vectors, returns a transform matrix that represents the rotation matrix from the first vector to the second vector.  <br /></td></tr>
<tr class="separator:ga4870ee93dae22bb750da059cefa6d9f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>This module contains all the mathematical functions and utilities used in the library. </p>
<p>This module depends on the <a class="el" href="group__concepts.html">Concepts</a> module.</p>
<p>You can access all the concepts of VCLib by including <code>#include &lt;<a class="el" href="math_8h_source.html">vclib/math.h</a>&gt;</code> </p>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga2f9b74af8b9f8a827e760dce325b820c" name="ga2f9b74af8b9f8a827e760dce325b820c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2f9b74af8b9f8a827e760dce325b820c">&#9670;&#160;</a></span>epsilonEquals()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classvcl_1_1Box.html">typename</a> Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Box.html">bool</a> vcl::epsilonEquals </td>
          <td>(</td>
          <td class="paramtype">Scalar&#160;</td>
          <td class="paramname"><em>n1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Scalar&#160;</td>
          <td class="paramname"><em>n2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Scalar&#160;</td>
          <td class="paramname"><em>epsilon</em> = <code>std::numeric_limits&lt;Scalar&gt;::epsilon()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if two floating point numbers are equal within an epsilon value. </p>
<p>This function returns true if the absolute difference between the two numbers is less than or equal to the epsilon value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n1</td><td>the first number to compare </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n2</td><td>the second number to compare </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">epsilon</td><td>the epsilon value to use for the check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the numbers are equal within the epsilon value, false otherwise. </dd></dl>

</div>
</div>
<a id="ga7da4c4b0342d3a5f906db63db504bea7" name="ga7da4c4b0342d3a5f906db63db504bea7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7da4c4b0342d3a5f906db63db504bea7">&#9670;&#160;</a></span>isDegenerate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classvcl_1_1Box.html">typename</a> Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Box.html">bool</a> vcl::isDegenerate </td>
          <td>(</td>
          <td class="paramtype">Scalar&#160;</td>
          <td class="paramname"><em>number</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if a floating point number is degenerate. </p>
<p>A floating point number is degenerate if it is infinite or NaN.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">number</td><td>the number to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the number is degenerate, false otherwise. </dd></dl>

</div>
</div>
<a id="gaa6613e39304926dee856b8b9770b3be5" name="gaa6613e39304926dee856b8b9770b3be5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa6613e39304926dee856b8b9770b3be5">&#9670;&#160;</a></span>lnOfFactorial()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Box.html">double</a> vcl::lnOfFactorial </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">int</a>&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes and caches the result of the natural logarithm of n! </p>
<p>If n &gt; 1024, uses the Stirling approximation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>the number for which to compute the natural logarithm of the factorial.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the natural logarithm of n!. </dd></dl>

</div>
</div>
<a id="ga212fbf643d263ad106507f7aa462cf46" name="ga212fbf643d263ad106507f7aa462cf46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga212fbf643d263ad106507f7aa462cf46">&#9670;&#160;</a></span>max() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classvcl_1_1Box.html">typename</a> <a class="el" href="classvcl_1_1Box.html">Head</a> , typename... Tail&gt; <br />
requires (sizeof...(<a class="el" href="classvcl_1_1Box.html">tail</a>) &gt; 0)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Box.html">constexpr</a> <a class="el" href="classvcl_1_1Box.html">auto</a> vcl::max </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">const</a> <a class="el" href="classvcl_1_1Box.html">Head</a> &amp;&#160;</td>
          <td class="paramname"><em>head0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">const</a> <a class="el" href="classvcl_1_1Box.html">Head</a> &amp;&#160;</td>
          <td class="paramname"><em>head1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">const</a> <a class="el" href="classvcl_1_1Box.html">Tail</a> &amp;...&#160;</td>
          <td class="paramname"><em>tail</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the maximum between several parameters. </p>
<p>Given a list of parameters, this function returns the maximum between all of them.</p>
<p>Example:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> <a class="code hl_class" href="classvcl_1_1Box.html">m</a> = <a class="code hl_function" href="group__math.html#ga45d99c06ee2cb1cd9434fd0e86a1a413">vcl::max</a>(1, 2, 3, 4, 5); <span class="comment">// m = 5</span></div>
<div class="ttc" id="aclassvcl_1_1Box_html"><div class="ttname"><a href="classvcl_1_1Box.html">vcl::Box</a></div><div class="ttdoc">A class representing a box in N-dimensional space.</div><div class="ttdef"><b>Definition</b> box.h:49</div></div>
<div class="ttc" id="agroup__math_html_ga45d99c06ee2cb1cd9434fd0e86a1a413"><div class="ttname"><a href="group__math.html#ga45d99c06ee2cb1cd9434fd0e86a1a413">vcl::max</a></div><div class="ttdeci">constexpr auto max(const T &amp;p1, const T &amp;p2)</div><div class="ttdoc">Returns the maximum between the two parameters.</div><div class="ttdef"><b>Definition</b> min_max.h:83</div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">head0</td><td>The first parameter. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">head1</td><td>The second parameter. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tail</td><td>The rest of the parameters. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The maximum between the parameters. </dd></dl>

</div>
</div>
<a id="ga49a9bdba85989ec5842081c5c84d4fc7" name="ga49a9bdba85989ec5842081c5c84d4fc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga49a9bdba85989ec5842081c5c84d4fc7">&#9670;&#160;</a></span>max() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;PointConcept PointType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Box.html">constexpr</a> <a class="el" href="classvcl_1_1Box.html">auto</a> vcl::max </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">const</a> PointType &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">const</a> PointType &amp;&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the maximum between two points. </p>
<p>This function returns a point that contains the maximum value between each component of the two input points.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p1</td><td>The first point. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p2</td><td>The second point. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The point containing the maximum value between the two input points. </dd></dl>

</div>
</div>
<a id="ga45d99c06ee2cb1cd9434fd0e86a1a413" name="ga45d99c06ee2cb1cd9434fd0e86a1a413"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga45d99c06ee2cb1cd9434fd0e86a1a413">&#9670;&#160;</a></span>max() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classvcl_1_1Box.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Box.html">constexpr</a> <a class="el" href="classvcl_1_1Box.html">auto</a> vcl::max </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">const</a> T &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">const</a> T &amp;&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the maximum between the two parameters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p1</td><td>The first parameter. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p2</td><td>The second parameter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The maximum between the two parameters. </dd></dl>

</div>
</div>
<a id="ga9c1835cef3addd7dbae2b21a43523f3a" name="ga9c1835cef3addd7dbae2b21a43523f3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9c1835cef3addd7dbae2b21a43523f3a">&#9670;&#160;</a></span>min() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classvcl_1_1Box.html">typename</a> <a class="el" href="classvcl_1_1Box.html">Head</a> , typename... Tail&gt; <br />
requires (sizeof...(<a class="el" href="classvcl_1_1Box.html">tail</a>) &gt; 0)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Box.html">constexpr</a> <a class="el" href="classvcl_1_1Box.html">auto</a> vcl::min </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">const</a> <a class="el" href="classvcl_1_1Box.html">Head</a> &amp;&#160;</td>
          <td class="paramname"><em>head0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">const</a> <a class="el" href="classvcl_1_1Box.html">Head</a> &amp;&#160;</td>
          <td class="paramname"><em>head1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">const</a> <a class="el" href="classvcl_1_1Box.html">Tail</a> &amp;...&#160;</td>
          <td class="paramname"><em>tail</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the minimum between several parameters. </p>
<p>Given a list of parameters, this function returns the minimum between all of them.</p>
<p>Example:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> <a class="code hl_class" href="classvcl_1_1Box.html">m</a> = <a class="code hl_function" href="group__math.html#gae6c5f005182de34972bb2430132acb8f">vcl::min</a>(1, 2, 3, 4, 5); <span class="comment">// m = 1</span></div>
<div class="ttc" id="agroup__math_html_gae6c5f005182de34972bb2430132acb8f"><div class="ttname"><a href="group__math.html#gae6c5f005182de34972bb2430132acb8f">vcl::min</a></div><div class="ttdeci">constexpr auto min(const T &amp;p1, const T &amp;p2)</div><div class="ttdoc">Returns the minimum between the two parameters.</div><div class="ttdef"><b>Definition</b> min_max.h:42</div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">head0</td><td>The first parameter. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">head1</td><td>The second parameter. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tail</td><td>The rest of the parameters. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The minimum between the parameters. </dd></dl>

</div>
</div>
<a id="gac11460526cb6d79733a8dfe0e15614f4" name="gac11460526cb6d79733a8dfe0e15614f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac11460526cb6d79733a8dfe0e15614f4">&#9670;&#160;</a></span>min() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;PointConcept PointType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Box.html">constexpr</a> <a class="el" href="classvcl_1_1Box.html">auto</a> vcl::min </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">const</a> PointType &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">const</a> PointType &amp;&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the minimum between two points. </p>
<p>This function returns a point that contains the minimum value between each component of the two input points.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p1</td><td>The first point. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p2</td><td>The second point. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The point containing the minimum value between the two input points. </dd></dl>

</div>
</div>
<a id="gae6c5f005182de34972bb2430132acb8f" name="gae6c5f005182de34972bb2430132acb8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae6c5f005182de34972bb2430132acb8f">&#9670;&#160;</a></span>min() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classvcl_1_1Box.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Box.html">constexpr</a> <a class="el" href="classvcl_1_1Box.html">auto</a> vcl::min </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">const</a> T &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">const</a> T &amp;&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the minimum between the two parameters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p1</td><td>The first parameter. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p2</td><td>The second parameter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The minimum between the two parameters. </dd></dl>

</div>
</div>
<a id="ga212c052ae1efd3426a5ea49051f8011c" name="ga212c052ae1efd3426a5ea49051f8011c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga212c052ae1efd3426a5ea49051f8011c">&#9670;&#160;</a></span>poissonRandomNumber()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Box.html">int</a> vcl::poissonRandomNumber </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">double</a>&#160;</td>
          <td class="paramname"><em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::mt19937 &amp;&#160;</td>
          <td class="paramname"><em>gen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>algorithm poisson random number (Knuth): init: Let L ← e^−λ, k ← 0 and p ← 1. do: k ← k + 1. Generate uniform random number u in [0,1] and let p ← p × u. while p &gt; L. return k − 1. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lambda</td><td></td></tr>
    <tr><td class="paramname">gen</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="ga2cc1884dbb897a34716178c7b06e7bb2" name="ga2cc1884dbb897a34716178c7b06e7bb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2cc1884dbb897a34716178c7b06e7bb2">&#9670;&#160;</a></span>poissonRatioOfUniformsInteger()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Box.html">int</a> vcl::poissonRatioOfUniformsInteger </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">double</a>&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::mt19937 &amp;&#160;</td>
          <td class="paramname"><em>gen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This subfunction generates a integer with the poisson distribution using the ratio-of-uniforms rejection method (PRUAt). This approach is STABLE even for large L (e.g. it does not suffer from the overflow limit of the classical Knuth implementation) Execution time does not depend on L, except that it matters whether is within the range where ln(n!) is tabulated. </p>
<p>Reference:</p>
<p>E. Stadlober "The ratio of uniforms approach for generating discrete random variates". Journal of Computational and Applied Mathematics, vol. 31, no. 1, 1990, pp. 181-189.</p>
<p>Partially adapted/inspired from some subfunctions of the Agner Fog stocc library ( www.agner.org/random ) Same licensing scheme.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">L</td><td></td></tr>
    <tr><td class="paramname">gen</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="ga1928216d4ca321551feca3fc03054e03" name="ga1928216d4ca321551feca3fc03054e03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1928216d4ca321551feca3fc03054e03">&#9670;&#160;</a></span>randomTriangleBarycentricCoordinate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Point3Concept PointType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">PointType vcl::randomTriangleBarycentricCoordinate </td>
          <td>(</td>
          <td class="paramtype">std::mt19937 &amp;&#160;</td>
          <td class="paramname"><em>gen</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate the barycentric coords of a random point over a triangle, with a uniform distribution over the triangle. It uses the parallelogram folding trick. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gen</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="gaefa0051d67bdf4a551140929a2cc0b2f" name="gaefa0051d67bdf4a551140929a2cc0b2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaefa0051d67bdf4a551140929a2cc0b2f">&#9670;&#160;</a></span>rotationMatrix() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MatrixConcept MatrixType, Point3Concept PointType, <a class="el" href="classvcl_1_1Box.html">typename</a> ScalarType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">MatrixType vcl::rotationMatrix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">const</a> PointType &amp;&#160;</td>
          <td class="paramname"><em>axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">const</a> ScalarType &amp;&#160;</td>
          <td class="paramname"><em>angleRad</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given an 3D axis and an angle expressed in radiants, returns a transform matrix that represents the rotation matrix of the given axis/angle. </p>
<p>The MatrixType must be at least a 3x3 matrix having the setIdentity() member function. If the matrix is a higher than 3x3 (e.g. 4x4), only the 3x3 submatrix will be set, leaving the identity values in the other cells of the matrix.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">axis</td><td></td></tr>
    <tr><td class="paramname">angleRad</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="ga4870ee93dae22bb750da059cefa6d9f2" name="ga4870ee93dae22bb750da059cefa6d9f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4870ee93dae22bb750da059cefa6d9f2">&#9670;&#160;</a></span>rotationMatrix() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MatrixConcept MatrixType, Point3Concept PointType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">MatrixType vcl::rotationMatrix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">const</a> PointType &amp;&#160;</td>
          <td class="paramname"><em>fromVector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">const</a> PointType &amp;&#160;</td>
          <td class="paramname"><em>toVector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given two 3D vectors, returns a transform matrix that represents the rotation matrix from the first vector to the second vector. </p>
<p>The MatrixType must be at least a 3x3 matrix having the setIdentity() member function. If the matrix is a higher than 3x3 (e.g. 4x4), only the 3x3 submatrix will be set, leaving the identity values in the other cells of the matrix.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fromVector</td><td></td></tr>
    <tr><td class="paramname">toVector</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="ga7f6b127154a5e14946cb66492d214de8" name="ga7f6b127154a5e14946cb66492d214de8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7f6b127154a5e14946cb66492d214de8">&#9670;&#160;</a></span>rotationMatrixDeg()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MatrixConcept MatrixType, Point3Concept PointType, <a class="el" href="classvcl_1_1Box.html">typename</a> ScalarType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">MatrixType vcl::rotationMatrixDeg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">const</a> PointType &amp;&#160;</td>
          <td class="paramname"><em>axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">const</a> ScalarType &amp;&#160;</td>
          <td class="paramname"><em>angleDeg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given an 3D axis and an angle expressed in degrees, fills the given matrix with a transform matrix that represents the rotation matrix of the given axis/angle. </p>
<p>The MatrixType must be at least a 3x3 matrix having the setIdentity() member function. If the matrix is a higher than 3x3 (e.g. 4x4), only the 3x3 submatrix will be set, leaving the identity values in the other cells of the matrix.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">axis</td><td></td></tr>
    <tr><td class="paramname">angleDeg</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="gaeae3bed7ce8fef5657452d857cf87bed" name="gaeae3bed7ce8fef5657452d857cf87bed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeae3bed7ce8fef5657452d857cf87bed">&#9670;&#160;</a></span>setTransformMatrixRotation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MatrixConcept MatrixType, Point3Concept PointType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Box.html">void</a> vcl::setTransformMatrixRotation </td>
          <td>(</td>
          <td class="paramtype">MatrixType &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">const</a> PointType &amp;&#160;</td>
          <td class="paramname"><em>fromVector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">const</a> PointType &amp;&#160;</td>
          <td class="paramname"><em>toVector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given two 3D vectors, fills the given matrix with a transform matrix that represents the rotation matrix from the first vector to the second vector. </p>
<p>The given matrix must be at least a 3x3 matrix. If the matrix is a higher than 3x3 (e.g. 4x4), only the 3x3 submatrix will be set, leaving unchanged the other values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix</td><td></td></tr>
    <tr><td class="paramname">fromVector</td><td></td></tr>
    <tr><td class="paramname">toVector</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga24901186f1a77f31a23d64f30f0b0dc3" name="ga24901186f1a77f31a23d64f30f0b0dc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga24901186f1a77f31a23d64f30f0b0dc3">&#9670;&#160;</a></span>setTransformMatrixRotation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MatrixConcept MatrixType, Point3Concept PointType, <a class="el" href="classvcl_1_1Box.html">typename</a> ScalarType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Box.html">void</a> vcl::setTransformMatrixRotation </td>
          <td>(</td>
          <td class="paramtype">MatrixType &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PointType&#160;</td>
          <td class="paramname"><em>axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">const</a> ScalarType &amp;&#160;</td>
          <td class="paramname"><em>angleRad</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given an 3D axis and an angle expressed in radiants, fills the given matrix with a transform matrix that represents the rotation matrix of the given axis/angle. </p>
<p>The given matrix must be at least a 3x3 matrix. If the matrix is a higher than 3x3 (e.g. 4x4), only the 3x3 submatrix will be set, leaving unchanged the other values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix</td><td></td></tr>
    <tr><td class="paramname">axis</td><td></td></tr>
    <tr><td class="paramname">angleRad</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gabd5d95d87600e42a0da835735e35ea99" name="gabd5d95d87600e42a0da835735e35ea99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabd5d95d87600e42a0da835735e35ea99">&#9670;&#160;</a></span>setTransformMatrixRotationDeg()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MatrixConcept MatrixType, Point3Concept PointType, <a class="el" href="classvcl_1_1Box.html">typename</a> ScalarType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Box.html">void</a> vcl::setTransformMatrixRotationDeg </td>
          <td>(</td>
          <td class="paramtype">MatrixType &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PointType&#160;</td>
          <td class="paramname"><em>axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">const</a> ScalarType &amp;&#160;</td>
          <td class="paramname"><em>angleDeg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given an 3D axis and an angle expressed in degrees, fills the given matrix with a transform matrix that represents the rotation matrix of the given axis/angle. </p>
<p>The given matrix must be at least a 3x3 matrix. If the matrix is a higher than 3x3 (e.g. 4x4), only the 3x3 submatrix will be set, leaving unchanged the other values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix</td><td></td></tr>
    <tr><td class="paramname">axis</td><td></td></tr>
    <tr><td class="paramname">angleDeg</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga438da980623645640c78105766bde287" name="ga438da980623645640c78105766bde287"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga438da980623645640c78105766bde287">&#9670;&#160;</a></span>sphericalFibonacciPointSet()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Point3Concept PointType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; PointType &gt; vcl::sphericalFibonacciPointSet </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a vector of <code>n</code> points distributed in a unit sphere. </p>
<p>This function returns a vector of <code>n</code> points that are uniformly distributed on a unit sphere, using the Spherical Fibonacci <a class="el" href="classvcl_1_1Point.html" title="The Point class represents an N-dimensional point containing N scalar values.">Point</a> Sets algorithm described in the paper "Spherical Fibonacci Mapping" by Benjamin Keinert, Matthias Innmann, Michael Sanger, and Marc Stamminger (TOG 2015).</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">PointType</td><td>The type of the point to generate. This type must satisfy the <code>Point3Concept</code> concept.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>The number of points to generate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of <code>n</code> points distributed in a unit sphere. </dd></dl>

</div>
</div>
<a id="gaaef0e24c2e1f1179f14204b1a56c57d9" name="gaaef0e24c2e1f1179f14204b1a56c57d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaef0e24c2e1f1179f14204b1a56c57d9">&#9670;&#160;</a></span>toDeg()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classvcl_1_1Box.html">typename</a> Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Scalar vcl::toDeg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">const</a> Scalar &amp;&#160;</td>
          <td class="paramname"><em>rad</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts an angle in radians to degrees. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rad</td><td>the angle in radians </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the angle in degrees. </dd></dl>

</div>
</div>
<a id="ga47c44328e5dfdb6c7e872aaa04fd2eba" name="ga47c44328e5dfdb6c7e872aaa04fd2eba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga47c44328e5dfdb6c7e872aaa04fd2eba">&#9670;&#160;</a></span>toRad()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classvcl_1_1Box.html">typename</a> Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Scalar vcl::toRad </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">const</a> Scalar &amp;&#160;</td>
          <td class="paramname"><em>deg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts an angle in degrees to radians. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">deg</td><td>the angle in degrees </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the angle in radians.ù </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
