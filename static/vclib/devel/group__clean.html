<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Visual Computing Library: Cleaning and Repairing Algorithms</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript" src="../version-selector.js"></script>
       <script type="text/javascript">
           DoxygenAwesomeDarkModeToggle.init()
       </script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Visual Computing Library
   &#160;<span id="projectnumber">devel</span>
   </div>
   <!-- Version selector dropdown -->
   <div id="version-selector" style="margin-top: 10px;">
     <label for="version-dropdown" style="font-size: 12px; color: #666;">Version:</label>
     <select id="version-dropdown" style="margin-left: 5px; padding: 2px 5px; font-size: 12px; border: 1px solid #ccc; border-radius: 3px;">
       <option value="">Loading versions...</option>
     </select>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group__clean.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Cleaning and Repairing Algorithms<div class="ingroups"><a class="el" href="group__algorithms__mesh.html">Mesh Algorithms</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>List of Mesh Cleaning and repairing algorithms.  
<a href="#details">More...</a></p>
<div class="dynheader">
Collaboration diagram for Cleaning and Repairing Algorithms:</div>
<div class="dyncontent">
<div class="center"><img src="group__clean.png" border="0" usemap="#agroup____clean" alt=""/></div>
<map name="agroup____clean" id="agroup____clean">
<area shape="rect" href="group__algorithms__mesh.html" title="List of Mesh algorithms." alt="" coords="5,13,137,38"/>
<area shape="rect" title="List of Mesh Cleaning and repairing algorithms." alt="" coords="185,5,359,45"/>
</map>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga200b140ad3fd1b049d6c683b82084d9f" id="r_ga200b140ad3fd1b049d6c683b82084d9f"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; <br />
requires HasPerFaceAdjacentFaces&lt;MeshType&gt;</td></tr>
<tr class="memitem:ga200b140ad3fd1b049d6c683b82084d9f"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::set&lt; uint &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__clean.html#ga200b140ad3fd1b049d6c683b82084d9f">vcl::connectedComponents</a> (<a class="el" href="classvcl_1_1Box.html">const</a> MeshType &amp;<a class="el" href="classvcl_1_1Box.html">m</a>)</td></tr>
<tr class="memdesc:ga200b140ad3fd1b049d6c683b82084d9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the connected components of the input mesh based on its topology.  <br /></td></tr>
<tr class="separator:ga200b140ad3fd1b049d6c683b82084d9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae4c34d80af91ce6339f86c6de2c702cd" id="r_gae4c34d80af91ce6339f86c6de2c702cd"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:gae4c34d80af91ce6339f86c6de2c702cd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Box.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__clean.html#gae4c34d80af91ce6339f86c6de2c702cd">vcl::isWaterTight</a> (<a class="el" href="classvcl_1_1Box.html">const</a> MeshType &amp;<a class="el" href="classvcl_1_1Box.html">m</a>)</td></tr>
<tr class="memdesc:gae4c34d80af91ce6339f86c6de2c702cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the input mesh is water tight.  <br /></td></tr>
<tr class="separator:gae4c34d80af91ce6339f86c6de2c702cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf8a059b21f1238f6e531191f40685670" id="r_gaf8a059b21f1238f6e531191f40685670"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:gaf8a059b21f1238f6e531191f40685670"><td class="memTemplItemLeft" align="right" valign="top">uint&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__clean.html#gaf8a059b21f1238f6e531191f40685670">vcl::numberConnectedComponents</a> (<a class="el" href="classvcl_1_1Box.html">const</a> MeshType &amp;<a class="el" href="classvcl_1_1Box.html">m</a>)</td></tr>
<tr class="memdesc:gaf8a059b21f1238f6e531191f40685670"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the number of connected components of the input mesh based on its topology.  <br /></td></tr>
<tr class="separator:gaf8a059b21f1238f6e531191f40685670"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9c26f362e15e9c53cb9c0ed13e0ed8b7" id="r_ga9c26f362e15e9c53cb9c0ed13e0ed8b7"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; <br />
requires HasPerFaceAdjacentFaces&lt;MeshType&gt;</td></tr>
<tr class="memitem:ga9c26f362e15e9c53cb9c0ed13e0ed8b7"><td class="memTemplItemLeft" align="right" valign="top">uint&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__clean.html#ga9c26f362e15e9c53cb9c0ed13e0ed8b7">vcl::numberHoles</a> (<a class="el" href="classvcl_1_1Box.html">const</a> MeshType &amp;<a class="el" href="classvcl_1_1Box.html">m</a>)</td></tr>
<tr class="memdesc:ga9c26f362e15e9c53cb9c0ed13e0ed8b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counts the number of holes in the input mesh.  <br /></td></tr>
<tr class="separator:ga9c26f362e15e9c53cb9c0ed13e0ed8b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd1e4943610b0e15397196d5fc73b0da" id="r_gabd1e4943610b0e15397196d5fc73b0da"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:gabd1e4943610b0e15397196d5fc73b0da"><td class="memTemplItemLeft" align="right" valign="top">uint&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__clean.html#gabd1e4943610b0e15397196d5fc73b0da">vcl::numberNonManifoldVertices</a> (<a class="el" href="classvcl_1_1Box.html">const</a> MeshType &amp;<a class="el" href="classvcl_1_1Box.html">m</a>)</td></tr>
<tr class="memdesc:gabd1e4943610b0e15397196d5fc73b0da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counts the number of non-manifold vertices in the input mesh.  <br /></td></tr>
<tr class="separator:gabd1e4943610b0e15397196d5fc73b0da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga79fa53e2d539bf957abab8e9bad12ff7" id="r_ga79fa53e2d539bf957abab8e9bad12ff7"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga79fa53e2d539bf957abab8e9bad12ff7"><td class="memTemplItemLeft" align="right" valign="top">uint&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__clean.html#ga79fa53e2d539bf957abab8e9bad12ff7">vcl::numberUnreferencedVertices</a> (<a class="el" href="classvcl_1_1Box.html">const</a> MeshType &amp;<a class="el" href="classvcl_1_1Box.html">m</a>, <a class="el" href="classvcl_1_1Box.html">bool</a> <a class="el" href="classvcl_1_1Box.html">onlyFaces</a>=<a class="el" href="classvcl_1_1Box.html">false</a>)</td></tr>
<tr class="memdesc:ga79fa53e2d539bf957abab8e9bad12ff7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of non-deleted unreferenced vertices of the mesh.  <br /></td></tr>
<tr class="separator:ga79fa53e2d539bf957abab8e9bad12ff7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd9ad1f8e67f067f3ac809f013ea5c54" id="r_gadd9ad1f8e67f067f3ac809f013ea5c54"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classvcl_1_1Box.html">typename</a> Container , MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:gadd9ad1f8e67f067f3ac809f013ea5c54"><td class="memTemplItemLeft" align="right" valign="top">Container&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__clean.html#gadd9ad1f8e67f067f3ac809f013ea5c54">vcl::referencedVertices</a> (<a class="el" href="classvcl_1_1Box.html">const</a> MeshType &amp;mesh, uint &amp;<a class="el" href="classvcl_1_1Box.html">nUnref</a>, <a class="el" href="classvcl_1_1Box.html">bool</a> <a class="el" href="classvcl_1_1Box.html">onlyFaces</a>=<a class="el" href="classvcl_1_1Box.html">false</a>)</td></tr>
<tr class="memdesc:gadd9ad1f8e67f067f3ac809f013ea5c54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a Container of values interpreted as booleans telling, for each vertex of the mesh, if it is referenced.  <br /></td></tr>
<tr class="separator:gadd9ad1f8e67f067f3ac809f013ea5c54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga351485ba1c87c7bd1193917323921ba7" id="r_ga351485ba1c87c7bd1193917323921ba7"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga351485ba1c87c7bd1193917323921ba7"><td class="memTemplItemLeft" align="right" valign="top">uint&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__clean.html#ga351485ba1c87c7bd1193917323921ba7">vcl::removeDegeneratedVertices</a> (MeshType &amp;<a class="el" href="classvcl_1_1Box.html">m</a>, <a class="el" href="classvcl_1_1Box.html">bool</a> <a class="el" href="classvcl_1_1Box.html">deleteAlsoFaces</a>)</td></tr>
<tr class="memdesc:ga351485ba1c87c7bd1193917323921ba7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all vertices that have position with invalid floating point values (NaN or inf).  <br /></td></tr>
<tr class="separator:ga351485ba1c87c7bd1193917323921ba7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3561ea390b2dfc6fec49d12543ea60e7" id="r_ga3561ea390b2dfc6fec49d12543ea60e7"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga3561ea390b2dfc6fec49d12543ea60e7"><td class="memTemplItemLeft" align="right" valign="top">uint&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__clean.html#ga3561ea390b2dfc6fec49d12543ea60e7">vcl::removeDegenerateFaces</a> (MeshType &amp;<a class="el" href="classvcl_1_1Box.html">m</a>)</td></tr>
<tr class="memdesc:ga3561ea390b2dfc6fec49d12543ea60e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all degenerate faces from the input mesh.  <br /></td></tr>
<tr class="separator:ga3561ea390b2dfc6fec49d12543ea60e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e771a075c5db04274b407af212d2c2b" id="r_ga6e771a075c5db04274b407af212d2c2b"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga6e771a075c5db04274b407af212d2c2b"><td class="memTemplItemLeft" align="right" valign="top">uint&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__clean.html#ga6e771a075c5db04274b407af212d2c2b">vcl::removeDuplicatedFaces</a> (MeshType &amp;<a class="el" href="classvcl_1_1Box.html">m</a>)</td></tr>
<tr class="memdesc:ga6e771a075c5db04274b407af212d2c2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all duplicate faces of the mesh by looking only at their vertex references.  <br /></td></tr>
<tr class="separator:ga6e771a075c5db04274b407af212d2c2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabce801a437aa06438837271fde16cb5a" id="r_gabce801a437aa06438837271fde16cb5a"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:gabce801a437aa06438837271fde16cb5a"><td class="memTemplItemLeft" align="right" valign="top">uint&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__clean.html#gabce801a437aa06438837271fde16cb5a">vcl::removeDuplicatedVertices</a> (MeshType &amp;<a class="el" href="classvcl_1_1Box.html">m</a>)</td></tr>
<tr class="memdesc:gabce801a437aa06438837271fde16cb5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marks as deleted the duplicate vertices of the mesh, by looking only at their spatial positions.  <br /></td></tr>
<tr class="separator:gabce801a437aa06438837271fde16cb5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25c5d478a258364fa7a8215e7ffbb7d2" id="r_ga25c5d478a258364fa7a8215e7ffbb7d2"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga25c5d478a258364fa7a8215e7ffbb7d2"><td class="memTemplItemLeft" align="right" valign="top">uint&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__clean.html#ga25c5d478a258364fa7a8215e7ffbb7d2">vcl::removeUnreferencedVertices</a> (MeshType &amp;<a class="el" href="classvcl_1_1Box.html">m</a>)</td></tr>
<tr class="memdesc:ga25c5d478a258364fa7a8215e7ffbb7d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marks as deleted all the non-deleted unreferenced vertices of the mesh.  <br /></td></tr>
<tr class="separator:ga25c5d478a258364fa7a8215e7ffbb7d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>List of Mesh Cleaning and repairing algorithms. </p>
<p>This group contains algorithms for cleaning and repairing meshes, along with algorithms for checking the mesh topology that allow to identify issues in the mesh structure.</p>
<p>You can access these algorithms by including <code>#include &lt;vclib/algorithms/clean.h&gt;</code> </p>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga200b140ad3fd1b049d6c683b82084d9f" name="ga200b140ad3fd1b049d6c683b82084d9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga200b140ad3fd1b049d6c683b82084d9f">&#9670;&#160;</a></span>connectedComponents()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; <br />
requires HasPerFaceAdjacentFaces&lt;MeshType&gt;</div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::set&lt; uint &gt; &gt; vcl::connectedComponents </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">const</a> MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the connected components of the input mesh based on its topology. </p>
<p>This function computes the connected components of the input mesh based on its topology, and returns a vector of sets, where each set represents a connected component and contains the face indices of the mesh that compose it. The function uses a depth-first search algorithm to traverse the mesh and find the connected components. The function requires the input MeshType to have per-face adjacent faces, and uses the <code><a class="el" href="group__face__requirements.html#gaff3602e750a1d1c93374f642be47a6b0" title="This function asserts that a Mesh has a FaceContainer, the Face has a AdjacentFaces Component,...">vcl::requirePerFaceAdjacentFaces</a></code> function to enforce this requirement.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MeshType</td><td>The type of the input <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>. It must satisfy the FaceMeshConcept and have per-face adjacent faces.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>The input mesh for which to compute the connected components. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of sets representing the connected components of the input mesh. Each set contains the face indices of the mesh that compose a connected component. </dd></dl>

</div>
</div>
<a id="gae4c34d80af91ce6339f86c6de2c702cd" name="gae4c34d80af91ce6339f86c6de2c702cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae4c34d80af91ce6339f86c6de2c702cd">&#9670;&#160;</a></span>isWaterTight()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Box.html">bool</a> vcl::isWaterTight </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">const</a> MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether the input mesh is water tight. </p>
<p>This function performs a simple test of water tightness on the input mesh, checking that there are no boundary and no non-manifold edges, assuming that the mesh is orientable. It could be debated whether a closed non-orientable surface is water tight or not, but this function does not take orientability into account.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MeshType</td><td>The type of the input <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>. It must satisfy the FaceMeshConcept.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>The input mesh to check for water tightness.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the input mesh is water tight (i.e., closed and manifold), <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="gaf8a059b21f1238f6e531191f40685670" name="gaf8a059b21f1238f6e531191f40685670"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf8a059b21f1238f6e531191f40685670">&#9670;&#160;</a></span>numberConnectedComponents()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">uint vcl::numberConnectedComponents </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">const</a> MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the number of connected components of the input mesh based on its topology. </p>
<p>This function computes the number of connected components of the input mesh based on its topology, and returns the result as an unsigned integer. The function simply calls the <code>connectedComponents</code> function to compute the connected components and then returns the size of the resulting vector.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MeshType</td><td>The type of the input <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>. It must satisfy the FaceMeshConcept and have per-face adjacent faces.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>The input mesh for which to compute the number of connected components. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of connected components of the input mesh. </dd></dl>

</div>
</div>
<a id="ga9c26f362e15e9c53cb9c0ed13e0ed8b7" name="ga9c26f362e15e9c53cb9c0ed13e0ed8b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9c26f362e15e9c53cb9c0ed13e0ed8b7">&#9670;&#160;</a></span>numberHoles()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; <br />
requires HasPerFaceAdjacentFaces&lt;MeshType&gt;</div>
      <table class="memname">
        <tr>
          <td class="memname">uint vcl::numberHoles </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">const</a> MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Counts the number of holes in the input mesh. </p>
<p>This function counts the number of holes in the input mesh, where a hole is defined as a closed loop of border edges. The function uses a depth-first search algorithm to traverse the mesh and find all the holes. The function requires the input MeshType to have per-face adjacent faces, and uses the <code><a class="el" href="group__face__requirements.html#gaff3602e750a1d1c93374f642be47a6b0" title="This function asserts that a Mesh has a FaceContainer, the Face has a AdjacentFaces Component,...">vcl::requirePerFaceAdjacentFaces</a></code> function to enforce this requirement.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MeshType</td><td>The type of the input <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>. It must satisfy the FaceMeshConcept and have per-face adjacent faces.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>The input mesh for which to count the number of holes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of holes in the input mesh. </dd></dl>

</div>
</div>
<a id="gabd1e4943610b0e15397196d5fc73b0da" name="gabd1e4943610b0e15397196d5fc73b0da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabd1e4943610b0e15397196d5fc73b0da">&#9670;&#160;</a></span>numberNonManifoldVertices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">uint vcl::numberNonManifoldVertices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">const</a> MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Counts the number of non-manifold vertices in the input mesh. </p>
<p>This function counts the number of vertices in the input mesh that are non-manifold, meaning that they are connected to more than two faces. A non-manifold vertex is one that belongs to two or more different edges that are not part of the same face.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MeshType</td><td>The type of the input <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>. It must satisfy the FaceMeshConcept.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>The input mesh for which to count the number of non-manifold vertices. This mesh will not be modified by the function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of non-manifold vertices in the input mesh. </dd></dl>

</div>
</div>
<a id="ga79fa53e2d539bf957abab8e9bad12ff7" name="ga79fa53e2d539bf957abab8e9bad12ff7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga79fa53e2d539bf957abab8e9bad12ff7">&#9670;&#160;</a></span>numberUnreferencedVertices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">uint vcl::numberUnreferencedVertices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">const</a> MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">bool</a>&#160;</td>
          <td class="paramname"><em>onlyFaces</em> = <code><a class="el" href="classvcl_1_1Box.html">false</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of non-deleted unreferenced vertices of the mesh. </p>
<p>This function calculates the number of vertices that are not referenced by any of the elements of the mesh, and which have not been marked as deleted.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MeshType</td><td>the type of the input <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>. It must satisfy the MeshConcept.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>The input mesh for which to calculate the number of unreferenced vertices. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">onlyFaces</td><td>If true, only the faces of the mesh are considered, and any other element will not be checked for vertex references. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of non-deleted unreferenced vertices in the mesh. </dd></dl>

</div>
</div>
<a id="gadd9ad1f8e67f067f3ac809f013ea5c54" name="gadd9ad1f8e67f067f3ac809f013ea5c54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadd9ad1f8e67f067f3ac809f013ea5c54">&#9670;&#160;</a></span>referencedVertices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classvcl_1_1Box.html">typename</a> Container , MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Container vcl::referencedVertices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">const</a> MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint &amp;&#160;</td>
          <td class="paramname"><em>nUnref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">bool</a>&#160;</td>
          <td class="paramname"><em>onlyFaces</em> = <code><a class="el" href="classvcl_1_1Box.html">false</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a Container of values interpreted as booleans telling, for each vertex of the mesh, if it is referenced. </p>
<p>If the parameter <code>onlyFaces</code> is <code>false</code> (default), the check is made for each <a class="el" href="classvcl_1_1Element.html" title="The Element class.">Element</a> of the mesh that stores <a class="el" href="classvcl_1_1Vertex.html" title="The Vertex class represents an Vertex element of the vcl::Mesh class.">Vertex</a> References. If <code>onlyFaces</code> is <code>true</code>, the check is made only for the Faces of the mesh.</p>
<p>The size of the returned container will be == to the vertexContainerSize of the mesh, and all the deleted vertices are marked as unreferenced by default.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Container</td><td>The type of the container to be used to store the boolean values. It must be a container that can be indexed with integer values and that can be initialized with a size and a default value. </td></tr>
    <tr><td class="paramname">MeshType</td><td>The type of the input <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>. It must satisfy the MeshConcept.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>The input mesh for which to calculate the referenced vertices. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">nUnref</td><td>The number of non-referenced vertices. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">onlyFaces</td><td>If true, only the faces of the mesh are considered, and any other element will not be checked for vertex references. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a Container of values interpreted as booleans telling, for each vertex of the mesh, if it is referenced. </dd></dl>

</div>
</div>
<a id="ga351485ba1c87c7bd1193917323921ba7" name="ga351485ba1c87c7bd1193917323921ba7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga351485ba1c87c7bd1193917323921ba7">&#9670;&#160;</a></span>removeDegeneratedVertices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">uint vcl::removeDegeneratedVertices </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">bool</a>&#160;</td>
          <td class="paramname"><em>deleteAlsoFaces</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes all vertices that have position with invalid floating point values (NaN or inf). </p>
<p>This function removes all vertices in the input mesh that have position with invalid floating point values, such as NaN or inf. If the input mesh has faces, and if the flag <code>deleteAlsoFaces</code> is set to true, all faces incident on deleted vertices are also deleted.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MeshType</td><td>The type of the input <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>. It must satisfy the MeshConcept.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">m</td><td>The input mesh for which to remove degenerated vertices. This mesh will be modified in place, with all degenerated vertices being marked as deleted.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">deleteAlsoFaces</td><td>If true, all faces incident on deleted vertices will also be deleted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of degenerated vertices that were marked as deleted. </dd></dl>

</div>
</div>
<a id="ga3561ea390b2dfc6fec49d12543ea60e7" name="ga3561ea390b2dfc6fec49d12543ea60e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3561ea390b2dfc6fec49d12543ea60e7">&#9670;&#160;</a></span>removeDegenerateFaces()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">uint vcl::removeDegenerateFaces </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes all degenerate faces from the input mesh. </p>
<p>This function removes all faces in the input mesh that are topologically degenerate, meaning that they have two or more vertex references that link the same vertex. All degenerate faces are zero area faces, but not all zero area faces are degenerate (for example, a face with three different vertex references, but two of them have the same position). Therefore, if you also want to remove these kinds of faces, you should call <code>removeDuplicatedVertices(m)</code> first. This function does not adjust topology.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MeshType</td><td>The type of the input <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>. It must satisfy the FaceMeshConcept.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">m</td><td>The input mesh for which to remove degenerate faces. This mesh will be modified in place, with all degenerate faces being marked as deleted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of degenerate faces that were marked as deleted. </dd></dl>

</div>
</div>
<a id="ga6e771a075c5db04274b407af212d2c2b" name="ga6e771a075c5db04274b407af212d2c2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6e771a075c5db04274b407af212d2c2b">&#9670;&#160;</a></span>removeDuplicatedFaces()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">uint vcl::removeDuplicatedFaces </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes all duplicate faces of the mesh by looking only at their vertex references. </p>
<p>This function removes all faces in the input mesh that have the same vertex references as another face in the mesh. The comparison of face vertex references is based on the indices of the face vertices, so it assumes that the mesh's vertices have already been unified.</p>
<dl class="section note"><dt>Note</dt><dd>This function currently only works for triangle meshes. It should be made more general to work for polygonal meshes as well.</dd>
<dd>
This function does not update any topology relation that could be affected by the removal of duplicate faces, such as the VF or FF relation. Therefore, it is usually performed before building any topology information.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MeshType</td><td>The type of the input <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>. It must satisfy the TriangleMeshConcept.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">m</td><td>The input mesh for which to remove duplicate faces. This mesh will be modified in place, with all duplicate faces being marked as deleted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of duplicated faces that were marked as deleted. </dd></dl>

</div>
</div>
<a id="gabce801a437aa06438837271fde16cb5a" name="gabce801a437aa06438837271fde16cb5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabce801a437aa06438837271fde16cb5a">&#9670;&#160;</a></span>removeDuplicatedVertices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">uint vcl::removeDuplicatedVertices </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Marks as deleted the duplicate vertices of the mesh, by looking only at their spatial positions. </p>
<p>This function marks as deleted all vertices in the input mesh that have the same spatial position as another vertex in the mesh. The comparison of vertex positions is based on the <code>position()</code> function of the vertex type, which must return a 3D point representing the vertex position.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MeshType</td><td>The type of the input <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>. It must satisfy the MeshConcept.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">m</td><td>The input mesh for which to remove duplicate vertices. This mesh will be modified in place, with all duplicate vertices being marked as deleted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of duplicated vertices that were marked as deleted. </dd></dl>

</div>
</div>
<a id="ga25c5d478a258364fa7a8215e7ffbb7d2" name="ga25c5d478a258364fa7a8215e7ffbb7d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga25c5d478a258364fa7a8215e7ffbb7d2">&#9670;&#160;</a></span>removeUnreferencedVertices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">uint vcl::removeUnreferencedVertices </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Marks as deleted all the non-deleted unreferenced vertices of the mesh. </p>
<p>This function marks as deleted all vertices in the input mesh that are not referenced by any of the mesh's elements, and which have not already been marked as deleted.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MeshType</td><td>The type of the input <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>. It must satisfy the MeshConcept.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">m</td><td>The input mesh for which to remove the unreferenced vertices. This mesh will be modified in place, with all unreferenced vertices being marked as deleted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of non-deleted vertices that were marked as deleted. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
