<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Visual Computing Library: Base</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript" src="../version-selector.js"></script>
       <script type="text/javascript">
           DoxygenAwesomeDarkModeToggle.init()
       </script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Visual Computing Library
   &#160;<span id="projectnumber">devel</span>
   </div>
   <!-- Version selector dropdown -->
   <div id="version-selector" style="margin-top: 10px;">
     <label for="version-dropdown" style="font-size: 12px; color: #666;">Version:</label>
     <select id="version-dropdown" style="margin-left: 5px; padding: 2px 5px; font-size: 12px; border: 1px solid #ccc; border-radius: 3px;">
       <option value="">Loading versions...</option>
     </select>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group__base.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#concepts">Concepts</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">Base</div></div>
</div><!--header-->
<div class="contents">

<p>The Base module defines all the utility definitions, types, classes and type traits that are common in the library.  
<a href="#details">More...</a></p>
<div class="dynheader">
Collaboration diagram for Base:</div>
<div class="dyncontent">
<div class="center"><img src="group__base.png" border="0" usemap="#agroup____base" alt=""/></div>
<map name="agroup____base" id="agroup____base">
<area shape="rect" title="The Base module defines all the utility definitions, types, classes and type traits that are common i..." alt="" coords="5,31,60,56"/>
<area shape="rect" href="group__exceptions.html" title="List of exceptions used in the library." alt="" coords="269,5,363,31"/>
<area shape="rect" href="group__views.html" title="List of range views of the library." alt="" coords="285,55,347,80"/>
</map>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="concepts" name="concepts"></a>
Concepts</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptvcl_1_1LoggerConcept.html">vcl::LoggerConcept</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The LoggerConcept is satisfied if the type T is a valid Logger type. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1AbstractLogger.html">vcl::AbstractLogger</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classvcl_1_1AbstractLogger.html" title="The AbstractLogger class is used as common ancestor class for all the logger types in the library.">AbstractLogger</a> class is used as common ancestor class for all the logger types in the library.  <a href="classvcl_1_1AbstractLogger.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvcl_1_1CompId.html">vcl::CompId</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="structvcl_1_1CompId.html" title="The CompId struct enumerates the components that can compose a element or a mesh.">CompId</a> struct enumerates the components that can compose a element or a mesh.  <a href="structvcl_1_1CompId.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvcl_1_1ComponentString.html">vcl::ComponentString&lt; COMP_ID &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="structvcl_1_1ComponentString.html" title="The ComponentString class is used to retrieve the string associated to a COMP_ID value,...">ComponentString</a> class is used to retrieve the string associated to a COMP_ID value, trough its member 'str'.  <a href="structvcl_1_1ComponentString.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvcl_1_1ElementString.html">vcl::ElementString&lt; ELEM_ID &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="structvcl_1_1ElementString.html" title="The ElementString class is used to retrieve the string associated to a ELEM_ID value,...">ElementString</a> class is used to retrieve the string associated to a ELEM_ID value, trough its member 'str'.  <a href="structvcl_1_1ElementString.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvcl_1_1ElemId.html">vcl::ElemId</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="structvcl_1_1ElemId.html" title="The ElemId struct enumerates the elements that can compose a mesh.">ElemId</a> struct enumerates the elements that can compose a mesh.  <a href="structvcl_1_1ElemId.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1FakePointerWithValue.html">vcl::FakePointerWithValue&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple utility class to represent a pointer with a value.  <a href="classvcl_1_1FakePointerWithValue.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvcl_1_1FilterTypesByCondition.html">vcl::FilterTypesByCondition&lt; typename,... &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all types that do not satisfy a condition, and get them as a <a class="el" href="structvcl_1_1TypeWrapper.html" title="A simple structure that wraps a list of variadic templates, without instantiating anything....">TypeWrapper</a>.  <a href="structvcl_1_1FilterTypesByCondition.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvcl_1_1FilterTypesByCondition_3_01Pred_00_01Head_00_01Tail_8_8_8_01_4.html">vcl::FilterTypesByCondition&lt; Pred, Head, Tail... &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all types that do not satisfy a condition, and get them as a <a class="el" href="structvcl_1_1TypeWrapper.html" title="A simple structure that wraps a list of variadic templates, without instantiating anything....">TypeWrapper</a>.    <a href="structvcl_1_1FilterTypesByCondition_3_01Pred_00_01Head_00_01Tail_8_8_8_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvcl_1_1FilterTypesByCondition_3_01Pred_00_01TypeWrapper_3_01Tail_8_8_8_01_4_01_4.html">vcl::FilterTypesByCondition&lt; Pred, TypeWrapper&lt; Tail... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all types that do not satisfy a condition, and get them as a <a class="el" href="structvcl_1_1TypeWrapper.html" title="A simple structure that wraps a list of variadic templates, without instantiating anything....">TypeWrapper</a>.    <a href="structvcl_1_1FilterTypesByCondition_3_01Pred_00_01TypeWrapper_3_01Tail_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvcl_1_1FirstType.html">vcl::FirstType&lt; Args &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the first type of a pack of types (variadic templates) or a <a class="el" href="structvcl_1_1TypeWrapper.html" title="A simple structure that wraps a list of variadic templates, without instantiating anything....">TypeWrapper</a>.  <a href="structvcl_1_1FirstType.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvcl_1_1FirstType_3_01TypeWrapper_3_01Args_8_8_8_01_4_01_4.html">vcl::FirstType&lt; TypeWrapper&lt; Args... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the first type of a pack of types (variadic templates) or a <a class="el" href="structvcl_1_1TypeWrapper.html" title="A simple structure that wraps a list of variadic templates, without instantiating anything....">TypeWrapper</a>.    <a href="structvcl_1_1FirstType_3_01TypeWrapper_3_01Args_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvcl_1_1ForEachType.html">vcl::ForEachType&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows to apply a function to each type in a variadic template pack.  <a href="structvcl_1_1ForEachType.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvcl_1_1ForEachType_3_01TypeWrapper_3_01T_8_8_8_01_4_01_4.html">vcl::ForEachType&lt; TypeWrapper&lt; T... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows to apply a function to each type in a variadic template pack.    <a href="structvcl_1_1ForEachType_3_01TypeWrapper_3_01T_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvcl_1_1GetTypeByCondition.html">vcl::GetTypeByCondition&lt; Pred, Args &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets <code>type</code> to the first type of a pack that satisfies the given condition.  <a href="structvcl_1_1GetTypeByCondition.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvcl_1_1GetTypeByCondition_3_01Pred_00_01TypeWrapper_3_01Args_8_8_8_01_4_01_4.html">vcl::GetTypeByCondition&lt; Pred, TypeWrapper&lt; Args... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets <code>type</code> to the first type of a pack that satisfies the given condition.    <a href="structvcl_1_1GetTypeByCondition_3_01Pred_00_01TypeWrapper_3_01Args_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvcl_1_1IndexInTypes.html">vcl::IndexInTypes&lt; T, Us &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the index of a type T in a pack of types (variadic templates) or a <a class="el" href="structvcl_1_1TypeWrapper.html" title="A simple structure that wraps a list of variadic templates, without instantiating anything....">TypeWrapper</a>.  <a href="structvcl_1_1IndexInTypes.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvcl_1_1IndexInTypes_3_01T_00_01TypeWrapper_3_01Us_8_8_8_01_4_01_4.html">vcl::IndexInTypes&lt; T, TypeWrapper&lt; Us... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the index of a type T in a pack of types (variadic templates) or a <a class="el" href="structvcl_1_1TypeWrapper.html" title="A simple structure that wraps a list of variadic templates, without instantiating anything....">TypeWrapper</a>.    <a href="structvcl_1_1IndexInTypes_3_01T_00_01TypeWrapper_3_01Us_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvcl_1_1IsDerivedFromSpecializationOf.html">vcl::IsDerivedFromSpecializationOf&lt; T, Template &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait to check if a type is derived from a specialization of a given template.  <a href="structvcl_1_1IsDerivedFromSpecializationOf.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvcl_1_1IsSpecializationOf.html">vcl::IsSpecializationOf&lt; T, Template &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait to check if a type is a specialization of a given template.  <a href="structvcl_1_1IsSpecializationOf.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvcl_1_1MakeConstPointer.html">vcl::MakeConstPointer&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility type that makes possible to treat const pointers in a templated class that can treat a both const and non-const pointer type.  <a href="structvcl_1_1MakeConstPointer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvcl_1_1MakeConstPointer_3_01T_01_5_01_4.html">vcl::MakeConstPointer&lt; T * &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility type that makes possible to treat const pointers in a templated class that can treat a both const and non-const pointer type.    <a href="structvcl_1_1MakeConstPointer_3_01T_01_5_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1NullLogger.html">vcl::NullLogger</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classvcl_1_1NullLogger.html" title="The NullLogger class is used as default type in all the library functions that take as input a logger...">NullLogger</a> class is used as default type in all the library functions that take as input a logger type.  <a href="classvcl_1_1NullLogger.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvcl_1_1NumberOfTypes.html">vcl::NumberOfTypes&lt; Args &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of types in a pack of types (variadic templates) or a <a class="el" href="structvcl_1_1TypeWrapper.html" title="A simple structure that wraps a list of variadic templates, without instantiating anything....">TypeWrapper</a>.  <a href="structvcl_1_1NumberOfTypes.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvcl_1_1NumberOfTypes_3_01TypeWrapper_3_01Args_8_8_8_01_4_01_4.html">vcl::NumberOfTypes&lt; TypeWrapper&lt; Args... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of types in a pack of types (variadic templates) or a <a class="el" href="structvcl_1_1TypeWrapper.html" title="A simple structure that wraps a list of variadic templates, without instantiating anything....">TypeWrapper</a>.    <a href="structvcl_1_1NumberOfTypes_3_01TypeWrapper_3_01Args_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvcl_1_1OneTypeAtLeastSatisfiesCondition.html">vcl::OneTypeAtLeastSatisfiesCondition&lt; Pred, Args &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets its <code>value</code> to <code>true</code> if there is at least one type in the given pack Args... that satisfies the given condition.  <a href="structvcl_1_1OneTypeAtLeastSatisfiesCondition.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvcl_1_1OneTypeAtLeastSatisfiesCondition_3_01Pred_00_01TypeWrapper_3_01Args_8_8_8_01_4_01_4.html">vcl::OneTypeAtLeastSatisfiesCondition&lt; Pred, TypeWrapper&lt; Args... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets its <code>value</code> to <code>true</code> if there is at least one type in the given pack Args... that satisfies the given condition.    <a href="structvcl_1_1OneTypeAtLeastSatisfiesCondition_3_01Pred_00_01TypeWrapper_3_01Args_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvcl_1_1TypeAt.html">vcl::TypeAt&lt; I, T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the type at a given index in a pack of types (variadic templates) or a <a class="el" href="structvcl_1_1TypeWrapper.html" title="A simple structure that wraps a list of variadic templates, without instantiating anything....">TypeWrapper</a>.  <a href="structvcl_1_1TypeAt.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvcl_1_1TypeAt_3_01I_00_01TypeWrapper_3_01T_8_8_8_01_4_01_4.html">vcl::TypeAt&lt; I, TypeWrapper&lt; T... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the type at a given index in a pack of types (variadic templates) or a <a class="el" href="structvcl_1_1TypeWrapper.html" title="A simple structure that wraps a list of variadic templates, without instantiating anything....">TypeWrapper</a>.    <a href="structvcl_1_1TypeAt_3_01I_00_01TypeWrapper_3_01T_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvcl_1_1TypeWrapper.html">vcl::TypeWrapper&lt; Args &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple structure that wraps a list of variadic templates, without instantiating anything. Useful when you need to wrap a list of types, and consider them as a single type.  <a href="structvcl_1_1TypeWrapper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1View.html">vcl::View&lt; It &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classvcl_1_1View.html" title="The View class is a simple class that stores and exposes two iterators begin and end.">View</a> class is a simple class that stores and exposes two iterators begin and end.  <a href="classvcl_1_1View.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1WrongSizeException.html">vcl::WrongSizeException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception thrown when the size (generally of a container) is not the expected one.  <a href="classvcl_1_1WrongSizeException.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gacf666dac86845a2be5e6ce935c5c67d7" id="r_gacf666dac86845a2be5e6ce935c5c67d7"><td class="memTemplParams" colspan="2"><a id="gacf666dac86845a2be5e6ce935c5c67d7" name="gacf666dac86845a2be5e6ce935c5c67d7"></a>
template&lt;<a class="el" href="classvcl_1_1Box.html">uint</a> COMP_ID, typename... Components&gt; </td></tr>
<tr class="memitem:gacf666dac86845a2be5e6ce935c5c67d7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Box.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>vcl::comp::ComponentOfType</b> = <a class="el" href="group__base.html#ga38c527736a2d0a3d7af0493e228227e3">FirstTypeT</a>&lt; <a class="el" href="classvcl_1_1Box.html">typename</a> detail::ComponentOfTypePred&lt; <a class="el" href="classvcl_1_1Box.html">COMP_ID</a>, Components... &gt;::type &gt;</td></tr>
<tr class="memdesc:gacf666dac86845a2be5e6ce935c5c67d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given the ID of a Component and a list of Component types (or a <a class="el" href="structvcl_1_1TypeWrapper.html" title="A simple structure that wraps a list of variadic templates, without instantiating anything....">TypeWrapper</a>), this alias sets its type to the corresponding Component type found in the list. <br /></td></tr>
<tr class="separator:gacf666dac86845a2be5e6ce935c5c67d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga38c527736a2d0a3d7af0493e228227e3" id="r_ga38c527736a2d0a3d7af0493e228227e3"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:ga38c527736a2d0a3d7af0493e228227e3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Box.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__base.html#ga38c527736a2d0a3d7af0493e228227e3">vcl::FirstTypeT</a> = <a class="el" href="classvcl_1_1Box.html">typename</a> <a class="el" href="structvcl_1_1FirstType.html">FirstType</a>&lt; Args... &gt;::type</td></tr>
<tr class="memdesc:ga38c527736a2d0a3d7af0493e228227e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for the type of the first type in a pack of types.  <br /></td></tr>
<tr class="separator:ga38c527736a2d0a3d7af0493e228227e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a37fc3ccf3b54b062d37fe46900e112" id="r_ga8a37fc3ccf3b54b062d37fe46900e112"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classvcl_1_1Box.html">typename</a> derived , <a class="el" href="classvcl_1_1Box.html">template</a>&lt; typename... &gt; <a class="el" href="classvcl_1_1Box.html">class</a> base&gt; </td></tr>
<tr class="memitem:ga8a37fc3ccf3b54b062d37fe46900e112"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Box.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__base.html#ga8a37fc3ccf3b54b062d37fe46900e112">vcl::IsDerivedFromTemplateSpecialization</a> = std::invoke_result&lt; detail::IsDerivedFromImplementation&lt; base &gt;, <a class="el" href="classvcl_1_1Box.html">typename</a> std::remove_cv&lt; derived &gt;::type * &gt;::type</td></tr>
<tr class="memdesc:ga8a37fc3ccf3b54b062d37fe46900e112"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility class that allows to check if given class 'Derived' is derived from a specialization of a templated class.  <br /></td></tr>
<tr class="separator:ga8a37fc3ccf3b54b062d37fe46900e112"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaacc96304be3365c944d0239dd550f74e" id="r_gaacc96304be3365c944d0239dd550f74e"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classvcl_1_1Box.html">typename</a> T &gt; </td></tr>
<tr class="memitem:gaacc96304be3365c944d0239dd550f74e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Box.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__base.html#gaacc96304be3365c944d0239dd550f74e">vcl::MakeConstPointerT</a> = <a class="el" href="classvcl_1_1Box.html">typename</a> <a class="el" href="structvcl_1_1MakeConstPointer.html">MakeConstPointer</a>&lt; T &gt;::type</td></tr>
<tr class="memdesc:gaacc96304be3365c944d0239dd550f74e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility alias for the <a class="el" href="structvcl_1_1MakeConstPointer.html" title="Utility type that makes possible to treat const pointers in a templated class that can treat a both c...">MakeConstPointer</a> type.  <br /></td></tr>
<tr class="separator:gaacc96304be3365c944d0239dd550f74e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacfdd7af0f9712ffc6b96c5d27be41965" id="r_gacfdd7af0f9712ffc6b96c5d27be41965"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classvcl_1_1Box.html">typename</a> T &gt; </td></tr>
<tr class="memitem:gacfdd7af0f9712ffc6b96c5d27be41965"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Box.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__base.html#gacfdd7af0f9712ffc6b96c5d27be41965">vcl::RemoveConstFromPointer</a> = std::conditional_t&lt; std::is_pointer_v&lt; T &gt;, std::add_pointer_t&lt; std::remove_cv_t&lt; <a class="el" href="group__base.html#ga25fc582d09d14f037e742c66fd58dbeb">RemovePtr</a>&lt; T &gt; &gt; &gt;, T &gt;</td></tr>
<tr class="memdesc:gacfdd7af0f9712ffc6b96c5d27be41965"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility alias to get a pointer type without the constness. e.g. If T is const int*, the resulting type is int* If the type is not a pointer, it is left as it was.  <br /></td></tr>
<tr class="separator:gacfdd7af0f9712ffc6b96c5d27be41965"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa1938bcd17ca07bf32500695f422efeb" id="r_gaa1938bcd17ca07bf32500695f422efeb"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classvcl_1_1Box.html">typename</a> T &gt; </td></tr>
<tr class="memitem:gaa1938bcd17ca07bf32500695f422efeb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Box.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__base.html#gaa1938bcd17ca07bf32500695f422efeb">vcl::RemoveCVRefAndPointer</a> = std::remove_cvref_t&lt; <a class="el" href="group__base.html#ga25fc582d09d14f037e742c66fd58dbeb">RemovePtr</a>&lt; T &gt; &gt;</td></tr>
<tr class="memdesc:gaa1938bcd17ca07bf32500695f422efeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility alias to get clean type from an input type that could have a reference or a pointer.  <br /></td></tr>
<tr class="separator:gaa1938bcd17ca07bf32500695f422efeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25fc582d09d14f037e742c66fd58dbeb" id="r_ga25fc582d09d14f037e742c66fd58dbeb"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classvcl_1_1Box.html">typename</a> T &gt; </td></tr>
<tr class="memitem:ga25fc582d09d14f037e742c66fd58dbeb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Box.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__base.html#ga25fc582d09d14f037e742c66fd58dbeb">vcl::RemovePtr</a> = std::remove_pointer_t&lt; T &gt;</td></tr>
<tr class="memdesc:ga25fc582d09d14f037e742c66fd58dbeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility alias to get a type without the pointer. e.g. If T is int*, the resulting type is int.  <br /></td></tr>
<tr class="separator:ga25fc582d09d14f037e742c66fd58dbeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c494877e683bb96964551900501a466" id="r_ga5c494877e683bb96964551900501a466"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classvcl_1_1Box.html">typename</a> T &gt; </td></tr>
<tr class="memitem:ga5c494877e683bb96964551900501a466"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Box.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__base.html#ga5c494877e683bb96964551900501a466">vcl::RemoveRef</a> = std::remove_reference_t&lt; T &gt;</td></tr>
<tr class="memdesc:ga5c494877e683bb96964551900501a466"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility alias to get a type type without the reference. e.g. If T is int&amp;, the resulting type is int.  <br /></td></tr>
<tr class="separator:ga5c494877e683bb96964551900501a466"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7532e3b30b940e66f546f75ea246acfa" id="r_ga7532e3b30b940e66f546f75ea246acfa"><td class="memTemplParams" colspan="2">template&lt;uint I, typename... T&gt; </td></tr>
<tr class="memitem:ga7532e3b30b940e66f546f75ea246acfa"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Box.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__base.html#ga7532e3b30b940e66f546f75ea246acfa">vcl::TypeAtT</a> = <a class="el" href="classvcl_1_1Box.html">typename</a> <a class="el" href="structvcl_1_1TypeAt.html">TypeAt</a>&lt; I, T... &gt;::type</td></tr>
<tr class="memdesc:ga7532e3b30b940e66f546f75ea246acfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for the type at a given index in a pack of types (variadic templates) or a <a class="el" href="structvcl_1_1TypeWrapper.html" title="A simple structure that wraps a list of variadic templates, without instantiating anything....">TypeWrapper</a>.  <br /></td></tr>
<tr class="separator:ga7532e3b30b940e66f546f75ea246acfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga16a1bfbea022f6766d2f3ebbf69a3b52" id="r_ga16a1bfbea022f6766d2f3ebbf69a3b52"><td class="memItemLeft" align="right" valign="top"><a id="ga16a1bfbea022f6766d2f3ebbf69a3b52" name="ga16a1bfbea022f6766d2f3ebbf69a3b52"></a>enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__base.html#ga16a1bfbea022f6766d2f3ebbf69a3b52">vcl::MatrixStorageType</a> { <b>ROW_MAJOR</b>
, <b>COLUMN_MAJOR</b>
 }</td></tr>
<tr class="memdesc:ga16a1bfbea022f6766d2f3ebbf69a3b52"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple type that enumerates the main storage types for matrices (row or column major). <br /></td></tr>
<tr class="separator:ga16a1bfbea022f6766d2f3ebbf69a3b52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga35a36b617de9550e23e0c1426a783464" id="r_ga35a36b617de9550e23e0c1426a783464"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__base.html#ga35a36b617de9550e23e0c1426a783464">vcl::PrimitiveType</a> { <br />
&#160;&#160;<b>CHAR</b>
, <b>UCHAR</b>
, <b>SHORT</b>
, <b>USHORT</b>
, <br />
&#160;&#160;<b>INT</b>
, <b>UINT</b>
, <b>FLOAT</b>
, <b>DOUBLE</b>
, <br />
&#160;&#160;<b>NONE</b>
<br />
 }</td></tr>
<tr class="memdesc:ga35a36b617de9550e23e0c1426a783464"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple type that enumerates the main primitive types.  <a href="group__base.html#ga35a36b617de9550e23e0c1426a783464">More...</a><br /></td></tr>
<tr class="separator:ga35a36b617de9550e23e0c1426a783464"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gae32401c3c5edbdeead1769b4d6160f87" id="r_gae32401c3c5edbdeead1769b4d6160f87"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classvcl_1_1Box.html">typename</a> T &gt; </td></tr>
<tr class="memitem:gae32401c3c5edbdeead1769b4d6160f87"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Box.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__base.html#gae32401c3c5edbdeead1769b4d6160f87">vcl::addressOfObj</a> (T &amp;<a class="el" href="classvcl_1_1Box.html">obj</a>)</td></tr>
<tr class="memdesc:gae32401c3c5edbdeead1769b4d6160f87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function that applies the unary operator '&amp;' to the argument only if it is not a pointer.  <br /></td></tr>
<tr class="separator:gae32401c3c5edbdeead1769b4d6160f87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ca8accd2e2b6881a3b2359e56396e77" id="r_ga9ca8accd2e2b6881a3b2359e56396e77"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classvcl_1_1Box.html">typename</a> T &gt; </td></tr>
<tr class="memitem:ga9ca8accd2e2b6881a3b2359e56396e77"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Box.html">constexpr</a> T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__base.html#ga9ca8accd2e2b6881a3b2359e56396e77">vcl::asConst</a> (<a class="el" href="classvcl_1_1Box.html">const</a> T &amp;value) <a class="el" href="classvcl_1_1Box.html">noexcept</a></td></tr>
<tr class="memdesc:ga9ca8accd2e2b6881a3b2359e56396e77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function that converts a const pointer/reference to a non-const pointer/reference.  <br /></td></tr>
<tr class="separator:ga9ca8accd2e2b6881a3b2359e56396e77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga943a3fda661e6e71d8fd7106f41dd878" id="r_ga943a3fda661e6e71d8fd7106f41dd878"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classvcl_1_1Box.html">typename</a> T &gt; </td></tr>
<tr class="memitem:ga943a3fda661e6e71d8fd7106f41dd878"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Box.html">constexpr</a> T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__base.html#ga943a3fda661e6e71d8fd7106f41dd878">vcl::asConst</a> (<a class="el" href="classvcl_1_1Box.html">const</a> T *value) <a class="el" href="classvcl_1_1Box.html">noexcept</a></td></tr>
<tr class="memdesc:ga943a3fda661e6e71d8fd7106f41dd878"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function that converts a const pointer/reference to a non-const pointer/reference.    <br /></td></tr>
<tr class="separator:ga943a3fda661e6e71d8fd7106f41dd878"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe5c457181ae725f99627c541993a3a8" id="r_gabe5c457181ae725f99627c541993a3a8"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classvcl_1_1Box.html">typename</a> T &gt; </td></tr>
<tr class="memitem:gabe5c457181ae725f99627c541993a3a8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Box.html">constexpr</a> T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__base.html#gabe5c457181ae725f99627c541993a3a8">vcl::asConst</a> (T *value) <a class="el" href="classvcl_1_1Box.html">noexcept</a></td></tr>
<tr class="memdesc:gabe5c457181ae725f99627c541993a3a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function that converts a const pointer/reference to a non-const pointer/reference.    <br /></td></tr>
<tr class="separator:gabe5c457181ae725f99627c541993a3a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga86d50e779d2b4fd59e31de5a48e6d112" id="r_ga86d50e779d2b4fd59e31de5a48e6d112"><td class="memTemplParams" colspan="2">template&lt;uint COMP_ID&gt; </td></tr>
<tr class="memitem:ga86d50e779d2b4fd59e31de5a48e6d112"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Box.html">constexpr</a> <a class="el" href="classvcl_1_1Box.html">const</a> <a class="el" href="classvcl_1_1Box.html">char</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__base.html#ga86d50e779d2b4fd59e31de5a48e6d112">vcl::componentEnumString</a> ()</td></tr>
<tr class="memdesc:ga86d50e779d2b4fd59e31de5a48e6d112"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the string associated to the COMP_ID value.  <br /></td></tr>
<tr class="separator:ga86d50e779d2b4fd59e31de5a48e6d112"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga769dac8f4b92030d30690a78b7fc2d79" id="r_ga769dac8f4b92030d30690a78b7fc2d79"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classvcl_1_1Box.html">typename</a> T &gt; </td></tr>
<tr class="memitem:ga769dac8f4b92030d30690a78b7fc2d79"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Box.html">auto</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__base.html#ga769dac8f4b92030d30690a78b7fc2d79">vcl::dereferencePtr</a> (T &amp;&amp;<a class="el" href="classvcl_1_1Box.html">obj</a>)</td></tr>
<tr class="memdesc:ga769dac8f4b92030d30690a78b7fc2d79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function that applies the unary operator '*' to the argument only if the object is a pointer, and returns a reference to the object itself.  <br /></td></tr>
<tr class="separator:ga769dac8f4b92030d30690a78b7fc2d79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0068c984cb7a600004242ea341b506eb" id="r_ga0068c984cb7a600004242ea341b506eb"><td class="memTemplParams" colspan="2">template&lt;uint ELEM_ID&gt; </td></tr>
<tr class="memitem:ga0068c984cb7a600004242ea341b506eb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Box.html">constexpr</a> <a class="el" href="classvcl_1_1Box.html">const</a> <a class="el" href="classvcl_1_1Box.html">char</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__base.html#ga0068c984cb7a600004242ea341b506eb">vcl::elementEnumCString</a> ()</td></tr>
<tr class="memdesc:ga0068c984cb7a600004242ea341b506eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the string associated to the ELEM_ID value.  <br /></td></tr>
<tr class="separator:ga0068c984cb7a600004242ea341b506eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab2bbb176efb4243ea25469bbbd1c53af" id="r_gab2bbb176efb4243ea25469bbbd1c53af"><td class="memTemplParams" colspan="2">template&lt;uint ELEM_ID&gt; </td></tr>
<tr class="memitem:gab2bbb176efb4243ea25469bbbd1c53af"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Box.html">const</a> std::string &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__base.html#gab2bbb176efb4243ea25469bbbd1c53af">vcl::elementEnumString</a> ()</td></tr>
<tr class="memdesc:gab2bbb176efb4243ea25469bbbd1c53af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the string associated to the ELEM_ID value.  <br /></td></tr>
<tr class="separator:gab2bbb176efb4243ea25469bbbd1c53af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f9b74af8b9f8a827e760dce325b820c" id="r_ga2f9b74af8b9f8a827e760dce325b820c"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classvcl_1_1Box.html">typename</a> Scalar &gt; </td></tr>
<tr class="memitem:ga2f9b74af8b9f8a827e760dce325b820c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Box.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__base.html#ga2f9b74af8b9f8a827e760dce325b820c">vcl::epsilonEquals</a> (Scalar <a class="el" href="classvcl_1_1Box.html">n1</a>, Scalar <a class="el" href="classvcl_1_1Box.html">n2</a>, Scalar <a class="el" href="classvcl_1_1Box.html">epsilon</a>=std::numeric_limits&lt; Scalar &gt;::epsilon())</td></tr>
<tr class="memdesc:ga2f9b74af8b9f8a827e760dce325b820c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if two floating point numbers are equal within an epsilon value.  <br /></td></tr>
<tr class="separator:ga2f9b74af8b9f8a827e760dce325b820c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb189433c1c9d7bf52a96ff359f364ec" id="r_gaeb189433c1c9d7bf52a96ff359f364ec"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classvcl_1_1Box.html">typename</a> T , typename... Rest&gt; </td></tr>
<tr class="memitem:gaeb189433c1c9d7bf52a96ff359f364ec"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Box.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__base.html#gaeb189433c1c9d7bf52a96ff359f364ec">vcl::hashCombine</a> (std::size_t &amp;<a class="el" href="classvcl_1_1Box.html">seed</a>, <a class="el" href="classvcl_1_1Box.html">const</a> T &amp;v, <a class="el" href="classvcl_1_1Box.html">const</a> <a class="el" href="classvcl_1_1Box.html">Rest</a> &amp;... <a class="el" href="classvcl_1_1Box.html">rest</a>)</td></tr>
<tr class="memdesc:gaeb189433c1c9d7bf52a96ff359f364ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starting from a seed, computes the hash of a series of objects.  <br /></td></tr>
<tr class="separator:gaeb189433c1c9d7bf52a96ff359f364ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae01694fdca8b252384be3296f82fa946" id="r_gae01694fdca8b252384be3296f82fa946"><td class="memTemplParams" colspan="2"><a id="gae01694fdca8b252384be3296f82fa946" name="gae01694fdca8b252384be3296f82fa946"></a>
template&lt;<a class="el" href="classvcl_1_1Box.html">typename</a> T , <a class="el" href="classvcl_1_1Box.html">typename</a> U , typename... Us&gt; </td></tr>
<tr class="memitem:gae01694fdca8b252384be3296f82fa946"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Box.html">constexpr</a> uint&#160;</td><td class="memTemplItemRight" valign="bottom"><b>vcl::indexInTypePack</b> ()</td></tr>
<tr class="memdesc:gae01694fdca8b252384be3296f82fa946"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that returns the index of a Type T in a pack of types (variadic templates). The pack is composed of U and Us... <br /></td></tr>
<tr class="separator:gae01694fdca8b252384be3296f82fa946"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac398b3cd16575f92ffc3e6cfd6ba1669" id="r_gac398b3cd16575f92ffc3e6cfd6ba1669"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classvcl_1_1Box.html">typename</a> U , typename... Us&gt; </td></tr>
<tr class="memitem:gac398b3cd16575f92ffc3e6cfd6ba1669"><td class="memTemplItemLeft" align="right" valign="top">uint&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__base.html#gac398b3cd16575f92ffc3e6cfd6ba1669">vcl::indexInTypePack</a> (std::type_index <a class="el" href="classvcl_1_1Box.html">ti</a>)</td></tr>
<tr class="memdesc:gac398b3cd16575f92ffc3e6cfd6ba1669"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that returns the index of the type having the given type_index in a pack of types (variadic templates). The pack is composed of U and Us...  <br /></td></tr>
<tr class="separator:gac398b3cd16575f92ffc3e6cfd6ba1669"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad6ce6ce1ca6a9813f3437aa0aeee2d94" id="r_gad6ce6ce1ca6a9813f3437aa0aeee2d94"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:gad6ce6ce1ca6a9813f3437aa0aeee2d94"><td class="memTemplItemLeft" align="right" valign="top">uint&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__base.html#gad6ce6ce1ca6a9813f3437aa0aeee2d94">vcl::indexInTypePack</a> (std::type_index <a class="el" href="classvcl_1_1Box.html">ti</a>, <a class="el" href="structvcl_1_1TypeWrapper.html">TypeWrapper</a>&lt; Args... &gt;)</td></tr>
<tr class="memdesc:gad6ce6ce1ca6a9813f3437aa0aeee2d94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that returns the index of the type having the given type_index in a <a class="el" href="structvcl_1_1TypeWrapper.html" title="A simple structure that wraps a list of variadic templates, without instantiating anything....">TypeWrapper</a>.  <br /></td></tr>
<tr class="separator:gad6ce6ce1ca6a9813f3437aa0aeee2d94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7da4c4b0342d3a5f906db63db504bea7" id="r_ga7da4c4b0342d3a5f906db63db504bea7"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classvcl_1_1Box.html">typename</a> Scalar &gt; </td></tr>
<tr class="memitem:ga7da4c4b0342d3a5f906db63db504bea7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Box.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__base.html#ga7da4c4b0342d3a5f906db63db504bea7">vcl::isDegenerate</a> (Scalar number)</td></tr>
<tr class="memdesc:ga7da4c4b0342d3a5f906db63db504bea7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a floating point number is degenerate.  <br /></td></tr>
<tr class="separator:ga7da4c4b0342d3a5f906db63db504bea7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa6613e39304926dee856b8b9770b3be5" id="r_gaa6613e39304926dee856b8b9770b3be5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Box.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__base.html#gaa6613e39304926dee856b8b9770b3be5">vcl::lnOfFactorial</a> (<a class="el" href="classvcl_1_1Box.html">int</a> <a class="el" href="classvcl_1_1Box.html">n</a>)</td></tr>
<tr class="memdesc:gaa6613e39304926dee856b8b9770b3be5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes and caches the result of the natural logarithm of n!  <br /></td></tr>
<tr class="separator:gaa6613e39304926dee856b8b9770b3be5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga212fbf643d263ad106507f7aa462cf46" id="r_ga212fbf643d263ad106507f7aa462cf46"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classvcl_1_1Box.html">typename</a> <a class="el" href="classvcl_1_1Box.html">Head</a> , typename... Tail&gt; <br />
requires (sizeof...(<a class="el" href="classvcl_1_1Box.html">tail</a>) &gt; 0)</td></tr>
<tr class="memitem:ga212fbf643d263ad106507f7aa462cf46"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Box.html">constexpr</a> <a class="el" href="classvcl_1_1Box.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__base.html#ga212fbf643d263ad106507f7aa462cf46">vcl::max</a> (<a class="el" href="classvcl_1_1Box.html">const</a> <a class="el" href="classvcl_1_1Box.html">Head</a> &amp;<a class="el" href="classvcl_1_1Box.html">head0</a>, <a class="el" href="classvcl_1_1Box.html">const</a> <a class="el" href="classvcl_1_1Box.html">Head</a> &amp;<a class="el" href="classvcl_1_1Box.html">head1</a>, <a class="el" href="classvcl_1_1Box.html">const</a> <a class="el" href="classvcl_1_1Box.html">Tail</a> &amp;... <a class="el" href="classvcl_1_1Box.html">tail</a>)</td></tr>
<tr class="memdesc:ga212fbf643d263ad106507f7aa462cf46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum between several parameters.  <br /></td></tr>
<tr class="separator:ga212fbf643d263ad106507f7aa462cf46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45d99c06ee2cb1cd9434fd0e86a1a413" id="r_ga45d99c06ee2cb1cd9434fd0e86a1a413"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classvcl_1_1Box.html">typename</a> T &gt; </td></tr>
<tr class="memitem:ga45d99c06ee2cb1cd9434fd0e86a1a413"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Box.html">constexpr</a> <a class="el" href="classvcl_1_1Box.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__base.html#ga45d99c06ee2cb1cd9434fd0e86a1a413">vcl::max</a> (<a class="el" href="classvcl_1_1Box.html">const</a> T &amp;p1, <a class="el" href="classvcl_1_1Box.html">const</a> T &amp;<a class="el" href="classvcl_1_1Box.html">p2</a>)</td></tr>
<tr class="memdesc:ga45d99c06ee2cb1cd9434fd0e86a1a413"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum between the two parameters.  <br /></td></tr>
<tr class="separator:ga45d99c06ee2cb1cd9434fd0e86a1a413"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9c1835cef3addd7dbae2b21a43523f3a" id="r_ga9c1835cef3addd7dbae2b21a43523f3a"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classvcl_1_1Box.html">typename</a> <a class="el" href="classvcl_1_1Box.html">Head</a> , typename... Tail&gt; <br />
requires (sizeof...(<a class="el" href="classvcl_1_1Box.html">tail</a>) &gt; 0)</td></tr>
<tr class="memitem:ga9c1835cef3addd7dbae2b21a43523f3a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Box.html">constexpr</a> <a class="el" href="classvcl_1_1Box.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__base.html#ga9c1835cef3addd7dbae2b21a43523f3a">vcl::min</a> (<a class="el" href="classvcl_1_1Box.html">const</a> <a class="el" href="classvcl_1_1Box.html">Head</a> &amp;<a class="el" href="classvcl_1_1Box.html">head0</a>, <a class="el" href="classvcl_1_1Box.html">const</a> <a class="el" href="classvcl_1_1Box.html">Head</a> &amp;<a class="el" href="classvcl_1_1Box.html">head1</a>, <a class="el" href="classvcl_1_1Box.html">const</a> <a class="el" href="classvcl_1_1Box.html">Tail</a> &amp;... <a class="el" href="classvcl_1_1Box.html">tail</a>)</td></tr>
<tr class="memdesc:ga9c1835cef3addd7dbae2b21a43523f3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the minimum between several parameters.  <br /></td></tr>
<tr class="separator:ga9c1835cef3addd7dbae2b21a43523f3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae6c5f005182de34972bb2430132acb8f" id="r_gae6c5f005182de34972bb2430132acb8f"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classvcl_1_1Box.html">typename</a> T &gt; </td></tr>
<tr class="memitem:gae6c5f005182de34972bb2430132acb8f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Box.html">constexpr</a> <a class="el" href="classvcl_1_1Box.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__base.html#gae6c5f005182de34972bb2430132acb8f">vcl::min</a> (<a class="el" href="classvcl_1_1Box.html">const</a> T &amp;p1, <a class="el" href="classvcl_1_1Box.html">const</a> T &amp;<a class="el" href="classvcl_1_1Box.html">p2</a>)</td></tr>
<tr class="memdesc:gae6c5f005182de34972bb2430132acb8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the minimum between the two parameters.  <br /></td></tr>
<tr class="separator:gae6c5f005182de34972bb2430132acb8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6636a67e3d567f5d2306024beb0b38e2" id="r_ga6636a67e3d567f5d2306024beb0b38e2"><td class="memItemLeft" align="right" valign="top">std::mt19937&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__base.html#ga6636a67e3d567f5d2306024beb0b38e2">vcl::randomGenerator</a> (std::optional&lt; uint &gt; <a class="el" href="classvcl_1_1Box.html">seed</a>=std::nullopt)</td></tr>
<tr class="memdesc:ga6636a67e3d567f5d2306024beb0b38e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a random number generator with an optional seed.  <br /></td></tr>
<tr class="separator:ga6636a67e3d567f5d2306024beb0b38e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9397cf00e2fe170e786a187514989916" id="r_ga9397cf00e2fe170e786a187514989916"><td class="memTemplParams" colspan="2">template&lt;Range R&gt; </td></tr>
<tr class="memitem:ga9397cf00e2fe170e786a187514989916"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Box.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__base.html#ga9397cf00e2fe170e786a187514989916">vcl::shuffle</a> (R &amp;&amp;<a class="el" href="classvcl_1_1Box.html">range</a>, std::optional&lt; uint &gt; <a class="el" href="classvcl_1_1Box.html">seed</a>=std::nullopt)</td></tr>
<tr class="memdesc:ga9397cf00e2fe170e786a187514989916"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shuffle the elements of a range.  <br /></td></tr>
<tr class="separator:ga9397cf00e2fe170e786a187514989916"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaef0e24c2e1f1179f14204b1a56c57d9" id="r_gaaef0e24c2e1f1179f14204b1a56c57d9"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classvcl_1_1Box.html">typename</a> Scalar &gt; </td></tr>
<tr class="memitem:gaaef0e24c2e1f1179f14204b1a56c57d9"><td class="memTemplItemLeft" align="right" valign="top">Scalar&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__base.html#gaaef0e24c2e1f1179f14204b1a56c57d9">vcl::toDeg</a> (<a class="el" href="classvcl_1_1Box.html">const</a> Scalar &amp;<a class="el" href="classvcl_1_1Box.html">rad</a>)</td></tr>
<tr class="memdesc:gaaef0e24c2e1f1179f14204b1a56c57d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an angle in radians to degrees.  <br /></td></tr>
<tr class="separator:gaaef0e24c2e1f1179f14204b1a56c57d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga47c44328e5dfdb6c7e872aaa04fd2eba" id="r_ga47c44328e5dfdb6c7e872aaa04fd2eba"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classvcl_1_1Box.html">typename</a> Scalar &gt; </td></tr>
<tr class="memitem:ga47c44328e5dfdb6c7e872aaa04fd2eba"><td class="memTemplItemLeft" align="right" valign="top">Scalar&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__base.html#ga47c44328e5dfdb6c7e872aaa04fd2eba">vcl::toRad</a> (<a class="el" href="classvcl_1_1Box.html">const</a> Scalar &amp;<a class="el" href="classvcl_1_1Box.html">deg</a>)</td></tr>
<tr class="memdesc:ga47c44328e5dfdb6c7e872aaa04fd2eba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an angle in degrees to radians.  <br /></td></tr>
<tr class="separator:ga47c44328e5dfdb6c7e872aaa04fd2eba"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga4d7a7538a2f5867a00048a1b3f32eaa6" id="r_ga4d7a7538a2f5867a00048a1b3f32eaa6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Box.html">constexpr</a> <a class="el" href="classvcl_1_1Box.html">const</a> <a class="el" href="classvcl_1_1Box.html">char</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__base.html#ga4d7a7538a2f5867a00048a1b3f32eaa6">vcl::COMPONENT_ENUM_STRINGS</a> [CompId::COMPONENTS_NUMBER]</td></tr>
<tr class="memdesc:ga4d7a7538a2f5867a00048a1b3f32eaa6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The COMPONENT_ENUM_STRINGS array contains the string representation of the CompId::Enum values.  <br /></td></tr>
<tr class="separator:ga4d7a7538a2f5867a00048a1b3f32eaa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaead83eb7c9cee68431c31c3890cbb10f" id="r_gaead83eb7c9cee68431c31c3890cbb10f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Box.html">constexpr</a> <a class="el" href="classvcl_1_1Box.html">const</a> <a class="el" href="classvcl_1_1Box.html">char</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__base.html#gaead83eb7c9cee68431c31c3890cbb10f">vcl::ELEMENT_ENUM_STRINGS</a> [ElemId::ELEMENTS_NUMBER]</td></tr>
<tr class="memdesc:gaead83eb7c9cee68431c31c3890cbb10f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The ELEMENT_ENUM_STRINGS array contains the string representation of the elements that can compose a mesh.  <br /></td></tr>
<tr class="separator:gaead83eb7c9cee68431c31c3890cbb10f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6856c5b5bb830c6061cbb56eeed8a9ea" id="r_ga6856c5b5bb830c6061cbb56eeed8a9ea"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classvcl_1_1Box.html">typename</a> T , <a class="el" href="classvcl_1_1Box.html">template</a>&lt; typename... &gt; <a class="el" href="classvcl_1_1Box.html">class</a> Template&gt; </td></tr>
<tr class="memitem:ga6856c5b5bb830c6061cbb56eeed8a9ea"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Box.html">constexpr</a> <a class="el" href="classvcl_1_1Box.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__base.html#ga6856c5b5bb830c6061cbb56eeed8a9ea">vcl::IsDerivedFromSpecializationOfV</a></td></tr>
<tr class="memdesc:ga6856c5b5bb830c6061cbb56eeed8a9ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for <a class="el" href="structvcl_1_1IsDerivedFromSpecializationOf.html" title="Trait to check if a type is derived from a specialization of a given template.">IsDerivedFromSpecializationOf</a> trait.  <br /></td></tr>
<tr class="separator:ga6856c5b5bb830c6061cbb56eeed8a9ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga905ec16eb62a94008bcd859a22a92481" id="r_ga905ec16eb62a94008bcd859a22a92481"><td class="memTemplParams" colspan="2"><a id="ga905ec16eb62a94008bcd859a22a92481" name="ga905ec16eb62a94008bcd859a22a92481"></a>
template&lt;<a class="el" href="classvcl_1_1Box.html">typename</a> T , <a class="el" href="classvcl_1_1Box.html">template</a>&lt; typename... &gt; <a class="el" href="classvcl_1_1Box.html">class</a> Template&gt; </td></tr>
<tr class="memitem:ga905ec16eb62a94008bcd859a22a92481"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Box.html">constexpr</a> <a class="el" href="classvcl_1_1Box.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>vcl::IsSpecializationOfV</b> = <a class="el" href="structvcl_1_1IsSpecializationOf.html">IsSpecializationOf</a>&lt;T, <a class="el" href="classvcl_1_1Box.html">Template</a>&gt;::value</td></tr>
<tr class="memdesc:ga905ec16eb62a94008bcd859a22a92481"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for <a class="el" href="structvcl_1_1IsSpecializationOf.html" title="Trait to check if a type is a specialization of a given template.">IsSpecializationOf</a> trait. <br /></td></tr>
<tr class="separator:ga905ec16eb62a94008bcd859a22a92481"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3377e3c875ec245e90ac5a395105ce99" id="r_ga3377e3c875ec245e90ac5a395105ce99"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1NullLogger.html">NullLogger</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__base.html#ga3377e3c875ec245e90ac5a395105ce99">vcl::nullLogger</a></td></tr>
<tr class="memdesc:ga3377e3c875ec245e90ac5a395105ce99"><td class="mdescLeft">&#160;</td><td class="mdescRight">The nullLogger object is an object of type <a class="el" href="classvcl_1_1NullLogger.html" title="The NullLogger class is used as default type in all the library functions that take as input a logger...">NullLogger</a> that is used as default argument in the functions that can take as input a logger.  <br /></td></tr>
<tr class="separator:ga3377e3c875ec245e90ac5a395105ce99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ad8104cd9ccfa9352d33bc7e6ba47e6" id="r_ga9ad8104cd9ccfa9352d33bc7e6ba47e6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Box.html">constexpr</a> uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__base.html#ga9ad8104cd9ccfa9352d33bc7e6ba47e6">vcl::UINT_NULL</a> = std::numeric_limits&lt;uint&gt;<a class="el" href="group__base.html#ga45d99c06ee2cb1cd9434fd0e86a1a413">::max</a>()</td></tr>
<tr class="memdesc:ga9ad8104cd9ccfa9352d33bc7e6ba47e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The UINT_NULL value represent a null value of uint that is the maximum value that can be represented with unsigned int.  <br /></td></tr>
<tr class="separator:ga9ad8104cd9ccfa9352d33bc7e6ba47e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>The Base module defines all the utility definitions, types, classes and type traits that are common in the library. </p>
<p>This module does not depend on any other module of the library, and it is used by all the other modules.</p>
<p>You can access to the module by including <code>#include &lt;<a class="el" href="base_8h_source.html">vclib/base.h</a>&gt;</code> </p>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga38c527736a2d0a3d7af0493e228227e3" name="ga38c527736a2d0a3d7af0493e228227e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga38c527736a2d0a3d7af0493e228227e3">&#9670;&#160;</a></span>FirstTypeT</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Box.html">using</a> <a class="el" href="group__base.html#ga38c527736a2d0a3d7af0493e228227e3">vcl::FirstTypeT</a> = <a class="el" href="classvcl_1_1Box.html">typedef</a> <a class="el" href="classvcl_1_1Box.html">typename</a> <a class="el" href="structvcl_1_1FirstType.html">FirstType</a>&lt;Args...&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias for the type of the first type in a pack of types. </p>
<p>Usage: </p><div class="fragment"><div class="line"><span class="keyword">using </span><a class="code hl_class" href="classvcl_1_1Box.html">ResType</a> = <a class="code hl_class" href="classvcl_1_1Box.html">FirstTypeT&lt;int, float, double&gt;</a>;</div>
<div class="line"><span class="keyword">static_assert</span>(std::is_same&lt;ResType, int&gt;::value, <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="ttc" id="aclassvcl_1_1Box_html"><div class="ttname"><a href="classvcl_1_1Box.html">vcl::Box</a></div><div class="ttdoc">A class representing a box in N-dimensional space.</div><div class="ttdef"><b>Definition</b> box.h:46</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ga8a37fc3ccf3b54b062d37fe46900e112" name="ga8a37fc3ccf3b54b062d37fe46900e112"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8a37fc3ccf3b54b062d37fe46900e112">&#9670;&#160;</a></span>IsDerivedFromTemplateSpecialization</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classvcl_1_1Box.html">typename</a> derived , <a class="el" href="classvcl_1_1Box.html">template</a>&lt; typename... &gt; <a class="el" href="classvcl_1_1Box.html">class</a> base&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Box.html">using</a> <a class="el" href="group__base.html#ga8a37fc3ccf3b54b062d37fe46900e112">vcl::IsDerivedFromTemplateSpecialization</a> = <a class="el" href="classvcl_1_1Box.html">typedef</a> std::invoke_result&lt; detail::IsDerivedFromImplementation&lt;base&gt;, <a class="el" href="classvcl_1_1Box.html">typename</a> std::remove_cv&lt;derived&gt;::type*&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Utility class that allows to check if given class 'Derived' is derived from a specialization of a templated class. </p>
<p>Given a class X and a templated class C&lt;template T&gt;, it can be used in the following way:</p>
<div class="fragment"><div class="line"><span class="keyword">using </span><a class="code hl_class" href="classvcl_1_1Box.html">myCheck</a> = <a class="code hl_typedef" href="group__base.html#ga8a37fc3ccf3b54b062d37fe46900e112">vcl::IsDerivedFromTemplateSpecialization&lt;X, C&gt;::type</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> <span class="keyword">constexpr</span> (myCheck::value) { ... }</div>
<div class="ttc" id="agroup__base_html_ga8a37fc3ccf3b54b062d37fe46900e112"><div class="ttname"><a href="group__base.html#ga8a37fc3ccf3b54b062d37fe46900e112">vcl::IsDerivedFromTemplateSpecialization</a></div><div class="ttdeci">std::invoke_result&lt; detail::IsDerivedFromImplementation&lt; base &gt;, typename std::remove_cv&lt; derived &gt;::type * &gt;::type IsDerivedFromTemplateSpecialization</div><div class="ttdoc">Utility class that allows to check if given class 'Derived' is derived from a specialization of a tem...</div><div class="ttdef"><b>Definition</b> inheritance.h:69</div></div>
</div><!-- fragment --><p>and will return true if X derives from any specialization of C.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">derived</td><td>The class to be checked. </td></tr>
    <tr><td class="paramname">base</td><td>The templated class to be checked. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaacc96304be3365c944d0239dd550f74e" name="gaacc96304be3365c944d0239dd550f74e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaacc96304be3365c944d0239dd550f74e">&#9670;&#160;</a></span>MakeConstPointerT</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classvcl_1_1Box.html">typename</a> T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Box.html">using</a> <a class="el" href="group__base.html#gaacc96304be3365c944d0239dd550f74e">vcl::MakeConstPointerT</a> = <a class="el" href="classvcl_1_1Box.html">typedef</a> <a class="el" href="classvcl_1_1Box.html">typename</a> <a class="el" href="structvcl_1_1MakeConstPointer.html">MakeConstPointer</a>&lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Utility alias for the <a class="el" href="structvcl_1_1MakeConstPointer.html" title="Utility type that makes possible to treat const pointers in a templated class that can treat a both c...">MakeConstPointer</a> type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type to be converted to a const pointer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gacfdd7af0f9712ffc6b96c5d27be41965" name="gacfdd7af0f9712ffc6b96c5d27be41965"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacfdd7af0f9712ffc6b96c5d27be41965">&#9670;&#160;</a></span>RemoveConstFromPointer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classvcl_1_1Box.html">typename</a> T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Box.html">using</a> <a class="el" href="group__base.html#gacfdd7af0f9712ffc6b96c5d27be41965">vcl::RemoveConstFromPointer</a> = <a class="el" href="classvcl_1_1Box.html">typedef</a> std::conditional_t&lt; std::is_pointer_v&lt;T&gt;, std::add_pointer_t&lt;std::remove_cv_t&lt;<a class="el" href="group__base.html#ga25fc582d09d14f037e742c66fd58dbeb">RemovePtr</a>&lt;T&gt; &gt;&gt;, T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Utility alias to get a pointer type without the constness. e.g. If T is const int*, the resulting type is int* If the type is not a pointer, it is left as it was. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The input type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa1938bcd17ca07bf32500695f422efeb" name="gaa1938bcd17ca07bf32500695f422efeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa1938bcd17ca07bf32500695f422efeb">&#9670;&#160;</a></span>RemoveCVRefAndPointer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classvcl_1_1Box.html">typename</a> T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Box.html">using</a> <a class="el" href="group__base.html#gaa1938bcd17ca07bf32500695f422efeb">vcl::RemoveCVRefAndPointer</a> = <a class="el" href="classvcl_1_1Box.html">typedef</a> std::remove_cvref_t&lt;<a class="el" href="group__base.html#ga25fc582d09d14f037e742c66fd58dbeb">RemovePtr</a>&lt;T&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Utility alias to get clean type from an input type that could have a reference or a pointer. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The input type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga25fc582d09d14f037e742c66fd58dbeb" name="ga25fc582d09d14f037e742c66fd58dbeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga25fc582d09d14f037e742c66fd58dbeb">&#9670;&#160;</a></span>RemovePtr</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classvcl_1_1Box.html">typename</a> T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Box.html">using</a> <a class="el" href="group__base.html#ga25fc582d09d14f037e742c66fd58dbeb">vcl::RemovePtr</a> = <a class="el" href="classvcl_1_1Box.html">typedef</a> std::remove_pointer_t&lt;T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Utility alias to get a type without the pointer. e.g. If T is int*, the resulting type is int. </p>
<p>It corresponds to std::remove_pointer_t.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The input type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5c494877e683bb96964551900501a466" name="ga5c494877e683bb96964551900501a466"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5c494877e683bb96964551900501a466">&#9670;&#160;</a></span>RemoveRef</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classvcl_1_1Box.html">typename</a> T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Box.html">using</a> <a class="el" href="group__base.html#ga5c494877e683bb96964551900501a466">vcl::RemoveRef</a> = <a class="el" href="classvcl_1_1Box.html">typedef</a> std::remove_reference_t&lt;T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Utility alias to get a type type without the reference. e.g. If T is int&amp;, the resulting type is int. </p>
<p>It corresponds to std::remove_reference_t.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The input type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7532e3b30b940e66f546f75ea246acfa" name="ga7532e3b30b940e66f546f75ea246acfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7532e3b30b940e66f546f75ea246acfa">&#9670;&#160;</a></span>TypeAtT</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;uint I, typename... T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Box.html">using</a> <a class="el" href="group__base.html#ga7532e3b30b940e66f546f75ea246acfa">vcl::TypeAtT</a> = <a class="el" href="classvcl_1_1Box.html">typedef</a> <a class="el" href="classvcl_1_1Box.html">typename</a> <a class="el" href="structvcl_1_1TypeAt.html">TypeAt</a>&lt;I, T...&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias for the type at a given index in a pack of types (variadic templates) or a <a class="el" href="structvcl_1_1TypeWrapper.html" title="A simple structure that wraps a list of variadic templates, without instantiating anything....">TypeWrapper</a>. </p>
<p>Usage: </p><div class="fragment"><div class="line"><span class="keyword">using </span><a class="code hl_class" href="classvcl_1_1Box.html">ResType</a> = <a class="code hl_class" href="classvcl_1_1Box.html">TypeAtT&lt;1, int, float, double&gt;</a>;</div>
<div class="line"><span class="keyword">static_assert</span>(std::is_same&lt;ResType, float&gt;::value, <span class="stringliteral">&quot;&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga35a36b617de9550e23e0c1426a783464" name="ga35a36b617de9550e23e0c1426a783464"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga35a36b617de9550e23e0c1426a783464">&#9670;&#160;</a></span>PrimitiveType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classvcl_1_1Box.html">class</a> <a class="el" href="group__base.html#ga35a36b617de9550e23e0c1426a783464">vcl::PrimitiveType</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A simple type that enumerates the main primitive types. </p>
<p>It is used mostly for I/O operations, but can be useful in any context where a type must be described in a variable at runtime. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gae32401c3c5edbdeead1769b4d6160f87" name="gae32401c3c5edbdeead1769b4d6160f87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae32401c3c5edbdeead1769b4d6160f87">&#9670;&#160;</a></span>addressOfObj()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classvcl_1_1Box.html">typename</a> T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Box.html">auto</a> vcl::addressOfObj </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Utility function that applies the unary operator '&amp;' to the argument only if it is not a pointer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the address of 'obj' if obj is not a pointer, or obj if it is a pointer. </dd></dl>

</div>
</div>
<a id="ga9ca8accd2e2b6881a3b2359e56396e77" name="ga9ca8accd2e2b6881a3b2359e56396e77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9ca8accd2e2b6881a3b2359e56396e77">&#9670;&#160;</a></span>asConst() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classvcl_1_1Box.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Box.html">constexpr</a> T &amp; vcl::asConst </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">const</a> T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Utility function that converts a const pointer/reference to a non-const pointer/reference. </p>
<p>It is useful when you need to re-use the same code for const and non-const member functions.</p>
<dl class="section warning"><dt>Warning</dt><dd>The function should be used only in contexts where the constness of the pointer/reference is guaranteed to be removed (see <a href="https://en.cppreference.com/w/cpp/language/const_cast">const_cast</a>).</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the pointer/reference. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The const pointer/reference to be const-casted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The non-const pointer/reference. </dd></dl>

</div>
</div>
<a id="ga943a3fda661e6e71d8fd7106f41dd878" name="ga943a3fda661e6e71d8fd7106f41dd878"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga943a3fda661e6e71d8fd7106f41dd878">&#9670;&#160;</a></span>asConst() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classvcl_1_1Box.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Box.html">constexpr</a> T * vcl::asConst </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">const</a> T *&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Utility function that converts a const pointer/reference to a non-const pointer/reference.   </p>
<p>It is useful when you need to re-use the same code for const and non-const member functions.</p>
<dl class="section warning"><dt>Warning</dt><dd>The function should be used only in contexts where the constness of the pointer/reference is guaranteed to be removed (see <a href="https://en.cppreference.com/w/cpp/language/const_cast">const_cast</a>).</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the pointer/reference. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The const pointer/reference to be const-casted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The non-const pointer/reference.   </dd></dl>

</div>
</div>
<a id="gabe5c457181ae725f99627c541993a3a8" name="gabe5c457181ae725f99627c541993a3a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabe5c457181ae725f99627c541993a3a8">&#9670;&#160;</a></span>asConst() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classvcl_1_1Box.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Box.html">constexpr</a> T * vcl::asConst </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Utility function that converts a const pointer/reference to a non-const pointer/reference.   </p>
<p>It is useful when you need to re-use the same code for const and non-const member functions.</p>
<dl class="section warning"><dt>Warning</dt><dd>The function should be used only in contexts where the constness of the pointer/reference is guaranteed to be removed (see <a href="https://en.cppreference.com/w/cpp/language/const_cast">const_cast</a>).</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the pointer/reference. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The const pointer/reference to be const-casted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The non-const pointer/reference.   </dd></dl>

</div>
</div>
<a id="ga86d50e779d2b4fd59e31de5a48e6d112" name="ga86d50e779d2b4fd59e31de5a48e6d112"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga86d50e779d2b4fd59e31de5a48e6d112">&#9670;&#160;</a></span>componentEnumString()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;uint COMP_ID&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Box.html">constexpr</a> <a class="el" href="classvcl_1_1Box.html">const</a> <a class="el" href="classvcl_1_1Box.html">char</a> * vcl::componentEnumString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the string associated to the COMP_ID value. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">COMP_ID</td><td>an unsigned integer that identifies the component. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The string associated to the COMP_ID value. </dd></dl>

</div>
</div>
<a id="ga769dac8f4b92030d30690a78b7fc2d79" name="ga769dac8f4b92030d30690a78b7fc2d79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga769dac8f4b92030d30690a78b7fc2d79">&#9670;&#160;</a></span>dereferencePtr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classvcl_1_1Box.html">typename</a> T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Box.html">auto</a> &amp; vcl::dereferencePtr </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Utility function that applies the unary operator '*' to the argument only if the object is a pointer, and returns a reference to the object itself. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">obj</td><td>The object to dereference. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to obj if it is not a pointer, or a reference to *obj if it is a pointer. </dd></dl>

</div>
</div>
<a id="ga0068c984cb7a600004242ea341b506eb" name="ga0068c984cb7a600004242ea341b506eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0068c984cb7a600004242ea341b506eb">&#9670;&#160;</a></span>elementEnumCString()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;uint ELEM_ID&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Box.html">constexpr</a> <a class="el" href="classvcl_1_1Box.html">const</a> <a class="el" href="classvcl_1_1Box.html">char</a> * vcl::elementEnumCString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the string associated to the ELEM_ID value. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ELEM_ID</td><td>an unsigned integer that identifies the element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The string associated to the ELEM_ID value. </dd></dl>

</div>
</div>
<a id="gab2bbb176efb4243ea25469bbbd1c53af" name="gab2bbb176efb4243ea25469bbbd1c53af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab2bbb176efb4243ea25469bbbd1c53af">&#9670;&#160;</a></span>elementEnumString()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;uint ELEM_ID&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Box.html">const</a> std::string &amp; vcl::elementEnumString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the string associated to the ELEM_ID value. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ELEM_ID</td><td>an unsigned integer that identifies the element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The string associated to the ELEM_ID value. </dd></dl>

</div>
</div>
<a id="ga2f9b74af8b9f8a827e760dce325b820c" name="ga2f9b74af8b9f8a827e760dce325b820c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2f9b74af8b9f8a827e760dce325b820c">&#9670;&#160;</a></span>epsilonEquals()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classvcl_1_1Box.html">typename</a> Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Box.html">bool</a> vcl::epsilonEquals </td>
          <td>(</td>
          <td class="paramtype">Scalar&#160;</td>
          <td class="paramname"><em>n1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Scalar&#160;</td>
          <td class="paramname"><em>n2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Scalar&#160;</td>
          <td class="paramname"><em>epsilon</em> = <code>std::numeric_limits&lt;Scalar&gt;::epsilon()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if two floating point numbers are equal within an epsilon value. </p>
<p>This function returns true if the absolute difference between the two numbers is less than or equal to the epsilon value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n1</td><td>the first number to compare </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n2</td><td>the second number to compare </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">epsilon</td><td>the epsilon value to use for the check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the numbers are equal within the epsilon value, false otherwise. </dd></dl>

</div>
</div>
<a id="gaeb189433c1c9d7bf52a96ff359f364ec" name="gaeb189433c1c9d7bf52a96ff359f364ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeb189433c1c9d7bf52a96ff359f364ec">&#9670;&#160;</a></span>hashCombine()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classvcl_1_1Box.html">typename</a> T , typename... Rest&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Box.html">void</a> vcl::hashCombine </td>
          <td>(</td>
          <td class="paramtype">std::size_t &amp;&#160;</td>
          <td class="paramname"><em>seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">const</a> T &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">const</a> <a class="el" href="classvcl_1_1Box.html">Rest</a> &amp;...&#160;</td>
          <td class="paramname"><em>rest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starting from a seed, computes the hash of a series of objects. </p>
<p><a href="https://stackoverflow.com/a/57595105/5851101">https://stackoverflow.com/a/57595105/5851101</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">seed</td><td>input seed and output hash </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>first argument object </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rest</td><td>rest of the argument objects </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac398b3cd16575f92ffc3e6cfd6ba1669" name="gac398b3cd16575f92ffc3e6cfd6ba1669"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac398b3cd16575f92ffc3e6cfd6ba1669">&#9670;&#160;</a></span>indexInTypePack() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classvcl_1_1Box.html">typename</a> U , typename... Us&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">uint vcl::indexInTypePack </td>
          <td>(</td>
          <td class="paramtype">std::type_index&#160;</td>
          <td class="paramname"><em>ti</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that returns the index of the type having the given type_index in a pack of types (variadic templates). The pack is composed of U and Us... </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ti</td><td>the type_index of the type to search. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad6ce6ce1ca6a9813f3437aa0aeee2d94" name="gad6ce6ce1ca6a9813f3437aa0aeee2d94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad6ce6ce1ca6a9813f3437aa0aeee2d94">&#9670;&#160;</a></span>indexInTypePack() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">uint vcl::indexInTypePack </td>
          <td>(</td>
          <td class="paramtype">std::type_index&#160;</td>
          <td class="paramname"><em>ti</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvcl_1_1TypeWrapper.html">TypeWrapper</a>&lt; Args... &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that returns the index of the type having the given type_index in a <a class="el" href="structvcl_1_1TypeWrapper.html" title="A simple structure that wraps a list of variadic templates, without instantiating anything....">TypeWrapper</a>. </p>
<p>The <a class="el" href="structvcl_1_1TypeWrapper.html" title="A simple structure that wraps a list of variadic templates, without instantiating anything....">TypeWrapper</a> must be given as a second argument to the function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ti</td><td>the type_index of the type to search. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tw</td><td>the <a class="el" href="structvcl_1_1TypeWrapper.html" title="A simple structure that wraps a list of variadic templates, without instantiating anything....">TypeWrapper</a> to search in. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7da4c4b0342d3a5f906db63db504bea7" name="ga7da4c4b0342d3a5f906db63db504bea7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7da4c4b0342d3a5f906db63db504bea7">&#9670;&#160;</a></span>isDegenerate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classvcl_1_1Box.html">typename</a> Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Box.html">bool</a> vcl::isDegenerate </td>
          <td>(</td>
          <td class="paramtype">Scalar&#160;</td>
          <td class="paramname"><em>number</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if a floating point number is degenerate. </p>
<p>A floating point number is degenerate if it is infinite or NaN.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">number</td><td>the number to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the number is degenerate, false otherwise. </dd></dl>

</div>
</div>
<a id="gaa6613e39304926dee856b8b9770b3be5" name="gaa6613e39304926dee856b8b9770b3be5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa6613e39304926dee856b8b9770b3be5">&#9670;&#160;</a></span>lnOfFactorial()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Box.html">double</a> vcl::lnOfFactorial </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">int</a>&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes and caches the result of the natural logarithm of n! </p>
<p>If n &gt; 1024, uses the Stirling approximation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>the number for which to compute the natural logarithm of the factorial.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the natural logarithm of n!. </dd></dl>

</div>
</div>
<a id="ga212fbf643d263ad106507f7aa462cf46" name="ga212fbf643d263ad106507f7aa462cf46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga212fbf643d263ad106507f7aa462cf46">&#9670;&#160;</a></span>max() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classvcl_1_1Box.html">typename</a> <a class="el" href="classvcl_1_1Box.html">Head</a> , typename... Tail&gt; <br />
requires (sizeof...(<a class="el" href="classvcl_1_1Box.html">tail</a>) &gt; 0)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Box.html">constexpr</a> <a class="el" href="classvcl_1_1Box.html">auto</a> vcl::max </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">const</a> <a class="el" href="classvcl_1_1Box.html">Head</a> &amp;&#160;</td>
          <td class="paramname"><em>head0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">const</a> <a class="el" href="classvcl_1_1Box.html">Head</a> &amp;&#160;</td>
          <td class="paramname"><em>head1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">const</a> <a class="el" href="classvcl_1_1Box.html">Tail</a> &amp;...&#160;</td>
          <td class="paramname"><em>tail</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the maximum between several parameters. </p>
<p>Given a list of parameters, this function returns the maximum between all of them.</p>
<p>Example:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> <a class="code hl_class" href="classvcl_1_1Box.html">m</a> = <a class="code hl_function" href="group__base.html#ga45d99c06ee2cb1cd9434fd0e86a1a413">vcl::max</a>(1, 2, 3, 4, 5); <span class="comment">// m = 5</span></div>
<div class="ttc" id="agroup__base_html_ga45d99c06ee2cb1cd9434fd0e86a1a413"><div class="ttname"><a href="group__base.html#ga45d99c06ee2cb1cd9434fd0e86a1a413">vcl::max</a></div><div class="ttdeci">constexpr auto max(const T &amp;p1, const T &amp;p2)</div><div class="ttdoc">Returns the maximum between the two parameters.</div><div class="ttdef"><b>Definition</b> min_max.h:81</div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">head0</td><td>The first parameter. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">head1</td><td>The second parameter. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tail</td><td>The rest of the parameters. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The maximum between the parameters. </dd></dl>

</div>
</div>
<a id="ga45d99c06ee2cb1cd9434fd0e86a1a413" name="ga45d99c06ee2cb1cd9434fd0e86a1a413"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga45d99c06ee2cb1cd9434fd0e86a1a413">&#9670;&#160;</a></span>max() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classvcl_1_1Box.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Box.html">constexpr</a> <a class="el" href="classvcl_1_1Box.html">auto</a> vcl::max </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">const</a> T &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">const</a> T &amp;&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the maximum between the two parameters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p1</td><td>The first parameter. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p2</td><td>The second parameter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The maximum between the two parameters. </dd></dl>

</div>
</div>
<a id="ga9c1835cef3addd7dbae2b21a43523f3a" name="ga9c1835cef3addd7dbae2b21a43523f3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9c1835cef3addd7dbae2b21a43523f3a">&#9670;&#160;</a></span>min() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classvcl_1_1Box.html">typename</a> <a class="el" href="classvcl_1_1Box.html">Head</a> , typename... Tail&gt; <br />
requires (sizeof...(<a class="el" href="classvcl_1_1Box.html">tail</a>) &gt; 0)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Box.html">constexpr</a> <a class="el" href="classvcl_1_1Box.html">auto</a> vcl::min </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">const</a> <a class="el" href="classvcl_1_1Box.html">Head</a> &amp;&#160;</td>
          <td class="paramname"><em>head0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">const</a> <a class="el" href="classvcl_1_1Box.html">Head</a> &amp;&#160;</td>
          <td class="paramname"><em>head1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">const</a> <a class="el" href="classvcl_1_1Box.html">Tail</a> &amp;...&#160;</td>
          <td class="paramname"><em>tail</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the minimum between several parameters. </p>
<p>Given a list of parameters, this function returns the minimum between all of them.</p>
<p>Example:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> <a class="code hl_class" href="classvcl_1_1Box.html">m</a> = <a class="code hl_function" href="group__base.html#gae6c5f005182de34972bb2430132acb8f">vcl::min</a>(1, 2, 3, 4, 5); <span class="comment">// m = 1</span></div>
<div class="ttc" id="agroup__base_html_gae6c5f005182de34972bb2430132acb8f"><div class="ttname"><a href="group__base.html#gae6c5f005182de34972bb2430132acb8f">vcl::min</a></div><div class="ttdeci">constexpr auto min(const T &amp;p1, const T &amp;p2)</div><div class="ttdoc">Returns the minimum between the two parameters.</div><div class="ttdef"><b>Definition</b> min_max.h:40</div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">head0</td><td>The first parameter. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">head1</td><td>The second parameter. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tail</td><td>The rest of the parameters. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The minimum between the parameters. </dd></dl>

</div>
</div>
<a id="gae6c5f005182de34972bb2430132acb8f" name="gae6c5f005182de34972bb2430132acb8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae6c5f005182de34972bb2430132acb8f">&#9670;&#160;</a></span>min() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classvcl_1_1Box.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Box.html">constexpr</a> <a class="el" href="classvcl_1_1Box.html">auto</a> vcl::min </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">const</a> T &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">const</a> T &amp;&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the minimum between the two parameters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p1</td><td>The first parameter. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p2</td><td>The second parameter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The minimum between the two parameters. </dd></dl>

</div>
</div>
<a id="ga6636a67e3d567f5d2306024beb0b38e2" name="ga6636a67e3d567f5d2306024beb0b38e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6636a67e3d567f5d2306024beb0b38e2">&#9670;&#160;</a></span>randomGenerator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::mt19937 vcl::randomGenerator </td>
          <td>(</td>
          <td class="paramtype">std::optional&lt; uint &gt;&#160;</td>
          <td class="paramname"><em>seed</em> = <code>std::nullopt</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a random number generator with an optional seed. </p>
<p>If a seed is provided, the generator is seeded with that value, otherwise it uses a random device to generate a random seed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seed</td><td>Optional seed value for the random number generator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A std::mt19937 random number generator. </dd></dl>

</div>
</div>
<a id="ga9397cf00e2fe170e786a187514989916" name="ga9397cf00e2fe170e786a187514989916"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9397cf00e2fe170e786a187514989916">&#9670;&#160;</a></span>shuffle()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Range R&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Box.html">void</a> vcl::shuffle </td>
          <td>(</td>
          <td class="paramtype">R &amp;&amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; uint &gt;&#160;</td>
          <td class="paramname"><em>seed</em> = <code>std::nullopt</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shuffle the elements of a range. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>Type of the range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">range</td><td>Range to shuffle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">seed</td><td>optional value of seed, to get deterministic results. If not provided, a random seed is used. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaaef0e24c2e1f1179f14204b1a56c57d9" name="gaaef0e24c2e1f1179f14204b1a56c57d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaef0e24c2e1f1179f14204b1a56c57d9">&#9670;&#160;</a></span>toDeg()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classvcl_1_1Box.html">typename</a> Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Scalar vcl::toDeg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">const</a> Scalar &amp;&#160;</td>
          <td class="paramname"><em>rad</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts an angle in radians to degrees. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rad</td><td>the angle in radians </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the angle in degrees. </dd></dl>

</div>
</div>
<a id="ga47c44328e5dfdb6c7e872aaa04fd2eba" name="ga47c44328e5dfdb6c7e872aaa04fd2eba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga47c44328e5dfdb6c7e872aaa04fd2eba">&#9670;&#160;</a></span>toRad()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classvcl_1_1Box.html">typename</a> Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Scalar vcl::toRad </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">const</a> Scalar &amp;&#160;</td>
          <td class="paramname"><em>deg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts an angle in degrees to radians. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">deg</td><td>the angle in degrees </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the angle in radians. </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ga4d7a7538a2f5867a00048a1b3f32eaa6" name="ga4d7a7538a2f5867a00048a1b3f32eaa6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4d7a7538a2f5867a00048a1b3f32eaa6">&#9670;&#160;</a></span>COMPONENT_ENUM_STRINGS</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Box.html">constexpr</a> <a class="el" href="classvcl_1_1Box.html">const</a> <a class="el" href="classvcl_1_1Box.html">char</a>* vcl::COMPONENT_ENUM_STRINGS[CompId::COMPONENTS_NUMBER]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {</div>
<div class="line">    <span class="stringliteral">&quot;BitFlags&quot;</span>,</div>
<div class="line">    <span class="stringliteral">&quot;Position&quot;</span>,</div>
<div class="line">    <span class="stringliteral">&quot;Normal&quot;</span>,</div>
<div class="line">    <span class="stringliteral">&quot;Color&quot;</span>,</div>
<div class="line">    <span class="stringliteral">&quot;Quality&quot;</span>,</div>
<div class="line">    <span class="stringliteral">&quot;Mark&quot;</span>,</div>
<div class="line">    <span class="stringliteral">&quot;PrincipalCurvature&quot;</span>,</div>
<div class="line">    <span class="stringliteral">&quot;TexCoord&quot;</span>,</div>
<div class="line">    <span class="stringliteral">&quot;VertexPointers&quot;</span>,</div>
<div class="line">    <span class="stringliteral">&quot;AdjacentEdges&quot;</span>,</div>
<div class="line">    <span class="stringliteral">&quot;AdjacentFaces&quot;</span>,</div>
<div class="line">    <span class="stringliteral">&quot;AdjacentVertices&quot;</span>,</div>
<div class="line">    <span class="stringliteral">&quot;WedgeColors&quot;</span>,</div>
<div class="line">    <span class="stringliteral">&quot;WedgeTexCoords&quot;</span>,</div>
<div class="line">    <span class="stringliteral">&quot;BoundingBox&quot;</span>,</div>
<div class="line">    <span class="stringliteral">&quot;Name&quot;</span>,</div>
<div class="line">    <span class="stringliteral">&quot;TextureImages&quot;</span>,</div>
<div class="line">    <span class="stringliteral">&quot;TexturePaths&quot;</span>,</div>
<div class="line">    <span class="stringliteral">&quot;TransformMatrix&quot;</span>,</div>
<div class="line">    <span class="stringliteral">&quot;CustomComponents&quot;</span>,</div>
<div class="line">}</div>
</div><!-- fragment -->
<p>The COMPONENT_ENUM_STRINGS array contains the string representation of the CompId::Enum values. </p>

</div>
</div>
<a id="gaead83eb7c9cee68431c31c3890cbb10f" name="gaead83eb7c9cee68431c31c3890cbb10f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaead83eb7c9cee68431c31c3890cbb10f">&#9670;&#160;</a></span>ELEMENT_ENUM_STRINGS</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Box.html">constexpr</a> <a class="el" href="classvcl_1_1Box.html">const</a> <a class="el" href="classvcl_1_1Box.html">char</a>* vcl::ELEMENT_ENUM_STRINGS[ElemId::ELEMENTS_NUMBER]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {</div>
<div class="line">    <span class="stringliteral">&quot;Vertex&quot;</span>,</div>
<div class="line">    <span class="stringliteral">&quot;Face&quot;</span>,</div>
<div class="line">    <span class="stringliteral">&quot;Edge&quot;</span>,</div>
<div class="line">}</div>
</div><!-- fragment -->
<p>The ELEMENT_ENUM_STRINGS array contains the string representation of the elements that can compose a mesh. </p>

</div>
</div>
<a id="ga6856c5b5bb830c6061cbb56eeed8a9ea" name="ga6856c5b5bb830c6061cbb56eeed8a9ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6856c5b5bb830c6061cbb56eeed8a9ea">&#9670;&#160;</a></span>IsDerivedFromSpecializationOfV</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classvcl_1_1Box.html">typename</a> T , <a class="el" href="classvcl_1_1Box.html">template</a>&lt; typename... &gt; <a class="el" href="classvcl_1_1Box.html">class</a> Template&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Box.html">constexpr</a> <a class="el" href="classvcl_1_1Box.html">bool</a> vcl::IsDerivedFromSpecializationOfV</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">    IsDerivedFromSpecializationOf&lt;T, Template&gt;::value</div>
</div><!-- fragment -->
<p>Alias for <a class="el" href="structvcl_1_1IsDerivedFromSpecializationOf.html" title="Trait to check if a type is derived from a specialization of a given template.">IsDerivedFromSpecializationOf</a> trait. </p>

</div>
</div>
<a id="ga3377e3c875ec245e90ac5a395105ce99" name="ga3377e3c875ec245e90ac5a395105ce99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3377e3c875ec245e90ac5a395105ce99">&#9670;&#160;</a></span>nullLogger</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1NullLogger.html">NullLogger</a> vcl::nullLogger</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The nullLogger object is an object of type <a class="el" href="classvcl_1_1NullLogger.html" title="The NullLogger class is used as default type in all the library functions that take as input a logger...">NullLogger</a> that is used as default argument in the functions that can take as input a logger. </p>
<p>A typical function that could take a logger is defined as follows:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, LoggerConcept LoggerType = NullLogger&gt;</div>
<div class="line"><span class="keywordtype">void</span> <a class="code hl_class" href="classvcl_1_1Box.html">foo</a>(T <a class="code hl_class" href="classvcl_1_1Box.html">obj</a>, <a class="code hl_class" href="classvcl_1_1Box.html">LoggerType</a> log = <a class="code hl_variable" href="group__base.html#ga3377e3c875ec245e90ac5a395105ce99">nullLogger</a>)</div>
<div class="line">{</div>
<div class="line">   <span class="comment">// code of the function...</span></div>
<div class="line"> </div>
<div class="line">   <span class="comment">// empty function will be called if the user does not give a logger</span></div>
<div class="line">   log.log(<span class="stringliteral">&quot;log!&quot;</span>);</div>
<div class="line"> </div>
<div class="line">}</div>
<div class="ttc" id="agroup__base_html_ga3377e3c875ec245e90ac5a395105ce99"><div class="ttname"><a href="group__base.html#ga3377e3c875ec245e90ac5a395105ce99">vcl::nullLogger</a></div><div class="ttdeci">NullLogger nullLogger</div><div class="ttdoc">The nullLogger object is an object of type NullLogger that is used as default argument in the functio...</div><div class="ttdef"><b>Definition</b> null_logger.h:123</div></div>
</div><!-- fragment --><p>In this way, when the user does not give a logger argument, the default will be an object of <a class="el" href="classvcl_1_1NullLogger.html" title="The NullLogger class is used as default type in all the library functions that take as input a logger...">NullLogger</a>. </p>

</div>
</div>
<a id="ga9ad8104cd9ccfa9352d33bc7e6ba47e6" name="ga9ad8104cd9ccfa9352d33bc7e6ba47e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9ad8104cd9ccfa9352d33bc7e6ba47e6">&#9670;&#160;</a></span>UINT_NULL</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Box.html">constexpr</a> uint vcl::UINT_NULL = std::numeric_limits&lt;uint&gt;<a class="el" href="group__base.html#ga45d99c06ee2cb1cd9434fd0e86a1a413">::max</a>()</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The UINT_NULL value represent a null value of uint that is the maximum value that can be represented with unsigned int. </p>
<p>Allows to fully use all the possible values (except one) that can be represented in an unsigned int, but with the possibility to flag whether the value is not initialized or is set to null. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
