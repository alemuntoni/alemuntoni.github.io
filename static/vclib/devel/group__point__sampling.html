<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Visual Computing Library: Point Sampling Algorithms</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript" src="../version-selector.js"></script>
       <script type="text/javascript">
           DoxygenAwesomeDarkModeToggle.init()
       </script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Visual Computing Library
   &#160;<span id="projectnumber">devel</span>
   </div>
   <!-- Version selector dropdown -->
   <div id="version-selector" style="margin-top: 10px;">
     <label for="version-dropdown" style="font-size: 12px; color: #666;">Version:</label>
     <select id="version-dropdown" style="margin-left: 5px; padding: 2px 5px; font-size: 12px; border: 1px solid #ccc; border-radius: 3px;">
       <option value="">Loading versions...</option>
     </select>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group__point__sampling.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Point Sampling Algorithms<div class="ingroups"><a class="el" href="group__algorithms__mesh.html">Mesh Algorithms</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>List of functions that compute point samplings.  
<a href="#details">More...</a></p>
<div class="dynheader">
Collaboration diagram for Point Sampling Algorithms:</div>
<div class="dyncontent">
<div class="center"><img src="group__point__sampling.png" border="0" usemap="#agroup____point____sampling" alt=""/></div>
<map name="agroup____point____sampling" id="agroup____point____sampling">
<area shape="rect" href="group__algorithms__mesh.html" title="List of Mesh algorithms." alt="" coords="5,5,137,31"/>
<area shape="rect" title="List of functions that compute point samplings." alt="" coords="185,5,380,31"/>
</map>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga8458b26d0611468e935530fdb235d1a5" id="r_ga8458b26d0611468e935530fdb235d1a5"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga8458b26d0611468e935530fdb235d1a5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Box.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__point__sampling.html#ga8458b26d0611468e935530fdb235d1a5">vcl::allFacesPointSampling</a> (<a class="el" href="classvcl_1_1Box.html">const</a> MeshType &amp;<a class="el" href="classvcl_1_1Box.html">m</a>, <a class="el" href="classvcl_1_1Box.html">bool</a> <a class="el" href="classvcl_1_1Box.html">onlySelected</a>=<a class="el" href="classvcl_1_1Box.html">false</a>)</td></tr>
<tr class="memdesc:ga8458b26d0611468e935530fdb235d1a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="classvcl_1_1PointSampler.html">PointSampler</a> object that contains all the faces contained in the given mesh.  <br /></td></tr>
<tr class="separator:ga8458b26d0611468e935530fdb235d1a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadae6ffd294d090913c4d72415a60174d" id="r_gadae6ffd294d090913c4d72415a60174d"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:gadae6ffd294d090913c4d72415a60174d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Box.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__point__sampling.html#gadae6ffd294d090913c4d72415a60174d">vcl::allFacesPointSampling</a> (<a class="el" href="classvcl_1_1Box.html">const</a> MeshType &amp;<a class="el" href="classvcl_1_1Box.html">m</a>, std::vector&lt; uint &gt; &amp;<a class="el" href="classvcl_1_1Box.html">birthFaces</a>, <a class="el" href="classvcl_1_1Box.html">bool</a> <a class="el" href="classvcl_1_1Box.html">onlySelected</a>=<a class="el" href="classvcl_1_1Box.html">false</a>)</td></tr>
<tr class="memdesc:gadae6ffd294d090913c4d72415a60174d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="classvcl_1_1PointSampler.html">PointSampler</a> object that contains all the faces contained in the given mesh.  <br /></td></tr>
<tr class="separator:gadae6ffd294d090913c4d72415a60174d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab35c70bead0b4f74b01e2b56523552c6" id="r_gab35c70bead0b4f74b01e2b56523552c6"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:gab35c70bead0b4f74b01e2b56523552c6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Box.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__point__sampling.html#gab35c70bead0b4f74b01e2b56523552c6">vcl::allVerticesPointSampling</a> (<a class="el" href="classvcl_1_1Box.html">const</a> MeshType &amp;<a class="el" href="classvcl_1_1Box.html">m</a>, <a class="el" href="classvcl_1_1Box.html">bool</a> <a class="el" href="classvcl_1_1Box.html">onlySelected</a>=<a class="el" href="classvcl_1_1Box.html">false</a>)</td></tr>
<tr class="memdesc:gab35c70bead0b4f74b01e2b56523552c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="classvcl_1_1PointSampler.html">PointSampler</a> object that contains all the vertices contained in the given mesh.  <br /></td></tr>
<tr class="separator:gab35c70bead0b4f74b01e2b56523552c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae33a24e58846b8a33da5d426af5152f0" id="r_gae33a24e58846b8a33da5d426af5152f0"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:gae33a24e58846b8a33da5d426af5152f0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Box.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__point__sampling.html#gae33a24e58846b8a33da5d426af5152f0">vcl::allVerticesPointSampling</a> (<a class="el" href="classvcl_1_1Box.html">const</a> MeshType &amp;<a class="el" href="classvcl_1_1Box.html">m</a>, std::vector&lt; uint &gt; &amp;<a class="el" href="classvcl_1_1Box.html">birthVertices</a>, <a class="el" href="classvcl_1_1Box.html">bool</a> <a class="el" href="classvcl_1_1Box.html">onlySelected</a>=<a class="el" href="classvcl_1_1Box.html">false</a>)</td></tr>
<tr class="memdesc:gae33a24e58846b8a33da5d426af5152f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="classvcl_1_1PointSampler.html">PointSampler</a> object that contains all the vertices contained in the given mesh.  <br /></td></tr>
<tr class="separator:gae33a24e58846b8a33da5d426af5152f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga59e2ff155382d1b0cc7e908d42405185" id="r_ga59e2ff155382d1b0cc7e908d42405185"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga59e2ff155382d1b0cc7e908d42405185"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Box.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__point__sampling.html#ga59e2ff155382d1b0cc7e908d42405185">vcl::faceAreaWeightedPointSampling</a> (<a class="el" href="classvcl_1_1Box.html">const</a> MeshType &amp;<a class="el" href="classvcl_1_1Box.html">m</a>, uint <a class="el" href="classvcl_1_1Box.html">nSamples</a>, std::optional&lt; uint &gt; <a class="el" href="classvcl_1_1Box.html">seed</a>=std::nullopt)</td></tr>
<tr class="memdesc:ga59e2ff155382d1b0cc7e908d42405185"><td class="mdescLeft">&#160;</td><td class="mdescRight">Samples the faces in a weighted way, using the per face area. Each face has a probability of being chosen that is proportional to its area.  <br /></td></tr>
<tr class="separator:ga59e2ff155382d1b0cc7e908d42405185"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ed8a1822e5971b573c11b61dfb9fd5f" id="r_ga9ed8a1822e5971b573c11b61dfb9fd5f"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga9ed8a1822e5971b573c11b61dfb9fd5f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Box.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__point__sampling.html#ga9ed8a1822e5971b573c11b61dfb9fd5f">vcl::faceQualityWeightedPointSampling</a> (<a class="el" href="classvcl_1_1Box.html">const</a> MeshType &amp;<a class="el" href="classvcl_1_1Box.html">m</a>, uint <a class="el" href="classvcl_1_1Box.html">nSamples</a>, std::optional&lt; uint &gt; <a class="el" href="classvcl_1_1Box.html">seed</a>=std::nullopt)</td></tr>
<tr class="memdesc:ga9ed8a1822e5971b573c11b61dfb9fd5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Samples the faces in a weighted way, using the per face Quality component. Each face has a probability of being chosen that is proportional to its quality value.  <br /></td></tr>
<tr class="separator:ga9ed8a1822e5971b573c11b61dfb9fd5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga011ec956d1f416fe96df4fe404f32a9a" id="r_ga011ec956d1f416fe96df4fe404f32a9a"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga011ec956d1f416fe96df4fe404f32a9a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Box.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__point__sampling.html#ga011ec956d1f416fe96df4fe404f32a9a">vcl::faceUniformPointSampling</a> (<a class="el" href="classvcl_1_1Box.html">const</a> MeshType &amp;<a class="el" href="classvcl_1_1Box.html">m</a>, uint <a class="el" href="classvcl_1_1Box.html">nSamples</a>, <a class="el" href="classvcl_1_1Box.html">bool</a> <a class="el" href="classvcl_1_1Box.html">onlySelected</a>=<a class="el" href="classvcl_1_1Box.html">false</a>, std::optional&lt; uint &gt; <a class="el" href="classvcl_1_1Box.html">seed</a>=std::nullopt)</td></tr>
<tr class="memdesc:ga011ec956d1f416fe96df4fe404f32a9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="classvcl_1_1PointSampler.html">PointSampler</a> object that contains the given number of samples taken from the faces of the given mesh. Each face has the same probability of being chosen. If onlySelected is true, only the selected faces are sampled.  <br /></td></tr>
<tr class="separator:ga011ec956d1f416fe96df4fe404f32a9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaafae8e3952408ba5b831be975864cd64" id="r_gaafae8e3952408ba5b831be975864cd64"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:gaafae8e3952408ba5b831be975864cd64"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Box.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__point__sampling.html#gaafae8e3952408ba5b831be975864cd64">vcl::faceUniformPointSampling</a> (<a class="el" href="classvcl_1_1Box.html">const</a> MeshType &amp;<a class="el" href="classvcl_1_1Box.html">m</a>, uint <a class="el" href="classvcl_1_1Box.html">nSamples</a>, std::vector&lt; uint &gt; &amp;<a class="el" href="classvcl_1_1Box.html">birthFaces</a>, <a class="el" href="classvcl_1_1Box.html">bool</a> <a class="el" href="classvcl_1_1Box.html">onlySelected</a>=<a class="el" href="classvcl_1_1Box.html">false</a>, std::optional&lt; uint &gt; <a class="el" href="classvcl_1_1Box.html">seed</a>=std::nullopt)</td></tr>
<tr class="memdesc:gaafae8e3952408ba5b831be975864cd64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="classvcl_1_1PointSampler.html">PointSampler</a> object that contains the given number of samples taken from the faces of the given mesh. Each face has the same probability of being chosen. If onlySelected is true, only the selected faces are sampled. The indices of the sampled faces in the mesh are stored in the birthFaces vector.  <br /></td></tr>
<tr class="separator:gaafae8e3952408ba5b831be975864cd64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec1a059349d1df8415f25df205afc1ec" id="r_gaec1a059349d1df8415f25df205afc1ec"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType, <a class="el" href="classvcl_1_1Box.html">typename</a> ScalarType &gt; </td></tr>
<tr class="memitem:gaec1a059349d1df8415f25df205afc1ec"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Box.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__point__sampling.html#gaec1a059349d1df8415f25df205afc1ec">vcl::faceWeightedPointSampling</a> (<a class="el" href="classvcl_1_1Box.html">const</a> MeshType &amp;<a class="el" href="classvcl_1_1Box.html">m</a>, <a class="el" href="classvcl_1_1Box.html">const</a> std::vector&lt; ScalarType &gt; &amp;<a class="el" href="classvcl_1_1Box.html">weights</a>, uint <a class="el" href="classvcl_1_1Box.html">nSamples</a>, std::optional&lt; uint &gt; <a class="el" href="classvcl_1_1Box.html">seed</a>=std::nullopt)</td></tr>
<tr class="memdesc:gaec1a059349d1df8415f25df205afc1ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="classvcl_1_1PointSampler.html">PointSampler</a> object that contains the given number of samples taken from the faces of the given mesh. Each face has the same probability of being chosen. If onlySelected is true, only the selected faces are sampled.  <br /></td></tr>
<tr class="separator:gaec1a059349d1df8415f25df205afc1ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3bd5e9052a48e4446fd80a4348562afb" id="r_ga3bd5e9052a48e4446fd80a4348562afb"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType, <a class="el" href="classvcl_1_1Box.html">typename</a> ScalarType &gt; </td></tr>
<tr class="memitem:ga3bd5e9052a48e4446fd80a4348562afb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Box.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__point__sampling.html#ga3bd5e9052a48e4446fd80a4348562afb">vcl::faceWeightedPointSampling</a> (<a class="el" href="classvcl_1_1Box.html">const</a> MeshType &amp;<a class="el" href="classvcl_1_1Box.html">m</a>, <a class="el" href="classvcl_1_1Box.html">const</a> std::vector&lt; ScalarType &gt; &amp;<a class="el" href="classvcl_1_1Box.html">weights</a>, uint <a class="el" href="classvcl_1_1Box.html">nSamples</a>, std::vector&lt; uint &gt; &amp;<a class="el" href="classvcl_1_1Box.html">birthFaces</a>, std::optional&lt; uint &gt; <a class="el" href="classvcl_1_1Box.html">seed</a>=std::nullopt)</td></tr>
<tr class="memdesc:ga3bd5e9052a48e4446fd80a4348562afb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="classvcl_1_1PointSampler.html">PointSampler</a> object that contains the given number of samples taken from the faces of the given mesh. Each face has the same probability of being chosen. If onlySelected is true, only the selected faces are sampled. The indices of the sampled faces in the mesh are stored in the birthFaces vector.  <br /></td></tr>
<tr class="separator:ga3bd5e9052a48e4446fd80a4348562afb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga455d95caa058906e4fc99989422ca22a" id="r_ga455d95caa058906e4fc99989422ca22a"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga455d95caa058906e4fc99989422ca22a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Box.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__point__sampling.html#ga455d95caa058906e4fc99989422ca22a">vcl::montecarloPointSampling</a> (<a class="el" href="classvcl_1_1Box.html">const</a> MeshType &amp;<a class="el" href="classvcl_1_1Box.html">m</a>, uint <a class="el" href="classvcl_1_1Box.html">nSamples</a>, std::optional&lt; uint &gt; <a class="el" href="classvcl_1_1Box.html">seed</a>=std::nullopt)</td></tr>
<tr class="memdesc:ga455d95caa058906e4fc99989422ca22a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a montecarlo distribution with an exact number of samples. It works by generating a sequence of consecutive segments proportional to the face areas and actually shooting sample over this line.  <br /></td></tr>
<tr class="separator:ga455d95caa058906e4fc99989422ca22a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d37f481062d792f9d58fa4b4341bee9" id="r_ga7d37f481062d792f9d58fa4b4341bee9"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga7d37f481062d792f9d58fa4b4341bee9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Box.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__point__sampling.html#ga7d37f481062d792f9d58fa4b4341bee9">vcl::montecarloPointSampling</a> (<a class="el" href="classvcl_1_1Box.html">const</a> MeshType &amp;<a class="el" href="classvcl_1_1Box.html">m</a>, uint <a class="el" href="classvcl_1_1Box.html">nSamples</a>, std::vector&lt; uint &gt; &amp;<a class="el" href="classvcl_1_1Box.html">birthFaces</a>, std::optional&lt; uint &gt; <a class="el" href="classvcl_1_1Box.html">seed</a>=std::nullopt)</td></tr>
<tr class="memdesc:ga7d37f481062d792f9d58fa4b4341bee9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a montecarlo distribution with an exact number of samples. It works by generating a sequence of consecutive segments proportional to the face areas and actually shooting sample over this line. The indices of the sampled faces in the mesh are stored in the birthFaces vector.  <br /></td></tr>
<tr class="separator:ga7d37f481062d792f9d58fa4b4341bee9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5bfa312feccdace9f672822ba6b16536" id="r_ga5bfa312feccdace9f672822ba6b16536"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga5bfa312feccdace9f672822ba6b16536"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Box.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__point__sampling.html#ga5bfa312feccdace9f672822ba6b16536">vcl::montecarloPoissonPointSampling</a> (<a class="el" href="classvcl_1_1Box.html">const</a> MeshType &amp;<a class="el" href="classvcl_1_1Box.html">m</a>, uint <a class="el" href="classvcl_1_1Box.html">nSamples</a>, std::optional&lt; uint &gt; <a class="el" href="classvcl_1_1Box.html">seed</a>=std::nullopt)</td></tr>
<tr class="memdesc:ga5bfa312feccdace9f672822ba6b16536"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function compute montecarlo distribution with an approximate number of samples exploiting the poisson distribution approximation of the binomial distribution.  <br /></td></tr>
<tr class="separator:ga5bfa312feccdace9f672822ba6b16536"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga972019b6401a71aa5a5f0cfe1900136c" id="r_ga972019b6401a71aa5a5f0cfe1900136c"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga972019b6401a71aa5a5f0cfe1900136c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Box.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__point__sampling.html#ga972019b6401a71aa5a5f0cfe1900136c">vcl::vertexAreaWeightedPointSampling</a> (<a class="el" href="classvcl_1_1Box.html">const</a> MeshType &amp;<a class="el" href="classvcl_1_1Box.html">m</a>, uint <a class="el" href="classvcl_1_1Box.html">nSamples</a>, std::optional&lt; uint &gt; <a class="el" href="classvcl_1_1Box.html">seed</a>=std::nullopt)</td></tr>
<tr class="memdesc:ga972019b6401a71aa5a5f0cfe1900136c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Samples the vertices in a weighted way, using the area. Each vertex has a probability of being chosen that is proportional to the average area of its adjacent faces.  <br /></td></tr>
<tr class="separator:ga972019b6401a71aa5a5f0cfe1900136c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa3c5d7de2da1f877611eb4fdccee1534" id="r_gaa3c5d7de2da1f877611eb4fdccee1534"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:gaa3c5d7de2da1f877611eb4fdccee1534"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Box.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__point__sampling.html#gaa3c5d7de2da1f877611eb4fdccee1534">vcl::vertexQualityWeightedPointSampling</a> (<a class="el" href="classvcl_1_1Box.html">const</a> MeshType &amp;<a class="el" href="classvcl_1_1Box.html">m</a>, uint <a class="el" href="classvcl_1_1Box.html">nSamples</a>, std::optional&lt; uint &gt; <a class="el" href="classvcl_1_1Box.html">seed</a>=std::nullopt)</td></tr>
<tr class="memdesc:gaa3c5d7de2da1f877611eb4fdccee1534"><td class="mdescLeft">&#160;</td><td class="mdescRight">Samples the vertices in a weighted way, using the per vertex Quality component. Each vertex has a probability of being chosen that is proportional to its quality value.  <br /></td></tr>
<tr class="separator:gaa3c5d7de2da1f877611eb4fdccee1534"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga212f629a172abbe1b3c35a6d2f4e0794" id="r_ga212f629a172abbe1b3c35a6d2f4e0794"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga212f629a172abbe1b3c35a6d2f4e0794"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Box.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__point__sampling.html#ga212f629a172abbe1b3c35a6d2f4e0794">vcl::vertexUniformPointSampling</a> (<a class="el" href="classvcl_1_1Box.html">const</a> MeshType &amp;<a class="el" href="classvcl_1_1Box.html">m</a>, uint <a class="el" href="classvcl_1_1Box.html">nSamples</a>, <a class="el" href="classvcl_1_1Box.html">bool</a> <a class="el" href="classvcl_1_1Box.html">onlySelected</a>=<a class="el" href="classvcl_1_1Box.html">false</a>, std::optional&lt; uint &gt; <a class="el" href="classvcl_1_1Box.html">seed</a>=std::nullopt)</td></tr>
<tr class="memdesc:ga212f629a172abbe1b3c35a6d2f4e0794"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="classvcl_1_1PointSampler.html">PointSampler</a> object that contains the given number of samples taken from the vertices of the given mesh. Each vertex has the same probability of being chosen. If onlySelected is true, only the selected vertices are sampled.  <br /></td></tr>
<tr class="separator:ga212f629a172abbe1b3c35a6d2f4e0794"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3612e2d816f457bc41ab2af8494a9f52" id="r_ga3612e2d816f457bc41ab2af8494a9f52"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga3612e2d816f457bc41ab2af8494a9f52"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Box.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__point__sampling.html#ga3612e2d816f457bc41ab2af8494a9f52">vcl::vertexUniformPointSampling</a> (<a class="el" href="classvcl_1_1Box.html">const</a> MeshType &amp;<a class="el" href="classvcl_1_1Box.html">m</a>, uint <a class="el" href="classvcl_1_1Box.html">nSamples</a>, std::vector&lt; uint &gt; &amp;<a class="el" href="classvcl_1_1Box.html">birthVertices</a>, <a class="el" href="classvcl_1_1Box.html">bool</a> <a class="el" href="classvcl_1_1Box.html">onlySelected</a>=<a class="el" href="classvcl_1_1Box.html">false</a>, std::optional&lt; uint &gt; <a class="el" href="classvcl_1_1Box.html">seed</a>=std::nullopt)</td></tr>
<tr class="memdesc:ga3612e2d816f457bc41ab2af8494a9f52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="classvcl_1_1PointSampler.html">PointSampler</a> object that contains the given number of samples taken from the vertices of the given mesh. Each vertex has the same probability of being chosen. If onlySelected is true, only the selected vertices are sampled. The indices of the sampled vertices in the mesh are stored in the birthVertices vector.  <br /></td></tr>
<tr class="separator:ga3612e2d816f457bc41ab2af8494a9f52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga06c26f12d530e3739cffd810338f686b" id="r_ga06c26f12d530e3739cffd810338f686b"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType, <a class="el" href="classvcl_1_1Box.html">typename</a> ScalarType &gt; </td></tr>
<tr class="memitem:ga06c26f12d530e3739cffd810338f686b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Box.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__point__sampling.html#ga06c26f12d530e3739cffd810338f686b">vcl::vertexWeightedPointSampling</a> (<a class="el" href="classvcl_1_1Box.html">const</a> MeshType &amp;<a class="el" href="classvcl_1_1Box.html">m</a>, <a class="el" href="classvcl_1_1Box.html">const</a> std::vector&lt; ScalarType &gt; &amp;<a class="el" href="classvcl_1_1Box.html">weights</a>, uint <a class="el" href="classvcl_1_1Box.html">nSamples</a>, std::optional&lt; uint &gt; <a class="el" href="classvcl_1_1Box.html">seed</a>=std::nullopt)</td></tr>
<tr class="memdesc:ga06c26f12d530e3739cffd810338f686b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Samples the vertices in a weighted way, using the per vertex weights given as input. Each vertex has a probability of being chosen that is proportional to its weight. If onlySelected is true, only the selected vertices are sampled.  <br /></td></tr>
<tr class="separator:ga06c26f12d530e3739cffd810338f686b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00cf40382afccb5d45b438c2e6d1afe2" id="r_ga00cf40382afccb5d45b438c2e6d1afe2"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType, <a class="el" href="classvcl_1_1Box.html">typename</a> ScalarType &gt; </td></tr>
<tr class="memitem:ga00cf40382afccb5d45b438c2e6d1afe2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Box.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__point__sampling.html#ga00cf40382afccb5d45b438c2e6d1afe2">vcl::vertexWeightedPointSampling</a> (<a class="el" href="classvcl_1_1Box.html">const</a> MeshType &amp;<a class="el" href="classvcl_1_1Box.html">m</a>, <a class="el" href="classvcl_1_1Box.html">const</a> std::vector&lt; ScalarType &gt; &amp;<a class="el" href="classvcl_1_1Box.html">weights</a>, uint <a class="el" href="classvcl_1_1Box.html">nSamples</a>, std::vector&lt; uint &gt; &amp;<a class="el" href="classvcl_1_1Box.html">birthVertices</a>, std::optional&lt; uint &gt; <a class="el" href="classvcl_1_1Box.html">seed</a>=std::nullopt)</td></tr>
<tr class="memdesc:ga00cf40382afccb5d45b438c2e6d1afe2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Samples the vertices in a weighted way, using the per vertex weights given as input. Each vertex has a probability of being chosen that is proportional to its weight. If onlySelected is true, only the selected vertices are sampled. The indices of the sampled vertices in the mesh are stored in the birthVertices vector.  <br /></td></tr>
<tr class="separator:ga00cf40382afccb5d45b438c2e6d1afe2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>List of functions that compute point samplings. </p>
<p>These functions compute saplings using various simple and complex methods, and return objects that satisfy the vcl::SamplerConcept. A Sampler is an object that allows to store points that can be results of some geometric function (e.g. a point sample that is computed as the barycentric coordinate of a triangle).</p>
<p>You can access these algorithms by including <code>#include &lt;vclib/algorithms/point_sampling.h&gt;</code> </p>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga8458b26d0611468e935530fdb235d1a5" name="ga8458b26d0611468e935530fdb235d1a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8458b26d0611468e935530fdb235d1a5">&#9670;&#160;</a></span>allFacesPointSampling() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Box.html">auto</a> vcl::allFacesPointSampling </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">const</a> MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">bool</a>&#160;</td>
          <td class="paramname"><em>onlySelected</em> = <code><a class="el" href="classvcl_1_1Box.html">false</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a <a class="el" href="classvcl_1_1PointSampler.html">PointSampler</a> object that contains all the faces contained in the given mesh. </p>
<p>This function creates a <a class="el" href="classvcl_1_1PointSampler.html">PointSampler</a> object that contains sampled points on the faces of the given MeshType object m. If onlySelected is true, only the selected faces are sampled.</p>
<p>The sampled point on each face is the face barycenter.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MeshType</td><td>A type that satisfies the FaceMeshConcept</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>A const reference to the <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a> object </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">onlySelected</td><td>A bool that specifies whether to sample only selected faces</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classvcl_1_1PointSampler.html">PointSampler</a> object that contains the sampled points on the faces </dd></dl>

</div>
</div>
<a id="gadae6ffd294d090913c4d72415a60174d" name="gadae6ffd294d090913c4d72415a60174d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadae6ffd294d090913c4d72415a60174d">&#9670;&#160;</a></span>allFacesPointSampling() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Box.html">auto</a> vcl::allFacesPointSampling </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">const</a> MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; uint &gt; &amp;&#160;</td>
          <td class="paramname"><em>birthFaces</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">bool</a>&#160;</td>
          <td class="paramname"><em>onlySelected</em> = <code><a class="el" href="classvcl_1_1Box.html">false</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a <a class="el" href="classvcl_1_1PointSampler.html">PointSampler</a> object that contains all the faces contained in the given mesh. </p>
<p>This function creates a <a class="el" href="classvcl_1_1PointSampler.html">PointSampler</a> object that contains sampled points on the faces of the given MeshType object m. If onlySelected is true, only the selected faces are sampled. The indices of the sampled faces in the mesh are stored in the birthFaces vector.</p>
<p>The sampled point on each face is the face barycenter.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MeshType</td><td>A type that satisfies the FaceMeshConcept</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>A const reference to the <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a> object </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">birthFaces</td><td>A vector of uints that will contain the indices of the sampled faces in the mesh </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">onlySelected</td><td>A bool that specifies whether to sample only selected faces</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classvcl_1_1PointSampler.html">PointSampler</a> object that contains the sampled points on the faces </dd></dl>

</div>
</div>
<a id="gab35c70bead0b4f74b01e2b56523552c6" name="gab35c70bead0b4f74b01e2b56523552c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab35c70bead0b4f74b01e2b56523552c6">&#9670;&#160;</a></span>allVerticesPointSampling() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Box.html">auto</a> vcl::allVerticesPointSampling </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">const</a> MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">bool</a>&#160;</td>
          <td class="paramname"><em>onlySelected</em> = <code><a class="el" href="classvcl_1_1Box.html">false</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a <a class="el" href="classvcl_1_1PointSampler.html">PointSampler</a> object that contains all the vertices contained in the given mesh. </p>
<p>This function creates a <a class="el" href="classvcl_1_1PointSampler.html">PointSampler</a> object that contains all the vertices in the given MeshType object m. If onlySelected is true, only the selected vertices are sampled.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MeshType</td><td>A type that satisfies the MeshConcept</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>A const reference to the <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a> object </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">onlySelected</td><td>A bool that specifies whether to sample only selected vertices</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classvcl_1_1PointSampler.html">PointSampler</a> object that contains the sampled vertices </dd></dl>

</div>
</div>
<a id="gae33a24e58846b8a33da5d426af5152f0" name="gae33a24e58846b8a33da5d426af5152f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae33a24e58846b8a33da5d426af5152f0">&#9670;&#160;</a></span>allVerticesPointSampling() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Box.html">auto</a> vcl::allVerticesPointSampling </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">const</a> MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; uint &gt; &amp;&#160;</td>
          <td class="paramname"><em>birthVertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">bool</a>&#160;</td>
          <td class="paramname"><em>onlySelected</em> = <code><a class="el" href="classvcl_1_1Box.html">false</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a <a class="el" href="classvcl_1_1PointSampler.html">PointSampler</a> object that contains all the vertices contained in the given mesh. </p>
<p>This function creates a <a class="el" href="classvcl_1_1PointSampler.html">PointSampler</a> object that contains all the vertices in the given MeshType object m. If onlySelected is true, only the selected vertices are sampled. The indices of the sampled vertices in the mesh are stored in the birthVertices vector.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MeshType</td><td>A type that satisfies the MeshConcept</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>A const reference to the <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a> object </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">birthVertices</td><td>A vector of uints that will contain the indices of the sampled vertices in the mesh </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">onlySelected</td><td>A bool that specifies whether to sample only selected vertices</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classvcl_1_1PointSampler.html">PointSampler</a> object that contains the sampled vertices </dd></dl>

</div>
</div>
<a id="ga59e2ff155382d1b0cc7e908d42405185" name="ga59e2ff155382d1b0cc7e908d42405185"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga59e2ff155382d1b0cc7e908d42405185">&#9670;&#160;</a></span>faceAreaWeightedPointSampling()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Box.html">auto</a> vcl::faceAreaWeightedPointSampling </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">const</a> MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>nSamples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; uint &gt;&#160;</td>
          <td class="paramname"><em>seed</em> = <code>std::nullopt</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Samples the faces in a weighted way, using the per face area. Each face has a probability of being chosen that is proportional to its area. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">m</td><td></td></tr>
    <tr><td class="paramdir"></td><td class="paramname">nSamples</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">seed</td><td>optional value of seed, to get deterministic results. If not provided, a random seed is used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="ga9ed8a1822e5971b573c11b61dfb9fd5f" name="ga9ed8a1822e5971b573c11b61dfb9fd5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9ed8a1822e5971b573c11b61dfb9fd5f">&#9670;&#160;</a></span>faceQualityWeightedPointSampling()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Box.html">auto</a> vcl::faceQualityWeightedPointSampling </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">const</a> MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>nSamples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; uint &gt;&#160;</td>
          <td class="paramname"><em>seed</em> = <code>std::nullopt</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Samples the faces in a weighted way, using the per face Quality component. Each face has a probability of being chosen that is proportional to its quality value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">m</td><td></td></tr>
    <tr><td class="paramdir"></td><td class="paramname">nSamples</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">seed</td><td>optional value of seed, to get deterministic results. If not provided, a random seed is used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="ga011ec956d1f416fe96df4fe404f32a9a" name="ga011ec956d1f416fe96df4fe404f32a9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga011ec956d1f416fe96df4fe404f32a9a">&#9670;&#160;</a></span>faceUniformPointSampling() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Box.html">auto</a> vcl::faceUniformPointSampling </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">const</a> MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>nSamples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">bool</a>&#160;</td>
          <td class="paramname"><em>onlySelected</em> = <code><a class="el" href="classvcl_1_1Box.html">false</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; uint &gt;&#160;</td>
          <td class="paramname"><em>seed</em> = <code>std::nullopt</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a <a class="el" href="classvcl_1_1PointSampler.html">PointSampler</a> object that contains the given number of samples taken from the faces of the given mesh. Each face has the same probability of being chosen. If onlySelected is true, only the selected faces are sampled. </p>
<p>The sampled point on each face is the face barycenter.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MeshType</td><td>A type that satisfies the FaceMeshConcept</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>The mesh to sample from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nSamples</td><td>The number of samples to take. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">onlySelected</td><td>Whether to only sample from the selected faces. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">seed</td><td>optional value of seed, to get deterministic results. If not provided, a random seed is used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classvcl_1_1PointSampler.html">PointSampler</a> object that contains the sampled points on the faces. </dd></dl>

</div>
</div>
<a id="gaafae8e3952408ba5b831be975864cd64" name="gaafae8e3952408ba5b831be975864cd64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaafae8e3952408ba5b831be975864cd64">&#9670;&#160;</a></span>faceUniformPointSampling() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Box.html">auto</a> vcl::faceUniformPointSampling </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">const</a> MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>nSamples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; uint &gt; &amp;&#160;</td>
          <td class="paramname"><em>birthFaces</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">bool</a>&#160;</td>
          <td class="paramname"><em>onlySelected</em> = <code><a class="el" href="classvcl_1_1Box.html">false</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; uint &gt;&#160;</td>
          <td class="paramname"><em>seed</em> = <code>std::nullopt</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a <a class="el" href="classvcl_1_1PointSampler.html">PointSampler</a> object that contains the given number of samples taken from the faces of the given mesh. Each face has the same probability of being chosen. If onlySelected is true, only the selected faces are sampled. The indices of the sampled faces in the mesh are stored in the birthFaces vector. </p>
<p>The sampled point on each face is the face barycenter.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MeshType</td><td>A type that satisfies the FaceMeshConcept</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>The mesh to sample from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nSamples</td><td>The number of samples to take. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">birthFaces</td><td>A vector of indices of the birth faces. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">onlySelected</td><td>Whether to only sample from the selected faces. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">seed</td><td>optional value of seed, to get deterministic results. If not provided, a random seed is used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classvcl_1_1PointSampler.html">PointSampler</a> object that contains the sampled points on the faces. </dd></dl>

</div>
</div>
<a id="gaec1a059349d1df8415f25df205afc1ec" name="gaec1a059349d1df8415f25df205afc1ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaec1a059349d1df8415f25df205afc1ec">&#9670;&#160;</a></span>faceWeightedPointSampling() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType, <a class="el" href="classvcl_1_1Box.html">typename</a> ScalarType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Box.html">auto</a> vcl::faceWeightedPointSampling </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">const</a> MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">const</a> std::vector&lt; ScalarType &gt; &amp;&#160;</td>
          <td class="paramname"><em>weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>nSamples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; uint &gt;&#160;</td>
          <td class="paramname"><em>seed</em> = <code>std::nullopt</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a <a class="el" href="classvcl_1_1PointSampler.html">PointSampler</a> object that contains the given number of samples taken from the faces of the given mesh. Each face has the same probability of being chosen. If onlySelected is true, only the selected faces are sampled. </p>
<p>The sampled point on each face is the face barycenter.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MeshType</td><td>A type that satisfies the FaceMeshConcept </td></tr>
    <tr><td class="paramname">ScalarType</td><td>The scalar type used for the weights</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>The mesh to sample from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">weights</td><td>A vector of scalars having the i-th entry associated to the face having index i. Note: weights.size() == m.faceContainerSize(). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nSamples</td><td>The number of samples to take. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">seed</td><td>optional value of seed, to get deterministic results. If not provided, a random seed is used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classvcl_1_1PointSampler.html">PointSampler</a> object that contains the sampled points on the faces. </dd></dl>

</div>
</div>
<a id="ga3bd5e9052a48e4446fd80a4348562afb" name="ga3bd5e9052a48e4446fd80a4348562afb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3bd5e9052a48e4446fd80a4348562afb">&#9670;&#160;</a></span>faceWeightedPointSampling() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType, <a class="el" href="classvcl_1_1Box.html">typename</a> ScalarType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Box.html">auto</a> vcl::faceWeightedPointSampling </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">const</a> MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">const</a> std::vector&lt; ScalarType &gt; &amp;&#160;</td>
          <td class="paramname"><em>weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>nSamples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; uint &gt; &amp;&#160;</td>
          <td class="paramname"><em>birthFaces</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; uint &gt;&#160;</td>
          <td class="paramname"><em>seed</em> = <code>std::nullopt</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a <a class="el" href="classvcl_1_1PointSampler.html">PointSampler</a> object that contains the given number of samples taken from the faces of the given mesh. Each face has the same probability of being chosen. If onlySelected is true, only the selected faces are sampled. The indices of the sampled faces in the mesh are stored in the birthFaces vector. </p>
<p>The sampled point on each face is the face barycenter.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MeshType</td><td>A type that satisfies the FaceMeshConcept </td></tr>
    <tr><td class="paramname">ScalarType</td><td>The scalar type used for the weights</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>The mesh to sample from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">weights</td><td>A vector of scalars having the i-th entry associated to the face having index i. Note: weights.size() == m.faceContainerSize(). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nSamples</td><td>The number of samples to take. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">birthFaces</td><td>A vector to store the indices of the faces that were sampled. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">seed</td><td>optional value of seed, to get deterministic results. If not provided, a random seed is used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classvcl_1_1PointSampler.html">PointSampler</a> object that contains the sampled points on the faces. </dd></dl>

</div>
</div>
<a id="ga455d95caa058906e4fc99989422ca22a" name="ga455d95caa058906e4fc99989422ca22a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga455d95caa058906e4fc99989422ca22a">&#9670;&#160;</a></span>montecarloPointSampling() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Box.html">auto</a> vcl::montecarloPointSampling </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">const</a> MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>nSamples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; uint &gt;&#160;</td>
          <td class="paramname"><em>seed</em> = <code>std::nullopt</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes a montecarlo distribution with an exact number of samples. It works by generating a sequence of consecutive segments proportional to the face areas and actually shooting sample over this line. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MeshType</td><td>A type that satisfies the FaceMeshConcept</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>The mesh to sample from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nSamples</td><td>The number of samples to take. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">seed</td><td>optional value of seed, to get deterministic results. If not provided, a random seed is used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classvcl_1_1PointSampler.html">PointSampler</a> object that contains the sampled points on the faces. </dd></dl>

</div>
</div>
<a id="ga7d37f481062d792f9d58fa4b4341bee9" name="ga7d37f481062d792f9d58fa4b4341bee9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7d37f481062d792f9d58fa4b4341bee9">&#9670;&#160;</a></span>montecarloPointSampling() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Box.html">auto</a> vcl::montecarloPointSampling </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">const</a> MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>nSamples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; uint &gt; &amp;&#160;</td>
          <td class="paramname"><em>birthFaces</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; uint &gt;&#160;</td>
          <td class="paramname"><em>seed</em> = <code>std::nullopt</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes a montecarlo distribution with an exact number of samples. It works by generating a sequence of consecutive segments proportional to the face areas and actually shooting sample over this line. The indices of the sampled faces in the mesh are stored in the birthFaces vector. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MeshType</td><td>A type that satisfies the FaceMeshConcept</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>The mesh to sample from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nSamples</td><td>The number of samples to take. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">birthFaces</td><td>A vector to store the indices of the faces that were sampled. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">seed</td><td>optional value of seed, to get deterministic results. If not provided, a random seed is used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classvcl_1_1PointSampler.html">PointSampler</a> object that contains the sampled points on the faces. </dd></dl>

</div>
</div>
<a id="ga5bfa312feccdace9f672822ba6b16536" name="ga5bfa312feccdace9f672822ba6b16536"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5bfa312feccdace9f672822ba6b16536">&#9670;&#160;</a></span>montecarloPoissonPointSampling()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Box.html">auto</a> vcl::montecarloPoissonPointSampling </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">const</a> MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>nSamples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; uint &gt;&#160;</td>
          <td class="paramname"><em>seed</em> = <code>std::nullopt</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function compute montecarlo distribution with an approximate number of samples exploiting the poisson distribution approximation of the binomial distribution. </p>
<p>For a given triangle t of area a_t, in a <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a> of area A, if we take n_s sample over the mesh, the number of samples that falls in t follows the poisson distribution of <code>P(lambda)</code> with <code>lambda = n_s * (a_t/A)</code>.</p>
<p>To approximate the Binomial we use a Poisson distribution with parameter <code>lambda = np</code> can be used as an approximation to <code>B(n,p)</code> (it works if n is sufficiently large and p is sufficiently small).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">m</td><td></td></tr>
    <tr><td class="paramdir"></td><td class="paramname">nSamples</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">seed</td><td>optional value of seed, to get deterministic results. If not provided, a random seed is used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="ga972019b6401a71aa5a5f0cfe1900136c" name="ga972019b6401a71aa5a5f0cfe1900136c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga972019b6401a71aa5a5f0cfe1900136c">&#9670;&#160;</a></span>vertexAreaWeightedPointSampling()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Box.html">auto</a> vcl::vertexAreaWeightedPointSampling </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">const</a> MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>nSamples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; uint &gt;&#160;</td>
          <td class="paramname"><em>seed</em> = <code>std::nullopt</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Samples the vertices in a weighted way, using the area. Each vertex has a probability of being chosen that is proportional to the average area of its adjacent faces. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">m</td><td></td></tr>
    <tr><td class="paramdir"></td><td class="paramname">nSamples</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">seed</td><td>optional value of seed, to get deterministic results. If not provided, a random seed is used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="gaa3c5d7de2da1f877611eb4fdccee1534" name="gaa3c5d7de2da1f877611eb4fdccee1534"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa3c5d7de2da1f877611eb4fdccee1534">&#9670;&#160;</a></span>vertexQualityWeightedPointSampling()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Box.html">auto</a> vcl::vertexQualityWeightedPointSampling </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">const</a> MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>nSamples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; uint &gt;&#160;</td>
          <td class="paramname"><em>seed</em> = <code>std::nullopt</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Samples the vertices in a weighted way, using the per vertex Quality component. Each vertex has a probability of being chosen that is proportional to its quality value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">m</td><td></td></tr>
    <tr><td class="paramdir"></td><td class="paramname">nSamples</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">seed</td><td>optional value of seed, to get deterministic results. If not provided, a random seed is used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="ga212f629a172abbe1b3c35a6d2f4e0794" name="ga212f629a172abbe1b3c35a6d2f4e0794"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga212f629a172abbe1b3c35a6d2f4e0794">&#9670;&#160;</a></span>vertexUniformPointSampling() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Box.html">auto</a> vcl::vertexUniformPointSampling </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">const</a> MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>nSamples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">bool</a>&#160;</td>
          <td class="paramname"><em>onlySelected</em> = <code><a class="el" href="classvcl_1_1Box.html">false</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; uint &gt;&#160;</td>
          <td class="paramname"><em>seed</em> = <code>std::nullopt</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a <a class="el" href="classvcl_1_1PointSampler.html">PointSampler</a> object that contains the given number of samples taken from the vertices of the given mesh. Each vertex has the same probability of being chosen. If onlySelected is true, only the selected vertices are sampled. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MeshType</td><td>A type that satisfies the MeshConcept</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>The mesh to sample from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nSamples</td><td>The number of samples to take. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">onlySelected</td><td>Whether to only sample from the selected vertices. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">seed</td><td>optional value of seed, to get deterministic results. If not provided, a random seed is used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classvcl_1_1PointSampler.html">PointSampler</a> object containing the sampled vertices. </dd></dl>

</div>
</div>
<a id="ga3612e2d816f457bc41ab2af8494a9f52" name="ga3612e2d816f457bc41ab2af8494a9f52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3612e2d816f457bc41ab2af8494a9f52">&#9670;&#160;</a></span>vertexUniformPointSampling() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Box.html">auto</a> vcl::vertexUniformPointSampling </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">const</a> MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>nSamples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; uint &gt; &amp;&#160;</td>
          <td class="paramname"><em>birthVertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">bool</a>&#160;</td>
          <td class="paramname"><em>onlySelected</em> = <code><a class="el" href="classvcl_1_1Box.html">false</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; uint &gt;&#160;</td>
          <td class="paramname"><em>seed</em> = <code>std::nullopt</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a <a class="el" href="classvcl_1_1PointSampler.html">PointSampler</a> object that contains the given number of samples taken from the vertices of the given mesh. Each vertex has the same probability of being chosen. If onlySelected is true, only the selected vertices are sampled. The indices of the sampled vertices in the mesh are stored in the birthVertices vector. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MeshType</td><td>A type that satisfies the MeshConcept</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>The mesh to sample from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nSamples</td><td>The number of samples to take. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">birthVertices</td><td>A vector of indices of the birth vertices. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">onlySelected</td><td>Whether to only sample from the selected vertices. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">seed</td><td>optional value of seed, to get deterministic results. If not provided, a random seed is used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classvcl_1_1PointSampler.html">PointSampler</a> object containing the sampled vertices. </dd></dl>

</div>
</div>
<a id="ga06c26f12d530e3739cffd810338f686b" name="ga06c26f12d530e3739cffd810338f686b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga06c26f12d530e3739cffd810338f686b">&#9670;&#160;</a></span>vertexWeightedPointSampling() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType, <a class="el" href="classvcl_1_1Box.html">typename</a> ScalarType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Box.html">auto</a> vcl::vertexWeightedPointSampling </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">const</a> MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">const</a> std::vector&lt; ScalarType &gt; &amp;&#160;</td>
          <td class="paramname"><em>weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>nSamples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; uint &gt;&#160;</td>
          <td class="paramname"><em>seed</em> = <code>std::nullopt</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Samples the vertices in a weighted way, using the per vertex weights given as input. Each vertex has a probability of being chosen that is proportional to its weight. If onlySelected is true, only the selected vertices are sampled. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MeshType</td><td>A type that satisfies the MeshConcept </td></tr>
    <tr><td class="paramname">ScalarType</td><td>The scalar type used for the weights</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>The input mesh to sample from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">weights</td><td>A vector of scalars having the i-th entry associated to the vertex having index i. Note: weights.size() == m.vertexContainerSize(). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nSamples</td><td>The number of vertices to sample. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">seed</td><td>optional value of seed, to get deterministic results. If not provided, a random seed is used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classvcl_1_1PointSampler.html">PointSampler</a> object containing the samples selected from the input mesh. </dd></dl>

</div>
</div>
<a id="ga00cf40382afccb5d45b438c2e6d1afe2" name="ga00cf40382afccb5d45b438c2e6d1afe2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga00cf40382afccb5d45b438c2e6d1afe2">&#9670;&#160;</a></span>vertexWeightedPointSampling() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType, <a class="el" href="classvcl_1_1Box.html">typename</a> ScalarType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Box.html">auto</a> vcl::vertexWeightedPointSampling </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">const</a> MeshType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">const</a> std::vector&lt; ScalarType &gt; &amp;&#160;</td>
          <td class="paramname"><em>weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>nSamples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; uint &gt; &amp;&#160;</td>
          <td class="paramname"><em>birthVertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; uint &gt;&#160;</td>
          <td class="paramname"><em>seed</em> = <code>std::nullopt</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Samples the vertices in a weighted way, using the per vertex weights given as input. Each vertex has a probability of being chosen that is proportional to its weight. If onlySelected is true, only the selected vertices are sampled. The indices of the sampled vertices in the mesh are stored in the birthVertices vector. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MeshType</td><td>A type that satisfies the MeshConcept </td></tr>
    <tr><td class="paramname">ScalarType</td><td>The scalar type used for the weights</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>The input mesh to sample from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">weights</td><td>A vector of scalars having the i-th entry associated to the vertex having index i. Note: weights.size() == m.vertexContainerSize(). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nSamples</td><td>The number of vertices to sample. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">birthVertices</td><td>A vector to store the indices of the vertices that were sampled. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">seed</td><td>optional value of seed, to get deterministic results. If not provided, a random seed is used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classvcl_1_1PointSampler.html">PointSampler</a> object containing the samples selected from the input mesh. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
