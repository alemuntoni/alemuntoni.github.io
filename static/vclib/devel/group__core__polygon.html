<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Visual Computing Library: Polygon Core Algorithms</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript" src="../version-selector.js"></script>
       <script type="text/javascript">
           DoxygenAwesomeDarkModeToggle.init()
       </script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Visual Computing Library
   &#160;<span id="projectnumber">devel</span>
   </div>
   <!-- Version selector dropdown -->
   <div id="version-selector" style="margin-top: 10px;">
     <label for="version-dropdown" style="font-size: 12px; color: #666;">Version:</label>
     <select id="version-dropdown" style="margin-left: 5px; padding: 2px 5px; font-size: 12px; border: 1px solid #ccc; border-radius: 3px;">
       <option value="">Loading versions...</option>
     </select>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group__core__polygon.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Polygon Core Algorithms<div class="ingroups"><a class="el" href="group__algorithms__core.html">Core Algorithms</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>List of Core Polygon algorithms.  
<a href="#details">More...</a></p>
<div class="dynheader">
Collaboration diagram for Polygon Core Algorithms:</div>
<div class="dyncontent">
<div class="center"><img src="group__core__polygon.png" border="0" usemap="#agroup____core____polygon" alt=""/></div>
<map name="agroup____core____polygon" id="agroup____core____polygon">
<area shape="rect" href="group__algorithms__core.html" title="List of Core algorithms." alt="" coords="5,5,132,31"/>
<area shape="rect" title="List of Core Polygon algorithms." alt="" coords="180,5,363,31"/>
</map>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gab42eaf577be42c2e6054b6edec73a1da" id="r_gab42eaf577be42c2e6054b6edec73a1da"><td class="memTemplParams" colspan="2">template&lt;Point2Concept PointType&gt; </td></tr>
<tr class="memitem:gab42eaf577be42c2e6054b6edec73a1da"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Box.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__core__polygon.html#gab42eaf577be42c2e6054b6edec73a1da">vcl::areCounterClockwise</a> (<a class="el" href="classvcl_1_1Box.html">const</a> PointType &amp;p0, <a class="el" href="classvcl_1_1Box.html">const</a> PointType &amp;p1, <a class="el" href="classvcl_1_1Box.html">const</a> PointType &amp;<a class="el" href="classvcl_1_1Box.html">p2</a>)</td></tr>
<tr class="memdesc:gab42eaf577be42c2e6054b6edec73a1da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the three points are counter-clockwise.  <br /></td></tr>
<tr class="separator:gab42eaf577be42c2e6054b6edec73a1da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45d7065ff3815093be1c32f8077d0e1c" id="r_ga45d7065ff3815093be1c32f8077d0e1c"><td class="memTemplParams" colspan="2">template&lt;Point2Concept PointType&gt; </td></tr>
<tr class="memitem:ga45d7065ff3815093be1c32f8077d0e1c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Box.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__core__polygon.html#ga45d7065ff3815093be1c32f8077d0e1c">vcl::collinearityTest</a> (<a class="el" href="classvcl_1_1Box.html">const</a> PointType &amp;p0, <a class="el" href="classvcl_1_1Box.html">const</a> PointType &amp;p1, <a class="el" href="classvcl_1_1Box.html">const</a> PointType &amp;<a class="el" href="classvcl_1_1Box.html">p2</a>)</td></tr>
<tr class="memdesc:ga45d7065ff3815093be1c32f8077d0e1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the collinearity test between three points. The test returns a positive value if the points are counter-clockwise, a negative value if the points are clockwise, and zero if the points are collinear.  <br /></td></tr>
<tr class="separator:ga45d7065ff3815093be1c32f8077d0e1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a8d4a5e28ec3ba08e0525b15aebeb1c" id="r_ga3a8d4a5e28ec3ba08e0525b15aebeb1c"><td class="memTemplParams" colspan="2">template&lt;Point2IteratorConcept InputIterator&gt; </td></tr>
<tr class="memitem:ga3a8d4a5e28ec3ba08e0525b15aebeb1c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Box.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__core__polygon.html#ga3a8d4a5e28ec3ba08e0525b15aebeb1c">vcl::convexHull</a> (InputIterator first, InputIterator end)</td></tr>
<tr class="memdesc:ga3a8d4a5e28ec3ba08e0525b15aebeb1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the 2D convex hull using Graham scan algorithm on a set of points.  <br /></td></tr>
<tr class="separator:ga3a8d4a5e28ec3ba08e0525b15aebeb1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac4dbcbe1f5e5f94f45c7830d6e08ade9" id="r_gac4dbcbe1f5e5f94f45c7830d6e08ade9"><td class="memTemplParams" colspan="2">template&lt;Polygon2Concept PolygonType&gt; </td></tr>
<tr class="memitem:gac4dbcbe1f5e5f94f45c7830d6e08ade9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Box.html">PolygonType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__core__polygon.html#gac4dbcbe1f5e5f94f45c7830d6e08ade9">vcl::createCircle</a> (uint <a class="el" href="classvcl_1_1Box.html">n</a>, <a class="el" href="classvcl_1_1Box.html">typename</a> PolygonType::ScalarType radius=1.0)</td></tr>
<tr class="memdesc:gac4dbcbe1f5e5f94f45c7830d6e08ade9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a 2D circle polygon with n vertices and the given radius.  <br /></td></tr>
<tr class="separator:gac4dbcbe1f5e5f94f45c7830d6e08ade9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3983ab4b434d669a765240b81daa236e" id="r_ga3983ab4b434d669a765240b81daa236e"><td class="memTemplParams" colspan="2">template&lt;FaceConcept Face&gt; </td></tr>
<tr class="memitem:ga3983ab4b434d669a765240b81daa236e"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; uint &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__core__polygon.html#ga3983ab4b434d669a765240b81daa236e">vcl::earCut</a> (<a class="el" href="classvcl_1_1Box.html">const</a> <a class="el" href="classvcl_1_1Face.html">Face</a> &amp;polygon)</td></tr>
<tr class="memdesc:ga3983ab4b434d669a765240b81daa236e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the earcut algorithm of a 3D <em>planar</em> polygonal face, that returns a triangulation of the polygon.  <br /></td></tr>
<tr class="separator:ga3983ab4b434d669a765240b81daa236e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5529ffbd22f80c7b3502d461b3f25fd2" id="r_ga5529ffbd22f80c7b3502d461b3f25fd2"><td class="memTemplParams" colspan="2">template&lt;Point2IteratorConcept Iterator&gt; </td></tr>
<tr class="memitem:ga5529ffbd22f80c7b3502d461b3f25fd2"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; uint &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__core__polygon.html#ga5529ffbd22f80c7b3502d461b3f25fd2">vcl::earCut</a> (Iterator begin, Iterator end)</td></tr>
<tr class="memdesc:ga5529ffbd22f80c7b3502d461b3f25fd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Triangulates a simple polygon with no holes using the ear-cutting algorithm.  <br /></td></tr>
<tr class="separator:ga5529ffbd22f80c7b3502d461b3f25fd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadce63d4185f787a510f769fadebc64f7" id="r_gadce63d4185f787a510f769fadebc64f7"><td class="memTemplParams" colspan="2">template&lt;Range R&gt; </td></tr>
<tr class="memitem:gadce63d4185f787a510f769fadebc64f7"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; uint &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__core__polygon.html#gadce63d4185f787a510f769fadebc64f7">vcl::earCut</a> (R &amp;&amp;<a class="el" href="classvcl_1_1Box.html">range</a>)</td></tr>
<tr class="memdesc:gadce63d4185f787a510f769fadebc64f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Triangulates a simple polygon with no holes using the ear-cutting algorithm.    <br /></td></tr>
<tr class="separator:gadce63d4185f787a510f769fadebc64f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga12529598a32a7b21eac27744b3578600" id="r_ga12529598a32a7b21eac27744b3578600"><td class="memTemplParams" colspan="2">template&lt;FaceConcept FaceType&gt; </td></tr>
<tr class="memitem:ga12529598a32a7b21eac27744b3578600"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Box.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__core__polygon.html#ga12529598a32a7b21eac27744b3578600">vcl::faceAngleOnVertexRad</a> (<a class="el" href="classvcl_1_1Box.html">const</a> FaceType &amp;f, uint <a class="el" href="classvcl_1_1Box.html">vi</a>)</td></tr>
<tr class="memdesc:ga12529598a32a7b21eac27744b3578600"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the internal angle (in radians) of the vi-th vertex of the face.  <br /></td></tr>
<tr class="separator:ga12529598a32a7b21eac27744b3578600"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9fc3b9cae851d7a729f40dc2f4ebe824" id="r_ga9fc3b9cae851d7a729f40dc2f4ebe824"><td class="memTemplParams" colspan="2">template&lt;FaceConcept FaceType&gt; </td></tr>
<tr class="memitem:ga9fc3b9cae851d7a729f40dc2f4ebe824"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Box.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__core__polygon.html#ga9fc3b9cae851d7a729f40dc2f4ebe824">vcl::faceArea</a> (<a class="el" href="classvcl_1_1Box.html">const</a> FaceType &amp;f)</td></tr>
<tr class="memdesc:ga9fc3b9cae851d7a729f40dc2f4ebe824"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the area of a face. Works both for triangle and polygonal faces, and it is optimized in case of triangle faces.  <br /></td></tr>
<tr class="separator:ga9fc3b9cae851d7a729f40dc2f4ebe824"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac00744c46a6af9b0611ce671f85d984c" id="r_gac00744c46a6af9b0611ce671f85d984c"><td class="memTemplParams" colspan="2">template&lt;FaceConcept FaceType&gt; </td></tr>
<tr class="memitem:gac00744c46a6af9b0611ce671f85d984c"><td class="memTemplItemLeft" align="right" valign="top">FaceType::VertexType::PositionType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__core__polygon.html#gac00744c46a6af9b0611ce671f85d984c">vcl::faceBarycenter</a> (<a class="el" href="classvcl_1_1Box.html">const</a> FaceType &amp;f)</td></tr>
<tr class="memdesc:gac00744c46a6af9b0611ce671f85d984c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the barycenter of a face. Works both for triangle and polygonal faces, and it is optimized in case of triangle faces.  <br /></td></tr>
<tr class="separator:gac00744c46a6af9b0611ce671f85d984c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2fd523c4f86a82d948003bd3849feef2" id="r_ga2fd523c4f86a82d948003bd3849feef2"><td class="memTemplParams" colspan="2">template&lt;FaceConcept FaceType&gt; </td></tr>
<tr class="memitem:ga2fd523c4f86a82d948003bd3849feef2"><td class="memTemplItemLeft" align="right" valign="top">FaceType::VertexType::PositionType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__core__polygon.html#ga2fd523c4f86a82d948003bd3849feef2">vcl::faceNormal</a> (<a class="el" href="classvcl_1_1Box.html">const</a> FaceType &amp;f)</td></tr>
<tr class="memdesc:ga2fd523c4f86a82d948003bd3849feef2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the normal of a face, without modifying the face. Works both for triangle and polygonal faces, and it is optimized in case of triangle faces.  <br /></td></tr>
<tr class="separator:ga2fd523c4f86a82d948003bd3849feef2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1dccfede16e36e5ded5213fb13643943" id="r_ga1dccfede16e36e5ded5213fb13643943"><td class="memTemplParams" colspan="2">template&lt;FaceConcept FaceType&gt; </td></tr>
<tr class="memitem:ga1dccfede16e36e5ded5213fb13643943"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Box.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__core__polygon.html#ga1dccfede16e36e5ded5213fb13643943">vcl::facePerimeter</a> (<a class="el" href="classvcl_1_1Box.html">const</a> FaceType &amp;f)</td></tr>
<tr class="memdesc:ga1dccfede16e36e5ded5213fb13643943"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the perimeter of a face. Works both for triangle and polygonal faces, and it is optimized in case of triangle faces.  <br /></td></tr>
<tr class="separator:ga1dccfede16e36e5ded5213fb13643943"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafcb157835aefece9139942d19a63d7c5" id="r_gafcb157835aefece9139942d19a63d7c5"><td class="memTemplParams" colspan="2">template&lt;Point2IteratorConcept Iterator&gt; </td></tr>
<tr class="memitem:gafcb157835aefece9139942d19a63d7c5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Box.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__core__polygon.html#gafcb157835aefece9139942d19a63d7c5">vcl::isCounterClockWise</a> (Iterator begin, Iterator end)</td></tr>
<tr class="memdesc:gafcb157835aefece9139942d19a63d7c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a set of points that form a polygon are in counter-clockwise order.  <br /></td></tr>
<tr class="separator:gafcb157835aefece9139942d19a63d7c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga025a3a732555abc356e597426d99764c" id="r_ga025a3a732555abc356e597426d99764c"><td class="memTemplParams" colspan="2">template&lt;Point3IteratorConcept Iterator&gt; </td></tr>
<tr class="memitem:ga025a3a732555abc356e597426d99764c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Box.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__core__polygon.html#ga025a3a732555abc356e597426d99764c">vcl::project</a> (Iterator begin, Iterator end)</td></tr>
<tr class="memdesc:ga025a3a732555abc356e597426d99764c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Project a 3D polygon onto a plane, and return the 2D polygon.  <br /></td></tr>
<tr class="separator:ga025a3a732555abc356e597426d99764c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab5ab47b215561bd319f7d1e851f906fc" id="r_gab5ab47b215561bd319f7d1e851f906fc"><td class="memTemplParams" colspan="2">template&lt;Range R&gt; <br />
requires Point3Concept&lt;std::ranges::range_value_t&lt;R&gt;&gt;</td></tr>
<tr class="memitem:gab5ab47b215561bd319f7d1e851f906fc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Box.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__core__polygon.html#gab5ab47b215561bd319f7d1e851f906fc">vcl::project</a> (R &amp;&amp;polygon)</td></tr>
<tr class="memdesc:gab5ab47b215561bd319f7d1e851f906fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Project a 3D polygon defined by the given range onto a plane, and return the 2D polygon.  <br /></td></tr>
<tr class="separator:gab5ab47b215561bd319f7d1e851f906fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad713d64f5e56ceb6b7f9bbb4b8eb27b3" id="r_gad713d64f5e56ceb6b7f9bbb4b8eb27b3"><td class="memTemplParams" colspan="2">template&lt;Point2IteratorConcept Iterator&gt; </td></tr>
<tr class="memitem:gad713d64f5e56ceb6b7f9bbb4b8eb27b3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Box.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__core__polygon.html#gad713d64f5e56ceb6b7f9bbb4b8eb27b3">vcl::sortConvexPolygonVertices</a> (Iterator begin, Iterator end)</td></tr>
<tr class="memdesc:gad713d64f5e56ceb6b7f9bbb4b8eb27b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts the vertices of a convex polygon in counter-clockwise order.  <br /></td></tr>
<tr class="separator:gad713d64f5e56ceb6b7f9bbb4b8eb27b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>List of Core Polygon algorithms. </p>
<h2 class="groupheader">Function Documentation</h2>
<a id="gab42eaf577be42c2e6054b6edec73a1da" name="gab42eaf577be42c2e6054b6edec73a1da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab42eaf577be42c2e6054b6edec73a1da">&#9670;&#160;</a></span>areCounterClockwise()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Point2Concept PointType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Box.html">bool</a> vcl::areCounterClockwise </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">const</a> PointType &amp;&#160;</td>
          <td class="paramname"><em>p0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">const</a> PointType &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">const</a> PointType &amp;&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the three points are counter-clockwise. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">PointType</td><td>the type of the points that satisfies the Point2Concept. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p0</td><td>the first point. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p1</td><td>the second point. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p2</td><td>the third point. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the points are counter-clockwise, false otherwise. </dd></dl>

</div>
</div>
<a id="ga45d7065ff3815093be1c32f8077d0e1c" name="ga45d7065ff3815093be1c32f8077d0e1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga45d7065ff3815093be1c32f8077d0e1c">&#9670;&#160;</a></span>collinearityTest()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Point2Concept PointType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Box.html">auto</a> vcl::collinearityTest </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">const</a> PointType &amp;&#160;</td>
          <td class="paramname"><em>p0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">const</a> PointType &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">const</a> PointType &amp;&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the collinearity test between three points. The test returns a positive value if the points are counter-clockwise, a negative value if the points are clockwise, and zero if the points are collinear. </p>
<p>The function computes the z coordinate of the cross product between the vectors p1 - p0 and p2 - p0:</p><ul>
<li>If the result is 0, the points are collinear;</li>
<li>if the result is positive, the three points constitute a "left turn" or counter-clockwise orientation (p0 is at the left of the line p1-p2);</li>
<li>if the result is negative, a "right turn" or clockwise orientation (p0 is at the right of the line p1-p2).</li>
</ul>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">PointType</td><td>the type of the points that satisfies the Point2Concept. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p0</td><td>the first point. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p1</td><td>the second point. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p2</td><td>the third point. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if the points are collinear, a positive value if the points are counter-clockwise, and a negative value if the points are clockwise. </dd></dl>

</div>
</div>
<a id="ga3a8d4a5e28ec3ba08e0525b15aebeb1c" name="ga3a8d4a5e28ec3ba08e0525b15aebeb1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3a8d4a5e28ec3ba08e0525b15aebeb1c">&#9670;&#160;</a></span>convexHull()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Point2IteratorConcept InputIterator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Box.html">auto</a> vcl::convexHull </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the 2D convex hull using Graham scan algorithm on a set of points. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">InputIterator</td><td>Iterator type of the input container of points. It must Iterate over a range of elements that satisfy the Point2Concept. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>First iterator of the input container of points. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">end</td><td>End iterator of the input container of points. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A polygon representing the convex hull of the input points. </dd></dl>

</div>
</div>
<a id="gac4dbcbe1f5e5f94f45c7830d6e08ade9" name="gac4dbcbe1f5e5f94f45c7830d6e08ade9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac4dbcbe1f5e5f94f45c7830d6e08ade9">&#9670;&#160;</a></span>createCircle()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Polygon2Concept PolygonType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Box.html">PolygonType</a> vcl::createCircle </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">typename</a> PolygonType::ScalarType&#160;</td>
          <td class="paramname"><em>radius</em> = <code>1.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a 2D circle polygon with n vertices and the given radius. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">PolygonType</td><td>The polygon type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>The number of vertices. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">radius</td><td>The radius of the circle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The circle polygon. </dd></dl>

</div>
</div>
<a id="ga3983ab4b434d669a765240b81daa236e" name="ga3983ab4b434d669a765240b81daa236e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3983ab4b434d669a765240b81daa236e">&#9670;&#160;</a></span>earCut() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceConcept Face&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; uint &gt; vcl::earCut </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">const</a> <a class="el" href="classvcl_1_1Face.html">Face</a> &amp;&#160;</td>
          <td class="paramname"><em>polygon</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the earcut algorithm of a 3D <em>planar</em> polygonal face, that returns a triangulation of the polygon. </p>
<p>Returns a list of indices in which each index is the index of a point of the 3D input polygon, organized in triplets, each one of these is a triangle of the resulting triangulation.</p>
<p>This algorithm first computes the normal of the given polygon, then projects it in a 2D plane and executes the classic 2D EarCut algorithm.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="el" href="classvcl_1_1Face.html" title="The Face class represents an Face element of the vcl::Mesh class.">Face</a></td><td>the type of the face that satisfies the FaceConcept.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">polygon</td><td>A (polygonal) face of a <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">vcl::Mesh</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of indices, representing the triplets of the triangulation of the polygon. </dd></dl>

</div>
</div>
<a id="ga5529ffbd22f80c7b3502d461b3f25fd2" name="ga5529ffbd22f80c7b3502d461b3f25fd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5529ffbd22f80c7b3502d461b3f25fd2">&#9670;&#160;</a></span>earCut() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Point2IteratorConcept Iterator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; uint &gt; vcl::earCut </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Triangulates a simple polygon with no holes using the ear-cutting algorithm. </p>
<p>Triangulates a simple polygon with no holes in 3D space by projecting it onto a 2D plane and applying the ear-cutting algorithm.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Iterator</td><td>The type of iterator used to represent the vertices of the polygon. It must satisfy the Point2Concept requirement. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">begin</td><td>An iterator pointing to the first vertex of the polygon. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">end</td><td>An iterator pointing to one past the last vertex of the polygon. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector containing the indices of the vertices that form triangles in the triangulated polygon. Each group of three indices represents the vertices of a single triangle, and the indices are ordered in a counter-clockwise direction. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>If the polygon is not simple or has holes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>This function uses the ear-cutting algorithm to triangulate a simple polygon with no holes. The polygon is represented as a sequence of vertices, where each vertex is a two-dimensional point. The function returns a vector containing the indices of the vertices that form triangles in the triangulated polygon. The indices are ordered in a counter-clockwise direction, and each group of three indices represents the vertices of a single triangle. The function requires that the type of iterator used to represent the vertices of the polygon satisfies the Point2Concept requirement, which means that it must have a value_type that is a Point2 object with a ScalarType member representing the scalar type used to represent the position of the point. If the polygon is not simple or has holes, the function throws a std::logic_error.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Iterator</td><td>The type of iterator used to represent the vertices of the polygon. It must satisfy the Point3Concept requirement. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">begin</td><td>An iterator pointing to the first vertex of the polygon. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">end</td><td>An iterator pointing to one past the last vertex of the polygon. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector containing the indices of the vertices that form triangles in the triangulated polygon. Each group of three indices represents the vertices of a single triangle, and the indices are ordered in a counter-clockwise direction. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>If the polygon is not simple or has holes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>This function triangulates a simple polygon with no holes in 3D space by projecting it onto a 2D plane and applying the ear-cutting algorithm. The polygon is represented as a sequence of vertices, where each vertex is a three-dimensional point. The function first calculates the normal vector of the polygon and an orthonormal basis for the plane containing the polygon. It then projects each vertex onto the plane and triangulates the resulting 2D polygon using the ear-cutting algorithm. The function returns a vector containing the indices of the vertices that form triangles in the triangulated polygon. The indices are ordered in a counter-clockwise direction, and each group of three indices represents the vertices of a single triangle. The function requires that the type of iterator used to represent the vertices of the polygon satisfies the Point3Concept requirement, which means that it must have a value_type that is a Point3 object with a ScalarType member representing the scalar type used to represent the position of the point. If the polygon is not simple or has holes, the function throws a std::logic_error. </dd></dl>

</div>
</div>
<a id="gadce63d4185f787a510f769fadebc64f7" name="gadce63d4185f787a510f769fadebc64f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadce63d4185f787a510f769fadebc64f7">&#9670;&#160;</a></span>earCut() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Range R&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; uint &gt; vcl::earCut </td>
          <td>(</td>
          <td class="paramtype">R &amp;&amp;&#160;</td>
          <td class="paramname"><em>range</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Triangulates a simple polygon with no holes using the ear-cutting algorithm.   </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>a range of points that satisfy the PointConcept. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">range</td><td>the range of points that define the polygon. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector containing the indices of the vertices that form triangles in the triangulated polygon. </dd></dl>

</div>
</div>
<a id="ga12529598a32a7b21eac27744b3578600" name="ga12529598a32a7b21eac27744b3578600"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga12529598a32a7b21eac27744b3578600">&#9670;&#160;</a></span>faceAngleOnVertexRad()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceConcept FaceType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Box.html">auto</a> vcl::faceAngleOnVertexRad </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">const</a> FaceType &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>vi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the internal angle (in radians) of the vi-th vertex of the face. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FaceType</td><td>the type of the face that satisfies the FaceConcept.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>the input face. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vi</td><td>the index of the vertex in the face on which calculate the angle </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the angle in radians at the vi-th vertex. </dd></dl>

</div>
</div>
<a id="ga9fc3b9cae851d7a729f40dc2f4ebe824" name="ga9fc3b9cae851d7a729f40dc2f4ebe824"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9fc3b9cae851d7a729f40dc2f4ebe824">&#9670;&#160;</a></span>faceArea()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceConcept FaceType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Box.html">auto</a> vcl::faceArea </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">const</a> FaceType &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the area of a face. Works both for triangle and polygonal faces, and it is optimized in case of triangle faces. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FaceType</td><td>the type of the face that satisfies the FaceConcept.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>the input face. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the area of the face. </dd></dl>

</div>
</div>
<a id="gac00744c46a6af9b0611ce671f85d984c" name="gac00744c46a6af9b0611ce671f85d984c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac00744c46a6af9b0611ce671f85d984c">&#9670;&#160;</a></span>faceBarycenter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceConcept FaceType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">FaceType::VertexType::PositionType vcl::faceBarycenter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">const</a> FaceType &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the barycenter of a face. Works both for triangle and polygonal faces, and it is optimized in case of triangle faces. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FaceType</td><td>the type of the face that satisfies the FaceConcept.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>the input face. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the barycenter of the face. </dd></dl>

</div>
</div>
<a id="ga2fd523c4f86a82d948003bd3849feef2" name="ga2fd523c4f86a82d948003bd3849feef2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2fd523c4f86a82d948003bd3849feef2">&#9670;&#160;</a></span>faceNormal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceConcept FaceType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">FaceType::VertexType::PositionType vcl::faceNormal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">const</a> FaceType &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the normal of a face, without modifying the face. Works both for triangle and polygonal faces, and it is optimized in case of triangle faces. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FaceType</td><td>the type of the face that satisfies the FaceConcept.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>the input face. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the normal of the face. </dd></dl>

</div>
</div>
<a id="ga1dccfede16e36e5ded5213fb13643943" name="ga1dccfede16e36e5ded5213fb13643943"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1dccfede16e36e5ded5213fb13643943">&#9670;&#160;</a></span>facePerimeter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceConcept FaceType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Box.html">auto</a> vcl::facePerimeter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">const</a> FaceType &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the perimeter of a face. Works both for triangle and polygonal faces, and it is optimized in case of triangle faces. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FaceType</td><td>the type of the face that satisfies the FaceConcept.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>the input face. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the perimeter of the face. </dd></dl>

</div>
</div>
<a id="gafcb157835aefece9139942d19a63d7c5" name="gafcb157835aefece9139942d19a63d7c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafcb157835aefece9139942d19a63d7c5">&#9670;&#160;</a></span>isCounterClockWise()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Point2IteratorConcept Iterator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Box.html">bool</a> vcl::isCounterClockWise </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if a set of points that form a polygon are in counter-clockwise order. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Iterator</td><td>the type of iterator that iterates over a range of points that satisfy the Point2Concept. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">begin</td><td>the iterator pointing to the first point. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">end</td><td>the iterator pointing to one past the last point. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the points are in counter-clockwise order, false otherwise. </dd></dl>

</div>
</div>
<a id="ga025a3a732555abc356e597426d99764c" name="ga025a3a732555abc356e597426d99764c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga025a3a732555abc356e597426d99764c">&#9670;&#160;</a></span>project() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Point3IteratorConcept Iterator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Box.html">auto</a> vcl::project </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Project a 3D polygon onto a plane, and return the 2D polygon. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Iterator</td><td>Iterator type, it must iterate over 3D points. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">begin</td><td>Iterator to the first point of the polygon. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">end</td><td>Iterator to the past-the-end point of the polygon. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The projected polygon. </dd></dl>

</div>
</div>
<a id="gab5ab47b215561bd319f7d1e851f906fc" name="gab5ab47b215561bd319f7d1e851f906fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab5ab47b215561bd319f7d1e851f906fc">&#9670;&#160;</a></span>project() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Range R&gt; <br />
requires Point3Concept&lt;std::ranges::range_value_t&lt;R&gt;&gt;</div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Box.html">auto</a> vcl::project </td>
          <td>(</td>
          <td class="paramtype">R &amp;&amp;&#160;</td>
          <td class="paramname"><em>polygon</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Project a 3D polygon defined by the given range onto a plane, and return the 2D polygon. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>A range of 3D points. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">polygon</td><td>The input polygon. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The projected polygon. </dd></dl>

</div>
</div>
<a id="gad713d64f5e56ceb6b7f9bbb4b8eb27b3" name="gad713d64f5e56ceb6b7f9bbb4b8eb27b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad713d64f5e56ceb6b7f9bbb4b8eb27b3">&#9670;&#160;</a></span>sortConvexPolygonVertices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Point2IteratorConcept Iterator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Box.html">void</a> vcl::sortConvexPolygonVertices </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sorts the vertices of a convex polygon in counter-clockwise order. </p>
<p>Given a set of points that form a convex polygon, this function sorts the points in counter-clockwise order. The function assumes that the input points form a convex polygon, and it sorts the points in counter-clockwise order with respect to the point with the lowest y-coordinate. The function uses the atan2 function to compute the angle of each point with respect to the point with the lowest y-coordinate, and it sorts the points based on these angles.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Iterator</td><td>the type of iterator that iterates over a range of points that satisfy the Point2Concept. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">begin</td><td>the iterator pointing to the first point. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">end</td><td>the iterator pointing to one past the last point. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
