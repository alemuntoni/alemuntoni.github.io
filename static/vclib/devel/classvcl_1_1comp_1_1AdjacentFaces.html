<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Visual Computing Library: vcl::comp::AdjacentFaces&lt; STORE_INDICES, Face, N, TTVN, ParentElemType, VERT, OPT &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript" src="../version-selector.js"></script>
       <script type="text/javascript">
           DoxygenAwesomeDarkModeToggle.init()
       </script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Visual Computing Library
   &#160;<span id="projectnumber">devel</span>
   </div>
   <!-- Version selector dropdown -->
   <div id="version-selector" style="margin-top: 10px;">
     <label for="version-dropdown" style="font-size: 12px; color: #666;">Version:</label>
     <select id="version-dropdown" style="margin-left: 5px; padding: 2px 5px; font-size: 12px; border: 1px solid #ccc; border-radius: 3px;">
       <option value="">Loading versions...</option>
     </select>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classvcl_1_1comp_1_1AdjacentFaces.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pri-types">Private Types</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="classvcl_1_1comp_1_1AdjacentFaces-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">vcl::comp::AdjacentFaces&lt; STORE_INDICES, Face, N, TTVN, ParentElemType, VERT, OPT &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__mesh.html">Mesh</a> &raquo; <a class="el" href="group__components.html">Components</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>The <a class="el" href="classvcl_1_1comp_1_1AdjacentFaces.html" title="The AdjacentFaces class is a container of Face indices or pointers. It could be used by any Element t...">AdjacentFaces</a> class is a container of <a class="el" href="classvcl_1_1Face.html" title="The Face class represents an Face element of the vcl::Mesh class.">Face</a> indices or pointers. It could be used by any <a class="el" href="classvcl_1_1Element.html" title="The Element class.">Element</a> to save adjacencies information (also the <a class="el" href="classvcl_1_1Face.html" title="The Face class represents an Face element of the vcl::Mesh class.">Face</a> element itself).  
 <a href="classvcl_1_1comp_1_1AdjacentFaces.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="adjacent__faces_8h_source.html">vclib/mesh/components/adjacent_faces.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for vcl::comp::AdjacentFaces&lt; STORE_INDICES, Face, N, TTVN, ParentElemType, VERT, OPT &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classvcl_1_1comp_1_1AdjacentFaces__inherit__graph.png" border="0" usemap="#avcl_1_1comp_1_1AdjacentFaces_3_01STORE__INDICES_00_01Face_00_01N_00_01TTVN_00_01ParentElemType_00_01VERT_00_01OPT_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="avcl_1_1comp_1_1AdjacentFaces_3_01STORE__INDICES_00_01Face_00_01N_00_01TTVN_00_01ParentElemType_00_01VERT_00_01OPT_01_4_inherit__map" id="avcl_1_1comp_1_1AdjacentFaces_3_01STORE__INDICES_00_01Face_00_01N_00_01TTVN_00_01ParentElemType_00_01VERT_00_01OPT_01_4_inherit__map">
<area shape="rect" title="The AdjacentFaces class is a container of Face indices or pointers. It could be used by any Element t..." alt="" coords="296,279,491,348"/>
<area shape="rect" href="classvcl_1_1polyedgemesh_1_1Edge.html" title="The Edge type used by the PolyEdgeMeshT class." alt="" coords="553,5,706,45"/>
<area shape="poly" title=" " alt="" coords="407,265,427,216,455,160,491,104,537,55,555,43,558,48,540,59,495,107,459,162,432,218,412,267"/>
<area shape="rect" href="classvcl_1_1polyedgemesh_1_1Face.html" title="The Face type used by the PolyEdgeMeshT class." alt="" coords="553,69,706,109"/>
<area shape="poly" title=" " alt="" coords="417,265,466,191,499,152,537,119,557,107,560,112,540,123,503,156,471,194,421,268"/>
<area shape="rect" href="classvcl_1_1polyedgemesh_1_1Vertex.html" title="The Vertex type used by the PolyEdgeMeshT class." alt="" coords="553,133,706,173"/>
<area shape="poly" title=" " alt="" coords="434,267,482,223,537,183,562,171,564,176,540,188,485,227,438,271"/>
<area shape="rect" href="classvcl_1_1polymesh_1_1Face.html" title="The Face type used by the PolyMeshT class." alt="" coords="554,197,705,237"/>
<area shape="poly" title=" " alt="" coords="482,271,538,247,569,235,571,240,540,252,484,275"/>
<area shape="rect" href="classvcl_1_1polymesh_1_1Vertex.html" title="The Vertex type used by the PolyMeshT class." alt="" coords="548,261,711,301"/>
<area shape="poly" title=" " alt="" coords="504,296,548,290,548,295,505,301"/>
<area shape="rect" href="classvcl_1_1triedgemesh_1_1Edge.html" title="The Edge type used by the TriEdgeMeshT class." alt="" coords="544,325,715,365"/>
<area shape="poly" title=" " alt="" coords="505,326,544,331,544,336,504,331"/>
<area shape="rect" href="classvcl_1_1triedgemesh_1_1Face.html" title="The Face type used by the TriEdgeMeshT class." alt="" coords="545,389,713,429"/>
<area shape="poly" title=" " alt="" coords="484,351,540,375,571,387,569,392,538,380,482,356"/>
<area shape="rect" href="classvcl_1_1triedgemesh_1_1Vertex.html" title="The Vertex type used by the TriEdgeMeshT class." alt="" coords="539,453,720,493"/>
<area shape="poly" title=" " alt="" coords="438,356,485,399,540,439,564,451,562,456,537,444,482,403,434,360"/>
<area shape="rect" href="classvcl_1_1trimesh_1_1Face.html" title="The Face type used by the TriMeshT class." alt="" coords="561,517,697,557"/>
<area shape="poly" title=" " alt="" coords="421,359,471,433,503,471,540,503,562,516,560,521,537,507,499,474,466,436,417,362"/>
<area shape="rect" href="classvcl_1_1trimesh_1_1Vertex.html" title="The Vertex type used by the TriMeshT class." alt="" coords="555,581,704,621"/>
<area shape="poly" title=" " alt="" coords="412,360,432,409,459,464,495,519,540,567,558,579,555,583,537,571,491,523,455,467,427,411,407,362"/>
<area shape="rect" title=" " alt="" coords="5,264,248,363"/>
<area shape="poly" title=" " alt="" coords="262,311,296,311,296,316,262,316"/>
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:abb7f5e45d200d254251db1879e7129dd" id="r_abb7f5e45d200d254251db1879e7129dd"><td class="memItemLeft" align="right" valign="top"><a id="abb7f5e45d200d254251db1879e7129dd" name="abb7f5e45d200d254251db1879e7129dd"></a>
<a class="el" href="classvcl_1_1Box.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><b>AdjacentFaceIterator</b> = Base::Iterator</td></tr>
<tr class="separator:abb7f5e45d200d254251db1879e7129dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a628fc5696e394f6f431a704e191c5d3b" id="r_a628fc5696e394f6f431a704e191c5d3b"><td class="memItemLeft" align="right" valign="top"><a id="a628fc5696e394f6f431a704e191c5d3b" name="a628fc5696e394f6f431a704e191c5d3b"></a>
<a class="el" href="classvcl_1_1Box.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><b>AdjacentFaceType</b> = <a class="el" href="classvcl_1_1Face.html">Face</a></td></tr>
<tr class="memdesc:a628fc5696e394f6f431a704e191c5d3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expose the type of the Adjacent <a class="el" href="classvcl_1_1Face.html" title="The Face class represents an Face element of the vcl::Mesh class.">Face</a>. <br /></td></tr>
<tr class="separator:a628fc5696e394f6f431a704e191c5d3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab960872046ffc1e806130c22393501e5" id="r_ab960872046ffc1e806130c22393501e5"><td class="memItemLeft" align="right" valign="top"><a id="ab960872046ffc1e806130c22393501e5" name="ab960872046ffc1e806130c22393501e5"></a>
<a class="el" href="classvcl_1_1Box.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><b>ConstAdjacentFaceIndexIterator</b> = <a class="el" href="classvcl_1_1Box.html#a7a51277b679305dae859f3a0744bb6f9">Base::ConstIndexIterator</a></td></tr>
<tr class="separator:ab960872046ffc1e806130c22393501e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab89d66228406ca24f412f2d6e9c483a8" id="r_ab89d66228406ca24f412f2d6e9c483a8"><td class="memItemLeft" align="right" valign="top"><a id="ab89d66228406ca24f412f2d6e9c483a8" name="ab89d66228406ca24f412f2d6e9c483a8"></a>
<a class="el" href="classvcl_1_1Box.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><b>ConstAdjacentFaceIterator</b> = Base::ConstIterator</td></tr>
<tr class="separator:ab89d66228406ca24f412f2d6e9c483a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a22c9df70e42572303a68674e062618b3" id="r_a22c9df70e42572303a68674e062618b3"><td class="memItemLeft" align="right" valign="top"><a id="a22c9df70e42572303a68674e062618b3" name="a22c9df70e42572303a68674e062618b3"></a>
<a class="el" href="classvcl_1_1Box.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><b>__adjacentFaces</b> () <a class="el" href="classvcl_1_1Box.html">const</a></td></tr>
<tr class="separator:a22c9df70e42572303a68674e062618b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4e84803e00028a144e02b0eeae644c6" id="r_ac4e84803e00028a144e02b0eeae644c6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1comp_1_1AdjacentFaces.html#ac4e84803e00028a144e02b0eeae644c6">AdjacentFaces</a> ()=<a class="el" href="classvcl_1_1Box.html">default</a></td></tr>
<tr class="memdesc:ac4e84803e00028a144e02b0eeae644c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty constructor.  <br /></td></tr>
<tr class="separator:ac4e84803e00028a144e02b0eeae644c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5d67e5d2fd25e9234aff3a74a05e978" id="r_aa5d67e5d2fd25e9234aff3a74a05e978"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Face.html">Face</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1comp_1_1AdjacentFaces.html#aa5d67e5d2fd25e9234aff3a74a05e978">adjFace</a> (<a class="el" href="classvcl_1_1Box.html">uint</a> <a class="el" href="classvcl_1_1Box.html">i</a>)</td></tr>
<tr class="memdesc:aa5d67e5d2fd25e9234aff3a74a05e978"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the pointer to the i-th adjacent face of this element.  <br /></td></tr>
<tr class="separator:aa5d67e5d2fd25e9234aff3a74a05e978"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79542e1e4c78267dfdd4a2ecc1fcb7c6" id="r_a79542e1e4c78267dfdd4a2ecc1fcb7c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Box.html">const</a> <a class="el" href="classvcl_1_1Face.html">Face</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1comp_1_1AdjacentFaces.html#a79542e1e4c78267dfdd4a2ecc1fcb7c6">adjFace</a> (<a class="el" href="classvcl_1_1Box.html">uint</a> <a class="el" href="classvcl_1_1Box.html">i</a>) <a class="el" href="classvcl_1_1Box.html">const</a></td></tr>
<tr class="memdesc:a79542e1e4c78267dfdd4a2ecc1fcb7c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const pointer to the i-th adjacent face of this element.  <br /></td></tr>
<tr class="separator:a79542e1e4c78267dfdd4a2ecc1fcb7c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a646be9c8cdc006eeda0cab27a73ccc2d" id="r_a646be9c8cdc006eeda0cab27a73ccc2d"><td class="memItemLeft" align="right" valign="top">AdjacentFaceIterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1comp_1_1AdjacentFaces.html#a646be9c8cdc006eeda0cab27a73ccc2d">adjFaceBegin</a> ()</td></tr>
<tr class="memdesc:a646be9c8cdc006eeda0cab27a73ccc2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first adjacent face in the container of this component.  <br /></td></tr>
<tr class="separator:a646be9c8cdc006eeda0cab27a73ccc2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e9a00f7f718995d12614057be2adc70" id="r_a1e9a00f7f718995d12614057be2adc70"><td class="memItemLeft" align="right" valign="top">ConstAdjacentFaceIterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1comp_1_1AdjacentFaces.html#a1e9a00f7f718995d12614057be2adc70">adjFaceBegin</a> () <a class="el" href="classvcl_1_1Box.html">const</a></td></tr>
<tr class="memdesc:a1e9a00f7f718995d12614057be2adc70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const iterator to the first adjacent face in the container of this component.  <br /></td></tr>
<tr class="separator:a1e9a00f7f718995d12614057be2adc70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad85bf5fa32951ed1682a958eeba4ec52" id="r_ad85bf5fa32951ed1682a958eeba4ec52"><td class="memItemLeft" align="right" valign="top">AdjacentFaceIterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1comp_1_1AdjacentFaces.html#ad85bf5fa32951ed1682a958eeba4ec52">adjFaceEnd</a> ()</td></tr>
<tr class="memdesc:ad85bf5fa32951ed1682a958eeba4ec52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the end of the container of this component.  <br /></td></tr>
<tr class="separator:ad85bf5fa32951ed1682a958eeba4ec52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28bba75f97bc322747bebe734dd67264" id="r_a28bba75f97bc322747bebe734dd67264"><td class="memItemLeft" align="right" valign="top">ConstAdjacentFaceIterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1comp_1_1AdjacentFaces.html#a28bba75f97bc322747bebe734dd67264">adjFaceEnd</a> () <a class="el" href="classvcl_1_1Box.html">const</a></td></tr>
<tr class="memdesc:a28bba75f97bc322747bebe734dd67264"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const iterator to the end of the container of this component.  <br /></td></tr>
<tr class="separator:a28bba75f97bc322747bebe734dd67264"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65e3408fd7259cd76cd8c3d7bcd4e98c" id="r_a65e3408fd7259cd76cd8c3d7bcd4e98c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Box.html">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1comp_1_1AdjacentFaces.html#a65e3408fd7259cd76cd8c3d7bcd4e98c">adjFaceIndex</a> (<a class="el" href="classvcl_1_1Box.html">uint</a> <a class="el" href="classvcl_1_1Box.html">i</a>) <a class="el" href="classvcl_1_1Box.html">const</a></td></tr>
<tr class="memdesc:a65e3408fd7259cd76cd8c3d7bcd4e98c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index in the face container of the i-th adjacent face of the element.  <br /></td></tr>
<tr class="separator:a65e3408fd7259cd76cd8c3d7bcd4e98c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fdef39c23b38b485d7d1b2e4e85e0f1" id="r_a9fdef39c23b38b485d7d1b2e4e85e0f1"><td class="memItemLeft" align="right" valign="top">ConstAdjacentFaceIndexIterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1comp_1_1AdjacentFaces.html#a9fdef39c23b38b485d7d1b2e4e85e0f1">adjFaceIndexBegin</a> () <a class="el" href="classvcl_1_1Box.html">const</a></td></tr>
<tr class="memdesc:a9fdef39c23b38b485d7d1b2e4e85e0f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first adjacent face index in the container of this component.  <br /></td></tr>
<tr class="separator:a9fdef39c23b38b485d7d1b2e4e85e0f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1043d4550571a2f3b247f29b133f5405" id="r_a1043d4550571a2f3b247f29b133f5405"><td class="memItemLeft" align="right" valign="top">ConstAdjacentFaceIndexIterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1comp_1_1AdjacentFaces.html#a1043d4550571a2f3b247f29b133f5405">adjFaceIndexEnd</a> () <a class="el" href="classvcl_1_1Box.html">const</a></td></tr>
<tr class="memdesc:a1043d4550571a2f3b247f29b133f5405"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the end of the container of this component.  <br /></td></tr>
<tr class="separator:a1043d4550571a2f3b247f29b133f5405"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac56ed64371e7816f1ebff996037811ec" id="r_ac56ed64371e7816f1ebff996037811ec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Box.html">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1comp_1_1AdjacentFaces.html#ac56ed64371e7816f1ebff996037811ec">adjFaceIndexMod</a> (<a class="el" href="classvcl_1_1Box.html">int</a> <a class="el" href="classvcl_1_1Box.html">i</a>) <a class="el" href="classvcl_1_1Box.html">const</a></td></tr>
<tr class="memdesc:ac56ed64371e7816f1ebff996037811ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index in the face container of the i-th adjacent face of the element, but using as index the module between i and the number of adjacent faces. You can use this function if you need to get the "index
of the adjacent face next to position k", without check if it is less than the number of adjacent faces. Works also for negative numbers:  <br /></td></tr>
<tr class="separator:ac56ed64371e7816f1ebff996037811ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0636c5fa3212abbff5ec2a66c4c51d5e" id="r_a0636c5fa3212abbff5ec2a66c4c51d5e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1View.html">View</a>&lt; ConstAdjacentFaceIndexIterator &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1comp_1_1AdjacentFaces.html#a0636c5fa3212abbff5ec2a66c4c51d5e">adjFaceIndices</a> () <a class="el" href="classvcl_1_1Box.html">const</a></td></tr>
<tr class="memdesc:a0636c5fa3212abbff5ec2a66c4c51d5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a lightweight view object that stores the begin and end iterators of the container of adjacent face indices of the element. The view object exposes the iterators trough the <code>begin()</code> and <code>end()</code> member functions, and therefore the returned object can be used in range-based for loops:  <br /></td></tr>
<tr class="separator:a0636c5fa3212abbff5ec2a66c4c51d5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3449b302f37fa8261c21f70ede5c9f12" id="r_a3449b302f37fa8261c21f70ede5c9f12"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Face.html">Face</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1comp_1_1AdjacentFaces.html#a3449b302f37fa8261c21f70ede5c9f12">adjFaceMod</a> (<a class="el" href="classvcl_1_1Box.html">int</a> <a class="el" href="classvcl_1_1Box.html">i</a>)</td></tr>
<tr class="memdesc:a3449b302f37fa8261c21f70ede5c9f12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the pointer to the i-th adjacent face of this element but using as index the module between i and the number of adjacent faces.  <br /></td></tr>
<tr class="separator:a3449b302f37fa8261c21f70ede5c9f12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91012c0991219df9597e9d0ff17721fa" id="r_a91012c0991219df9597e9d0ff17721fa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Box.html">const</a> <a class="el" href="classvcl_1_1Face.html">Face</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1comp_1_1AdjacentFaces.html#a91012c0991219df9597e9d0ff17721fa">adjFaceMod</a> (<a class="el" href="classvcl_1_1Box.html">int</a> <a class="el" href="classvcl_1_1Box.html">i</a>) <a class="el" href="classvcl_1_1Box.html">const</a></td></tr>
<tr class="memdesc:a91012c0991219df9597e9d0ff17721fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same of adjFaceMod, but returns a const Pointer to the adjacent face.  <br /></td></tr>
<tr class="separator:a91012c0991219df9597e9d0ff17721fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a796174e4e8d398f878c84cc92caa605a" id="r_a796174e4e8d398f878c84cc92caa605a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1View.html">View</a>&lt; AdjacentFaceIterator &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1comp_1_1AdjacentFaces.html#a796174e4e8d398f878c84cc92caa605a">adjFaces</a> ()</td></tr>
<tr class="memdesc:a796174e4e8d398f878c84cc92caa605a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a lightweight view object that stores the begin and end iterators of the container of adjacent faces of the element. The view object exposes the iterators trough the <code>begin()</code> and <code>end()</code> member functions, and therefore the returned object can be used in range-based for loops:  <br /></td></tr>
<tr class="separator:a796174e4e8d398f878c84cc92caa605a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a452b4a9d1c1be2e0fdb3de69a6c2a588" id="r_a452b4a9d1c1be2e0fdb3de69a6c2a588"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1View.html">View</a>&lt; ConstAdjacentFaceIterator &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1comp_1_1AdjacentFaces.html#a452b4a9d1c1be2e0fdb3de69a6c2a588">adjFaces</a> () <a class="el" href="classvcl_1_1Box.html">const</a></td></tr>
<tr class="memdesc:a452b4a9d1c1be2e0fdb3de69a6c2a588"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a lightweight const view object that stores the begin and end iterators of the container of adjacent faces of the element. The view object exposes the iterators trough the <code>begin()</code> and <code>end()</code> member functions, and therefore the returned object can be used in range-based for loops:  <br /></td></tr>
<tr class="separator:a452b4a9d1c1be2e0fdb3de69a6c2a588"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a573670fcad6b4fb04a2bcf05d20fa402" id="r_a573670fcad6b4fb04a2bcf05d20fa402"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Box.html">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1comp_1_1AdjacentFaces.html#a573670fcad6b4fb04a2bcf05d20fa402">adjFacesNumber</a> () <a class="el" href="classvcl_1_1Box.html">const</a></td></tr>
<tr class="memdesc:a573670fcad6b4fb04a2bcf05d20fa402"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of adjacent faces of this element.  <br /></td></tr>
<tr class="separator:a573670fcad6b4fb04a2bcf05d20fa402"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8817b4212bfeb9a76bb07663e3ab0756" id="r_a8817b4212bfeb9a76bb07663e3ab0756"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Box.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1comp_1_1AdjacentFaces.html#a8817b4212bfeb9a76bb07663e3ab0756">clearAdjFaces</a> ()</td></tr>
<tr class="memdesc:a8817b4212bfeb9a76bb07663e3ab0756"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the container of adjacent faces, making it empty.  <br /></td></tr>
<tr class="separator:a8817b4212bfeb9a76bb07663e3ab0756"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81949d55c0f4d7793f57a523fbffc348" id="r_a81949d55c0f4d7793f57a523fbffc348"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Box.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1comp_1_1AdjacentFaces.html#a81949d55c0f4d7793f57a523fbffc348">containsAdjFace</a> (<a class="el" href="classvcl_1_1Box.html">const</a> <a class="el" href="classvcl_1_1Face.html">Face</a> *f) <a class="el" href="classvcl_1_1Box.html">const</a></td></tr>
<tr class="memdesc:a81949d55c0f4d7793f57a523fbffc348"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if the container of adjacent faces contains the given face, <code>false</code> otherwise.  <br /></td></tr>
<tr class="separator:a81949d55c0f4d7793f57a523fbffc348"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac71ff6576d6da05371f35b0aec87a228" id="r_ac71ff6576d6da05371f35b0aec87a228"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Box.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1comp_1_1AdjacentFaces.html#ac71ff6576d6da05371f35b0aec87a228">containsAdjFace</a> (<a class="el" href="classvcl_1_1Box.html">uint</a> <a class="el" href="classvcl_1_1Box.html">fi</a>) <a class="el" href="classvcl_1_1Box.html">const</a></td></tr>
<tr class="memdesc:ac71ff6576d6da05371f35b0aec87a228"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if the container of adjacent faces contains the face with the given index, <code>false</code> otherwise.  <br /></td></tr>
<tr class="separator:ac71ff6576d6da05371f35b0aec87a228"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8d6e5b90fc327b2f015d02ed2f0f251" id="r_ae8d6e5b90fc327b2f015d02ed2f0f251"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Box.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1comp_1_1AdjacentFaces.html#ae8d6e5b90fc327b2f015d02ed2f0f251">eraseAdjFace</a> (<a class="el" href="classvcl_1_1Box.html">uint</a> <a class="el" href="classvcl_1_1Box.html">i</a>)</td></tr>
<tr class="memdesc:ae8d6e5b90fc327b2f015d02ed2f0f251"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the adjacent face at the given position from the container.  <br /></td></tr>
<tr class="separator:ae8d6e5b90fc327b2f015d02ed2f0f251"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bdc4f7a60b7519df571dc33771c5446" id="r_a6bdc4f7a60b7519df571dc33771c5446"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Box.html">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1comp_1_1AdjacentFaces.html#a6bdc4f7a60b7519df571dc33771c5446">indexOfAdjFace</a> (<a class="el" href="classvcl_1_1Box.html">const</a> <a class="el" href="classvcl_1_1Face.html">Face</a> *f) <a class="el" href="classvcl_1_1Box.html">const</a></td></tr>
<tr class="memdesc:a6bdc4f7a60b7519df571dc33771c5446"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of the given adjacent face in the container of this element. If the given adjacent face is not in the container, returns UINT_NULL.  <br /></td></tr>
<tr class="separator:a6bdc4f7a60b7519df571dc33771c5446"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75d34bed34447f350d15c248abd879f2" id="r_a75d34bed34447f350d15c248abd879f2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Box.html">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1comp_1_1AdjacentFaces.html#a75d34bed34447f350d15c248abd879f2">indexOfAdjFace</a> (<a class="el" href="classvcl_1_1Box.html">uint</a> <a class="el" href="classvcl_1_1Box.html">fi</a>) <a class="el" href="classvcl_1_1Box.html">const</a></td></tr>
<tr class="memdesc:a75d34bed34447f350d15c248abd879f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of the adjacent face with the given index in the container of this element. If the adjacent face with the given index is not in the container, returns UINT_NULL.  <br /></td></tr>
<tr class="separator:a75d34bed34447f350d15c248abd879f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accba199f83752de2ec5fcb66d731a86f" id="r_accba199f83752de2ec5fcb66d731a86f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Box.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1comp_1_1AdjacentFaces.html#accba199f83752de2ec5fcb66d731a86f">insertAdjFace</a> (<a class="el" href="classvcl_1_1Box.html">uint</a> <a class="el" href="classvcl_1_1Box.html">i</a>, <a class="el" href="classvcl_1_1Face.html">Face</a> *f)</td></tr>
<tr class="memdesc:accba199f83752de2ec5fcb66d731a86f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts the given adjacent face in the container at the given position.  <br /></td></tr>
<tr class="separator:accba199f83752de2ec5fcb66d731a86f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8bd97e62f603f129deb0d8d990cb43c" id="r_ad8bd97e62f603f129deb0d8d990cb43c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Box.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1comp_1_1AdjacentFaces.html#ad8bd97e62f603f129deb0d8d990cb43c">insertAdjFace</a> (<a class="el" href="classvcl_1_1Box.html">uint</a> <a class="el" href="classvcl_1_1Box.html">i</a>, <a class="el" href="classvcl_1_1Box.html">uint</a> <a class="el" href="classvcl_1_1Box.html">fi</a>)</td></tr>
<tr class="memdesc:ad8bd97e62f603f129deb0d8d990cb43c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts the adjacent face with the given index in the container at the given position.  <br /></td></tr>
<tr class="separator:ad8bd97e62f603f129deb0d8d990cb43c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60f33225270061c89afb8b9e103892e1" id="r_a60f33225270061c89afb8b9e103892e1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Box.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1comp_1_1AdjacentFaces.html#a60f33225270061c89afb8b9e103892e1">pushAdjFace</a> (<a class="el" href="classvcl_1_1Face.html">Face</a> *f)</td></tr>
<tr class="memdesc:a60f33225270061c89afb8b9e103892e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pushes in the back of the container the given adjacent face.  <br /></td></tr>
<tr class="separator:a60f33225270061c89afb8b9e103892e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b3c5591a323f38281c8409fc9053ad4" id="r_a7b3c5591a323f38281c8409fc9053ad4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Box.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1comp_1_1AdjacentFaces.html#a7b3c5591a323f38281c8409fc9053ad4">pushAdjFace</a> (<a class="el" href="classvcl_1_1Box.html">uint</a> <a class="el" href="classvcl_1_1Box.html">fi</a>)</td></tr>
<tr class="memdesc:a7b3c5591a323f38281c8409fc9053ad4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pushes in the back of the container the given adjacent face.  <br /></td></tr>
<tr class="separator:a7b3c5591a323f38281c8409fc9053ad4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a841d8af03d2d929e4671f5397ffc538f" id="r_a841d8af03d2d929e4671f5397ffc538f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Box.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1comp_1_1AdjacentFaces.html#a841d8af03d2d929e4671f5397ffc538f">resizeAdjFaces</a> (<a class="el" href="classvcl_1_1Box.html">uint</a> <a class="el" href="classvcl_1_1Box.html">n</a>)</td></tr>
<tr class="memdesc:a841d8af03d2d929e4671f5397ffc538f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resize the container of the adjacent faces to the given size.  <br /></td></tr>
<tr class="separator:a841d8af03d2d929e4671f5397ffc538f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ae26b6cfd36db23c549af917ba0f10b" id="r_a5ae26b6cfd36db23c549af917ba0f10b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Box.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1comp_1_1AdjacentFaces.html#a5ae26b6cfd36db23c549af917ba0f10b">setAdjFace</a> (ConstAdjacentFaceIndexIterator <a class="el" href="classvcl_1_1Box.html">it</a>, <a class="el" href="classvcl_1_1Face.html">Face</a> *f)</td></tr>
<tr class="memdesc:a5ae26b6cfd36db23c549af917ba0f10b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the adjacent face pointed by the iterator.  <br /></td></tr>
<tr class="separator:a5ae26b6cfd36db23c549af917ba0f10b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc3a242a866f39d07f04e652952adb27" id="r_acc3a242a866f39d07f04e652952adb27"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Box.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1comp_1_1AdjacentFaces.html#acc3a242a866f39d07f04e652952adb27">setAdjFace</a> (ConstAdjacentFaceIndexIterator <a class="el" href="classvcl_1_1Box.html">it</a>, <a class="el" href="classvcl_1_1Box.html">uint</a> <a class="el" href="classvcl_1_1Box.html">fi</a>)</td></tr>
<tr class="memdesc:acc3a242a866f39d07f04e652952adb27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the adjacent face pointed by the iterator.  <br /></td></tr>
<tr class="separator:acc3a242a866f39d07f04e652952adb27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6336a789c177d3e43fac8f0fa9b00183" id="r_a6336a789c177d3e43fac8f0fa9b00183"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Box.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1comp_1_1AdjacentFaces.html#a6336a789c177d3e43fac8f0fa9b00183">setAdjFace</a> (ConstAdjacentFaceIterator <a class="el" href="classvcl_1_1Box.html">it</a>, <a class="el" href="classvcl_1_1Face.html">Face</a> *f)</td></tr>
<tr class="memdesc:a6336a789c177d3e43fac8f0fa9b00183"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the adjacent face pointed by the iterator.  <br /></td></tr>
<tr class="separator:a6336a789c177d3e43fac8f0fa9b00183"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ee6c286930b371694404a21e3b9d32d" id="r_a4ee6c286930b371694404a21e3b9d32d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Box.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1comp_1_1AdjacentFaces.html#a4ee6c286930b371694404a21e3b9d32d">setAdjFace</a> (ConstAdjacentFaceIterator <a class="el" href="classvcl_1_1Box.html">it</a>, <a class="el" href="classvcl_1_1Box.html">uint</a> <a class="el" href="classvcl_1_1Box.html">fi</a>)</td></tr>
<tr class="memdesc:a4ee6c286930b371694404a21e3b9d32d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the adjacent face pointed by the iterator.  <br /></td></tr>
<tr class="separator:a4ee6c286930b371694404a21e3b9d32d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab80ebcfe018c351efbe698eb5ae90625" id="r_ab80ebcfe018c351efbe698eb5ae90625"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Box.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1comp_1_1AdjacentFaces.html#ab80ebcfe018c351efbe698eb5ae90625">setAdjFace</a> (<a class="el" href="classvcl_1_1Box.html">uint</a> <a class="el" href="classvcl_1_1Box.html">i</a>, <a class="el" href="classvcl_1_1Face.html">Face</a> *f)</td></tr>
<tr class="memdesc:ab80ebcfe018c351efbe698eb5ae90625"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the i-th adjacent face of this element.  <br /></td></tr>
<tr class="separator:ab80ebcfe018c351efbe698eb5ae90625"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b8aeb381747461148daf3914fac1b2d" id="r_a2b8aeb381747461148daf3914fac1b2d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Box.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1comp_1_1AdjacentFaces.html#a2b8aeb381747461148daf3914fac1b2d">setAdjFace</a> (<a class="el" href="classvcl_1_1Box.html">uint</a> <a class="el" href="classvcl_1_1Box.html">i</a>, <a class="el" href="classvcl_1_1Box.html">uint</a> <a class="el" href="classvcl_1_1Box.html">fi</a>)</td></tr>
<tr class="memdesc:a2b8aeb381747461148daf3914fac1b2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the i-th adjacent face of the element.  <br /></td></tr>
<tr class="separator:a2b8aeb381747461148daf3914fac1b2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5357e3737058323eaed2802753a7b6f4" id="r_a5357e3737058323eaed2802753a7b6f4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Box.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1comp_1_1AdjacentFaces.html#a5357e3737058323eaed2802753a7b6f4">setAdjFaceMod</a> (<a class="el" href="classvcl_1_1Box.html">int</a> <a class="el" href="classvcl_1_1Box.html">i</a>, <a class="el" href="classvcl_1_1Face.html">Face</a> *f)</td></tr>
<tr class="memdesc:a5357e3737058323eaed2802753a7b6f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the i-th adjacent face of the element, but using as index the module between i and the number of adjacent faces. You can use this function if you need to set the "next adjacent face after position k", without check if it is less than the number of adjacent faces. Works also for negative numbers:  <br /></td></tr>
<tr class="separator:a5357e3737058323eaed2802753a7b6f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e3fdc1ea6f0234ced228e85600f1d82" id="r_a9e3fdc1ea6f0234ced228e85600f1d82"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Box.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1comp_1_1AdjacentFaces.html#a9e3fdc1ea6f0234ced228e85600f1d82">setAdjFaceMod</a> (<a class="el" href="classvcl_1_1Box.html">int</a> <a class="el" href="classvcl_1_1Box.html">i</a>, <a class="el" href="classvcl_1_1Box.html">uint</a> <a class="el" href="classvcl_1_1Box.html">fi</a>)</td></tr>
<tr class="memdesc:a9e3fdc1ea6f0234ced228e85600f1d82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the i-th adjacent face of the element, but using as index the module between i and the number of adjacent faces. You can use this function if you need to set the "next adjacent face after position k", without check if it is less than the number of adjacent faces. Works also for negative numbers:  <br /></td></tr>
<tr class="separator:a9e3fdc1ea6f0234ced228e85600f1d82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba809bafa2607a499a2805f3c1fa8c81" id="r_aba809bafa2607a499a2805f3c1fa8c81"><td class="memTemplParams" colspan="2">template&lt;Range Rng&gt; <br />
requires InputRange&lt;<a class="el" href="classvcl_1_1Box.html">Rng</a>, <a class="el" href="classvcl_1_1Face.html">Face</a>*&gt;</td></tr>
<tr class="memitem:aba809bafa2607a499a2805f3c1fa8c81"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Box.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvcl_1_1comp_1_1AdjacentFaces.html#aba809bafa2607a499a2805f3c1fa8c81">setAdjFaces</a> (<a class="el" href="classvcl_1_1Box.html">Rng</a> &amp;&amp;<a class="el" href="classvcl_1_1Box.html">r</a>)</td></tr>
<tr class="memdesc:aba809bafa2607a499a2805f3c1fa8c81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets all the adjacent faces of this element.  <br /></td></tr>
<tr class="separator:aba809bafa2607a499a2805f3c1fa8c81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a152a8a1f7faee4d58b1db87735bb43f4" id="r_a152a8a1f7faee4d58b1db87735bb43f4"><td class="memTemplParams" colspan="2">template&lt;Range Rng&gt; <br />
requires InputRange&lt;<a class="el" href="classvcl_1_1Box.html">Rng</a>, <a class="el" href="classvcl_1_1Box.html">uint</a>&gt;</td></tr>
<tr class="memitem:a152a8a1f7faee4d58b1db87735bb43f4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Box.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvcl_1_1comp_1_1AdjacentFaces.html#a152a8a1f7faee4d58b1db87735bb43f4">setAdjFaces</a> (<a class="el" href="classvcl_1_1Box.html">Rng</a> &amp;&amp;<a class="el" href="classvcl_1_1Box.html">r</a>)</td></tr>
<tr class="memdesc:a152a8a1f7faee4d58b1db87735bb43f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets all the adjacent faces of this element.  <br /></td></tr>
<tr class="separator:a152a8a1f7faee4d58b1db87735bb43f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a6b8a02df9bc585eeb245f12f12bad1bf" id="r_a6b8a02df9bc585eeb245f12f12bad1bf"><td class="memItemLeft" align="right" valign="top"><a id="a6b8a02df9bc585eeb245f12f12bad1bf" name="a6b8a02df9bc585eeb245f12f12bad1bf"></a>
<a class="el" href="classvcl_1_1Box.html">static</a> <a class="el" href="classvcl_1_1Box.html">const</a> <a class="el" href="classvcl_1_1Box.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><b>ADJ_FACE_NUMBER</b> = Base::SIZE</td></tr>
<tr class="memdesc:a6b8a02df9bc585eeb245f12f12bad1bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static size of the container. If the container is dynamic, this value will be negative and you should use the <a class="el" href="classvcl_1_1comp_1_1AdjacentFaces.html#a573670fcad6b4fb04a2bcf05d20fa402" title="Returns the number of adjacent faces of this element.">adjFacesNumber()</a> member function. <br /></td></tr>
<tr class="separator:a6b8a02df9bc585eeb245f12f12bad1bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:abd0021f3515878c5f4bbb301023ab08c" id="r_abd0021f3515878c5f4bbb301023ab08c"><td class="memItemLeft" align="right" valign="top"><a id="abd0021f3515878c5f4bbb301023ab08c" name="abd0021f3515878c5f4bbb301023ab08c"></a>
<a class="el" href="classvcl_1_1Box.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><b>deserialize</b> (std::istream &amp;is)</td></tr>
<tr class="separator:abd0021f3515878c5f4bbb301023ab08c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bc9703880b13c4457e3e46f261b61f1" id="r_a6bc9703880b13c4457e3e46f261b61f1"><td class="memTemplParams" colspan="2"><a id="a6bc9703880b13c4457e3e46f261b61f1" name="a6bc9703880b13c4457e3e46f261b61f1"></a>
template&lt;<a class="el" href="classvcl_1_1Box.html">typename</a> <a class="el" href="classvcl_1_1Element.html">Element</a> &gt; </td></tr>
<tr class="memitem:a6bc9703880b13c4457e3e46f261b61f1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Box.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>importFrom</b> (<a class="el" href="classvcl_1_1Box.html">const</a> <a class="el" href="classvcl_1_1Element.html">Element</a> &amp;e, <a class="el" href="classvcl_1_1Box.html">bool</a> <a class="el" href="classvcl_1_1Box.html">importRefs</a>=<a class="el" href="classvcl_1_1Box.html">true</a>)</td></tr>
<tr class="separator:a6bc9703880b13c4457e3e46f261b61f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c59d11622ca7d8be82ff19f23ce3722" id="r_a0c59d11622ca7d8be82ff19f23ce3722"><td class="memItemLeft" align="right" valign="top"><a id="a0c59d11622ca7d8be82ff19f23ce3722" name="a0c59d11622ca7d8be82ff19f23ce3722"></a>
<a class="el" href="classvcl_1_1Box.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><b>serialize</b> (std::ostream &amp;<a class="el" href="classvcl_1_1Box.html">os</a>) <a class="el" href="classvcl_1_1Box.html">const</a></td></tr>
<tr class="separator:a0c59d11622ca7d8be82ff19f23ce3722"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-types" name="pri-types"></a>
Private Types</h2></td></tr>
<tr class="memitem:a9ff99aeceba086adcf92ddbf52535514" id="r_a9ff99aeceba086adcf92ddbf52535514"><td class="memItemLeft" align="right" valign="top"><a id="a9ff99aeceba086adcf92ddbf52535514" name="a9ff99aeceba086adcf92ddbf52535514"></a>
<a class="el" href="classvcl_1_1Box.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Base</b> = ReferenceContainerComponent&lt; <a class="el" href="classvcl_1_1Box.html">STORE_INDICES</a>, <a class="el" href="classvcl_1_1comp_1_1AdjacentFaces.html">AdjacentFaces</a>&lt; <a class="el" href="classvcl_1_1Box.html">STORE_INDICES</a>, <a class="el" href="classvcl_1_1Face.html">Face</a>, N, <a class="el" href="classvcl_1_1Box.html">TTVN</a>, <a class="el" href="classvcl_1_1Box.html">ParentElemType</a>, <a class="el" href="classvcl_1_1Box.html">VERT</a>, <a class="el" href="classvcl_1_1Box.html">OPT</a> &gt;, CompId::ADJACENT_FACES, <a class="el" href="classvcl_1_1Face.html">Face</a>, N, <a class="el" href="classvcl_1_1Box.html">ParentElemType</a>, <a class="el" href="classvcl_1_1Box.html">VERT</a>, <a class="el" href="classvcl_1_1Box.html">OPT</a>, <a class="el" href="classvcl_1_1Box.html">TTVN</a> &gt;</td></tr>
<tr class="separator:a9ff99aeceba086adcf92ddbf52535514"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-methods" name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:ada7691c92e13c1fadf6a98916bb822f2" id="r_ada7691c92e13c1fadf6a98916bb822f2"><td class="memTemplParams" colspan="2"><a id="ada7691c92e13c1fadf6a98916bb822f2" name="ada7691c92e13c1fadf6a98916bb822f2"></a>
template&lt;<a class="el" href="classvcl_1_1Box.html">typename</a> <a class="el" href="classvcl_1_1Element.html">Element</a> &gt; </td></tr>
<tr class="memitem:ada7691c92e13c1fadf6a98916bb822f2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Box.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>importIndicesFrom</b> (<a class="el" href="classvcl_1_1Box.html">const</a> <a class="el" href="classvcl_1_1Element.html">Element</a> &amp;e)</td></tr>
<tr class="separator:ada7691c92e13c1fadf6a98916bb822f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;<a class="el" href="classvcl_1_1Box.html">bool</a> STORE_INDICES, <a class="el" href="classvcl_1_1Box.html">typename</a> <a class="el" href="classvcl_1_1Face.html">Face</a>, <a class="el" href="classvcl_1_1Box.html">int</a> N, <a class="el" href="classvcl_1_1Box.html">bool</a> TTVN, <a class="el" href="classvcl_1_1Box.html">typename</a> <a class="el" href="classvcl_1_1Box.html">ParentElemType</a> = void, <a class="el" href="classvcl_1_1Box.html">bool</a> VERT = false, <a class="el" href="classvcl_1_1Box.html">bool</a> OPT = false&gt;<br />
class vcl::comp::AdjacentFaces&lt; STORE_INDICES, Face, N, TTVN, ParentElemType, VERT, OPT &gt;</div><p>The <a class="el" href="classvcl_1_1comp_1_1AdjacentFaces.html" title="The AdjacentFaces class is a container of Face indices or pointers. It could be used by any Element t...">AdjacentFaces</a> class is a container of <a class="el" href="classvcl_1_1Face.html" title="The Face class represents an Face element of the vcl::Mesh class.">Face</a> indices or pointers. It could be used by any <a class="el" href="classvcl_1_1Element.html" title="The Element class.">Element</a> to save adjacencies information (also the <a class="el" href="classvcl_1_1Face.html" title="The Face class represents an Face element of the vcl::Mesh class.">Face</a> element itself). </p>
<p>It is a random access container having static or dynamic size, depending on the value of N (a negative number means dynamic).</p>
<p>The member functions of this class will be available in the instance of any <a class="el" href="classvcl_1_1Element.html" title="The Element class.">Element</a> that will contain this component.</p>
<p>For example, if you have a <a class="el" href="classvcl_1_1Vertex.html" title="The Vertex class represents an Vertex element of the vcl::Mesh class.">Vertex</a> <a class="el" href="classvcl_1_1Element.html" title="The Element class.">Element</a> <code>v</code> that has the <a class="el" href="classvcl_1_1comp_1_1AdjacentFaces.html" title="The AdjacentFaces class is a container of Face indices or pointers. It could be used by any Element t...">AdjacentFaces</a> component, you'll be able to access to this component member functions from <code>v</code>:</p>
<div class="fragment"><div class="line">v.adjFacesNumber();</div>
<div class="line"><span class="keyword">auto</span>* f = v.adjFace(0);</div>
<div class="line"><a class="code hl_class" href="classvcl_1_1Box.html">uint</a> <a class="code hl_class" href="classvcl_1_1Box.html">vi</a> = v.adjFaceIndex(0);</div>
<div class="ttc" id="aclassvcl_1_1Box_html"><div class="ttname"><a href="classvcl_1_1Box.html">vcl::Box</a></div><div class="ttdoc">A class representing a box in N-dimensional space.</div><div class="ttdef"><b>Definition</b> box.h:46</div></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>This component could be <em>Tied To <a class="el" href="classvcl_1_1Vertex.html" title="The Vertex class represents an Vertex element of the vcl::Mesh class.">Vertex</a> Number</em>: it means that the size of the container, if dynamic, will change automatically along the <a class="el" href="classvcl_1_1Vertex.html" title="The Vertex class represents an Vertex element of the vcl::Mesh class.">Vertex</a> Number of the Component. Check the <code>TTVN</code> template value on the specialization of your component to check if it is tied to the <a class="el" href="classvcl_1_1Vertex.html" title="The Vertex class represents an Vertex element of the vcl::Mesh class.">Vertex</a> Number. For further details check the documentation of the ContainerComponent class.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">STORE_INDICES</td><td>If true, the component will store indices, otherwise pointers to <a class="el" href="classvcl_1_1Face.html" title="The Face class represents an Face element of the vcl::Mesh class.">Face</a>. </td></tr>
    <tr><td class="paramname"><a class="el" href="classvcl_1_1Face.html" title="The Face class represents an Face element of the vcl::Mesh class.">Face</a></td><td>The type of the adjacent <a class="el" href="classvcl_1_1Face.html" title="The Face class represents an Face element of the vcl::Mesh class.">Face</a> element. </td></tr>
    <tr><td class="paramname">N</td><td>The size of the container, that will represent the number of storable adjacent faces. If negative, the container is dynamic. </td></tr>
    <tr><td class="paramname">TTVN</td><td>If true, the size of the container will be tied to the <a class="el" href="classvcl_1_1Vertex.html" title="The Vertex class represents an Vertex element of the vcl::Mesh class.">Vertex</a> Number of the component (this is used mostly on <a class="el" href="classvcl_1_1Face.html" title="The Face class represents an Face element of the vcl::Mesh class.">Face</a> elements). </td></tr>
    <tr><td class="paramname">ParentElemType</td><td>This type is used to get access to the <a class="el" href="classvcl_1_1Element.html" title="The Element class.">Element</a> that has the component (and, in case, to the <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a> that has the <a class="el" href="classvcl_1_1Element.html" title="The Element class.">Element</a>). If the component doesn't need to access the <a class="el" href="classvcl_1_1Element.html" title="The Element class.">Element</a>, this type can be void. Note: if the component is vertical (or optional), this type cannot be void. </td></tr>
    <tr><td class="paramname">VERT</td><td>If true, the component will be stored vertically. This argument is considered only if the ElementType is not void. </td></tr>
    <tr><td class="paramname">OPT</td><td>If true, the component will be optional. This argument is considered only if the component is stored vertically. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ac4e84803e00028a144e02b0eeae644c6" name="ac4e84803e00028a144e02b0eeae644c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4e84803e00028a144e02b0eeae644c6">&#9670;&#160;</a></span>AdjacentFaces()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classvcl_1_1Box.html">bool</a> STORE_INDICES, <a class="el" href="classvcl_1_1Box.html">typename</a> <a class="el" href="classvcl_1_1Face.html">Face</a> , <a class="el" href="classvcl_1_1Box.html">int</a> N, <a class="el" href="classvcl_1_1Box.html">bool</a> TTVN, <a class="el" href="classvcl_1_1Box.html">typename</a> <a class="el" href="classvcl_1_1Box.html">ParentElemType</a>  = void, <a class="el" href="classvcl_1_1Box.html">bool</a> VERT = false, <a class="el" href="classvcl_1_1Box.html">bool</a> OPT = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1comp_1_1AdjacentFaces.html">vcl::comp::AdjacentFaces</a>&lt; <a class="el" href="classvcl_1_1Box.html">STORE_INDICES</a>, <a class="el" href="classvcl_1_1Face.html">Face</a>, N, <a class="el" href="classvcl_1_1Box.html">TTVN</a>, <a class="el" href="classvcl_1_1Box.html">ParentElemType</a>, <a class="el" href="classvcl_1_1Box.html">VERT</a>, <a class="el" href="classvcl_1_1Box.html">OPT</a> &gt;::AdjacentFaces </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Empty constructor. </p>
<p>If the Adjacent Faces container size is static, initializes all the Adjacent Faces to <code>nullptr</code>, otherwise the container will be empty. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aa5d67e5d2fd25e9234aff3a74a05e978" name="aa5d67e5d2fd25e9234aff3a74a05e978"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5d67e5d2fd25e9234aff3a74a05e978">&#9670;&#160;</a></span>adjFace() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classvcl_1_1Box.html">bool</a> STORE_INDICES, <a class="el" href="classvcl_1_1Box.html">typename</a> <a class="el" href="classvcl_1_1Face.html">Face</a> , <a class="el" href="classvcl_1_1Box.html">int</a> N, <a class="el" href="classvcl_1_1Box.html">bool</a> TTVN, <a class="el" href="classvcl_1_1Box.html">typename</a> <a class="el" href="classvcl_1_1Box.html">ParentElemType</a>  = void, <a class="el" href="classvcl_1_1Box.html">bool</a> VERT = false, <a class="el" href="classvcl_1_1Box.html">bool</a> OPT = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Face.html">Face</a> * <a class="el" href="classvcl_1_1comp_1_1AdjacentFaces.html">vcl::comp::AdjacentFaces</a>&lt; <a class="el" href="classvcl_1_1Box.html">STORE_INDICES</a>, <a class="el" href="classvcl_1_1Face.html">Face</a>, N, <a class="el" href="classvcl_1_1Box.html">TTVN</a>, <a class="el" href="classvcl_1_1Box.html">ParentElemType</a>, <a class="el" href="classvcl_1_1Box.html">VERT</a>, <a class="el" href="classvcl_1_1Box.html">OPT</a> &gt;::adjFace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">uint</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the pointer to the i-th adjacent face of this element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>the position of the required adjacent face in this container; the value must be between 0 and the number of adj faces. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The pointer to the i-th adjacent face of this element. </dd></dl>

</div>
</div>
<a id="a79542e1e4c78267dfdd4a2ecc1fcb7c6" name="a79542e1e4c78267dfdd4a2ecc1fcb7c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79542e1e4c78267dfdd4a2ecc1fcb7c6">&#9670;&#160;</a></span>adjFace() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classvcl_1_1Box.html">bool</a> STORE_INDICES, <a class="el" href="classvcl_1_1Box.html">typename</a> <a class="el" href="classvcl_1_1Face.html">Face</a> , <a class="el" href="classvcl_1_1Box.html">int</a> N, <a class="el" href="classvcl_1_1Box.html">bool</a> TTVN, <a class="el" href="classvcl_1_1Box.html">typename</a> <a class="el" href="classvcl_1_1Box.html">ParentElemType</a>  = void, <a class="el" href="classvcl_1_1Box.html">bool</a> VERT = false, <a class="el" href="classvcl_1_1Box.html">bool</a> OPT = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Box.html">const</a> <a class="el" href="classvcl_1_1Face.html">Face</a> * <a class="el" href="classvcl_1_1comp_1_1AdjacentFaces.html">vcl::comp::AdjacentFaces</a>&lt; <a class="el" href="classvcl_1_1Box.html">STORE_INDICES</a>, <a class="el" href="classvcl_1_1Face.html">Face</a>, N, <a class="el" href="classvcl_1_1Box.html">TTVN</a>, <a class="el" href="classvcl_1_1Box.html">ParentElemType</a>, <a class="el" href="classvcl_1_1Box.html">VERT</a>, <a class="el" href="classvcl_1_1Box.html">OPT</a> &gt;::adjFace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">uint</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a const pointer to the i-th adjacent face of this element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>the position of the required adjacent face in this container; the value must be between 0 and the number of adj faces. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The pointer to the i-th adjacent face of this element. </dd></dl>

</div>
</div>
<a id="a646be9c8cdc006eeda0cab27a73ccc2d" name="a646be9c8cdc006eeda0cab27a73ccc2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a646be9c8cdc006eeda0cab27a73ccc2d">&#9670;&#160;</a></span>adjFaceBegin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classvcl_1_1Box.html">bool</a> STORE_INDICES, <a class="el" href="classvcl_1_1Box.html">typename</a> <a class="el" href="classvcl_1_1Face.html">Face</a> , <a class="el" href="classvcl_1_1Box.html">int</a> N, <a class="el" href="classvcl_1_1Box.html">bool</a> TTVN, <a class="el" href="classvcl_1_1Box.html">typename</a> <a class="el" href="classvcl_1_1Box.html">ParentElemType</a>  = void, <a class="el" href="classvcl_1_1Box.html">bool</a> VERT = false, <a class="el" href="classvcl_1_1Box.html">bool</a> OPT = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">AdjacentFaceIterator <a class="el" href="classvcl_1_1comp_1_1AdjacentFaces.html">vcl::comp::AdjacentFaces</a>&lt; <a class="el" href="classvcl_1_1Box.html">STORE_INDICES</a>, <a class="el" href="classvcl_1_1Face.html">Face</a>, N, <a class="el" href="classvcl_1_1Box.html">TTVN</a>, <a class="el" href="classvcl_1_1Box.html">ParentElemType</a>, <a class="el" href="classvcl_1_1Box.html">VERT</a>, <a class="el" href="classvcl_1_1Box.html">OPT</a> &gt;::adjFaceBegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the first adjacent face in the container of this component. </p>
<dl class="section return"><dt>Returns</dt><dd>an iterator pointing to the begin of this container. </dd></dl>

</div>
</div>
<a id="a1e9a00f7f718995d12614057be2adc70" name="a1e9a00f7f718995d12614057be2adc70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e9a00f7f718995d12614057be2adc70">&#9670;&#160;</a></span>adjFaceBegin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classvcl_1_1Box.html">bool</a> STORE_INDICES, <a class="el" href="classvcl_1_1Box.html">typename</a> <a class="el" href="classvcl_1_1Face.html">Face</a> , <a class="el" href="classvcl_1_1Box.html">int</a> N, <a class="el" href="classvcl_1_1Box.html">bool</a> TTVN, <a class="el" href="classvcl_1_1Box.html">typename</a> <a class="el" href="classvcl_1_1Box.html">ParentElemType</a>  = void, <a class="el" href="classvcl_1_1Box.html">bool</a> VERT = false, <a class="el" href="classvcl_1_1Box.html">bool</a> OPT = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ConstAdjacentFaceIterator <a class="el" href="classvcl_1_1comp_1_1AdjacentFaces.html">vcl::comp::AdjacentFaces</a>&lt; <a class="el" href="classvcl_1_1Box.html">STORE_INDICES</a>, <a class="el" href="classvcl_1_1Face.html">Face</a>, N, <a class="el" href="classvcl_1_1Box.html">TTVN</a>, <a class="el" href="classvcl_1_1Box.html">ParentElemType</a>, <a class="el" href="classvcl_1_1Box.html">VERT</a>, <a class="el" href="classvcl_1_1Box.html">OPT</a> &gt;::adjFaceBegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a const iterator to the first adjacent face in the container of this component. </p>
<dl class="section return"><dt>Returns</dt><dd>an iterator pointing to the begin of this container. </dd></dl>

</div>
</div>
<a id="ad85bf5fa32951ed1682a958eeba4ec52" name="ad85bf5fa32951ed1682a958eeba4ec52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad85bf5fa32951ed1682a958eeba4ec52">&#9670;&#160;</a></span>adjFaceEnd() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classvcl_1_1Box.html">bool</a> STORE_INDICES, <a class="el" href="classvcl_1_1Box.html">typename</a> <a class="el" href="classvcl_1_1Face.html">Face</a> , <a class="el" href="classvcl_1_1Box.html">int</a> N, <a class="el" href="classvcl_1_1Box.html">bool</a> TTVN, <a class="el" href="classvcl_1_1Box.html">typename</a> <a class="el" href="classvcl_1_1Box.html">ParentElemType</a>  = void, <a class="el" href="classvcl_1_1Box.html">bool</a> VERT = false, <a class="el" href="classvcl_1_1Box.html">bool</a> OPT = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">AdjacentFaceIterator <a class="el" href="classvcl_1_1comp_1_1AdjacentFaces.html">vcl::comp::AdjacentFaces</a>&lt; <a class="el" href="classvcl_1_1Box.html">STORE_INDICES</a>, <a class="el" href="classvcl_1_1Face.html">Face</a>, N, <a class="el" href="classvcl_1_1Box.html">TTVN</a>, <a class="el" href="classvcl_1_1Box.html">ParentElemType</a>, <a class="el" href="classvcl_1_1Box.html">VERT</a>, <a class="el" href="classvcl_1_1Box.html">OPT</a> &gt;::adjFaceEnd </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the end of the container of this component. </p>
<dl class="section return"><dt>Returns</dt><dd>an iterator pointing to the end of this container. </dd></dl>

</div>
</div>
<a id="a28bba75f97bc322747bebe734dd67264" name="a28bba75f97bc322747bebe734dd67264"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28bba75f97bc322747bebe734dd67264">&#9670;&#160;</a></span>adjFaceEnd() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classvcl_1_1Box.html">bool</a> STORE_INDICES, <a class="el" href="classvcl_1_1Box.html">typename</a> <a class="el" href="classvcl_1_1Face.html">Face</a> , <a class="el" href="classvcl_1_1Box.html">int</a> N, <a class="el" href="classvcl_1_1Box.html">bool</a> TTVN, <a class="el" href="classvcl_1_1Box.html">typename</a> <a class="el" href="classvcl_1_1Box.html">ParentElemType</a>  = void, <a class="el" href="classvcl_1_1Box.html">bool</a> VERT = false, <a class="el" href="classvcl_1_1Box.html">bool</a> OPT = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ConstAdjacentFaceIterator <a class="el" href="classvcl_1_1comp_1_1AdjacentFaces.html">vcl::comp::AdjacentFaces</a>&lt; <a class="el" href="classvcl_1_1Box.html">STORE_INDICES</a>, <a class="el" href="classvcl_1_1Face.html">Face</a>, N, <a class="el" href="classvcl_1_1Box.html">TTVN</a>, <a class="el" href="classvcl_1_1Box.html">ParentElemType</a>, <a class="el" href="classvcl_1_1Box.html">VERT</a>, <a class="el" href="classvcl_1_1Box.html">OPT</a> &gt;::adjFaceEnd </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a const iterator to the end of the container of this component. </p>
<dl class="section return"><dt>Returns</dt><dd>an iterator pointing to the end of this container. </dd></dl>

</div>
</div>
<a id="a65e3408fd7259cd76cd8c3d7bcd4e98c" name="a65e3408fd7259cd76cd8c3d7bcd4e98c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65e3408fd7259cd76cd8c3d7bcd4e98c">&#9670;&#160;</a></span>adjFaceIndex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classvcl_1_1Box.html">bool</a> STORE_INDICES, <a class="el" href="classvcl_1_1Box.html">typename</a> <a class="el" href="classvcl_1_1Face.html">Face</a> , <a class="el" href="classvcl_1_1Box.html">int</a> N, <a class="el" href="classvcl_1_1Box.html">bool</a> TTVN, <a class="el" href="classvcl_1_1Box.html">typename</a> <a class="el" href="classvcl_1_1Box.html">ParentElemType</a>  = void, <a class="el" href="classvcl_1_1Box.html">bool</a> VERT = false, <a class="el" href="classvcl_1_1Box.html">bool</a> OPT = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Box.html">uint</a> <a class="el" href="classvcl_1_1comp_1_1AdjacentFaces.html">vcl::comp::AdjacentFaces</a>&lt; <a class="el" href="classvcl_1_1Box.html">STORE_INDICES</a>, <a class="el" href="classvcl_1_1Face.html">Face</a>, N, <a class="el" href="classvcl_1_1Box.html">TTVN</a>, <a class="el" href="classvcl_1_1Box.html">ParentElemType</a>, <a class="el" href="classvcl_1_1Box.html">VERT</a>, <a class="el" href="classvcl_1_1Box.html">OPT</a> &gt;::adjFaceIndex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">uint</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the index in the face container of the i-th adjacent face of the element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>the position of the required face in this container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the i-th adjacent face of the element. </dd></dl>

</div>
</div>
<a id="a9fdef39c23b38b485d7d1b2e4e85e0f1" name="a9fdef39c23b38b485d7d1b2e4e85e0f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fdef39c23b38b485d7d1b2e4e85e0f1">&#9670;&#160;</a></span>adjFaceIndexBegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classvcl_1_1Box.html">bool</a> STORE_INDICES, <a class="el" href="classvcl_1_1Box.html">typename</a> <a class="el" href="classvcl_1_1Face.html">Face</a> , <a class="el" href="classvcl_1_1Box.html">int</a> N, <a class="el" href="classvcl_1_1Box.html">bool</a> TTVN, <a class="el" href="classvcl_1_1Box.html">typename</a> <a class="el" href="classvcl_1_1Box.html">ParentElemType</a>  = void, <a class="el" href="classvcl_1_1Box.html">bool</a> VERT = false, <a class="el" href="classvcl_1_1Box.html">bool</a> OPT = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ConstAdjacentFaceIndexIterator <a class="el" href="classvcl_1_1comp_1_1AdjacentFaces.html">vcl::comp::AdjacentFaces</a>&lt; <a class="el" href="classvcl_1_1Box.html">STORE_INDICES</a>, <a class="el" href="classvcl_1_1Face.html">Face</a>, N, <a class="el" href="classvcl_1_1Box.html">TTVN</a>, <a class="el" href="classvcl_1_1Box.html">ParentElemType</a>, <a class="el" href="classvcl_1_1Box.html">VERT</a>, <a class="el" href="classvcl_1_1Box.html">OPT</a> &gt;::adjFaceIndexBegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the first adjacent face index in the container of this component. </p>
<dl class="section return"><dt>Returns</dt><dd>an iterator pointing to the begin of the adjacent face indices. </dd></dl>

</div>
</div>
<a id="a1043d4550571a2f3b247f29b133f5405" name="a1043d4550571a2f3b247f29b133f5405"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1043d4550571a2f3b247f29b133f5405">&#9670;&#160;</a></span>adjFaceIndexEnd()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classvcl_1_1Box.html">bool</a> STORE_INDICES, <a class="el" href="classvcl_1_1Box.html">typename</a> <a class="el" href="classvcl_1_1Face.html">Face</a> , <a class="el" href="classvcl_1_1Box.html">int</a> N, <a class="el" href="classvcl_1_1Box.html">bool</a> TTVN, <a class="el" href="classvcl_1_1Box.html">typename</a> <a class="el" href="classvcl_1_1Box.html">ParentElemType</a>  = void, <a class="el" href="classvcl_1_1Box.html">bool</a> VERT = false, <a class="el" href="classvcl_1_1Box.html">bool</a> OPT = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ConstAdjacentFaceIndexIterator <a class="el" href="classvcl_1_1comp_1_1AdjacentFaces.html">vcl::comp::AdjacentFaces</a>&lt; <a class="el" href="classvcl_1_1Box.html">STORE_INDICES</a>, <a class="el" href="classvcl_1_1Face.html">Face</a>, N, <a class="el" href="classvcl_1_1Box.html">TTVN</a>, <a class="el" href="classvcl_1_1Box.html">ParentElemType</a>, <a class="el" href="classvcl_1_1Box.html">VERT</a>, <a class="el" href="classvcl_1_1Box.html">OPT</a> &gt;::adjFaceIndexEnd </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the end of the container of this component. </p>
<dl class="section return"><dt>Returns</dt><dd>an iterator pointing to the end of the adjacent face indices. </dd></dl>

</div>
</div>
<a id="ac56ed64371e7816f1ebff996037811ec" name="ac56ed64371e7816f1ebff996037811ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac56ed64371e7816f1ebff996037811ec">&#9670;&#160;</a></span>adjFaceIndexMod()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classvcl_1_1Box.html">bool</a> STORE_INDICES, <a class="el" href="classvcl_1_1Box.html">typename</a> <a class="el" href="classvcl_1_1Face.html">Face</a> , <a class="el" href="classvcl_1_1Box.html">int</a> N, <a class="el" href="classvcl_1_1Box.html">bool</a> TTVN, <a class="el" href="classvcl_1_1Box.html">typename</a> <a class="el" href="classvcl_1_1Box.html">ParentElemType</a>  = void, <a class="el" href="classvcl_1_1Box.html">bool</a> VERT = false, <a class="el" href="classvcl_1_1Box.html">bool</a> OPT = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Box.html">uint</a> <a class="el" href="classvcl_1_1comp_1_1AdjacentFaces.html">vcl::comp::AdjacentFaces</a>&lt; <a class="el" href="classvcl_1_1Box.html">STORE_INDICES</a>, <a class="el" href="classvcl_1_1Face.html">Face</a>, N, <a class="el" href="classvcl_1_1Box.html">TTVN</a>, <a class="el" href="classvcl_1_1Box.html">ParentElemType</a>, <a class="el" href="classvcl_1_1Box.html">VERT</a>, <a class="el" href="classvcl_1_1Box.html">OPT</a> &gt;::adjFaceIndexMod </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the index in the face container of the i-th adjacent face of the element, but using as index the module between i and the number of adjacent faces. You can use this function if you need to get the "index
of the adjacent face next to position k", without check if it is less than the number of adjacent faces. Works also for negative numbers: </p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classvcl_1_1Box.html">k</a> = <a class="code hl_class" href="classvcl_1_1Box.html">pos</a>; <span class="comment">// some position of an adjacent face</span></div>
<div class="line"><span class="keyword">auto</span> <a class="code hl_class" href="classvcl_1_1Box.html">idx</a> = e.adjFaceIndexMod(<a class="code hl_class" href="classvcl_1_1Box.html">k</a>+1); <span class="comment">// the index of the adjacent face next</span></div>
<div class="line">                                   <span class="comment">// to k, that may also be at pos 0</span></div>
<div class="line"><span class="keyword">auto</span> <a class="code hl_class" href="classvcl_1_1Box.html">lastIdx</a> = e.adjFaceIndexMod(-1); <span class="comment">// the index of the adjacent face</span></div>
<div class="line">                                      <span class="comment">// in position adjFacesNumber()-1</span></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>the position of the required adjacent face in this container, w.r.t. the position 0; value is modularized on <a class="el" href="classvcl_1_1comp_1_1AdjacentFaces.html#a573670fcad6b4fb04a2bcf05d20fa402" title="Returns the number of adjacent faces of this element.">adjFacesNumber()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the required adjacent face of the element. </dd></dl>

</div>
</div>
<a id="a0636c5fa3212abbff5ec2a66c4c51d5e" name="a0636c5fa3212abbff5ec2a66c4c51d5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0636c5fa3212abbff5ec2a66c4c51d5e">&#9670;&#160;</a></span>adjFaceIndices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classvcl_1_1Box.html">bool</a> STORE_INDICES, <a class="el" href="classvcl_1_1Box.html">typename</a> <a class="el" href="classvcl_1_1Face.html">Face</a> , <a class="el" href="classvcl_1_1Box.html">int</a> N, <a class="el" href="classvcl_1_1Box.html">bool</a> TTVN, <a class="el" href="classvcl_1_1Box.html">typename</a> <a class="el" href="classvcl_1_1Box.html">ParentElemType</a>  = void, <a class="el" href="classvcl_1_1Box.html">bool</a> VERT = false, <a class="el" href="classvcl_1_1Box.html">bool</a> OPT = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1View.html">View</a>&lt; ConstAdjacentFaceIndexIterator &gt; <a class="el" href="classvcl_1_1comp_1_1AdjacentFaces.html">vcl::comp::AdjacentFaces</a>&lt; <a class="el" href="classvcl_1_1Box.html">STORE_INDICES</a>, <a class="el" href="classvcl_1_1Face.html">Face</a>, N, <a class="el" href="classvcl_1_1Box.html">TTVN</a>, <a class="el" href="classvcl_1_1Box.html">ParentElemType</a>, <a class="el" href="classvcl_1_1Box.html">VERT</a>, <a class="el" href="classvcl_1_1Box.html">OPT</a> &gt;::adjFaceIndices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a lightweight view object that stores the begin and end iterators of the container of adjacent face indices of the element. The view object exposes the iterators trough the <code>begin()</code> and <code>end()</code> member functions, and therefore the returned object can be used in range-based for loops: </p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<a class="code hl_class" href="classvcl_1_1Box.html">uint</a> <a class="code hl_class" href="classvcl_1_1Box.html">eid</a> : <a class="code hl_class" href="classvcl_1_1Box.html">el</a>.<a class="code hl_function" href="classvcl_1_1comp_1_1AdjacentFaces.html#a0636c5fa3212abbff5ec2a66c4c51d5e">adjFaceIndices</a>()) {</div>
<div class="line">    <span class="comment">// Do something with adj face index...</span></div>
<div class="line">}</div>
<div class="ttc" id="aclassvcl_1_1comp_1_1AdjacentFaces_html_a0636c5fa3212abbff5ec2a66c4c51d5e"><div class="ttname"><a href="classvcl_1_1comp_1_1AdjacentFaces.html#a0636c5fa3212abbff5ec2a66c4c51d5e">vcl::comp::AdjacentFaces::adjFaceIndices</a></div><div class="ttdeci">View&lt; ConstAdjacentFaceIndexIterator &gt; adjFaceIndices() const</div><div class="ttdoc">Returns a lightweight view object that stores the begin and end iterators of the container of adjacen...</div><div class="ttdef"><b>Definition</b> adjacent_faces.h:602</div></div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>a lightweight view object that can be used in range-based for loops to iterate over adjacent face indices. </dd></dl>

</div>
</div>
<a id="a3449b302f37fa8261c21f70ede5c9f12" name="a3449b302f37fa8261c21f70ede5c9f12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3449b302f37fa8261c21f70ede5c9f12">&#9670;&#160;</a></span>adjFaceMod() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classvcl_1_1Box.html">bool</a> STORE_INDICES, <a class="el" href="classvcl_1_1Box.html">typename</a> <a class="el" href="classvcl_1_1Face.html">Face</a> , <a class="el" href="classvcl_1_1Box.html">int</a> N, <a class="el" href="classvcl_1_1Box.html">bool</a> TTVN, <a class="el" href="classvcl_1_1Box.html">typename</a> <a class="el" href="classvcl_1_1Box.html">ParentElemType</a>  = void, <a class="el" href="classvcl_1_1Box.html">bool</a> VERT = false, <a class="el" href="classvcl_1_1Box.html">bool</a> OPT = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Face.html">Face</a> * <a class="el" href="classvcl_1_1comp_1_1AdjacentFaces.html">vcl::comp::AdjacentFaces</a>&lt; <a class="el" href="classvcl_1_1Box.html">STORE_INDICES</a>, <a class="el" href="classvcl_1_1Face.html">Face</a>, N, <a class="el" href="classvcl_1_1Box.html">TTVN</a>, <a class="el" href="classvcl_1_1Box.html">ParentElemType</a>, <a class="el" href="classvcl_1_1Box.html">VERT</a>, <a class="el" href="classvcl_1_1Box.html">OPT</a> &gt;::adjFaceMod </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the pointer to the i-th adjacent face of this element but using as index the module between i and the number of adjacent faces. </p>
<p>You can use this function if you need to get the "next
adjacent face after position k", without check if it is less than the number of adj faces. Works also for negative numbers:</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classvcl_1_1Box.html">k</a> = <a class="code hl_class" href="classvcl_1_1Box.html">pos</a>; <span class="comment">// some position of an adjacent face</span></div>
<div class="line"><span class="keyword">auto</span>* <a class="code hl_class" href="classvcl_1_1Box.html">next</a> = e.adjFaceMod(<a class="code hl_class" href="classvcl_1_1Box.html">k</a>+1); <span class="comment">// the adj face next to k, that may also</span></div>
<div class="line">                                <span class="comment">// be at pos 0</span></div>
<div class="line"><span class="keyword">auto</span>* <a class="code hl_class" href="classvcl_1_1Box.html">last</a> = e.adjFaceMod(-1); <span class="comment">// the adj face in position</span></div>
<div class="line">                               <span class="comment">// adjFacesNumber()-1</span></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>the position of the required adjacent face in this container, w.r.t. the position 0; value is modularized on <a class="el" href="classvcl_1_1comp_1_1AdjacentFaces.html#a573670fcad6b4fb04a2bcf05d20fa402" title="Returns the number of adjacent faces of this element.">adjFacesNumber()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The pointer to the required adjacent face of this element. </dd></dl>

</div>
</div>
<a id="a91012c0991219df9597e9d0ff17721fa" name="a91012c0991219df9597e9d0ff17721fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91012c0991219df9597e9d0ff17721fa">&#9670;&#160;</a></span>adjFaceMod() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classvcl_1_1Box.html">bool</a> STORE_INDICES, <a class="el" href="classvcl_1_1Box.html">typename</a> <a class="el" href="classvcl_1_1Face.html">Face</a> , <a class="el" href="classvcl_1_1Box.html">int</a> N, <a class="el" href="classvcl_1_1Box.html">bool</a> TTVN, <a class="el" href="classvcl_1_1Box.html">typename</a> <a class="el" href="classvcl_1_1Box.html">ParentElemType</a>  = void, <a class="el" href="classvcl_1_1Box.html">bool</a> VERT = false, <a class="el" href="classvcl_1_1Box.html">bool</a> OPT = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Box.html">const</a> <a class="el" href="classvcl_1_1Face.html">Face</a> * <a class="el" href="classvcl_1_1comp_1_1AdjacentFaces.html">vcl::comp::AdjacentFaces</a>&lt; <a class="el" href="classvcl_1_1Box.html">STORE_INDICES</a>, <a class="el" href="classvcl_1_1Face.html">Face</a>, N, <a class="el" href="classvcl_1_1Box.html">TTVN</a>, <a class="el" href="classvcl_1_1Box.html">ParentElemType</a>, <a class="el" href="classvcl_1_1Box.html">VERT</a>, <a class="el" href="classvcl_1_1Box.html">OPT</a> &gt;::adjFaceMod </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same of adjFaceMod, but returns a const Pointer to the adjacent face. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>the position of the required adjacent face in this container, w.r.t. the position 0; value is modularized on <a class="el" href="classvcl_1_1comp_1_1AdjacentFaces.html#a573670fcad6b4fb04a2bcf05d20fa402" title="Returns the number of adjacent faces of this element.">adjFacesNumber()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The pointer to the required adjacent face of this element. </dd></dl>

</div>
</div>
<a id="a796174e4e8d398f878c84cc92caa605a" name="a796174e4e8d398f878c84cc92caa605a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a796174e4e8d398f878c84cc92caa605a">&#9670;&#160;</a></span>adjFaces() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classvcl_1_1Box.html">bool</a> STORE_INDICES, <a class="el" href="classvcl_1_1Box.html">typename</a> <a class="el" href="classvcl_1_1Face.html">Face</a> , <a class="el" href="classvcl_1_1Box.html">int</a> N, <a class="el" href="classvcl_1_1Box.html">bool</a> TTVN, <a class="el" href="classvcl_1_1Box.html">typename</a> <a class="el" href="classvcl_1_1Box.html">ParentElemType</a>  = void, <a class="el" href="classvcl_1_1Box.html">bool</a> VERT = false, <a class="el" href="classvcl_1_1Box.html">bool</a> OPT = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1View.html">View</a>&lt; AdjacentFaceIterator &gt; <a class="el" href="classvcl_1_1comp_1_1AdjacentFaces.html">vcl::comp::AdjacentFaces</a>&lt; <a class="el" href="classvcl_1_1Box.html">STORE_INDICES</a>, <a class="el" href="classvcl_1_1Face.html">Face</a>, N, <a class="el" href="classvcl_1_1Box.html">TTVN</a>, <a class="el" href="classvcl_1_1Box.html">ParentElemType</a>, <a class="el" href="classvcl_1_1Box.html">VERT</a>, <a class="el" href="classvcl_1_1Box.html">OPT</a> &gt;::adjFaces </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a lightweight view object that stores the begin and end iterators of the container of adjacent faces of the element. The view object exposes the iterators trough the <code>begin()</code> and <code>end()</code> member functions, and therefore the returned object can be used in range-based for loops: </p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span>* <a class="code hl_function" href="classvcl_1_1comp_1_1AdjacentFaces.html#aa5d67e5d2fd25e9234aff3a74a05e978">adjFace</a> : <a class="code hl_class" href="classvcl_1_1Box.html">el</a>.<a class="code hl_function" href="classvcl_1_1comp_1_1AdjacentFaces.html#a796174e4e8d398f878c84cc92caa605a">adjFaces</a>()) {</div>
<div class="line">    <span class="comment">// Do something with adjFace</span></div>
<div class="line">}</div>
<div class="ttc" id="aclassvcl_1_1comp_1_1AdjacentFaces_html_a796174e4e8d398f878c84cc92caa605a"><div class="ttname"><a href="classvcl_1_1comp_1_1AdjacentFaces.html#a796174e4e8d398f878c84cc92caa605a">vcl::comp::AdjacentFaces::adjFaces</a></div><div class="ttdeci">View&lt; AdjacentFaceIterator &gt; adjFaces()</div><div class="ttdoc">Returns a lightweight view object that stores the begin and end iterators of the container of adjacen...</div><div class="ttdef"><b>Definition</b> adjacent_faces.h:563</div></div>
<div class="ttc" id="aclassvcl_1_1comp_1_1AdjacentFaces_html_aa5d67e5d2fd25e9234aff3a74a05e978"><div class="ttname"><a href="classvcl_1_1comp_1_1AdjacentFaces.html#aa5d67e5d2fd25e9234aff3a74a05e978">vcl::comp::AdjacentFaces::adjFace</a></div><div class="ttdeci">Face * adjFace(uint i)</div><div class="ttdoc">Returns the pointer to the i-th adjacent face of this element.</div><div class="ttdef"><b>Definition</b> adjacent_faces.h:161</div></div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>a lightweight view object that can be used in range-based for loops to iterate over adjacent faces. </dd></dl>

</div>
</div>
<a id="a452b4a9d1c1be2e0fdb3de69a6c2a588" name="a452b4a9d1c1be2e0fdb3de69a6c2a588"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a452b4a9d1c1be2e0fdb3de69a6c2a588">&#9670;&#160;</a></span>adjFaces() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classvcl_1_1Box.html">bool</a> STORE_INDICES, <a class="el" href="classvcl_1_1Box.html">typename</a> <a class="el" href="classvcl_1_1Face.html">Face</a> , <a class="el" href="classvcl_1_1Box.html">int</a> N, <a class="el" href="classvcl_1_1Box.html">bool</a> TTVN, <a class="el" href="classvcl_1_1Box.html">typename</a> <a class="el" href="classvcl_1_1Box.html">ParentElemType</a>  = void, <a class="el" href="classvcl_1_1Box.html">bool</a> VERT = false, <a class="el" href="classvcl_1_1Box.html">bool</a> OPT = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1View.html">View</a>&lt; ConstAdjacentFaceIterator &gt; <a class="el" href="classvcl_1_1comp_1_1AdjacentFaces.html">vcl::comp::AdjacentFaces</a>&lt; <a class="el" href="classvcl_1_1Box.html">STORE_INDICES</a>, <a class="el" href="classvcl_1_1Face.html">Face</a>, N, <a class="el" href="classvcl_1_1Box.html">TTVN</a>, <a class="el" href="classvcl_1_1Box.html">ParentElemType</a>, <a class="el" href="classvcl_1_1Box.html">VERT</a>, <a class="el" href="classvcl_1_1Box.html">OPT</a> &gt;::adjFaces </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a lightweight const view object that stores the begin and end iterators of the container of adjacent faces of the element. The view object exposes the iterators trough the <code>begin()</code> and <code>end()</code> member functions, and therefore the returned object can be used in range-based for loops: </p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>* <a class="code hl_function" href="classvcl_1_1comp_1_1AdjacentFaces.html#aa5d67e5d2fd25e9234aff3a74a05e978">adjFace</a> : <a class="code hl_class" href="classvcl_1_1Box.html">el</a>.<a class="code hl_function" href="classvcl_1_1comp_1_1AdjacentFaces.html#a796174e4e8d398f878c84cc92caa605a">adjFaces</a>()) {</div>
<div class="line">    <span class="comment">// Do something read-only with adjFace</span></div>
<div class="line">}</div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>a lightweight view object that can be used in range-based for loops to iterate over adjacent faces. </dd></dl>

</div>
</div>
<a id="a573670fcad6b4fb04a2bcf05d20fa402" name="a573670fcad6b4fb04a2bcf05d20fa402"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a573670fcad6b4fb04a2bcf05d20fa402">&#9670;&#160;</a></span>adjFacesNumber()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classvcl_1_1Box.html">bool</a> STORE_INDICES, <a class="el" href="classvcl_1_1Box.html">typename</a> <a class="el" href="classvcl_1_1Face.html">Face</a> , <a class="el" href="classvcl_1_1Box.html">int</a> N, <a class="el" href="classvcl_1_1Box.html">bool</a> TTVN, <a class="el" href="classvcl_1_1Box.html">typename</a> <a class="el" href="classvcl_1_1Box.html">ParentElemType</a>  = void, <a class="el" href="classvcl_1_1Box.html">bool</a> VERT = false, <a class="el" href="classvcl_1_1Box.html">bool</a> OPT = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Box.html">uint</a> <a class="el" href="classvcl_1_1comp_1_1AdjacentFaces.html">vcl::comp::AdjacentFaces</a>&lt; <a class="el" href="classvcl_1_1Box.html">STORE_INDICES</a>, <a class="el" href="classvcl_1_1Face.html">Face</a>, N, <a class="el" href="classvcl_1_1Box.html">TTVN</a>, <a class="el" href="classvcl_1_1Box.html">ParentElemType</a>, <a class="el" href="classvcl_1_1Box.html">VERT</a>, <a class="el" href="classvcl_1_1Box.html">OPT</a> &gt;::adjFacesNumber </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of adjacent faces of this element. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of adjacent faces of this element. </dd></dl>

</div>
</div>
<a id="a8817b4212bfeb9a76bb07663e3ab0756" name="a8817b4212bfeb9a76bb07663e3ab0756"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8817b4212bfeb9a76bb07663e3ab0756">&#9670;&#160;</a></span>clearAdjFaces()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classvcl_1_1Box.html">bool</a> STORE_INDICES, <a class="el" href="classvcl_1_1Box.html">typename</a> <a class="el" href="classvcl_1_1Face.html">Face</a> , <a class="el" href="classvcl_1_1Box.html">int</a> N, <a class="el" href="classvcl_1_1Box.html">bool</a> TTVN, <a class="el" href="classvcl_1_1Box.html">typename</a> <a class="el" href="classvcl_1_1Box.html">ParentElemType</a>  = void, <a class="el" href="classvcl_1_1Box.html">bool</a> VERT = false, <a class="el" href="classvcl_1_1Box.html">bool</a> OPT = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Box.html">void</a> <a class="el" href="classvcl_1_1comp_1_1AdjacentFaces.html">vcl::comp::AdjacentFaces</a>&lt; <a class="el" href="classvcl_1_1Box.html">STORE_INDICES</a>, <a class="el" href="classvcl_1_1Face.html">Face</a>, N, <a class="el" href="classvcl_1_1Box.html">TTVN</a>, <a class="el" href="classvcl_1_1Box.html">ParentElemType</a>, <a class="el" href="classvcl_1_1Box.html">VERT</a>, <a class="el" href="classvcl_1_1Box.html">OPT</a> &gt;::clearAdjFaces </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clears the container of adjacent faces, making it empty. </p>
<dl class="section note"><dt>Note</dt><dd>This function is available only if the container of the Adjacent Faces component has dynamic size. </dd></dl>

</div>
</div>
<a id="a81949d55c0f4d7793f57a523fbffc348" name="a81949d55c0f4d7793f57a523fbffc348"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81949d55c0f4d7793f57a523fbffc348">&#9670;&#160;</a></span>containsAdjFace() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classvcl_1_1Box.html">bool</a> STORE_INDICES, <a class="el" href="classvcl_1_1Box.html">typename</a> <a class="el" href="classvcl_1_1Face.html">Face</a> , <a class="el" href="classvcl_1_1Box.html">int</a> N, <a class="el" href="classvcl_1_1Box.html">bool</a> TTVN, <a class="el" href="classvcl_1_1Box.html">typename</a> <a class="el" href="classvcl_1_1Box.html">ParentElemType</a>  = void, <a class="el" href="classvcl_1_1Box.html">bool</a> VERT = false, <a class="el" href="classvcl_1_1Box.html">bool</a> OPT = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Box.html">bool</a> <a class="el" href="classvcl_1_1comp_1_1AdjacentFaces.html">vcl::comp::AdjacentFaces</a>&lt; <a class="el" href="classvcl_1_1Box.html">STORE_INDICES</a>, <a class="el" href="classvcl_1_1Face.html">Face</a>, N, <a class="el" href="classvcl_1_1Box.html">TTVN</a>, <a class="el" href="classvcl_1_1Box.html">ParentElemType</a>, <a class="el" href="classvcl_1_1Box.html">VERT</a>, <a class="el" href="classvcl_1_1Box.html">OPT</a> &gt;::containsAdjFace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">const</a> <a class="el" href="classvcl_1_1Face.html">Face</a> *&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <code>true</code> if the container of adjacent faces contains the given face, <code>false</code> otherwise. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>the pointer to the face to search. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the container of adjacent faces contains the given face, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="ac71ff6576d6da05371f35b0aec87a228" name="ac71ff6576d6da05371f35b0aec87a228"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac71ff6576d6da05371f35b0aec87a228">&#9670;&#160;</a></span>containsAdjFace() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classvcl_1_1Box.html">bool</a> STORE_INDICES, <a class="el" href="classvcl_1_1Box.html">typename</a> <a class="el" href="classvcl_1_1Face.html">Face</a> , <a class="el" href="classvcl_1_1Box.html">int</a> N, <a class="el" href="classvcl_1_1Box.html">bool</a> TTVN, <a class="el" href="classvcl_1_1Box.html">typename</a> <a class="el" href="classvcl_1_1Box.html">ParentElemType</a>  = void, <a class="el" href="classvcl_1_1Box.html">bool</a> VERT = false, <a class="el" href="classvcl_1_1Box.html">bool</a> OPT = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Box.html">bool</a> <a class="el" href="classvcl_1_1comp_1_1AdjacentFaces.html">vcl::comp::AdjacentFaces</a>&lt; <a class="el" href="classvcl_1_1Box.html">STORE_INDICES</a>, <a class="el" href="classvcl_1_1Face.html">Face</a>, N, <a class="el" href="classvcl_1_1Box.html">TTVN</a>, <a class="el" href="classvcl_1_1Box.html">ParentElemType</a>, <a class="el" href="classvcl_1_1Box.html">VERT</a>, <a class="el" href="classvcl_1_1Box.html">OPT</a> &gt;::containsAdjFace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">uint</a>&#160;</td>
          <td class="paramname"><em>fi</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <code>true</code> if the container of adjacent faces contains the face with the given index, <code>false</code> otherwise. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fi</td><td>the index of the face to search. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the container of adjacent faces contains the face with the given index, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="ae8d6e5b90fc327b2f015d02ed2f0f251" name="ae8d6e5b90fc327b2f015d02ed2f0f251"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8d6e5b90fc327b2f015d02ed2f0f251">&#9670;&#160;</a></span>eraseAdjFace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classvcl_1_1Box.html">bool</a> STORE_INDICES, <a class="el" href="classvcl_1_1Box.html">typename</a> <a class="el" href="classvcl_1_1Face.html">Face</a> , <a class="el" href="classvcl_1_1Box.html">int</a> N, <a class="el" href="classvcl_1_1Box.html">bool</a> TTVN, <a class="el" href="classvcl_1_1Box.html">typename</a> <a class="el" href="classvcl_1_1Box.html">ParentElemType</a>  = void, <a class="el" href="classvcl_1_1Box.html">bool</a> VERT = false, <a class="el" href="classvcl_1_1Box.html">bool</a> OPT = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Box.html">void</a> <a class="el" href="classvcl_1_1comp_1_1AdjacentFaces.html">vcl::comp::AdjacentFaces</a>&lt; <a class="el" href="classvcl_1_1Box.html">STORE_INDICES</a>, <a class="el" href="classvcl_1_1Face.html">Face</a>, N, <a class="el" href="classvcl_1_1Box.html">TTVN</a>, <a class="el" href="classvcl_1_1Box.html">ParentElemType</a>, <a class="el" href="classvcl_1_1Box.html">VERT</a>, <a class="el" href="classvcl_1_1Box.html">OPT</a> &gt;::eraseAdjFace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">uint</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the adjacent face at the given position from the container. </p>
<dl class="section note"><dt>Note</dt><dd>This function is available only if the container of the Adjacent Faces component has dynamic size. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>The position of the adjacent face to remove from this container. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6bdc4f7a60b7519df571dc33771c5446" name="a6bdc4f7a60b7519df571dc33771c5446"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bdc4f7a60b7519df571dc33771c5446">&#9670;&#160;</a></span>indexOfAdjFace() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classvcl_1_1Box.html">bool</a> STORE_INDICES, <a class="el" href="classvcl_1_1Box.html">typename</a> <a class="el" href="classvcl_1_1Face.html">Face</a> , <a class="el" href="classvcl_1_1Box.html">int</a> N, <a class="el" href="classvcl_1_1Box.html">bool</a> TTVN, <a class="el" href="classvcl_1_1Box.html">typename</a> <a class="el" href="classvcl_1_1Box.html">ParentElemType</a>  = void, <a class="el" href="classvcl_1_1Box.html">bool</a> VERT = false, <a class="el" href="classvcl_1_1Box.html">bool</a> OPT = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Box.html">uint</a> <a class="el" href="classvcl_1_1comp_1_1AdjacentFaces.html">vcl::comp::AdjacentFaces</a>&lt; <a class="el" href="classvcl_1_1Box.html">STORE_INDICES</a>, <a class="el" href="classvcl_1_1Face.html">Face</a>, N, <a class="el" href="classvcl_1_1Box.html">TTVN</a>, <a class="el" href="classvcl_1_1Box.html">ParentElemType</a>, <a class="el" href="classvcl_1_1Box.html">VERT</a>, <a class="el" href="classvcl_1_1Box.html">OPT</a> &gt;::indexOfAdjFace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">const</a> <a class="el" href="classvcl_1_1Face.html">Face</a> *&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the index of the given adjacent face in the container of this element. If the given adjacent face is not in the container, returns UINT_NULL. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>the pointer to the adjacent face to search. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the index of the given adjacent face, or UINT_NULL if it is not found. </dd></dl>

</div>
</div>
<a id="a75d34bed34447f350d15c248abd879f2" name="a75d34bed34447f350d15c248abd879f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75d34bed34447f350d15c248abd879f2">&#9670;&#160;</a></span>indexOfAdjFace() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classvcl_1_1Box.html">bool</a> STORE_INDICES, <a class="el" href="classvcl_1_1Box.html">typename</a> <a class="el" href="classvcl_1_1Face.html">Face</a> , <a class="el" href="classvcl_1_1Box.html">int</a> N, <a class="el" href="classvcl_1_1Box.html">bool</a> TTVN, <a class="el" href="classvcl_1_1Box.html">typename</a> <a class="el" href="classvcl_1_1Box.html">ParentElemType</a>  = void, <a class="el" href="classvcl_1_1Box.html">bool</a> VERT = false, <a class="el" href="classvcl_1_1Box.html">bool</a> OPT = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Box.html">uint</a> <a class="el" href="classvcl_1_1comp_1_1AdjacentFaces.html">vcl::comp::AdjacentFaces</a>&lt; <a class="el" href="classvcl_1_1Box.html">STORE_INDICES</a>, <a class="el" href="classvcl_1_1Face.html">Face</a>, N, <a class="el" href="classvcl_1_1Box.html">TTVN</a>, <a class="el" href="classvcl_1_1Box.html">ParentElemType</a>, <a class="el" href="classvcl_1_1Box.html">VERT</a>, <a class="el" href="classvcl_1_1Box.html">OPT</a> &gt;::indexOfAdjFace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">uint</a>&#160;</td>
          <td class="paramname"><em>fi</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the index of the adjacent face with the given index in the container of this element. If the adjacent face with the given index is not in the container, returns UINT_NULL. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fi</td><td>the index of the adjacent face to search. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the index of the adjacent face with the given index, or UINT_NULL if it is not found. </dd></dl>

</div>
</div>
<a id="accba199f83752de2ec5fcb66d731a86f" name="accba199f83752de2ec5fcb66d731a86f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accba199f83752de2ec5fcb66d731a86f">&#9670;&#160;</a></span>insertAdjFace() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classvcl_1_1Box.html">bool</a> STORE_INDICES, <a class="el" href="classvcl_1_1Box.html">typename</a> <a class="el" href="classvcl_1_1Face.html">Face</a> , <a class="el" href="classvcl_1_1Box.html">int</a> N, <a class="el" href="classvcl_1_1Box.html">bool</a> TTVN, <a class="el" href="classvcl_1_1Box.html">typename</a> <a class="el" href="classvcl_1_1Box.html">ParentElemType</a>  = void, <a class="el" href="classvcl_1_1Box.html">bool</a> VERT = false, <a class="el" href="classvcl_1_1Box.html">bool</a> OPT = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Box.html">void</a> <a class="el" href="classvcl_1_1comp_1_1AdjacentFaces.html">vcl::comp::AdjacentFaces</a>&lt; <a class="el" href="classvcl_1_1Box.html">STORE_INDICES</a>, <a class="el" href="classvcl_1_1Face.html">Face</a>, N, <a class="el" href="classvcl_1_1Box.html">TTVN</a>, <a class="el" href="classvcl_1_1Box.html">ParentElemType</a>, <a class="el" href="classvcl_1_1Box.html">VERT</a>, <a class="el" href="classvcl_1_1Box.html">OPT</a> &gt;::insertAdjFace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">uint</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Face.html">Face</a> *&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts the given adjacent face in the container at the given position. </p>
<dl class="section note"><dt>Note</dt><dd>This function is available only if the container of the Adjacent Faces component has dynamic size. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>The position in this container where to insert the adjacent face. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>The pointer to the adjacent face to insert in the container. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad8bd97e62f603f129deb0d8d990cb43c" name="ad8bd97e62f603f129deb0d8d990cb43c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8bd97e62f603f129deb0d8d990cb43c">&#9670;&#160;</a></span>insertAdjFace() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classvcl_1_1Box.html">bool</a> STORE_INDICES, <a class="el" href="classvcl_1_1Box.html">typename</a> <a class="el" href="classvcl_1_1Face.html">Face</a> , <a class="el" href="classvcl_1_1Box.html">int</a> N, <a class="el" href="classvcl_1_1Box.html">bool</a> TTVN, <a class="el" href="classvcl_1_1Box.html">typename</a> <a class="el" href="classvcl_1_1Box.html">ParentElemType</a>  = void, <a class="el" href="classvcl_1_1Box.html">bool</a> VERT = false, <a class="el" href="classvcl_1_1Box.html">bool</a> OPT = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Box.html">void</a> <a class="el" href="classvcl_1_1comp_1_1AdjacentFaces.html">vcl::comp::AdjacentFaces</a>&lt; <a class="el" href="classvcl_1_1Box.html">STORE_INDICES</a>, <a class="el" href="classvcl_1_1Face.html">Face</a>, N, <a class="el" href="classvcl_1_1Box.html">TTVN</a>, <a class="el" href="classvcl_1_1Box.html">ParentElemType</a>, <a class="el" href="classvcl_1_1Box.html">VERT</a>, <a class="el" href="classvcl_1_1Box.html">OPT</a> &gt;::insertAdjFace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">uint</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">uint</a>&#160;</td>
          <td class="paramname"><em>fi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts the adjacent face with the given index in the container at the given position. </p>
<dl class="section note"><dt>Note</dt><dd>This function is available only if the container of the Adjacent Faces component has dynamic size. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>The position in this container where to insert the adjacent face. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fi</td><td>The index to the adjacent face to insert in the container. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a60f33225270061c89afb8b9e103892e1" name="a60f33225270061c89afb8b9e103892e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60f33225270061c89afb8b9e103892e1">&#9670;&#160;</a></span>pushAdjFace() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classvcl_1_1Box.html">bool</a> STORE_INDICES, <a class="el" href="classvcl_1_1Box.html">typename</a> <a class="el" href="classvcl_1_1Face.html">Face</a> , <a class="el" href="classvcl_1_1Box.html">int</a> N, <a class="el" href="classvcl_1_1Box.html">bool</a> TTVN, <a class="el" href="classvcl_1_1Box.html">typename</a> <a class="el" href="classvcl_1_1Box.html">ParentElemType</a>  = void, <a class="el" href="classvcl_1_1Box.html">bool</a> VERT = false, <a class="el" href="classvcl_1_1Box.html">bool</a> OPT = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Box.html">void</a> <a class="el" href="classvcl_1_1comp_1_1AdjacentFaces.html">vcl::comp::AdjacentFaces</a>&lt; <a class="el" href="classvcl_1_1Box.html">STORE_INDICES</a>, <a class="el" href="classvcl_1_1Face.html">Face</a>, N, <a class="el" href="classvcl_1_1Box.html">TTVN</a>, <a class="el" href="classvcl_1_1Box.html">ParentElemType</a>, <a class="el" href="classvcl_1_1Box.html">VERT</a>, <a class="el" href="classvcl_1_1Box.html">OPT</a> &gt;::pushAdjFace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Face.html">Face</a> *&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pushes in the back of the container the given adjacent face. </p>
<dl class="section note"><dt>Note</dt><dd>This function is available only if the container of the Adjacent Faces component has dynamic size. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>The pointer to the adjacent face to push in the back of the container. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7b3c5591a323f38281c8409fc9053ad4" name="a7b3c5591a323f38281c8409fc9053ad4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b3c5591a323f38281c8409fc9053ad4">&#9670;&#160;</a></span>pushAdjFace() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classvcl_1_1Box.html">bool</a> STORE_INDICES, <a class="el" href="classvcl_1_1Box.html">typename</a> <a class="el" href="classvcl_1_1Face.html">Face</a> , <a class="el" href="classvcl_1_1Box.html">int</a> N, <a class="el" href="classvcl_1_1Box.html">bool</a> TTVN, <a class="el" href="classvcl_1_1Box.html">typename</a> <a class="el" href="classvcl_1_1Box.html">ParentElemType</a>  = void, <a class="el" href="classvcl_1_1Box.html">bool</a> VERT = false, <a class="el" href="classvcl_1_1Box.html">bool</a> OPT = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Box.html">void</a> <a class="el" href="classvcl_1_1comp_1_1AdjacentFaces.html">vcl::comp::AdjacentFaces</a>&lt; <a class="el" href="classvcl_1_1Box.html">STORE_INDICES</a>, <a class="el" href="classvcl_1_1Face.html">Face</a>, N, <a class="el" href="classvcl_1_1Box.html">TTVN</a>, <a class="el" href="classvcl_1_1Box.html">ParentElemType</a>, <a class="el" href="classvcl_1_1Box.html">VERT</a>, <a class="el" href="classvcl_1_1Box.html">OPT</a> &gt;::pushAdjFace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">uint</a>&#160;</td>
          <td class="paramname"><em>fi</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pushes in the back of the container the given adjacent face. </p>
<dl class="section note"><dt>Note</dt><dd>This function is available only if the container of the Adjacent Faces component has dynamic size. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fi</td><td>The index to the adjacent face to push in the back of the container. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a841d8af03d2d929e4671f5397ffc538f" name="a841d8af03d2d929e4671f5397ffc538f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a841d8af03d2d929e4671f5397ffc538f">&#9670;&#160;</a></span>resizeAdjFaces()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classvcl_1_1Box.html">bool</a> STORE_INDICES, <a class="el" href="classvcl_1_1Box.html">typename</a> <a class="el" href="classvcl_1_1Face.html">Face</a> , <a class="el" href="classvcl_1_1Box.html">int</a> N, <a class="el" href="classvcl_1_1Box.html">bool</a> TTVN, <a class="el" href="classvcl_1_1Box.html">typename</a> <a class="el" href="classvcl_1_1Box.html">ParentElemType</a>  = void, <a class="el" href="classvcl_1_1Box.html">bool</a> VERT = false, <a class="el" href="classvcl_1_1Box.html">bool</a> OPT = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Box.html">void</a> <a class="el" href="classvcl_1_1comp_1_1AdjacentFaces.html">vcl::comp::AdjacentFaces</a>&lt; <a class="el" href="classvcl_1_1Box.html">STORE_INDICES</a>, <a class="el" href="classvcl_1_1Face.html">Face</a>, N, <a class="el" href="classvcl_1_1Box.html">TTVN</a>, <a class="el" href="classvcl_1_1Box.html">ParentElemType</a>, <a class="el" href="classvcl_1_1Box.html">VERT</a>, <a class="el" href="classvcl_1_1Box.html">OPT</a> &gt;::resizeAdjFaces </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">uint</a>&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resize the container of the adjacent faces to the given size. </p>
<dl class="section note"><dt>Note</dt><dd>This function is available only if the container of the Adjacent Faces is has dynamic size. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>The new size of the adjacent faces container. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5ae26b6cfd36db23c549af917ba0f10b" name="a5ae26b6cfd36db23c549af917ba0f10b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ae26b6cfd36db23c549af917ba0f10b">&#9670;&#160;</a></span>setAdjFace() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classvcl_1_1Box.html">bool</a> STORE_INDICES, <a class="el" href="classvcl_1_1Box.html">typename</a> <a class="el" href="classvcl_1_1Face.html">Face</a> , <a class="el" href="classvcl_1_1Box.html">int</a> N, <a class="el" href="classvcl_1_1Box.html">bool</a> TTVN, <a class="el" href="classvcl_1_1Box.html">typename</a> <a class="el" href="classvcl_1_1Box.html">ParentElemType</a>  = void, <a class="el" href="classvcl_1_1Box.html">bool</a> VERT = false, <a class="el" href="classvcl_1_1Box.html">bool</a> OPT = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Box.html">void</a> <a class="el" href="classvcl_1_1comp_1_1AdjacentFaces.html">vcl::comp::AdjacentFaces</a>&lt; <a class="el" href="classvcl_1_1Box.html">STORE_INDICES</a>, <a class="el" href="classvcl_1_1Face.html">Face</a>, N, <a class="el" href="classvcl_1_1Box.html">TTVN</a>, <a class="el" href="classvcl_1_1Box.html">ParentElemType</a>, <a class="el" href="classvcl_1_1Box.html">VERT</a>, <a class="el" href="classvcl_1_1Box.html">OPT</a> &gt;::setAdjFace </td>
          <td>(</td>
          <td class="paramtype">ConstAdjacentFaceIndexIterator&#160;</td>
          <td class="paramname"><em>it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Face.html">Face</a> *&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the adjacent face pointed by the iterator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">it</td><td>the iterator in this container on which set the adjacent face; the value must be between begin() and end(). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>The pointer to the adjacent face to set to the element. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acc3a242a866f39d07f04e652952adb27" name="acc3a242a866f39d07f04e652952adb27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc3a242a866f39d07f04e652952adb27">&#9670;&#160;</a></span>setAdjFace() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classvcl_1_1Box.html">bool</a> STORE_INDICES, <a class="el" href="classvcl_1_1Box.html">typename</a> <a class="el" href="classvcl_1_1Face.html">Face</a> , <a class="el" href="classvcl_1_1Box.html">int</a> N, <a class="el" href="classvcl_1_1Box.html">bool</a> TTVN, <a class="el" href="classvcl_1_1Box.html">typename</a> <a class="el" href="classvcl_1_1Box.html">ParentElemType</a>  = void, <a class="el" href="classvcl_1_1Box.html">bool</a> VERT = false, <a class="el" href="classvcl_1_1Box.html">bool</a> OPT = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Box.html">void</a> <a class="el" href="classvcl_1_1comp_1_1AdjacentFaces.html">vcl::comp::AdjacentFaces</a>&lt; <a class="el" href="classvcl_1_1Box.html">STORE_INDICES</a>, <a class="el" href="classvcl_1_1Face.html">Face</a>, N, <a class="el" href="classvcl_1_1Box.html">TTVN</a>, <a class="el" href="classvcl_1_1Box.html">ParentElemType</a>, <a class="el" href="classvcl_1_1Box.html">VERT</a>, <a class="el" href="classvcl_1_1Box.html">OPT</a> &gt;::setAdjFace </td>
          <td>(</td>
          <td class="paramtype">ConstAdjacentFaceIndexIterator&#160;</td>
          <td class="paramname"><em>it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">uint</a>&#160;</td>
          <td class="paramname"><em>fi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the adjacent face pointed by the iterator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">it</td><td>the iterator in this container on which set the adjacent face; the value must be between begin() and end(). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fi</td><td>The index in the face container of the face to set. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6336a789c177d3e43fac8f0fa9b00183" name="a6336a789c177d3e43fac8f0fa9b00183"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6336a789c177d3e43fac8f0fa9b00183">&#9670;&#160;</a></span>setAdjFace() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classvcl_1_1Box.html">bool</a> STORE_INDICES, <a class="el" href="classvcl_1_1Box.html">typename</a> <a class="el" href="classvcl_1_1Face.html">Face</a> , <a class="el" href="classvcl_1_1Box.html">int</a> N, <a class="el" href="classvcl_1_1Box.html">bool</a> TTVN, <a class="el" href="classvcl_1_1Box.html">typename</a> <a class="el" href="classvcl_1_1Box.html">ParentElemType</a>  = void, <a class="el" href="classvcl_1_1Box.html">bool</a> VERT = false, <a class="el" href="classvcl_1_1Box.html">bool</a> OPT = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Box.html">void</a> <a class="el" href="classvcl_1_1comp_1_1AdjacentFaces.html">vcl::comp::AdjacentFaces</a>&lt; <a class="el" href="classvcl_1_1Box.html">STORE_INDICES</a>, <a class="el" href="classvcl_1_1Face.html">Face</a>, N, <a class="el" href="classvcl_1_1Box.html">TTVN</a>, <a class="el" href="classvcl_1_1Box.html">ParentElemType</a>, <a class="el" href="classvcl_1_1Box.html">VERT</a>, <a class="el" href="classvcl_1_1Box.html">OPT</a> &gt;::setAdjFace </td>
          <td>(</td>
          <td class="paramtype">ConstAdjacentFaceIterator&#160;</td>
          <td class="paramname"><em>it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Face.html">Face</a> *&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the adjacent face pointed by the iterator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">it</td><td>the iterator in this container on which set the adjacent face; the value must be between begin() and end(). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>The pointer to the adjacent face to set to the element. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4ee6c286930b371694404a21e3b9d32d" name="a4ee6c286930b371694404a21e3b9d32d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ee6c286930b371694404a21e3b9d32d">&#9670;&#160;</a></span>setAdjFace() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classvcl_1_1Box.html">bool</a> STORE_INDICES, <a class="el" href="classvcl_1_1Box.html">typename</a> <a class="el" href="classvcl_1_1Face.html">Face</a> , <a class="el" href="classvcl_1_1Box.html">int</a> N, <a class="el" href="classvcl_1_1Box.html">bool</a> TTVN, <a class="el" href="classvcl_1_1Box.html">typename</a> <a class="el" href="classvcl_1_1Box.html">ParentElemType</a>  = void, <a class="el" href="classvcl_1_1Box.html">bool</a> VERT = false, <a class="el" href="classvcl_1_1Box.html">bool</a> OPT = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Box.html">void</a> <a class="el" href="classvcl_1_1comp_1_1AdjacentFaces.html">vcl::comp::AdjacentFaces</a>&lt; <a class="el" href="classvcl_1_1Box.html">STORE_INDICES</a>, <a class="el" href="classvcl_1_1Face.html">Face</a>, N, <a class="el" href="classvcl_1_1Box.html">TTVN</a>, <a class="el" href="classvcl_1_1Box.html">ParentElemType</a>, <a class="el" href="classvcl_1_1Box.html">VERT</a>, <a class="el" href="classvcl_1_1Box.html">OPT</a> &gt;::setAdjFace </td>
          <td>(</td>
          <td class="paramtype">ConstAdjacentFaceIterator&#160;</td>
          <td class="paramname"><em>it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">uint</a>&#160;</td>
          <td class="paramname"><em>fi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the adjacent face pointed by the iterator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">it</td><td>the iterator in this container on which set the adjacent face; the value must be between begin() and end(). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fi</td><td>The index in the face container of the face to set. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab80ebcfe018c351efbe698eb5ae90625" name="ab80ebcfe018c351efbe698eb5ae90625"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab80ebcfe018c351efbe698eb5ae90625">&#9670;&#160;</a></span>setAdjFace() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classvcl_1_1Box.html">bool</a> STORE_INDICES, <a class="el" href="classvcl_1_1Box.html">typename</a> <a class="el" href="classvcl_1_1Face.html">Face</a> , <a class="el" href="classvcl_1_1Box.html">int</a> N, <a class="el" href="classvcl_1_1Box.html">bool</a> TTVN, <a class="el" href="classvcl_1_1Box.html">typename</a> <a class="el" href="classvcl_1_1Box.html">ParentElemType</a>  = void, <a class="el" href="classvcl_1_1Box.html">bool</a> VERT = false, <a class="el" href="classvcl_1_1Box.html">bool</a> OPT = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Box.html">void</a> <a class="el" href="classvcl_1_1comp_1_1AdjacentFaces.html">vcl::comp::AdjacentFaces</a>&lt; <a class="el" href="classvcl_1_1Box.html">STORE_INDICES</a>, <a class="el" href="classvcl_1_1Face.html">Face</a>, N, <a class="el" href="classvcl_1_1Box.html">TTVN</a>, <a class="el" href="classvcl_1_1Box.html">ParentElemType</a>, <a class="el" href="classvcl_1_1Box.html">VERT</a>, <a class="el" href="classvcl_1_1Box.html">OPT</a> &gt;::setAdjFace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">uint</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Face.html">Face</a> *&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the i-th adjacent face of this element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>the position in this container on which set the adj face; the value must be between 0 and the number of adj faces. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>The pointer to the adjacent face to set to this element. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2b8aeb381747461148daf3914fac1b2d" name="a2b8aeb381747461148daf3914fac1b2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b8aeb381747461148daf3914fac1b2d">&#9670;&#160;</a></span>setAdjFace() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classvcl_1_1Box.html">bool</a> STORE_INDICES, <a class="el" href="classvcl_1_1Box.html">typename</a> <a class="el" href="classvcl_1_1Face.html">Face</a> , <a class="el" href="classvcl_1_1Box.html">int</a> N, <a class="el" href="classvcl_1_1Box.html">bool</a> TTVN, <a class="el" href="classvcl_1_1Box.html">typename</a> <a class="el" href="classvcl_1_1Box.html">ParentElemType</a>  = void, <a class="el" href="classvcl_1_1Box.html">bool</a> VERT = false, <a class="el" href="classvcl_1_1Box.html">bool</a> OPT = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Box.html">void</a> <a class="el" href="classvcl_1_1comp_1_1AdjacentFaces.html">vcl::comp::AdjacentFaces</a>&lt; <a class="el" href="classvcl_1_1Box.html">STORE_INDICES</a>, <a class="el" href="classvcl_1_1Face.html">Face</a>, N, <a class="el" href="classvcl_1_1Box.html">TTVN</a>, <a class="el" href="classvcl_1_1Box.html">ParentElemType</a>, <a class="el" href="classvcl_1_1Box.html">VERT</a>, <a class="el" href="classvcl_1_1Box.html">OPT</a> &gt;::setAdjFace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">uint</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">uint</a>&#160;</td>
          <td class="paramname"><em>fi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the i-th adjacent face of the element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>the position in this container on which set the adj face; the value must be between 0 and the number of adj faces. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fi</td><td>The index in the face container of the face to set. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5357e3737058323eaed2802753a7b6f4" name="a5357e3737058323eaed2802753a7b6f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5357e3737058323eaed2802753a7b6f4">&#9670;&#160;</a></span>setAdjFaceMod() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classvcl_1_1Box.html">bool</a> STORE_INDICES, <a class="el" href="classvcl_1_1Box.html">typename</a> <a class="el" href="classvcl_1_1Face.html">Face</a> , <a class="el" href="classvcl_1_1Box.html">int</a> N, <a class="el" href="classvcl_1_1Box.html">bool</a> TTVN, <a class="el" href="classvcl_1_1Box.html">typename</a> <a class="el" href="classvcl_1_1Box.html">ParentElemType</a>  = void, <a class="el" href="classvcl_1_1Box.html">bool</a> VERT = false, <a class="el" href="classvcl_1_1Box.html">bool</a> OPT = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Box.html">void</a> <a class="el" href="classvcl_1_1comp_1_1AdjacentFaces.html">vcl::comp::AdjacentFaces</a>&lt; <a class="el" href="classvcl_1_1Box.html">STORE_INDICES</a>, <a class="el" href="classvcl_1_1Face.html">Face</a>, N, <a class="el" href="classvcl_1_1Box.html">TTVN</a>, <a class="el" href="classvcl_1_1Box.html">ParentElemType</a>, <a class="el" href="classvcl_1_1Box.html">VERT</a>, <a class="el" href="classvcl_1_1Box.html">OPT</a> &gt;::setAdjFaceMod </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Face.html">Face</a> *&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the i-th adjacent face of the element, but using as index the module between i and the number of adjacent faces. You can use this function if you need to set the "next adjacent face after position k", without check if it is less than the number of adjacent faces. Works also for negative numbers: </p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classvcl_1_1Box.html">k</a> = <a class="code hl_class" href="classvcl_1_1Box.html">pos</a>; <span class="comment">// some position of an adj face</span></div>
<div class="line">e.setAdjFaceMod(<a class="code hl_class" href="classvcl_1_1Box.html">k</a>+1, <a class="code hl_class" href="classvcl_1_1Box.html">aFace</a>); <span class="comment">// set the adj face next to k, that may also</span></div>
<div class="line">                              <span class="comment">// be at pos 0</span></div>
<div class="line">e.setAdjFaceMod(-1, <a class="code hl_class" href="classvcl_1_1Box.html">aFace</a>); <span class="comment">// set the adj face in position</span></div>
<div class="line">                             <span class="comment">// adjFacesNumber()-1</span></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>the position in this container w.r.t. the position 0 on which set the adj face; value is modularized on <a class="el" href="classvcl_1_1comp_1_1AdjacentFaces.html#a573670fcad6b4fb04a2bcf05d20fa402" title="Returns the number of adjacent faces of this element.">adjFacesNumber()</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>The pointer to the adj face to set to the element. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9e3fdc1ea6f0234ced228e85600f1d82" name="a9e3fdc1ea6f0234ced228e85600f1d82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e3fdc1ea6f0234ced228e85600f1d82">&#9670;&#160;</a></span>setAdjFaceMod() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classvcl_1_1Box.html">bool</a> STORE_INDICES, <a class="el" href="classvcl_1_1Box.html">typename</a> <a class="el" href="classvcl_1_1Face.html">Face</a> , <a class="el" href="classvcl_1_1Box.html">int</a> N, <a class="el" href="classvcl_1_1Box.html">bool</a> TTVN, <a class="el" href="classvcl_1_1Box.html">typename</a> <a class="el" href="classvcl_1_1Box.html">ParentElemType</a>  = void, <a class="el" href="classvcl_1_1Box.html">bool</a> VERT = false, <a class="el" href="classvcl_1_1Box.html">bool</a> OPT = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Box.html">void</a> <a class="el" href="classvcl_1_1comp_1_1AdjacentFaces.html">vcl::comp::AdjacentFaces</a>&lt; <a class="el" href="classvcl_1_1Box.html">STORE_INDICES</a>, <a class="el" href="classvcl_1_1Face.html">Face</a>, N, <a class="el" href="classvcl_1_1Box.html">TTVN</a>, <a class="el" href="classvcl_1_1Box.html">ParentElemType</a>, <a class="el" href="classvcl_1_1Box.html">VERT</a>, <a class="el" href="classvcl_1_1Box.html">OPT</a> &gt;::setAdjFaceMod </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">uint</a>&#160;</td>
          <td class="paramname"><em>fi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the i-th adjacent face of the element, but using as index the module between i and the number of adjacent faces. You can use this function if you need to set the "next adjacent face after position k", without check if it is less than the number of adjacent faces. Works also for negative numbers: </p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classvcl_1_1Box.html">k</a> = <a class="code hl_class" href="classvcl_1_1Box.html">pos</a>; <span class="comment">// some position of an adj face</span></div>
<div class="line">e.setAdjFaceMod(<a class="code hl_class" href="classvcl_1_1Box.html">k</a>+1, <a class="code hl_class" href="classvcl_1_1Box.html">aFaceInd</a>); <span class="comment">// set the adj face next to k, that may</span></div>
<div class="line">                                <span class="comment">// also be at pos 0</span></div>
<div class="line">e.setAdjFaceMod(-1, <a class="code hl_class" href="classvcl_1_1Box.html">aFaceInd</a>); <span class="comment">// set the adj face in position</span></div>
<div class="line">                               <span class="comment">// adjFacesNumber()-1</span></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>the position in this container w.r.t. the position 0 on which set the adj face; value is modularized on <a class="el" href="classvcl_1_1comp_1_1AdjacentFaces.html#a573670fcad6b4fb04a2bcf05d20fa402" title="Returns the number of adjacent faces of this element.">adjFacesNumber()</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fi</td><td>The index in the face containrt of the face to set. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aba809bafa2607a499a2805f3c1fa8c81" name="aba809bafa2607a499a2805f3c1fa8c81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba809bafa2607a499a2805f3c1fa8c81">&#9670;&#160;</a></span>setAdjFaces() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classvcl_1_1Box.html">bool</a> STORE_INDICES, <a class="el" href="classvcl_1_1Box.html">typename</a> <a class="el" href="classvcl_1_1Face.html">Face</a> , <a class="el" href="classvcl_1_1Box.html">int</a> N, <a class="el" href="classvcl_1_1Box.html">bool</a> TTVN, <a class="el" href="classvcl_1_1Box.html">typename</a> <a class="el" href="classvcl_1_1Box.html">ParentElemType</a>  = void, <a class="el" href="classvcl_1_1Box.html">bool</a> VERT = false, <a class="el" href="classvcl_1_1Box.html">bool</a> OPT = false&gt; </div>
<div class="memtemplate">
template&lt;Range Rng&gt; <br />
requires InputRange&lt;<a class="el" href="classvcl_1_1Box.html">Rng</a>, <a class="el" href="classvcl_1_1Face.html">Face</a>*&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Box.html">void</a> <a class="el" href="classvcl_1_1comp_1_1AdjacentFaces.html">vcl::comp::AdjacentFaces</a>&lt; <a class="el" href="classvcl_1_1Box.html">STORE_INDICES</a>, <a class="el" href="classvcl_1_1Face.html">Face</a>, N, <a class="el" href="classvcl_1_1Box.html">TTVN</a>, <a class="el" href="classvcl_1_1Box.html">ParentElemType</a>, <a class="el" href="classvcl_1_1Box.html">VERT</a>, <a class="el" href="classvcl_1_1Box.html">OPT</a> &gt;::setAdjFaces </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">Rng</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets all the adjacent faces of this element. </p>
<p>If the size of the container is static, the size of the input range must be the same one of the container.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Rng</td><td>The type of the range of adjacent faces to set. The value type of the range must be convertible to a pointer to an AdjacentFace.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">r</td><td>range of face pointers to set. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a152a8a1f7faee4d58b1db87735bb43f4" name="a152a8a1f7faee4d58b1db87735bb43f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a152a8a1f7faee4d58b1db87735bb43f4">&#9670;&#160;</a></span>setAdjFaces() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classvcl_1_1Box.html">bool</a> STORE_INDICES, <a class="el" href="classvcl_1_1Box.html">typename</a> <a class="el" href="classvcl_1_1Face.html">Face</a> , <a class="el" href="classvcl_1_1Box.html">int</a> N, <a class="el" href="classvcl_1_1Box.html">bool</a> TTVN, <a class="el" href="classvcl_1_1Box.html">typename</a> <a class="el" href="classvcl_1_1Box.html">ParentElemType</a>  = void, <a class="el" href="classvcl_1_1Box.html">bool</a> VERT = false, <a class="el" href="classvcl_1_1Box.html">bool</a> OPT = false&gt; </div>
<div class="memtemplate">
template&lt;Range Rng&gt; <br />
requires InputRange&lt;<a class="el" href="classvcl_1_1Box.html">Rng</a>, <a class="el" href="classvcl_1_1Box.html">uint</a>&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Box.html">void</a> <a class="el" href="classvcl_1_1comp_1_1AdjacentFaces.html">vcl::comp::AdjacentFaces</a>&lt; <a class="el" href="classvcl_1_1Box.html">STORE_INDICES</a>, <a class="el" href="classvcl_1_1Face.html">Face</a>, N, <a class="el" href="classvcl_1_1Box.html">TTVN</a>, <a class="el" href="classvcl_1_1Box.html">ParentElemType</a>, <a class="el" href="classvcl_1_1Box.html">VERT</a>, <a class="el" href="classvcl_1_1Box.html">OPT</a> &gt;::setAdjFaces </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">Rng</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets all the adjacent faces of this element. </p>
<p>If the size of the container is static, the size of the input range must be the same one of the container.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Rng</td><td>The type of the range of adjacent faces to set. The value type of the range must be convertible to an unsigned integer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">r</td><td>range of face indices to set. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>vclib/core/include/vclib/mesh/components/<a class="el" href="adjacent__faces_8h_source.html">adjacent_faces.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>vcl</b></li><li class="navelem"><b>comp</b></li><li class="navelem"><a class="el" href="classvcl_1_1comp_1_1AdjacentFaces.html">AdjacentFaces</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
