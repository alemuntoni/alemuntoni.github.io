<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Visual Computing Library: vcl::mesh::VertexContainer&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
       <script type="text/javascript">
           DoxygenAwesomeDarkModeToggle.init()
       </script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Visual Computing Library
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classvcl_1_1mesh_1_1VertexContainer.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-types">Private Types</a> &#124;
<a href="classvcl_1_1mesh_1_1VertexContainer-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">vcl::mesh::VertexContainer&lt; T &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__mesh.html">Mesh</a> &raquo; <a class="el" href="group__containers.html">Containers</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>The <a class="el" href="classvcl_1_1Vertex.html" title="The Vertex class represents an Vertex element of the vcl::Mesh class.">Vertex</a> Container class, will be used when the template argument given to the <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a> is a <a class="el" href="classvcl_1_1Vertex.html" title="The Vertex class represents an Vertex element of the vcl::Mesh class.">Vertex</a>.  
 <a href="classvcl_1_1mesh_1_1VertexContainer.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="mesh_2containers_2vertex__container_8h_source.html">vclib/mesh/containers/vertex_container.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for vcl::mesh::VertexContainer&lt; T &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classvcl_1_1mesh_1_1VertexContainer__inherit__graph.png" border="0" usemap="#avcl_1_1mesh_1_1VertexContainer_3_01T_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="avcl_1_1mesh_1_1VertexContainer_3_01T_01_4_inherit__map" id="avcl_1_1mesh_1_1VertexContainer_3_01T_01_4_inherit__map">
<area shape="rect" title="The Vertex Container class, will be used when the template argument given to the Mesh is a Vertex." alt="" coords="301,292,537,317"/>
<area shape="rect" href="classvcl_1_1EdgeMeshT.html" title=" " alt="" coords="585,5,792,31"/>
<area shape="poly" title=" " alt="" coords="427,278,447,228,480,163,525,97,553,67,584,41,608,28,610,33,587,46,557,71,530,101,485,166,452,230,432,280"/>
<area shape="rect" href="classvcl_1_1PolyEdgeMeshT.html" title=" " alt="" coords="613,55,765,95"/>
<area shape="poly" title=" " alt="" coords="432,279,457,240,491,194,534,146,584,105,611,91,614,96,587,110,538,150,495,197,461,243,437,281"/>
<area shape="rect" href="classvcl_1_1PolyMeshT.html" title=" " alt="" coords="587,120,790,145"/>
<area shape="poly" title=" " alt="" coords="438,280,499,218,540,184,584,156,616,143,618,148,587,160,543,188,502,221,442,283"/>
<area shape="rect" href="classvcl_1_1TriEdgeMeshT.html" title=" " alt="" coords="613,170,764,210"/>
<area shape="poly" title=" " alt="" coords="454,283,514,252,584,220,617,208,619,213,586,224,516,256,456,288"/>
<area shape="rect" href="classvcl_1_1TriMeshT.html" title=" " alt="" coords="594,235,783,260"/>
<area shape="poly" title=" " alt="" coords="493,286,628,257,629,263,494,292"/>
<area shape="rect" href="classvcl_1_1EdgeMeshT.html" title="The EdgeMeshT class is a mesh class that represents a mesh that stores only vertices and edges (no fa..." alt="" coords="597,285,780,325"/>
<area shape="poly" title=" " alt="" coords="551,302,597,302,597,307,551,307"/>
<area shape="rect" href="classvcl_1_1PointCloudT.html" title="The PointCloudT class is a mesh class that represents a point cloud." alt="" coords="590,349,787,375"/>
<area shape="poly" title=" " alt="" coords="494,318,629,347,628,352,493,323"/>
<area shape="rect" href="classvcl_1_1PolyEdgeMeshT.html" title="The PolyEdgeMeshT class is a mesh class that represents a polygonal mesh with edges." alt="" coords="609,399,768,439"/>
<area shape="poly" title=" " alt="" coords="456,322,516,353,586,385,619,397,617,402,584,390,514,358,454,326"/>
<area shape="rect" href="classvcl_1_1PolyMeshT.html" title="The PolyMeshT class is a mesh class that represents a polygonal mesh." alt="" coords="599,463,778,503"/>
<area shape="poly" title=" " alt="" coords="443,326,503,387,543,420,587,449,612,461,609,466,584,454,540,425,500,391,439,330"/>
<area shape="rect" href="classvcl_1_1TriEdgeMeshT.html" title="The TriEdgeMeshT class is a mesh class that represents a triangle mesh with edges." alt="" coords="613,527,764,567"/>
<area shape="poly" title=" " alt="" coords="436,329,460,369,493,419,536,470,587,513,614,528,612,532,584,518,533,473,489,422,455,372,431,331"/>
<area shape="rect" href="classvcl_1_1TriMeshT.html" title="The TriMeshT class is a mesh class that represents a triangle mesh." alt="" coords="605,591,772,631"/>
<area shape="poly" title=" " alt="" coords="432,330,452,382,484,449,529,518,557,550,587,577,606,589,604,594,584,581,553,553,525,521,480,451,447,384,427,332"/>
<area shape="rect" href="classvcl_1_1mesh_1_1ElementContainer.html" title=" " alt="" coords="5,292,253,317"/>
<area shape="poly" title=" " alt="" coords="267,302,301,302,301,307,267,307"/>
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a6e0332114044b439d6738c1bb64ad7dc" id="r_a6e0332114044b439d6738c1bb64ad7dc"><td class="memItemLeft" align="right" valign="top"><a id="a6e0332114044b439d6738c1bb64ad7dc" name="a6e0332114044b439d6738c1bb64ad7dc"></a>
<a class="el" href="classvcl_1_1Segment.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Vertex</b> = T</td></tr>
<tr class="separator:a6e0332114044b439d6738c1bb64ad7dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64eb23d0ad8115b2aac98d5fbae0bc43" id="r_a64eb23d0ad8115b2aac98d5fbae0bc43"><td class="memItemLeft" align="right" valign="top"><a id="a64eb23d0ad8115b2aac98d5fbae0bc43" name="a64eb23d0ad8115b2aac98d5fbae0bc43"></a>
<a class="el" href="classvcl_1_1Segment.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><b>VertexType</b> = T</td></tr>
<tr class="separator:a64eb23d0ad8115b2aac98d5fbae0bc43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12702551c437573303004846b926c3da" id="r_a12702551c437573303004846b926c3da"><td class="memItemLeft" align="right" valign="top"><a id="a12702551c437573303004846b926c3da" name="a12702551c437573303004846b926c3da"></a>
<a class="el" href="classvcl_1_1Segment.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><b>VertexIterator</b> = Base::ElementIterator</td></tr>
<tr class="separator:a12702551c437573303004846b926c3da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa863a1cf721acd8a6c8177e6d4342878" id="r_aa863a1cf721acd8a6c8177e6d4342878"><td class="memItemLeft" align="right" valign="top"><a id="aa863a1cf721acd8a6c8177e6d4342878" name="aa863a1cf721acd8a6c8177e6d4342878"></a>
<a class="el" href="classvcl_1_1Segment.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><b>ConstVertexIterator</b> = Base::ConstElementIterator</td></tr>
<tr class="separator:aa863a1cf721acd8a6c8177e6d4342878"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ad2cac8daece6d44babf7a880241b21f6" id="r_ad2cac8daece6d44babf7a880241b21f6"><td class="memItemLeft" align="right" valign="top"><a id="ad2cac8daece6d44babf7a880241b21f6" name="ad2cac8daece6d44babf7a880241b21f6"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>VertexContainer</b> ()=<a class="el" href="classvcl_1_1Segment.html">default</a></td></tr>
<tr class="memdesc:ad2cac8daece6d44babf7a880241b21f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty constructor that creates an empty container of Vertices. <br /></td></tr>
<tr class="separator:ad2cac8daece6d44babf7a880241b21f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af60143c1bd9f5d27c4e3ff49c895064b" id="r_af60143c1bd9f5d27c4e3ff49c895064b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Segment.html">const</a> VertexType &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1mesh_1_1VertexContainer.html#af60143c1bd9f5d27c4e3ff49c895064b">vertex</a> (<a class="el" href="classvcl_1_1Segment.html">uint</a> <a class="el" href="classvcl_1_1Segment.html">i</a>) <a class="el" href="classvcl_1_1Segment.html">const</a></td></tr>
<tr class="memdesc:af60143c1bd9f5d27c4e3ff49c895064b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const reference of the vertex at the i-th position in the <a class="el" href="classvcl_1_1Vertex.html" title="The Vertex class represents an Vertex element of the vcl::Mesh class.">Vertex</a> Container of the <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>, which will be the vertex having index = i.  <br /></td></tr>
<tr class="separator:af60143c1bd9f5d27c4e3ff49c895064b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a281a6b3aae817871391d838d97f9ca5a" id="r_a281a6b3aae817871391d838d97f9ca5a"><td class="memItemLeft" align="right" valign="top">VertexType &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1mesh_1_1VertexContainer.html#a281a6b3aae817871391d838d97f9ca5a">vertex</a> (<a class="el" href="classvcl_1_1Segment.html">uint</a> <a class="el" href="classvcl_1_1Segment.html">i</a>)</td></tr>
<tr class="memdesc:a281a6b3aae817871391d838d97f9ca5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference of the vertex at the i-th position in the <a class="el" href="classvcl_1_1Vertex.html" title="The Vertex class represents an Vertex element of the vcl::Mesh class.">Vertex</a> Container of the <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>, which will be the vertex having index = i.  <br /></td></tr>
<tr class="separator:a281a6b3aae817871391d838d97f9ca5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c9be0bf45c7d2b18356181591bbb3ee" id="r_a7c9be0bf45c7d2b18356181591bbb3ee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Segment.html">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1mesh_1_1VertexContainer.html#a7c9be0bf45c7d2b18356181591bbb3ee">vertexNumber</a> () <a class="el" href="classvcl_1_1Segment.html">const</a></td></tr>
<tr class="memdesc:a7c9be0bf45c7d2b18356181591bbb3ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of <b>non-deleted</b> vertices contained in the <a class="el" href="classvcl_1_1Vertex.html" title="The Vertex class represents an Vertex element of the vcl::Mesh class.">Vertex</a> container of the <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>.  <br /></td></tr>
<tr class="separator:a7c9be0bf45c7d2b18356181591bbb3ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab89515980efa65095d8318720a8ff4d3" id="r_ab89515980efa65095d8318720a8ff4d3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Segment.html">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1mesh_1_1VertexContainer.html#ab89515980efa65095d8318720a8ff4d3">vertexContainerSize</a> () <a class="el" href="classvcl_1_1Segment.html">const</a></td></tr>
<tr class="memdesc:ab89515980efa65095d8318720a8ff4d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of vertices (also deleted) contained in the <a class="el" href="classvcl_1_1Vertex.html" title="The Vertex class represents an Vertex element of the vcl::Mesh class.">Vertex</a> container of the <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>.  <br /></td></tr>
<tr class="separator:ab89515980efa65095d8318720a8ff4d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9313879921d09c88ab805a2efaf8e31" id="r_ae9313879921d09c88ab805a2efaf8e31"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Segment.html">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1mesh_1_1VertexContainer.html#ae9313879921d09c88ab805a2efaf8e31">deletedVertexNumber</a> () <a class="el" href="classvcl_1_1Segment.html">const</a></td></tr>
<tr class="memdesc:ae9313879921d09c88ab805a2efaf8e31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of deleted vertices in the <a class="el" href="classvcl_1_1Vertex.html" title="The Vertex class represents an Vertex element of the vcl::Mesh class.">Vertex</a> container, that is <a class="el" href="classvcl_1_1mesh_1_1VertexContainer.html#ab89515980efa65095d8318720a8ff4d3" title="Returns the number of vertices (also deleted) contained in the Vertex container of the Mesh.">vertexContainerSize()</a> - <a class="el" href="classvcl_1_1mesh_1_1VertexContainer.html#a7c9be0bf45c7d2b18356181591bbb3ee" title="Returns the number of non-deleted vertices contained in the Vertex container of the Mesh.">vertexNumber()</a>.  <br /></td></tr>
<tr class="separator:ae9313879921d09c88ab805a2efaf8e31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98f6b97063334e7dcc0a8abb3bcb6c27" id="r_a98f6b97063334e7dcc0a8abb3bcb6c27"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Segment.html">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1mesh_1_1VertexContainer.html#a98f6b97063334e7dcc0a8abb3bcb6c27">addVertex</a> ()</td></tr>
<tr class="memdesc:a98f6b97063334e7dcc0a8abb3bcb6c27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a new vertex into the vertex container, returning the index of the added vertex.  <br /></td></tr>
<tr class="separator:a98f6b97063334e7dcc0a8abb3bcb6c27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36f2757fafafd2cd6ddb0676127a169a" id="r_a36f2757fafafd2cd6ddb0676127a169a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Segment.html">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1mesh_1_1VertexContainer.html#a36f2757fafafd2cd6ddb0676127a169a">addVertex</a> (<a class="el" href="classvcl_1_1Segment.html">const</a> <a class="el" href="classvcl_1_1Segment.html">typename</a> T::CoordType &amp;<a class="el" href="classvcl_1_1Segment.html">p</a>)</td></tr>
<tr class="memdesc:a36f2757fafafd2cd6ddb0676127a169a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a new vertex with the given coordinate into the vertex container, returning the id of the added vertex.  <br /></td></tr>
<tr class="separator:a36f2757fafafd2cd6ddb0676127a169a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9344364538cdfdc22a1db65a53debaf5" id="r_a9344364538cdfdc22a1db65a53debaf5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Segment.html">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1mesh_1_1VertexContainer.html#a9344364538cdfdc22a1db65a53debaf5">addVertices</a> (<a class="el" href="classvcl_1_1Segment.html">uint</a> <a class="el" href="classvcl_1_1Segment.html">n</a>)</td></tr>
<tr class="memdesc:a9344364538cdfdc22a1db65a53debaf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an arbitrary number of n vertices, returning the id of the first added vertex.  <br /></td></tr>
<tr class="separator:a9344364538cdfdc22a1db65a53debaf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5313b9f5e7858b360c07fe689ea89d06" id="r_a5313b9f5e7858b360c07fe689ea89d06"><td class="memTemplParams" colspan="2">template&lt;typename... VC&gt; </td></tr>
<tr class="memitem:a5313b9f5e7858b360c07fe689ea89d06"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Segment.html">uint</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvcl_1_1mesh_1_1VertexContainer.html#a5313b9f5e7858b360c07fe689ea89d06">addVertices</a> (<a class="el" href="classvcl_1_1Segment.html">const</a> <a class="el" href="classvcl_1_1Segment.html">typename</a> T::CoordType &amp;<a class="el" href="classvcl_1_1Segment.html">p</a>, <a class="el" href="classvcl_1_1Segment.html">const</a> <a class="el" href="classvcl_1_1Segment.html">VC</a> &amp;... v)</td></tr>
<tr class="memdesc:a5313b9f5e7858b360c07fe689ea89d06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an arbitrary number of vertices with the given coordinates, returning the id of the first added vertex.  <br /></td></tr>
<tr class="separator:a5313b9f5e7858b360c07fe689ea89d06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07f082b3515679742c1cf13d410cb1eb" id="r_a07f082b3515679742c1cf13d410cb1eb"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="conceptvcl_1_1Range.html">vcl::Range</a> R&gt; <br />
requires RangeOf&lt;R, <a class="el" href="classvcl_1_1Segment.html">typename</a> T::CoordType&gt;</td></tr>
<tr class="memitem:a07f082b3515679742c1cf13d410cb1eb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Segment.html">uint</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvcl_1_1mesh_1_1VertexContainer.html#a07f082b3515679742c1cf13d410cb1eb">addVertices</a> (R &amp;&amp;<a class="el" href="classvcl_1_1Segment.html">range</a>)</td></tr>
<tr class="memdesc:a07f082b3515679742c1cf13d410cb1eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an arbitrary number of vertices with the coordinates contained in the given range, returning the id of the first added vertex.  <br /></td></tr>
<tr class="separator:a07f082b3515679742c1cf13d410cb1eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2862b33e9651ea6ba0d5746ed3bc7b78" id="r_a2862b33e9651ea6ba0d5746ed3bc7b78"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Segment.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1mesh_1_1VertexContainer.html#a2862b33e9651ea6ba0d5746ed3bc7b78">clearVertices</a> ()</td></tr>
<tr class="memdesc:a2862b33e9651ea6ba0d5746ed3bc7b78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the <a class="el" href="classvcl_1_1Vertex.html" title="The Vertex class represents an Vertex element of the vcl::Mesh class.">Vertex</a> container of the <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>, deleting all the vertices.  <br /></td></tr>
<tr class="separator:a2862b33e9651ea6ba0d5746ed3bc7b78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54e1446a592f06ce15b2343c20a79aad" id="r_a54e1446a592f06ce15b2343c20a79aad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Segment.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1mesh_1_1VertexContainer.html#a54e1446a592f06ce15b2343c20a79aad">resizeVertices</a> (<a class="el" href="classvcl_1_1Segment.html">uint</a> <a class="el" href="classvcl_1_1Segment.html">n</a>)</td></tr>
<tr class="memdesc:a54e1446a592f06ce15b2343c20a79aad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizes the <a class="el" href="classvcl_1_1Vertex.html" title="The Vertex class represents an Vertex element of the vcl::Mesh class.">Vertex</a> container to contain <code>n</code> vertices.  <br /></td></tr>
<tr class="separator:a54e1446a592f06ce15b2343c20a79aad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad248e4d4a2ef91ef0173ce33935c7846" id="r_ad248e4d4a2ef91ef0173ce33935c7846"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Segment.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1mesh_1_1VertexContainer.html#ad248e4d4a2ef91ef0173ce33935c7846">reserveVertices</a> (<a class="el" href="classvcl_1_1Segment.html">uint</a> <a class="el" href="classvcl_1_1Segment.html">n</a>)</td></tr>
<tr class="memdesc:ad248e4d4a2ef91ef0173ce33935c7846"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reserve a number of vertices in the container of Vertices. This is useful when you know (or you have an idea) of how much vertices are going to add into a newly or existing mesh. Calling this function before any add_vertex() call will avoid unuseful reallocations of the container, saving execution time.  <br /></td></tr>
<tr class="separator:ad248e4d4a2ef91ef0173ce33935c7846"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a617d7d729b96f0c99c82724a9eee7cc1" id="r_a617d7d729b96f0c99c82724a9eee7cc1"><td class="memItemLeft" align="right" valign="top"><a id="a617d7d729b96f0c99c82724a9eee7cc1" name="a617d7d729b96f0c99c82724a9eee7cc1"></a>
<a class="el" href="classvcl_1_1Segment.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><b>compactVertices</b> ()</td></tr>
<tr class="memdesc:a617d7d729b96f0c99c82724a9eee7cc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compacts the <a class="el" href="classvcl_1_1Vertex.html" title="The Vertex class represents an Vertex element of the vcl::Mesh class.">Vertex</a> Container, removing all the vertices marked as deleted. Vertices indices will change accordingly. The function will automatically take care of updating all the <a class="el" href="classvcl_1_1Vertex.html" title="The Vertex class represents an Vertex element of the vcl::Mesh class.">Vertex</a> pointers contained in the <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>. <br /></td></tr>
<tr class="separator:a617d7d729b96f0c99c82724a9eee7cc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e6b1482fa3de582b71011466bafe452" id="r_a1e6b1482fa3de582b71011466bafe452"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Segment.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1mesh_1_1VertexContainer.html#a1e6b1482fa3de582b71011466bafe452">deleteVertex</a> (<a class="el" href="classvcl_1_1Segment.html">uint</a> <a class="el" href="classvcl_1_1Segment.html">i</a>)</td></tr>
<tr class="memdesc:a1e6b1482fa3de582b71011466bafe452"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marks as deleted the vertex with the given id.  <br /></td></tr>
<tr class="separator:a1e6b1482fa3de582b71011466bafe452"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afeecaf670815757658735a763ab28416" id="r_afeecaf670815757658735a763ab28416"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Segment.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1mesh_1_1VertexContainer.html#afeecaf670815757658735a763ab28416">deleteVertex</a> (<a class="el" href="classvcl_1_1Segment.html">const</a> VertexType *v)</td></tr>
<tr class="memdesc:afeecaf670815757658735a763ab28416"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marks as deleted the given vertex, before asserting that the vertex belongs to this container.  <br /></td></tr>
<tr class="separator:afeecaf670815757658735a763ab28416"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bd411cf90c0448949360036246d0e0b" id="r_a8bd411cf90c0448949360036246d0e0b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Segment.html">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1mesh_1_1VertexContainer.html#a8bd411cf90c0448949360036246d0e0b">vertexIndexIfCompact</a> (<a class="el" href="classvcl_1_1Segment.html">uint</a> <a class="el" href="classvcl_1_1Segment.html">i</a>) <a class="el" href="classvcl_1_1Segment.html">const</a></td></tr>
<tr class="memdesc:a8bd411cf90c0448949360036246d0e0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an utility member function that returns the index of an element if the container would be compact, that is the number of non-deleted elements before the vertex with the given index.  <br /></td></tr>
<tr class="separator:a8bd411cf90c0448949360036246d0e0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af43a99e3a2c9dc5a74ff9f599e4dac13" id="r_af43a99e3a2c9dc5a74ff9f599e4dac13"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classvcl_1_1Segment.html">uint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1mesh_1_1VertexContainer.html#af43a99e3a2c9dc5a74ff9f599e4dac13">vertexCompactIndices</a> () <a class="el" href="classvcl_1_1Segment.html">const</a></td></tr>
<tr class="memdesc:af43a99e3a2c9dc5a74ff9f599e4dac13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector that tells, for each actual vertex index, the new index that the vertex would have in a compacted container. For each deleted vertex index, the value of the vector will be UINT_NULL.  <br /></td></tr>
<tr class="separator:af43a99e3a2c9dc5a74ff9f599e4dac13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c89260e14b61963b1dc5ff35217a3da" id="r_a0c89260e14b61963b1dc5ff35217a3da"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Segment.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1mesh_1_1VertexContainer.html#a0c89260e14b61963b1dc5ff35217a3da">updateVertexIndices</a> (<a class="el" href="classvcl_1_1Segment.html">const</a> std::vector&lt; <a class="el" href="classvcl_1_1Segment.html">uint</a> &gt; &amp;<a class="el" href="classvcl_1_1Segment.html">newIndices</a>)</td></tr>
<tr class="memdesc:a0c89260e14b61963b1dc5ff35217a3da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates all the indices and pointers of the vertices of this container that are stored in any container of the mesh, according to the mapping stored in the newIndices vector, that tells for each old vertex index, the new vertex index.  <br /></td></tr>
<tr class="separator:a0c89260e14b61963b1dc5ff35217a3da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3269666db546393fb9238a3b50d7680" id="r_ac3269666db546393fb9238a3b50d7680"><td class="memItemLeft" align="right" valign="top">VertexIterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1mesh_1_1VertexContainer.html#ac3269666db546393fb9238a3b50d7680">vertexBegin</a> (<a class="el" href="classvcl_1_1Segment.html">bool</a> <a class="el" href="classvcl_1_1Segment.html">jumpDeleted</a>=<a class="el" href="classvcl_1_1Segment.html">true</a>)</td></tr>
<tr class="memdesc:ac3269666db546393fb9238a3b50d7680"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the beginning of the container.  <br /></td></tr>
<tr class="separator:ac3269666db546393fb9238a3b50d7680"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3e975ca1f096f908729984ca4f331c3" id="r_ae3e975ca1f096f908729984ca4f331c3"><td class="memItemLeft" align="right" valign="top">VertexIterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1mesh_1_1VertexContainer.html#ae3e975ca1f096f908729984ca4f331c3">vertexEnd</a> ()</td></tr>
<tr class="memdesc:ae3e975ca1f096f908729984ca4f331c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the end of the container.  <br /></td></tr>
<tr class="separator:ae3e975ca1f096f908729984ca4f331c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e9f63240146b08aaf7a47ac68d2b9d9" id="r_a7e9f63240146b08aaf7a47ac68d2b9d9"><td class="memItemLeft" align="right" valign="top">ConstVertexIterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1mesh_1_1VertexContainer.html#a7e9f63240146b08aaf7a47ac68d2b9d9">vertexBegin</a> (<a class="el" href="classvcl_1_1Segment.html">bool</a> <a class="el" href="classvcl_1_1Segment.html">jumpDeleted</a>=<a class="el" href="classvcl_1_1Segment.html">true</a>) <a class="el" href="classvcl_1_1Segment.html">const</a></td></tr>
<tr class="memdesc:a7e9f63240146b08aaf7a47ac68d2b9d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const iterator to the beginning of the container.  <br /></td></tr>
<tr class="separator:a7e9f63240146b08aaf7a47ac68d2b9d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4470262c8c7aca508625bbe8c54a94c4" id="r_a4470262c8c7aca508625bbe8c54a94c4"><td class="memItemLeft" align="right" valign="top">ConstVertexIterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1mesh_1_1VertexContainer.html#a4470262c8c7aca508625bbe8c54a94c4">vertexEnd</a> () <a class="el" href="classvcl_1_1Segment.html">const</a></td></tr>
<tr class="memdesc:a4470262c8c7aca508625bbe8c54a94c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const iterator to the end of the container.  <br /></td></tr>
<tr class="separator:a4470262c8c7aca508625bbe8c54a94c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1aac0c075f3ff34ab9efa083ff1fd4e8" id="r_a1aac0c075f3ff34ab9efa083ff1fd4e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Segment.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1mesh_1_1VertexContainer.html#a1aac0c075f3ff34ab9efa083ff1fd4e8">vertices</a> (<a class="el" href="classvcl_1_1Segment.html">bool</a> <a class="el" href="classvcl_1_1Segment.html">jumpDeleted</a>=<a class="el" href="classvcl_1_1Segment.html">true</a>)</td></tr>
<tr class="memdesc:a1aac0c075f3ff34ab9efa083ff1fd4e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a small utility object that allows to iterate over the vertices of the containers, providing two member functions begin() and end().  <br /></td></tr>
<tr class="separator:a1aac0c075f3ff34ab9efa083ff1fd4e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3140ae97a7243135bb2e762309d3ac42" id="r_a3140ae97a7243135bb2e762309d3ac42"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Segment.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1mesh_1_1VertexContainer.html#a3140ae97a7243135bb2e762309d3ac42">vertices</a> (<a class="el" href="classvcl_1_1Segment.html">bool</a> <a class="el" href="classvcl_1_1Segment.html">jumpDeleted</a>=<a class="el" href="classvcl_1_1Segment.html">true</a>) <a class="el" href="classvcl_1_1Segment.html">const</a></td></tr>
<tr class="memdesc:a3140ae97a7243135bb2e762309d3ac42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a small utility object that allows to iterate over the vertices of the containers, providing two member functions begin() and end().  <br /></td></tr>
<tr class="separator:a3140ae97a7243135bb2e762309d3ac42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8300e6c81cc1a577d86399933391521" id="r_ad8300e6c81cc1a577d86399933391521"><td class="memItemLeft" align="right" valign="top"><a id="ad8300e6c81cc1a577d86399933391521" name="ad8300e6c81cc1a577d86399933391521"></a>
<a class="el" href="classvcl_1_1Segment.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><b>enableAllPerVertexOptionalComponents</b> ()</td></tr>
<tr class="memdesc:ad8300e6c81cc1a577d86399933391521"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables all the optional components associated to the <a class="el" href="classvcl_1_1Vertex.html" title="The Vertex class represents an Vertex element of the vcl::Mesh class.">Vertex</a> type contained in the <a class="el" href="classvcl_1_1mesh_1_1VertexContainer.html" title="The Vertex Container class, will be used when the template argument given to the Mesh is a Vertex.">VertexContainer</a>. <br /></td></tr>
<tr class="separator:ad8300e6c81cc1a577d86399933391521"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e64d41cbf4c1de8e654a9c7950d2b05" id="r_a8e64d41cbf4c1de8e654a9c7950d2b05"><td class="memItemLeft" align="right" valign="top"><a id="a8e64d41cbf4c1de8e654a9c7950d2b05" name="a8e64d41cbf4c1de8e654a9c7950d2b05"></a>
<a class="el" href="classvcl_1_1Segment.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><b>disableAllPerVertexOptionalComponents</b> ()</td></tr>
<tr class="memdesc:a8e64d41cbf4c1de8e654a9c7950d2b05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables all the optional components associated to the <a class="el" href="classvcl_1_1Vertex.html" title="The Vertex class represents an Vertex element of the vcl::Mesh class.">Vertex</a> type contained in the <a class="el" href="classvcl_1_1mesh_1_1VertexContainer.html" title="The Vertex Container class, will be used when the template argument given to the Mesh is a Vertex.">VertexContainer</a>. <br /></td></tr>
<tr class="separator:a8e64d41cbf4c1de8e654a9c7950d2b05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac4b92349090126a38b76765e4c4023c" id="r_aac4b92349090126a38b76765e4c4023c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Segment.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1mesh_1_1VertexContainer.html#aac4b92349090126a38b76765e4c4023c">isPerVertexAdjacentEdgesEnabled</a> () <a class="el" href="classvcl_1_1Segment.html">const</a></td></tr>
<tr class="memdesc:aac4b92349090126a38b76765e4c4023c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the vertex Optional Adjacent Edges component is enabled.  <br /></td></tr>
<tr class="separator:aac4b92349090126a38b76765e4c4023c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cbb40f7ba6cab1420dbaed157985852" id="r_a1cbb40f7ba6cab1420dbaed157985852"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Segment.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1mesh_1_1VertexContainer.html#a1cbb40f7ba6cab1420dbaed157985852">enablePerVertexAdjacentEdges</a> ()</td></tr>
<tr class="memdesc:a1cbb40f7ba6cab1420dbaed157985852"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables the Optional Adjacent Edges of the vertex.  <br /></td></tr>
<tr class="separator:a1cbb40f7ba6cab1420dbaed157985852"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8dfc6237f1fa5217ee19ea7dc7281ed" id="r_ab8dfc6237f1fa5217ee19ea7dc7281ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Segment.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1mesh_1_1VertexContainer.html#ab8dfc6237f1fa5217ee19ea7dc7281ed">disablePerVertexAdjacentEdges</a> ()</td></tr>
<tr class="memdesc:ab8dfc6237f1fa5217ee19ea7dc7281ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables the Optional Adjacent Edges of the vertex.  <br /></td></tr>
<tr class="separator:ab8dfc6237f1fa5217ee19ea7dc7281ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4d3969cc77b89119b3455cc9625b122" id="r_ac4d3969cc77b89119b3455cc9625b122"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Segment.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1mesh_1_1VertexContainer.html#ac4d3969cc77b89119b3455cc9625b122">isPerVertexAdjacentFacesEnabled</a> () <a class="el" href="classvcl_1_1Segment.html">const</a></td></tr>
<tr class="memdesc:ac4d3969cc77b89119b3455cc9625b122"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the vertex Optional Adjacent Faces component is enabled.  <br /></td></tr>
<tr class="separator:ac4d3969cc77b89119b3455cc9625b122"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8b07ec4ed52d86a05a0adfa2c84af85" id="r_ac8b07ec4ed52d86a05a0adfa2c84af85"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Segment.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1mesh_1_1VertexContainer.html#ac8b07ec4ed52d86a05a0adfa2c84af85">enablePerVertexAdjacentFaces</a> ()</td></tr>
<tr class="memdesc:ac8b07ec4ed52d86a05a0adfa2c84af85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables the Optional Adjacent Faces of the vertex.  <br /></td></tr>
<tr class="separator:ac8b07ec4ed52d86a05a0adfa2c84af85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a1af41e20543fd9087181a695ea43b7" id="r_a4a1af41e20543fd9087181a695ea43b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Segment.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1mesh_1_1VertexContainer.html#a4a1af41e20543fd9087181a695ea43b7">disablePerVertexAdjacentFaces</a> ()</td></tr>
<tr class="memdesc:a4a1af41e20543fd9087181a695ea43b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables the Optional Adjacent Faces of the vertex.  <br /></td></tr>
<tr class="separator:a4a1af41e20543fd9087181a695ea43b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93e92feeba10d3f7eca9d666a59bf299" id="r_a93e92feeba10d3f7eca9d666a59bf299"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Segment.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1mesh_1_1VertexContainer.html#a93e92feeba10d3f7eca9d666a59bf299">isPerVertexAdjacentVerticesEnabled</a> () <a class="el" href="classvcl_1_1Segment.html">const</a></td></tr>
<tr class="memdesc:a93e92feeba10d3f7eca9d666a59bf299"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the vertex Optional Adjacent Vertices component is enabled.  <br /></td></tr>
<tr class="separator:a93e92feeba10d3f7eca9d666a59bf299"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabf6a1042fddfa786cdfa5e6193a9d4b" id="r_aabf6a1042fddfa786cdfa5e6193a9d4b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Segment.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1mesh_1_1VertexContainer.html#aabf6a1042fddfa786cdfa5e6193a9d4b">enablePerVertexAdjacentVertices</a> ()</td></tr>
<tr class="memdesc:aabf6a1042fddfa786cdfa5e6193a9d4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables the Optional Adjacent Vertices of the vertex.  <br /></td></tr>
<tr class="separator:aabf6a1042fddfa786cdfa5e6193a9d4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac950d9cae73e85a30966fc953ca3ee7b" id="r_ac950d9cae73e85a30966fc953ca3ee7b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Segment.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1mesh_1_1VertexContainer.html#ac950d9cae73e85a30966fc953ca3ee7b">disablePerVertexAdjacentVertices</a> ()</td></tr>
<tr class="memdesc:ac950d9cae73e85a30966fc953ca3ee7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables the Optional Adjacent Vertices of the vertex.  <br /></td></tr>
<tr class="separator:ac950d9cae73e85a30966fc953ca3ee7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b042c41437a30e5078d7c1b5a150004" id="r_a1b042c41437a30e5078d7c1b5a150004"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Segment.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1mesh_1_1VertexContainer.html#a1b042c41437a30e5078d7c1b5a150004">isPerVertexColorEnabled</a> () <a class="el" href="classvcl_1_1Segment.html">const</a></td></tr>
<tr class="memdesc:a1b042c41437a30e5078d7c1b5a150004"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the vertex Optional <a class="el" href="classvcl_1_1Color.html" title="The Color class represents a 32 bit color.">Color</a> is enabled.  <br /></td></tr>
<tr class="separator:a1b042c41437a30e5078d7c1b5a150004"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a794af16726277e3da49e7d3e1c25bae9" id="r_a794af16726277e3da49e7d3e1c25bae9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Segment.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1mesh_1_1VertexContainer.html#a794af16726277e3da49e7d3e1c25bae9">enablePerVertexColor</a> ()</td></tr>
<tr class="memdesc:a794af16726277e3da49e7d3e1c25bae9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables the Optional <a class="el" href="classvcl_1_1Color.html" title="The Color class represents a 32 bit color.">Color</a> of the vertex.  <br /></td></tr>
<tr class="separator:a794af16726277e3da49e7d3e1c25bae9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad029521a2906fb5f3f3373da11deece0" id="r_ad029521a2906fb5f3f3373da11deece0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Segment.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1mesh_1_1VertexContainer.html#ad029521a2906fb5f3f3373da11deece0">disablePerVertexColor</a> ()</td></tr>
<tr class="memdesc:ad029521a2906fb5f3f3373da11deece0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables the Optional <a class="el" href="classvcl_1_1Color.html" title="The Color class represents a 32 bit color.">Color</a> of the vertex.  <br /></td></tr>
<tr class="separator:ad029521a2906fb5f3f3373da11deece0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6b18107b3e962aeb2eb5de14bcfd386" id="r_ae6b18107b3e962aeb2eb5de14bcfd386"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Segment.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1mesh_1_1VertexContainer.html#ae6b18107b3e962aeb2eb5de14bcfd386">isPerVertexMarkEnabled</a> () <a class="el" href="classvcl_1_1Segment.html">const</a></td></tr>
<tr class="memdesc:ae6b18107b3e962aeb2eb5de14bcfd386"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the vertex Optional Mark is enabled.  <br /></td></tr>
<tr class="separator:ae6b18107b3e962aeb2eb5de14bcfd386"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac072db473a48666dcab2c768b73db5af" id="r_ac072db473a48666dcab2c768b73db5af"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Segment.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1mesh_1_1VertexContainer.html#ac072db473a48666dcab2c768b73db5af">enablePerVertexMark</a> ()</td></tr>
<tr class="memdesc:ac072db473a48666dcab2c768b73db5af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables the Optional Mark of the vertex.  <br /></td></tr>
<tr class="separator:ac072db473a48666dcab2c768b73db5af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca54cee62748e26cb2ada5ac5549c51e" id="r_aca54cee62748e26cb2ada5ac5549c51e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Segment.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1mesh_1_1VertexContainer.html#aca54cee62748e26cb2ada5ac5549c51e">disablePerVertexMark</a> ()</td></tr>
<tr class="memdesc:aca54cee62748e26cb2ada5ac5549c51e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container::disableVertexMark disables the Optional Mark of the vertex.  <br /></td></tr>
<tr class="separator:aca54cee62748e26cb2ada5ac5549c51e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae55646f2ac1ec14b4e3961fe8e5ea0dd" id="r_ae55646f2ac1ec14b4e3961fe8e5ea0dd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Segment.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1mesh_1_1VertexContainer.html#ae55646f2ac1ec14b4e3961fe8e5ea0dd">isPerVertexNormalEnabled</a> () <a class="el" href="classvcl_1_1Segment.html">const</a></td></tr>
<tr class="memdesc:ae55646f2ac1ec14b4e3961fe8e5ea0dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the vertex Optional Normal is enabled.  <br /></td></tr>
<tr class="separator:ae55646f2ac1ec14b4e3961fe8e5ea0dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab783b9004ccf5d9d7139cc00f3cd8f1f" id="r_ab783b9004ccf5d9d7139cc00f3cd8f1f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Segment.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1mesh_1_1VertexContainer.html#ab783b9004ccf5d9d7139cc00f3cd8f1f">enablePerVertexNormal</a> ()</td></tr>
<tr class="memdesc:ab783b9004ccf5d9d7139cc00f3cd8f1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables the Optional Normal of the vertex.  <br /></td></tr>
<tr class="separator:ab783b9004ccf5d9d7139cc00f3cd8f1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52df3972de88425fac2f653448d591d1" id="r_a52df3972de88425fac2f653448d591d1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Segment.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1mesh_1_1VertexContainer.html#a52df3972de88425fac2f653448d591d1">disablePerVertexNormal</a> ()</td></tr>
<tr class="memdesc:a52df3972de88425fac2f653448d591d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the vertex Optional <a class="el" href="classvcl_1_1PrincipalCurvature.html" title="The PrincipalCurvature class stores the principal curvature directions and values at a point on a 3D ...">PrincipalCurvature</a> is enabled.  <br /></td></tr>
<tr class="separator:a52df3972de88425fac2f653448d591d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa20a89792fce4ad7e545bbe1b61db9af" id="r_aa20a89792fce4ad7e545bbe1b61db9af"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Segment.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1mesh_1_1VertexContainer.html#aa20a89792fce4ad7e545bbe1b61db9af">isPerVertexPrincipalCurvatureEnabled</a> () <a class="el" href="classvcl_1_1Segment.html">const</a></td></tr>
<tr class="memdesc:aa20a89792fce4ad7e545bbe1b61db9af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the vertex Optional <a class="el" href="classvcl_1_1PrincipalCurvature.html" title="The PrincipalCurvature class stores the principal curvature directions and values at a point on a 3D ...">PrincipalCurvature</a> is enabled.  <br /></td></tr>
<tr class="separator:aa20a89792fce4ad7e545bbe1b61db9af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95260476863abed20aa57e13a78d0536" id="r_a95260476863abed20aa57e13a78d0536"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Segment.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1mesh_1_1VertexContainer.html#a95260476863abed20aa57e13a78d0536">enablePerVertexPrincipalCurvature</a> ()</td></tr>
<tr class="memdesc:a95260476863abed20aa57e13a78d0536"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables the Optional <a class="el" href="classvcl_1_1PrincipalCurvature.html" title="The PrincipalCurvature class stores the principal curvature directions and values at a point on a 3D ...">PrincipalCurvature</a> of the vertex.  <br /></td></tr>
<tr class="separator:a95260476863abed20aa57e13a78d0536"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09cb59aca0a8031521b372605d536939" id="r_a09cb59aca0a8031521b372605d536939"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Segment.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1mesh_1_1VertexContainer.html#a09cb59aca0a8031521b372605d536939">disablePerVertexPrincipalCurvature</a> ()</td></tr>
<tr class="memdesc:a09cb59aca0a8031521b372605d536939"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables the Optional <a class="el" href="classvcl_1_1PrincipalCurvature.html" title="The PrincipalCurvature class stores the principal curvature directions and values at a point on a 3D ...">PrincipalCurvature</a> of the vertex.  <br /></td></tr>
<tr class="separator:a09cb59aca0a8031521b372605d536939"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cba62bf6152dfadd55037304f66f469" id="r_a2cba62bf6152dfadd55037304f66f469"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Segment.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1mesh_1_1VertexContainer.html#a2cba62bf6152dfadd55037304f66f469">isPerVertexQualityEnabled</a> () <a class="el" href="classvcl_1_1Segment.html">const</a></td></tr>
<tr class="memdesc:a2cba62bf6152dfadd55037304f66f469"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the vertex Optional Quality is enabled.  <br /></td></tr>
<tr class="separator:a2cba62bf6152dfadd55037304f66f469"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeafc2f71ab1a39d5c4833d559808f542" id="r_aeafc2f71ab1a39d5c4833d559808f542"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Segment.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1mesh_1_1VertexContainer.html#aeafc2f71ab1a39d5c4833d559808f542">enablePerVertexQuality</a> ()</td></tr>
<tr class="memdesc:aeafc2f71ab1a39d5c4833d559808f542"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables the Optional Quality of the vertex.  <br /></td></tr>
<tr class="separator:aeafc2f71ab1a39d5c4833d559808f542"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a409e11f32dc8e6a245f80b933f42641d" id="r_a409e11f32dc8e6a245f80b933f42641d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Segment.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1mesh_1_1VertexContainer.html#a409e11f32dc8e6a245f80b933f42641d">disablePerVertexQuality</a> ()</td></tr>
<tr class="memdesc:a409e11f32dc8e6a245f80b933f42641d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables the Optional Quality of the vertex.  <br /></td></tr>
<tr class="separator:a409e11f32dc8e6a245f80b933f42641d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7d9136be92e3c1c3b78655627182618" id="r_ad7d9136be92e3c1c3b78655627182618"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Segment.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1mesh_1_1VertexContainer.html#ad7d9136be92e3c1c3b78655627182618">isPerVertexTexCoordEnabled</a> () <a class="el" href="classvcl_1_1Segment.html">const</a></td></tr>
<tr class="memdesc:ad7d9136be92e3c1c3b78655627182618"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the vertex Optional <a class="el" href="classvcl_1_1TexCoord.html" title="The TexCoord class represents a 2-dimensional texture coordinate containing two scalar values.">TexCoord</a> is enabled.  <br /></td></tr>
<tr class="separator:ad7d9136be92e3c1c3b78655627182618"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabe30468d1779420f6750120091c99eb" id="r_aabe30468d1779420f6750120091c99eb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Segment.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1mesh_1_1VertexContainer.html#aabe30468d1779420f6750120091c99eb">enablePerVertexTexCoord</a> ()</td></tr>
<tr class="memdesc:aabe30468d1779420f6750120091c99eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables the Optional <a class="el" href="classvcl_1_1TexCoord.html" title="The TexCoord class represents a 2-dimensional texture coordinate containing two scalar values.">TexCoord</a> of the vertex.  <br /></td></tr>
<tr class="separator:aabe30468d1779420f6750120091c99eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1562776f51491bcd3a5177726bc6b22e" id="r_a1562776f51491bcd3a5177726bc6b22e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Segment.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1mesh_1_1VertexContainer.html#a1562776f51491bcd3a5177726bc6b22e">disablePerVertexTexCoord</a> ()</td></tr>
<tr class="memdesc:a1562776f51491bcd3a5177726bc6b22e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables the Optional <a class="el" href="classvcl_1_1TexCoord.html" title="The TexCoord class represents a 2-dimensional texture coordinate containing two scalar values.">TexCoord</a> of the vertex.  <br /></td></tr>
<tr class="separator:a1562776f51491bcd3a5177726bc6b22e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62a2797607bc7c06d1e4a8fba79466aa" id="r_a62a2797607bc7c06d1e4a8fba79466aa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Segment.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1mesh_1_1VertexContainer.html#a62a2797607bc7c06d1e4a8fba79466aa">hasPerVertexCustomComponent</a> (<a class="el" href="classvcl_1_1Segment.html">const</a> std::string &amp;name) <a class="el" href="classvcl_1_1Segment.html">const</a></td></tr>
<tr class="memdesc:a62a2797607bc7c06d1e4a8fba79466aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if vertices have a custom component with the given name.  <br /></td></tr>
<tr class="separator:a62a2797607bc7c06d1e4a8fba79466aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a472ccf650986d2f46e6cd2cfb3cc9780" id="r_a472ccf650986d2f46e6cd2cfb3cc9780"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1mesh_1_1VertexContainer.html#a472ccf650986d2f46e6cd2cfb3cc9780">perVertexCustomComponentNames</a> () <a class="el" href="classvcl_1_1Segment.html">const</a></td></tr>
<tr class="memdesc:a472ccf650986d2f46e6cd2cfb3cc9780"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector containing all the names of the custom components of any type associated to the <a class="el" href="classvcl_1_1Vertex.html" title="The Vertex class represents an Vertex element of the vcl::Mesh class.">Vertex</a> <a class="el" href="classvcl_1_1Element.html" title="The Element class.">Element</a>.  <br /></td></tr>
<tr class="separator:a472ccf650986d2f46e6cd2cfb3cc9780"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb00571719f436731eaa075618e05eda" id="r_adb00571719f436731eaa075618e05eda"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classvcl_1_1Segment.html">typename</a> K &gt; <br />
requires vert::HasCustomComponents&lt;T&gt;</td></tr>
<tr class="memitem:adb00571719f436731eaa075618e05eda"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Segment.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvcl_1_1mesh_1_1VertexContainer.html#adb00571719f436731eaa075618e05eda">isPerVertexCustomComponentOfType</a> (<a class="el" href="classvcl_1_1Segment.html">const</a> std::string &amp;name) <a class="el" href="classvcl_1_1Segment.html">const</a></td></tr>
<tr class="memdesc:adb00571719f436731eaa075618e05eda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the custom component of the <a class="el" href="classvcl_1_1Vertex.html" title="The Vertex class represents an Vertex element of the vcl::Mesh class.">Vertex</a> <a class="el" href="classvcl_1_1Element.html" title="The Element class.">Element</a> having the given name has the same type of the given template argument type of this function.  <br /></td></tr>
<tr class="separator:adb00571719f436731eaa075618e05eda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96fc0ff63bda8ac0d2ef3c86e714d5ca" id="r_a96fc0ff63bda8ac0d2ef3c86e714d5ca"><td class="memItemLeft" align="right" valign="top">std::type_index&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1mesh_1_1VertexContainer.html#a96fc0ff63bda8ac0d2ef3c86e714d5ca">perVertexCustomComponentType</a> (<a class="el" href="classvcl_1_1Segment.html">const</a> std::string &amp;name) <a class="el" href="classvcl_1_1Segment.html">const</a></td></tr>
<tr class="memdesc:a96fc0ff63bda8ac0d2ef3c86e714d5ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the std::type_index of the custom component of the <a class="el" href="classvcl_1_1Vertex.html" title="The Vertex class represents an Vertex element of the vcl::Mesh class.">Vertex</a> <a class="el" href="classvcl_1_1Element.html" title="The Element class.">Element</a> having the given input name.  <br /></td></tr>
<tr class="separator:a96fc0ff63bda8ac0d2ef3c86e714d5ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab747bd4c58cd3fea6643586be65f2428" id="r_ab747bd4c58cd3fea6643586be65f2428"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classvcl_1_1Segment.html">typename</a> K &gt; <br />
requires vert::HasCustomComponents&lt;T&gt;</td></tr>
<tr class="memitem:ab747bd4c58cd3fea6643586be65f2428"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvcl_1_1mesh_1_1VertexContainer.html#ab747bd4c58cd3fea6643586be65f2428">perVertexCustomComponentNamesOfType</a> () <a class="el" href="classvcl_1_1Segment.html">const</a></td></tr>
<tr class="memdesc:ab747bd4c58cd3fea6643586be65f2428"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector containing all the names of the custom components associated to the <a class="el" href="classvcl_1_1Vertex.html" title="The Vertex class represents an Vertex element of the vcl::Mesh class.">Vertex</a> <a class="el" href="classvcl_1_1Element.html" title="The Element class.">Element</a> having the same type of the given template argument type of this function.  <br /></td></tr>
<tr class="separator:ab747bd4c58cd3fea6643586be65f2428"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fef9e15ba6e654141ec74041369b87e" id="r_a7fef9e15ba6e654141ec74041369b87e"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classvcl_1_1Segment.html">typename</a> K &gt; <br />
requires vert::HasCustomComponents&lt;T&gt;</td></tr>
<tr class="memitem:a7fef9e15ba6e654141ec74041369b87e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Segment.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvcl_1_1mesh_1_1VertexContainer.html#a7fef9e15ba6e654141ec74041369b87e">addPerVertexCustomComponent</a> (<a class="el" href="classvcl_1_1Segment.html">const</a> std::string &amp;name)</td></tr>
<tr class="memdesc:a7fef9e15ba6e654141ec74041369b87e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a custom component of type K to the <a class="el" href="classvcl_1_1Vertex.html" title="The Vertex class represents an Vertex element of the vcl::Mesh class.">Vertex</a>, having the given name.  <br /></td></tr>
<tr class="separator:a7fef9e15ba6e654141ec74041369b87e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69492022fa918c736ddb8c8caffa4851" id="r_a69492022fa918c736ddb8c8caffa4851"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Segment.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1mesh_1_1VertexContainer.html#a69492022fa918c736ddb8c8caffa4851">deletePerVertexCustomComponent</a> (<a class="el" href="classvcl_1_1Segment.html">const</a> std::string &amp;name)</td></tr>
<tr class="memdesc:a69492022fa918c736ddb8c8caffa4851"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the custom component of the given name from the <a class="el" href="classvcl_1_1Vertex.html" title="The Vertex class represents an Vertex element of the vcl::Mesh class.">Vertex</a> <a class="el" href="classvcl_1_1Element.html" title="The Element class.">Element</a>.  <br /></td></tr>
<tr class="separator:a69492022fa918c736ddb8c8caffa4851"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92f5d5fd9284780d6ad2df61c0126de1" id="r_a92f5d5fd9284780d6ad2df61c0126de1"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classvcl_1_1Segment.html">typename</a> K &gt; <br />
requires vert::HasCustomComponents&lt;T&gt;</td></tr>
<tr class="memitem:a92f5d5fd9284780d6ad2df61c0126de1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1CustomComponentVectorHandle.html">CustomComponentVectorHandle</a>&lt; K &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvcl_1_1mesh_1_1VertexContainer.html#a92f5d5fd9284780d6ad2df61c0126de1">perVertexCustomComponentVectorHandle</a> (<a class="el" href="classvcl_1_1Segment.html">const</a> std::string &amp;name)</td></tr>
<tr class="memdesc:a92f5d5fd9284780d6ad2df61c0126de1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector handle to the custom component having the type K and the given name.  <br /></td></tr>
<tr class="separator:a92f5d5fd9284780d6ad2df61c0126de1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a481934735302d0c88583f6d6ab44dc8f" id="r_a481934735302d0c88583f6d6ab44dc8f"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classvcl_1_1Segment.html">typename</a> K &gt; <br />
requires vert::HasCustomComponents&lt;T&gt;</td></tr>
<tr class="memitem:a481934735302d0c88583f6d6ab44dc8f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Segment.html">ConstCustomComponentVectorHandle</a>&lt; K &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvcl_1_1mesh_1_1VertexContainer.html#a481934735302d0c88583f6d6ab44dc8f">perVertexCustomComponentVectorHandle</a> (<a class="el" href="classvcl_1_1Segment.html">const</a> std::string &amp;name) <a class="el" href="classvcl_1_1Segment.html">const</a></td></tr>
<tr class="memdesc:a481934735302d0c88583f6d6ab44dc8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const vector handle to the custom component having type K and the given name.  <br /></td></tr>
<tr class="separator:a481934735302d0c88583f6d6ab44dc8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-types" name="pri-types"></a>
Private Types</h2></td></tr>
<tr class="memitem:a3682e84f026e1fd9cbfbb7271eca30a6" id="r_a3682e84f026e1fd9cbfbb7271eca30a6"><td class="memItemLeft" align="right" valign="top"><a id="a3682e84f026e1fd9cbfbb7271eca30a6" name="a3682e84f026e1fd9cbfbb7271eca30a6"></a>
<a class="el" href="classvcl_1_1Segment.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><b>VertexContainerType</b> = <a class="el" href="classvcl_1_1mesh_1_1VertexContainer.html">VertexContainer</a>&lt; T &gt;</td></tr>
<tr class="separator:a3682e84f026e1fd9cbfbb7271eca30a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d035808caa404ad8aefe6f1c929ffac" id="r_a7d035808caa404ad8aefe6f1c929ffac"><td class="memItemLeft" align="right" valign="top"><a id="a7d035808caa404ad8aefe6f1c929ffac" name="a7d035808caa404ad8aefe6f1c929ffac"></a>
<a class="el" href="classvcl_1_1Segment.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Base</b> = <a class="el" href="classvcl_1_1mesh_1_1ElementContainer.html">ElementContainer</a>&lt; T &gt;</td></tr>
<tr class="separator:a7d035808caa404ad8aefe6f1c929ffac"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;VertexConcept T&gt;<br />
class vcl::mesh::VertexContainer&lt; T &gt;</div><p>The <a class="el" href="classvcl_1_1Vertex.html" title="The Vertex class represents an Vertex element of the vcl::Mesh class.">Vertex</a> Container class, will be used when the template argument given to the <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a> is a <a class="el" href="classvcl_1_1Vertex.html" title="The Vertex class represents an Vertex element of the vcl::Mesh class.">Vertex</a>. </p>
<p>This class adds a container (vector) of vertices to the <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>, making available the accessors members to the vertices, the vertex number, iterators... This class will also take care to add enablers/disablers of the eventual optional components of the vertex.</p>
<p>This container can be templated on a type that satisfies the VertexConcept concept. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a7fef9e15ba6e654141ec74041369b87e" name="a7fef9e15ba6e654141ec74041369b87e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fef9e15ba6e654141ec74041369b87e">&#9670;&#160;</a></span>addPerVertexCustomComponent()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;VertexConcept T&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classvcl_1_1Segment.html">typename</a> K &gt; <br />
requires vert::HasCustomComponents&lt;T&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Segment.html">void</a> <a class="el" href="classvcl_1_1mesh_1_1VertexContainer.html">vcl::mesh::VertexContainer</a>&lt; T &gt;::addPerVertexCustomComponent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Segment.html">const</a> std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a custom component of type K to the <a class="el" href="classvcl_1_1Vertex.html" title="The Vertex class represents an Vertex element of the vcl::Mesh class.">Vertex</a>, having the given name. </p>
<dl class="section note"><dt>Note</dt><dd>This function is available only if the <a class="el" href="classvcl_1_1Vertex.html" title="The Vertex class represents an Vertex element of the vcl::Mesh class.">Vertex</a> <a class="el" href="classvcl_1_1Element.html" title="The Element class.">Element</a> has the CustomComponents Component.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">K</td><td>the type of the custom component added to the <a class="el" href="classvcl_1_1Vertex.html" title="The Vertex class represents an Vertex element of the vcl::Mesh class.">Vertex</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>the name of the custom component added to the <a class="el" href="classvcl_1_1Vertex.html" title="The Vertex class represents an Vertex element of the vcl::Mesh class.">Vertex</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a98f6b97063334e7dcc0a8abb3bcb6c27" name="a98f6b97063334e7dcc0a8abb3bcb6c27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98f6b97063334e7dcc0a8abb3bcb6c27">&#9670;&#160;</a></span>addVertex() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;VertexConcept T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Segment.html">uint</a> <a class="el" href="classvcl_1_1mesh_1_1VertexContainer.html">vcl::mesh::VertexContainer</a>&lt; T &gt;::addVertex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a new vertex into the vertex container, returning the index of the added vertex. </p>
<p>If the call of this function will cause a reallocation of the <a class="el" href="classvcl_1_1Vertex.html" title="The Vertex class represents an Vertex element of the vcl::Mesh class.">Vertex</a> container, the function will automatically take care of updating all the <a class="el" href="classvcl_1_1Vertex.html" title="The Vertex class represents an Vertex element of the vcl::Mesh class.">Vertex</a> pointers contained in the <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>the index of the new vertex. </dd></dl>

</div>
</div>
<a id="a36f2757fafafd2cd6ddb0676127a169a" name="a36f2757fafafd2cd6ddb0676127a169a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36f2757fafafd2cd6ddb0676127a169a">&#9670;&#160;</a></span>addVertex() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;VertexConcept T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Segment.html">uint</a> <a class="el" href="classvcl_1_1mesh_1_1VertexContainer.html">vcl::mesh::VertexContainer</a>&lt; T &gt;::addVertex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Segment.html">const</a> <a class="el" href="classvcl_1_1Segment.html">typename</a> T::CoordType &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a new vertex with the given coordinate into the vertex container, returning the id of the added vertex. </p>
<p>If the call of this function will cause a reallocation of the <a class="el" href="classvcl_1_1Vertex.html" title="The Vertex class represents an Vertex element of the vcl::Mesh class.">Vertex</a> container, the function will automatically take care of updating all the <a class="el" href="classvcl_1_1Vertex.html" title="The Vertex class represents an Vertex element of the vcl::Mesh class.">Vertex</a> pointers contained in the <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>coordinate of the new vertex. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the id of the new vertex. </dd></dl>

</div>
</div>
<a id="a5313b9f5e7858b360c07fe689ea89d06" name="a5313b9f5e7858b360c07fe689ea89d06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5313b9f5e7858b360c07fe689ea89d06">&#9670;&#160;</a></span>addVertices() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;VertexConcept T&gt; </div>
<div class="memtemplate">
template&lt;typename... VC&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Segment.html">uint</a> <a class="el" href="classvcl_1_1mesh_1_1VertexContainer.html">vcl::mesh::VertexContainer</a>&lt; T &gt;::addVertices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Segment.html">const</a> <a class="el" href="classvcl_1_1Segment.html">typename</a> T::CoordType &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Segment.html">const</a> <a class="el" href="classvcl_1_1Segment.html">VC</a> &amp;...&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add an arbitrary number of vertices with the given coordinates, returning the id of the first added vertex. </p>
<p>You can call this member function like:</p>
<div class="fragment"><div class="line">CoordType p0, p1, <a class="code hl_class" href="classvcl_1_1Segment.html">p2</a>, <a class="code hl_class" href="classvcl_1_1Segment.html">p3</a>;</div>
<div class="line"><span class="comment">// init coords...</span></div>
<div class="line"><a class="code hl_class" href="classvcl_1_1Segment.html">m</a>.addVertices(p0, p1, <a class="code hl_class" href="classvcl_1_1Segment.html">p2</a>, <a class="code hl_class" href="classvcl_1_1Segment.html">p3</a>);</div>
<div class="ttc" id="aclassvcl_1_1Segment_html"><div class="ttname"><a href="classvcl_1_1Segment.html">vcl::Segment</a></div><div class="ttdoc">A class representing a line segment in n-dimensional space. The class is parameterized by a PointConc...</div><div class="ttdef"><b>Definition</b> segment.h:43</div></div>
</div><!-- fragment --><p>The number of accepted Coordtype arguments is variable.</p>
<p>If the call of this function will cause a reallocation of the <a class="el" href="classvcl_1_1Vertex.html" title="The Vertex class represents an Vertex element of the vcl::Mesh class.">Vertex</a> container, the function will automatically take care of updating all the <a class="el" href="classvcl_1_1Vertex.html" title="The Vertex class represents an Vertex element of the vcl::Mesh class.">Vertex</a> pointers contained in the <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>first vertex coordinate </td></tr>
    <tr><td class="paramname">v</td><td>list of other vertex coordinates </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the id of the first added vertex. </dd></dl>

</div>
</div>
<a id="a07f082b3515679742c1cf13d410cb1eb" name="a07f082b3515679742c1cf13d410cb1eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07f082b3515679742c1cf13d410cb1eb">&#9670;&#160;</a></span>addVertices() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;VertexConcept T&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="conceptvcl_1_1Range.html">vcl::Range</a> R&gt; <br />
requires RangeOf&lt;R, <a class="el" href="classvcl_1_1Segment.html">typename</a> T::CoordType&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Segment.html">uint</a> <a class="el" href="classvcl_1_1mesh_1_1VertexContainer.html">vcl::mesh::VertexContainer</a>&lt; T &gt;::addVertices </td>
          <td>(</td>
          <td class="paramtype">R &amp;&amp;&#160;</td>
          <td class="paramname"><em>range</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add an arbitrary number of vertices with the coordinates contained in the given range, returning the id of the first added vertex. </p>
<p>If the call of this function will cause a reallocation of the <a class="el" href="classvcl_1_1Vertex.html" title="The Vertex class represents an Vertex element of the vcl::Mesh class.">Vertex</a> container, the function will automatically take care of updating all the <a class="el" href="classvcl_1_1Vertex.html" title="The Vertex class represents an Vertex element of the vcl::Mesh class.">Vertex</a> pointers contained in the <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">range</td><td>the range of coordinates of the vertices to add. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the id of the first added vertex. </dd></dl>

</div>
</div>
<a id="a9344364538cdfdc22a1db65a53debaf5" name="a9344364538cdfdc22a1db65a53debaf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9344364538cdfdc22a1db65a53debaf5">&#9670;&#160;</a></span>addVertices() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;VertexConcept T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Segment.html">uint</a> <a class="el" href="classvcl_1_1mesh_1_1VertexContainer.html">vcl::mesh::VertexContainer</a>&lt; T &gt;::addVertices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Segment.html">uint</a>&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add an arbitrary number of n vertices, returning the id of the first added vertex. </p>
<p>This means that, if you want to add 5 vertices and this member function returns 4, the added vertices will have id from 4 to id 8 included.</p>
<p>If the call of this function will cause a reallocation of the <a class="el" href="classvcl_1_1Vertex.html" title="The Vertex class represents an Vertex element of the vcl::Mesh class.">Vertex</a> container, the function will automatically take care of updating all the <a class="el" href="classvcl_1_1Vertex.html" title="The Vertex class represents an Vertex element of the vcl::Mesh class.">Vertex</a> pointers contained in the <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the number of vertices to add to the mesh. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the id of the first added vertex. </dd></dl>

</div>
</div>
<a id="a2862b33e9651ea6ba0d5746ed3bc7b78" name="a2862b33e9651ea6ba0d5746ed3bc7b78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2862b33e9651ea6ba0d5746ed3bc7b78">&#9670;&#160;</a></span>clearVertices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;VertexConcept T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Segment.html">void</a> <a class="el" href="classvcl_1_1mesh_1_1VertexContainer.html">vcl::mesh::VertexContainer</a>&lt; T &gt;::clearVertices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clears the <a class="el" href="classvcl_1_1Vertex.html" title="The Vertex class represents an Vertex element of the vcl::Mesh class.">Vertex</a> container of the <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>, deleting all the vertices. </p>
<p>The contained vertices are actually removed from the container, not only marked as deleted. Therefore, the container will have size 0 (<code><a class="el" href="classvcl_1_1mesh_1_1VertexContainer.html#ab89515980efa65095d8318720a8ff4d3" title="Returns the number of vertices (also deleted) contained in the Vertex container of the Mesh.">vertexContainerSize()</a> == 0</code>) after the call of this function.</p>
<dl class="section note"><dt>Note</dt><dd>This function does not cause a reallocation of the <a class="el" href="classvcl_1_1Vertex.html" title="The Vertex class represents an Vertex element of the vcl::Mesh class.">Vertex</a> container.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Any pointer to vertices in the <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a> will be left unchanged, and therefore will point to invalid vertices. This means that, if you have a pointer to a vertex and you call this function, you will have a dangling pointer. </dd></dl>

</div>
</div>
<a id="ae9313879921d09c88ab805a2efaf8e31" name="ae9313879921d09c88ab805a2efaf8e31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9313879921d09c88ab805a2efaf8e31">&#9670;&#160;</a></span>deletedVertexNumber()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;VertexConcept T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Segment.html">uint</a> <a class="el" href="classvcl_1_1mesh_1_1VertexContainer.html">vcl::mesh::VertexContainer</a>&lt; T &gt;::deletedVertexNumber </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of deleted vertices in the <a class="el" href="classvcl_1_1Vertex.html" title="The Vertex class represents an Vertex element of the vcl::Mesh class.">Vertex</a> container, that is <a class="el" href="classvcl_1_1mesh_1_1VertexContainer.html#ab89515980efa65095d8318720a8ff4d3" title="Returns the number of vertices (also deleted) contained in the Vertex container of the Mesh.">vertexContainerSize()</a> - <a class="el" href="classvcl_1_1mesh_1_1VertexContainer.html#a7c9be0bf45c7d2b18356181591bbb3ee" title="Returns the number of non-deleted vertices contained in the Vertex container of the Mesh.">vertexNumber()</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of deleted vertices in the container. </dd></dl>

</div>
</div>
<a id="a69492022fa918c736ddb8c8caffa4851" name="a69492022fa918c736ddb8c8caffa4851"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69492022fa918c736ddb8c8caffa4851">&#9670;&#160;</a></span>deletePerVertexCustomComponent()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;VertexConcept T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Segment.html">void</a> <a class="el" href="classvcl_1_1mesh_1_1VertexContainer.html">vcl::mesh::VertexContainer</a>&lt; T &gt;::deletePerVertexCustomComponent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Segment.html">const</a> std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes the custom component of the given name from the <a class="el" href="classvcl_1_1Vertex.html" title="The Vertex class represents an Vertex element of the vcl::Mesh class.">Vertex</a> <a class="el" href="classvcl_1_1Element.html" title="The Element class.">Element</a>. </p>
<p>The function does nothing if the custom component does not exists.</p>
<dl class="section note"><dt>Note</dt><dd>This function is available only if the <a class="el" href="classvcl_1_1Vertex.html" title="The Vertex class represents an Vertex element of the vcl::Mesh class.">Vertex</a> <a class="el" href="classvcl_1_1Element.html" title="The Element class.">Element</a> has the CustomComponents Component.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>the name of the custom component that will be removed from the <a class="el" href="classvcl_1_1Vertex.html" title="The Vertex class represents an Vertex element of the vcl::Mesh class.">Vertex</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afeecaf670815757658735a763ab28416" name="afeecaf670815757658735a763ab28416"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afeecaf670815757658735a763ab28416">&#9670;&#160;</a></span>deleteVertex() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;VertexConcept T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Segment.html">void</a> <a class="el" href="classvcl_1_1mesh_1_1VertexContainer.html">vcl::mesh::VertexContainer</a>&lt; T &gt;::deleteVertex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Segment.html">const</a> VertexType *&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Marks as deleted the given vertex, before asserting that the vertex belongs to this container. </p>
<p>This member function does not perform any reallocation of the vertices: the deleted vertices will stay in the <a class="el" href="classvcl_1_1Vertex.html" title="The Vertex class represents an Vertex element of the vcl::Mesh class.">Vertex</a> Container, but will be marked as deleted.</p>
<p>Deleted vertices are automatically jumped by the iterators provided by the <a class="el" href="classvcl_1_1Vertex.html" title="The Vertex class represents an Vertex element of the vcl::Mesh class.">Vertex</a> Container.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>the pointer of the vertex that will be marked as deleted. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1e6b1482fa3de582b71011466bafe452" name="a1e6b1482fa3de582b71011466bafe452"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e6b1482fa3de582b71011466bafe452">&#9670;&#160;</a></span>deleteVertex() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;VertexConcept T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Segment.html">void</a> <a class="el" href="classvcl_1_1mesh_1_1VertexContainer.html">vcl::mesh::VertexContainer</a>&lt; T &gt;::deleteVertex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Segment.html">uint</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Marks as deleted the vertex with the given id. </p>
<p>This member function does not perform any reallocation of the vertices: the deleted vertices will stay in the <a class="el" href="classvcl_1_1Vertex.html" title="The Vertex class represents an Vertex element of the vcl::Mesh class.">Vertex</a> Container, but will be marked as deleted.</p>
<p>Deleted vertices are automatically jumped by the iterators provided by the <a class="el" href="classvcl_1_1Vertex.html" title="The Vertex class represents an Vertex element of the vcl::Mesh class.">Vertex</a> Container.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>the id of the vertex that will be marked as deleted. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab8dfc6237f1fa5217ee19ea7dc7281ed" name="ab8dfc6237f1fa5217ee19ea7dc7281ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8dfc6237f1fa5217ee19ea7dc7281ed">&#9670;&#160;</a></span>disablePerVertexAdjacentEdges()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;VertexConcept T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Segment.html">void</a> <a class="el" href="classvcl_1_1mesh_1_1VertexContainer.html">vcl::mesh::VertexContainer</a>&lt; T &gt;::disablePerVertexAdjacentEdges </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Disables the Optional Adjacent Edges of the vertex. </p>
<dl class="section note"><dt>Note</dt><dd>This function is available only if the <a class="el" href="classvcl_1_1Vertex.html" title="The Vertex class represents an Vertex element of the vcl::Mesh class.">Vertex</a> <a class="el" href="classvcl_1_1Element.html" title="The Element class.">Element</a> has the OptionalAdjacentEdges Component. </dd></dl>

</div>
</div>
<a id="a4a1af41e20543fd9087181a695ea43b7" name="a4a1af41e20543fd9087181a695ea43b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a1af41e20543fd9087181a695ea43b7">&#9670;&#160;</a></span>disablePerVertexAdjacentFaces()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;VertexConcept T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Segment.html">void</a> <a class="el" href="classvcl_1_1mesh_1_1VertexContainer.html">vcl::mesh::VertexContainer</a>&lt; T &gt;::disablePerVertexAdjacentFaces </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Disables the Optional Adjacent Faces of the vertex. </p>
<dl class="section note"><dt>Note</dt><dd>This function is available only if the <a class="el" href="classvcl_1_1Vertex.html" title="The Vertex class represents an Vertex element of the vcl::Mesh class.">Vertex</a> <a class="el" href="classvcl_1_1Element.html" title="The Element class.">Element</a> has the OptionalAdjacentFaces Component. </dd></dl>

</div>
</div>
<a id="ac950d9cae73e85a30966fc953ca3ee7b" name="ac950d9cae73e85a30966fc953ca3ee7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac950d9cae73e85a30966fc953ca3ee7b">&#9670;&#160;</a></span>disablePerVertexAdjacentVertices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;VertexConcept T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Segment.html">void</a> <a class="el" href="classvcl_1_1mesh_1_1VertexContainer.html">vcl::mesh::VertexContainer</a>&lt; T &gt;::disablePerVertexAdjacentVertices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Disables the Optional Adjacent Vertices of the vertex. </p>
<dl class="section note"><dt>Note</dt><dd>This function is available only if the <a class="el" href="classvcl_1_1Vertex.html" title="The Vertex class represents an Vertex element of the vcl::Mesh class.">Vertex</a> <a class="el" href="classvcl_1_1Element.html" title="The Element class.">Element</a> has the OptionalAdjacentVertices Component. </dd></dl>

</div>
</div>
<a id="ad029521a2906fb5f3f3373da11deece0" name="ad029521a2906fb5f3f3373da11deece0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad029521a2906fb5f3f3373da11deece0">&#9670;&#160;</a></span>disablePerVertexColor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;VertexConcept T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Segment.html">void</a> <a class="el" href="classvcl_1_1mesh_1_1VertexContainer.html">vcl::mesh::VertexContainer</a>&lt; T &gt;::disablePerVertexColor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Disables the Optional <a class="el" href="classvcl_1_1Color.html" title="The Color class represents a 32 bit color.">Color</a> of the vertex. </p>
<dl class="section note"><dt>Note</dt><dd>This function is available only if the <a class="el" href="classvcl_1_1Vertex.html" title="The Vertex class represents an Vertex element of the vcl::Mesh class.">Vertex</a> <a class="el" href="classvcl_1_1Element.html" title="The Element class.">Element</a> has the OptionalColor Component. </dd></dl>

</div>
</div>
<a id="aca54cee62748e26cb2ada5ac5549c51e" name="aca54cee62748e26cb2ada5ac5549c51e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca54cee62748e26cb2ada5ac5549c51e">&#9670;&#160;</a></span>disablePerVertexMark()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;VertexConcept T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Segment.html">void</a> <a class="el" href="classvcl_1_1mesh_1_1VertexContainer.html">vcl::mesh::VertexContainer</a>&lt; T &gt;::disablePerVertexMark </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Container::disableVertexMark disables the Optional Mark of the vertex. </p>
<dl class="section note"><dt>Note</dt><dd>This function is available only if the <a class="el" href="classvcl_1_1Vertex.html" title="The Vertex class represents an Vertex element of the vcl::Mesh class.">Vertex</a> <a class="el" href="classvcl_1_1Element.html" title="The Element class.">Element</a> has the OptionalMark Component. </dd></dl>

</div>
</div>
<a id="a52df3972de88425fac2f653448d591d1" name="a52df3972de88425fac2f653448d591d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52df3972de88425fac2f653448d591d1">&#9670;&#160;</a></span>disablePerVertexNormal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;VertexConcept T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Segment.html">void</a> <a class="el" href="classvcl_1_1mesh_1_1VertexContainer.html">vcl::mesh::VertexContainer</a>&lt; T &gt;::disablePerVertexNormal </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the vertex Optional <a class="el" href="classvcl_1_1PrincipalCurvature.html" title="The PrincipalCurvature class stores the principal curvature directions and values at a point on a 3D ...">PrincipalCurvature</a> is enabled. </p>
<dl class="section note"><dt>Note</dt><dd>This function is available only if the <a class="el" href="classvcl_1_1Vertex.html" title="The Vertex class represents an Vertex element of the vcl::Mesh class.">Vertex</a> <a class="el" href="classvcl_1_1Element.html" title="The Element class.">Element</a> has the OptionalPrincipalCurvature Component. </dd></dl>

</div>
</div>
<a id="a09cb59aca0a8031521b372605d536939" name="a09cb59aca0a8031521b372605d536939"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09cb59aca0a8031521b372605d536939">&#9670;&#160;</a></span>disablePerVertexPrincipalCurvature()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;VertexConcept T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Segment.html">void</a> <a class="el" href="classvcl_1_1mesh_1_1VertexContainer.html">vcl::mesh::VertexContainer</a>&lt; T &gt;::disablePerVertexPrincipalCurvature </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Disables the Optional <a class="el" href="classvcl_1_1PrincipalCurvature.html" title="The PrincipalCurvature class stores the principal curvature directions and values at a point on a 3D ...">PrincipalCurvature</a> of the vertex. </p>
<dl class="section note"><dt>Note</dt><dd>This function is available only if the <a class="el" href="classvcl_1_1Vertex.html" title="The Vertex class represents an Vertex element of the vcl::Mesh class.">Vertex</a> <a class="el" href="classvcl_1_1Element.html" title="The Element class.">Element</a> has the OptionalPrincipalCurvature Component. </dd></dl>

</div>
</div>
<a id="a409e11f32dc8e6a245f80b933f42641d" name="a409e11f32dc8e6a245f80b933f42641d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a409e11f32dc8e6a245f80b933f42641d">&#9670;&#160;</a></span>disablePerVertexQuality()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;VertexConcept T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Segment.html">void</a> <a class="el" href="classvcl_1_1mesh_1_1VertexContainer.html">vcl::mesh::VertexContainer</a>&lt; T &gt;::disablePerVertexQuality </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Disables the Optional Quality of the vertex. </p>
<dl class="section note"><dt>Note</dt><dd>This function is available only if the <a class="el" href="classvcl_1_1Vertex.html" title="The Vertex class represents an Vertex element of the vcl::Mesh class.">Vertex</a> <a class="el" href="classvcl_1_1Element.html" title="The Element class.">Element</a> has the OptionalQuality Component. </dd></dl>

</div>
</div>
<a id="a1562776f51491bcd3a5177726bc6b22e" name="a1562776f51491bcd3a5177726bc6b22e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1562776f51491bcd3a5177726bc6b22e">&#9670;&#160;</a></span>disablePerVertexTexCoord()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;VertexConcept T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Segment.html">void</a> <a class="el" href="classvcl_1_1mesh_1_1VertexContainer.html">vcl::mesh::VertexContainer</a>&lt; T &gt;::disablePerVertexTexCoord </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Disables the Optional <a class="el" href="classvcl_1_1TexCoord.html" title="The TexCoord class represents a 2-dimensional texture coordinate containing two scalar values.">TexCoord</a> of the vertex. </p>
<dl class="section note"><dt>Note</dt><dd>This function is available only if the <a class="el" href="classvcl_1_1Vertex.html" title="The Vertex class represents an Vertex element of the vcl::Mesh class.">Vertex</a> <a class="el" href="classvcl_1_1Element.html" title="The Element class.">Element</a> has the OptionalTexCoord Component. </dd></dl>

</div>
</div>
<a id="a1cbb40f7ba6cab1420dbaed157985852" name="a1cbb40f7ba6cab1420dbaed157985852"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cbb40f7ba6cab1420dbaed157985852">&#9670;&#160;</a></span>enablePerVertexAdjacentEdges()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;VertexConcept T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Segment.html">void</a> <a class="el" href="classvcl_1_1mesh_1_1VertexContainer.html">vcl::mesh::VertexContainer</a>&lt; T &gt;::enablePerVertexAdjacentEdges </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enables the Optional Adjacent Edges of the vertex. </p>
<dl class="section note"><dt>Note</dt><dd>This function is available only if the <a class="el" href="classvcl_1_1Vertex.html" title="The Vertex class represents an Vertex element of the vcl::Mesh class.">Vertex</a> <a class="el" href="classvcl_1_1Element.html" title="The Element class.">Element</a> has the OptionalAdjacentEdges Component. </dd></dl>

</div>
</div>
<a id="ac8b07ec4ed52d86a05a0adfa2c84af85" name="ac8b07ec4ed52d86a05a0adfa2c84af85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8b07ec4ed52d86a05a0adfa2c84af85">&#9670;&#160;</a></span>enablePerVertexAdjacentFaces()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;VertexConcept T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Segment.html">void</a> <a class="el" href="classvcl_1_1mesh_1_1VertexContainer.html">vcl::mesh::VertexContainer</a>&lt; T &gt;::enablePerVertexAdjacentFaces </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enables the Optional Adjacent Faces of the vertex. </p>
<dl class="section note"><dt>Note</dt><dd>This function is available only if the <a class="el" href="classvcl_1_1Vertex.html" title="The Vertex class represents an Vertex element of the vcl::Mesh class.">Vertex</a> <a class="el" href="classvcl_1_1Element.html" title="The Element class.">Element</a> has the OptionalAdjacentFaces Component. </dd></dl>

</div>
</div>
<a id="aabf6a1042fddfa786cdfa5e6193a9d4b" name="aabf6a1042fddfa786cdfa5e6193a9d4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabf6a1042fddfa786cdfa5e6193a9d4b">&#9670;&#160;</a></span>enablePerVertexAdjacentVertices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;VertexConcept T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Segment.html">void</a> <a class="el" href="classvcl_1_1mesh_1_1VertexContainer.html">vcl::mesh::VertexContainer</a>&lt; T &gt;::enablePerVertexAdjacentVertices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enables the Optional Adjacent Vertices of the vertex. </p>
<dl class="section note"><dt>Note</dt><dd>This function is available only if the <a class="el" href="classvcl_1_1Vertex.html" title="The Vertex class represents an Vertex element of the vcl::Mesh class.">Vertex</a> <a class="el" href="classvcl_1_1Element.html" title="The Element class.">Element</a> has the OptionalAdjacentVertices Component. </dd></dl>

</div>
</div>
<a id="a794af16726277e3da49e7d3e1c25bae9" name="a794af16726277e3da49e7d3e1c25bae9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a794af16726277e3da49e7d3e1c25bae9">&#9670;&#160;</a></span>enablePerVertexColor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;VertexConcept T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Segment.html">void</a> <a class="el" href="classvcl_1_1mesh_1_1VertexContainer.html">vcl::mesh::VertexContainer</a>&lt; T &gt;::enablePerVertexColor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enables the Optional <a class="el" href="classvcl_1_1Color.html" title="The Color class represents a 32 bit color.">Color</a> of the vertex. </p>
<dl class="section note"><dt>Note</dt><dd>This function is available only if the <a class="el" href="classvcl_1_1Vertex.html" title="The Vertex class represents an Vertex element of the vcl::Mesh class.">Vertex</a> <a class="el" href="classvcl_1_1Element.html" title="The Element class.">Element</a> has the OptionalColor Component. </dd></dl>

</div>
</div>
<a id="ac072db473a48666dcab2c768b73db5af" name="ac072db473a48666dcab2c768b73db5af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac072db473a48666dcab2c768b73db5af">&#9670;&#160;</a></span>enablePerVertexMark()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;VertexConcept T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Segment.html">void</a> <a class="el" href="classvcl_1_1mesh_1_1VertexContainer.html">vcl::mesh::VertexContainer</a>&lt; T &gt;::enablePerVertexMark </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enables the Optional Mark of the vertex. </p>
<dl class="section note"><dt>Note</dt><dd>This function is available only if the <a class="el" href="classvcl_1_1Vertex.html" title="The Vertex class represents an Vertex element of the vcl::Mesh class.">Vertex</a> <a class="el" href="classvcl_1_1Element.html" title="The Element class.">Element</a> has the OptionalMark Component. </dd></dl>

</div>
</div>
<a id="ab783b9004ccf5d9d7139cc00f3cd8f1f" name="ab783b9004ccf5d9d7139cc00f3cd8f1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab783b9004ccf5d9d7139cc00f3cd8f1f">&#9670;&#160;</a></span>enablePerVertexNormal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;VertexConcept T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Segment.html">void</a> <a class="el" href="classvcl_1_1mesh_1_1VertexContainer.html">vcl::mesh::VertexContainer</a>&lt; T &gt;::enablePerVertexNormal </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enables the Optional Normal of the vertex. </p>
<dl class="section note"><dt>Note</dt><dd>This function is available only if the <a class="el" href="classvcl_1_1Vertex.html" title="The Vertex class represents an Vertex element of the vcl::Mesh class.">Vertex</a> <a class="el" href="classvcl_1_1Element.html" title="The Element class.">Element</a> has the OptionalNormal Component. </dd></dl>

</div>
</div>
<a id="a95260476863abed20aa57e13a78d0536" name="a95260476863abed20aa57e13a78d0536"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95260476863abed20aa57e13a78d0536">&#9670;&#160;</a></span>enablePerVertexPrincipalCurvature()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;VertexConcept T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Segment.html">void</a> <a class="el" href="classvcl_1_1mesh_1_1VertexContainer.html">vcl::mesh::VertexContainer</a>&lt; T &gt;::enablePerVertexPrincipalCurvature </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enables the Optional <a class="el" href="classvcl_1_1PrincipalCurvature.html" title="The PrincipalCurvature class stores the principal curvature directions and values at a point on a 3D ...">PrincipalCurvature</a> of the vertex. </p>
<dl class="section note"><dt>Note</dt><dd>This function is available only if the <a class="el" href="classvcl_1_1Vertex.html" title="The Vertex class represents an Vertex element of the vcl::Mesh class.">Vertex</a> <a class="el" href="classvcl_1_1Element.html" title="The Element class.">Element</a> has the OptionalPrincipalCurvature Component. </dd></dl>

</div>
</div>
<a id="aeafc2f71ab1a39d5c4833d559808f542" name="aeafc2f71ab1a39d5c4833d559808f542"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeafc2f71ab1a39d5c4833d559808f542">&#9670;&#160;</a></span>enablePerVertexQuality()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;VertexConcept T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Segment.html">void</a> <a class="el" href="classvcl_1_1mesh_1_1VertexContainer.html">vcl::mesh::VertexContainer</a>&lt; T &gt;::enablePerVertexQuality </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enables the Optional Quality of the vertex. </p>
<dl class="section note"><dt>Note</dt><dd>This function is available only if the <a class="el" href="classvcl_1_1Vertex.html" title="The Vertex class represents an Vertex element of the vcl::Mesh class.">Vertex</a> <a class="el" href="classvcl_1_1Element.html" title="The Element class.">Element</a> has the OptionalQuality Component. </dd></dl>

</div>
</div>
<a id="aabe30468d1779420f6750120091c99eb" name="aabe30468d1779420f6750120091c99eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabe30468d1779420f6750120091c99eb">&#9670;&#160;</a></span>enablePerVertexTexCoord()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;VertexConcept T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Segment.html">void</a> <a class="el" href="classvcl_1_1mesh_1_1VertexContainer.html">vcl::mesh::VertexContainer</a>&lt; T &gt;::enablePerVertexTexCoord </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enables the Optional <a class="el" href="classvcl_1_1TexCoord.html" title="The TexCoord class represents a 2-dimensional texture coordinate containing two scalar values.">TexCoord</a> of the vertex. </p>
<dl class="section note"><dt>Note</dt><dd>This function is available only if the <a class="el" href="classvcl_1_1Vertex.html" title="The Vertex class represents an Vertex element of the vcl::Mesh class.">Vertex</a> <a class="el" href="classvcl_1_1Element.html" title="The Element class.">Element</a> has the OptionalTexCoord Component. </dd></dl>

</div>
</div>
<a id="a62a2797607bc7c06d1e4a8fba79466aa" name="a62a2797607bc7c06d1e4a8fba79466aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62a2797607bc7c06d1e4a8fba79466aa">&#9670;&#160;</a></span>hasPerVertexCustomComponent()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;VertexConcept T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Segment.html">bool</a> <a class="el" href="classvcl_1_1mesh_1_1VertexContainer.html">vcl::mesh::VertexContainer</a>&lt; T &gt;::hasPerVertexCustomComponent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Segment.html">const</a> std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if vertices have a custom component with the given name. </p>
<p>This function does not take into account the type of the custom component.</p>
<dl class="section note"><dt>Note</dt><dd>This function is available only if the <a class="el" href="classvcl_1_1Vertex.html" title="The Vertex class represents an Vertex element of the vcl::Mesh class.">Vertex</a> <a class="el" href="classvcl_1_1Element.html" title="The Element class.">Element</a> has the CustomComponents Component.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the <a class="el" href="classvcl_1_1Vertex.html" title="The Vertex class represents an Vertex element of the vcl::Mesh class.">Vertex</a> <a class="el" href="classvcl_1_1Element.html" title="The Element class.">Element</a> has a custom component with the given name. </dd></dl>

</div>
</div>
<a id="aac4b92349090126a38b76765e4c4023c" name="aac4b92349090126a38b76765e4c4023c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac4b92349090126a38b76765e4c4023c">&#9670;&#160;</a></span>isPerVertexAdjacentEdgesEnabled()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;VertexConcept T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Segment.html">bool</a> <a class="el" href="classvcl_1_1mesh_1_1VertexContainer.html">vcl::mesh::VertexContainer</a>&lt; T &gt;::isPerVertexAdjacentEdgesEnabled </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the vertex Optional Adjacent Edges component is enabled. </p>
<dl class="section note"><dt>Note</dt><dd>This function is available only if the <a class="el" href="classvcl_1_1Vertex.html" title="The Vertex class represents an Vertex element of the vcl::Mesh class.">Vertex</a> <a class="el" href="classvcl_1_1Element.html" title="The Element class.">Element</a> has the OptionalAdjacentEdges Component.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>true if the Optional Adjacent Edges is enabled, false otherwise. </dd></dl>

</div>
</div>
<a id="ac4d3969cc77b89119b3455cc9625b122" name="ac4d3969cc77b89119b3455cc9625b122"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4d3969cc77b89119b3455cc9625b122">&#9670;&#160;</a></span>isPerVertexAdjacentFacesEnabled()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;VertexConcept T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Segment.html">bool</a> <a class="el" href="classvcl_1_1mesh_1_1VertexContainer.html">vcl::mesh::VertexContainer</a>&lt; T &gt;::isPerVertexAdjacentFacesEnabled </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the vertex Optional Adjacent Faces component is enabled. </p>
<dl class="section note"><dt>Note</dt><dd>This function is available only if the <a class="el" href="classvcl_1_1Vertex.html" title="The Vertex class represents an Vertex element of the vcl::Mesh class.">Vertex</a> <a class="el" href="classvcl_1_1Element.html" title="The Element class.">Element</a> has the OptionalAdjacentFaces Component.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>true if the Optional Adjacent Faces is enabled, false otherwise. </dd></dl>

</div>
</div>
<a id="a93e92feeba10d3f7eca9d666a59bf299" name="a93e92feeba10d3f7eca9d666a59bf299"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93e92feeba10d3f7eca9d666a59bf299">&#9670;&#160;</a></span>isPerVertexAdjacentVerticesEnabled()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;VertexConcept T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Segment.html">bool</a> <a class="el" href="classvcl_1_1mesh_1_1VertexContainer.html">vcl::mesh::VertexContainer</a>&lt; T &gt;::isPerVertexAdjacentVerticesEnabled </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the vertex Optional Adjacent Vertices component is enabled. </p>
<dl class="section note"><dt>Note</dt><dd>This function is available **only if the <a class="el" href="classvcl_1_1Vertex.html" title="The Vertex class represents an Vertex element of the vcl::Mesh class.">Vertex</a> <a class="el" href="classvcl_1_1Element.html" title="The Element class.">Element</a> has the OptionalAdjacentVertices Component.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>true if the Optional Adjacent Vertices is enabled, false otherwise. </dd></dl>

</div>
</div>
<a id="a1b042c41437a30e5078d7c1b5a150004" name="a1b042c41437a30e5078d7c1b5a150004"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b042c41437a30e5078d7c1b5a150004">&#9670;&#160;</a></span>isPerVertexColorEnabled()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;VertexConcept T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Segment.html">bool</a> <a class="el" href="classvcl_1_1mesh_1_1VertexContainer.html">vcl::mesh::VertexContainer</a>&lt; T &gt;::isPerVertexColorEnabled </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the vertex Optional <a class="el" href="classvcl_1_1Color.html" title="The Color class represents a 32 bit color.">Color</a> is enabled. </p>
<dl class="section note"><dt>Note</dt><dd>This function is available only if the <a class="el" href="classvcl_1_1Vertex.html" title="The Vertex class represents an Vertex element of the vcl::Mesh class.">Vertex</a> <a class="el" href="classvcl_1_1Element.html" title="The Element class.">Element</a> has the OptionalColor Component.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>true if the Optional <a class="el" href="classvcl_1_1Color.html" title="The Color class represents a 32 bit color.">Color</a> is enabled, false otherwise. </dd></dl>

</div>
</div>
<a id="adb00571719f436731eaa075618e05eda" name="adb00571719f436731eaa075618e05eda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb00571719f436731eaa075618e05eda">&#9670;&#160;</a></span>isPerVertexCustomComponentOfType()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;VertexConcept T&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classvcl_1_1Segment.html">typename</a> K &gt; <br />
requires vert::HasCustomComponents&lt;T&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Segment.html">bool</a> <a class="el" href="classvcl_1_1mesh_1_1VertexContainer.html">vcl::mesh::VertexContainer</a>&lt; T &gt;::isPerVertexCustomComponentOfType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Segment.html">const</a> std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the custom component of the <a class="el" href="classvcl_1_1Vertex.html" title="The Vertex class represents an Vertex element of the vcl::Mesh class.">Vertex</a> <a class="el" href="classvcl_1_1Element.html" title="The Element class.">Element</a> having the given name has the same type of the given template argument type of this function. </p>
<p>For example, the following code checks if the component called <code>cc</code> is of type <code>double</code>: </p><div class="fragment"><div class="line"><span class="keywordflow">if</span> (<a class="code hl_class" href="classvcl_1_1Segment.html">m</a>.isPerVertexCustomComponentOfType&lt;<span class="keywordtype">double</span>&gt;(<span class="stringliteral">&quot;cc&quot;</span>)) {</div>
<div class="line">  ...</div>
<div class="line">}</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>This function is available only if the <a class="el" href="classvcl_1_1Vertex.html" title="The Vertex class represents an Vertex element of the vcl::Mesh class.">Vertex</a> <a class="el" href="classvcl_1_1Element.html" title="The Element class.">Element</a> has the CustomComponents Component.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">K</td><td>the type of the custom component to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>the name of the custom component to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if no custom component of the given name was found. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the custom component is of the same type of the template argument. </dd></dl>

</div>
</div>
<a id="ae6b18107b3e962aeb2eb5de14bcfd386" name="ae6b18107b3e962aeb2eb5de14bcfd386"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6b18107b3e962aeb2eb5de14bcfd386">&#9670;&#160;</a></span>isPerVertexMarkEnabled()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;VertexConcept T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Segment.html">bool</a> <a class="el" href="classvcl_1_1mesh_1_1VertexContainer.html">vcl::mesh::VertexContainer</a>&lt; T &gt;::isPerVertexMarkEnabled </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the vertex Optional Mark is enabled. </p>
<dl class="section note"><dt>Note</dt><dd>This function is available only if the <a class="el" href="classvcl_1_1Vertex.html" title="The Vertex class represents an Vertex element of the vcl::Mesh class.">Vertex</a> <a class="el" href="classvcl_1_1Element.html" title="The Element class.">Element</a> has the OptionalMark Component.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>true if the Optional Mark is enabled, false otherwise. </dd></dl>

</div>
</div>
<a id="ae55646f2ac1ec14b4e3961fe8e5ea0dd" name="ae55646f2ac1ec14b4e3961fe8e5ea0dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae55646f2ac1ec14b4e3961fe8e5ea0dd">&#9670;&#160;</a></span>isPerVertexNormalEnabled()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;VertexConcept T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Segment.html">bool</a> <a class="el" href="classvcl_1_1mesh_1_1VertexContainer.html">vcl::mesh::VertexContainer</a>&lt; T &gt;::isPerVertexNormalEnabled </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the vertex Optional Normal is enabled. </p>
<dl class="section note"><dt>Note</dt><dd>This function is available only if the <a class="el" href="classvcl_1_1Vertex.html" title="The Vertex class represents an Vertex element of the vcl::Mesh class.">Vertex</a> <a class="el" href="classvcl_1_1Element.html" title="The Element class.">Element</a> has the OptionalNormal Component.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>true if the Optional Normal is enabled, false otherwise. </dd></dl>

</div>
</div>
<a id="aa20a89792fce4ad7e545bbe1b61db9af" name="aa20a89792fce4ad7e545bbe1b61db9af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa20a89792fce4ad7e545bbe1b61db9af">&#9670;&#160;</a></span>isPerVertexPrincipalCurvatureEnabled()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;VertexConcept T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Segment.html">bool</a> <a class="el" href="classvcl_1_1mesh_1_1VertexContainer.html">vcl::mesh::VertexContainer</a>&lt; T &gt;::isPerVertexPrincipalCurvatureEnabled </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the vertex Optional <a class="el" href="classvcl_1_1PrincipalCurvature.html" title="The PrincipalCurvature class stores the principal curvature directions and values at a point on a 3D ...">PrincipalCurvature</a> is enabled. </p>
<dl class="section note"><dt>Note</dt><dd>This function is available only if the <a class="el" href="classvcl_1_1Vertex.html" title="The Vertex class represents an Vertex element of the vcl::Mesh class.">Vertex</a> <a class="el" href="classvcl_1_1Element.html" title="The Element class.">Element</a> has the OptionalPrincipalCurvature Component.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>true if the Optional <a class="el" href="classvcl_1_1PrincipalCurvature.html" title="The PrincipalCurvature class stores the principal curvature directions and values at a point on a 3D ...">PrincipalCurvature</a> is enabled, false otherwise. </dd></dl>

</div>
</div>
<a id="a2cba62bf6152dfadd55037304f66f469" name="a2cba62bf6152dfadd55037304f66f469"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cba62bf6152dfadd55037304f66f469">&#9670;&#160;</a></span>isPerVertexQualityEnabled()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;VertexConcept T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Segment.html">bool</a> <a class="el" href="classvcl_1_1mesh_1_1VertexContainer.html">vcl::mesh::VertexContainer</a>&lt; T &gt;::isPerVertexQualityEnabled </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the vertex Optional Quality is enabled. </p>
<dl class="section note"><dt>Note</dt><dd>This function is available only if the <a class="el" href="classvcl_1_1Vertex.html" title="The Vertex class represents an Vertex element of the vcl::Mesh class.">Vertex</a> <a class="el" href="classvcl_1_1Element.html" title="The Element class.">Element</a> has the OptionalQuality Component.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>true if the Optional Quality is enabled, false otherwise. </dd></dl>

</div>
</div>
<a id="ad7d9136be92e3c1c3b78655627182618" name="ad7d9136be92e3c1c3b78655627182618"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7d9136be92e3c1c3b78655627182618">&#9670;&#160;</a></span>isPerVertexTexCoordEnabled()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;VertexConcept T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Segment.html">bool</a> <a class="el" href="classvcl_1_1mesh_1_1VertexContainer.html">vcl::mesh::VertexContainer</a>&lt; T &gt;::isPerVertexTexCoordEnabled </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the vertex Optional <a class="el" href="classvcl_1_1TexCoord.html" title="The TexCoord class represents a 2-dimensional texture coordinate containing two scalar values.">TexCoord</a> is enabled. </p>
<dl class="section note"><dt>Note</dt><dd>This function is available only if the <a class="el" href="classvcl_1_1Vertex.html" title="The Vertex class represents an Vertex element of the vcl::Mesh class.">Vertex</a> <a class="el" href="classvcl_1_1Element.html" title="The Element class.">Element</a> has the OptionalTexCoord Component.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>true if the Optional <a class="el" href="classvcl_1_1TexCoord.html" title="The TexCoord class represents a 2-dimensional texture coordinate containing two scalar values.">TexCoord</a> is enabled, false otherwise. </dd></dl>

</div>
</div>
<a id="a472ccf650986d2f46e6cd2cfb3cc9780" name="a472ccf650986d2f46e6cd2cfb3cc9780"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a472ccf650986d2f46e6cd2cfb3cc9780">&#9670;&#160;</a></span>perVertexCustomComponentNames()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;VertexConcept T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; <a class="el" href="classvcl_1_1mesh_1_1VertexContainer.html">vcl::mesh::VertexContainer</a>&lt; T &gt;::perVertexCustomComponentNames </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a vector containing all the names of the custom components of any type associated to the <a class="el" href="classvcl_1_1Vertex.html" title="The Vertex class represents an Vertex element of the vcl::Mesh class.">Vertex</a> <a class="el" href="classvcl_1_1Element.html" title="The Element class.">Element</a>. </p>
<dl class="section note"><dt>Note</dt><dd>This function is available only if the <a class="el" href="classvcl_1_1Vertex.html" title="The Vertex class represents an Vertex element of the vcl::Mesh class.">Vertex</a> <a class="el" href="classvcl_1_1Element.html" title="The Element class.">Element</a> has the CustomComponents Component.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of strings representing all the names of the custom components. </dd></dl>

</div>
</div>
<a id="ab747bd4c58cd3fea6643586be65f2428" name="ab747bd4c58cd3fea6643586be65f2428"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab747bd4c58cd3fea6643586be65f2428">&#9670;&#160;</a></span>perVertexCustomComponentNamesOfType()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;VertexConcept T&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classvcl_1_1Segment.html">typename</a> K &gt; <br />
requires vert::HasCustomComponents&lt;T&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; <a class="el" href="classvcl_1_1mesh_1_1VertexContainer.html">vcl::mesh::VertexContainer</a>&lt; T &gt;::perVertexCustomComponentNamesOfType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a vector containing all the names of the custom components associated to the <a class="el" href="classvcl_1_1Vertex.html" title="The Vertex class represents an Vertex element of the vcl::Mesh class.">Vertex</a> <a class="el" href="classvcl_1_1Element.html" title="The Element class.">Element</a> having the same type of the given template argument type of this function. </p>
<p>For example, the following code gets a vector containing all the custom components of type <code>double</code>: </p><div class="fragment"><div class="line">std::vector&lt;std::string&gt; <a class="code hl_class" href="classvcl_1_1Segment.html">cdouble</a> =</div>
<div class="line"><a class="code hl_class" href="classvcl_1_1Segment.html">m</a>.perVertexCustomComponentNamesOfType&lt;<span class="keywordtype">double</span>&gt;();</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>This function is available only if the <a class="el" href="classvcl_1_1Vertex.html" title="The Vertex class represents an Vertex element of the vcl::Mesh class.">Vertex</a> <a class="el" href="classvcl_1_1Element.html" title="The Element class.">Element</a> has the CustomComponents Component.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">K</td><td>the type of the custom component names. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of strings representing the names of the custom components of a given type. </dd></dl>

</div>
</div>
<a id="a96fc0ff63bda8ac0d2ef3c86e714d5ca" name="a96fc0ff63bda8ac0d2ef3c86e714d5ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96fc0ff63bda8ac0d2ef3c86e714d5ca">&#9670;&#160;</a></span>perVertexCustomComponentType()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;VertexConcept T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::type_index <a class="el" href="classvcl_1_1mesh_1_1VertexContainer.html">vcl::mesh::VertexContainer</a>&lt; T &gt;::perVertexCustomComponentType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Segment.html">const</a> std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the std::type_index of the custom component of the <a class="el" href="classvcl_1_1Vertex.html" title="The Vertex class represents an Vertex element of the vcl::Mesh class.">Vertex</a> <a class="el" href="classvcl_1_1Element.html" title="The Element class.">Element</a> having the given input name. </p>
<dl class="section note"><dt>Note</dt><dd>This function is available only if the <a class="el" href="classvcl_1_1Vertex.html" title="The Vertex class represents an Vertex element of the vcl::Mesh class.">Vertex</a> <a class="el" href="classvcl_1_1Element.html" title="The Element class.">Element</a> has the CustomComponents Component.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>the name of the custom component to get the std::type_index from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if no custom component of the given name was found.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The std::type_index of the custom component having the given input name. </dd></dl>

</div>
</div>
<a id="a92f5d5fd9284780d6ad2df61c0126de1" name="a92f5d5fd9284780d6ad2df61c0126de1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92f5d5fd9284780d6ad2df61c0126de1">&#9670;&#160;</a></span>perVertexCustomComponentVectorHandle() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;VertexConcept T&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classvcl_1_1Segment.html">typename</a> K &gt; <br />
requires vert::HasCustomComponents&lt;T&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1CustomComponentVectorHandle.html">CustomComponentVectorHandle</a>&lt; K &gt; <a class="el" href="classvcl_1_1mesh_1_1VertexContainer.html">vcl::mesh::VertexContainer</a>&lt; T &gt;::perVertexCustomComponentVectorHandle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Segment.html">const</a> std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a vector handle to the custom component having the type K and the given name. </p>
<p>The handle can be used like a normal std::vector, but does not have access to the modifiers member functions (resize, push_back...). The handle contains <b>references</b> to the custom component, therefore you can modify the custom component by modifying the element of the handle vector normally. Since the handle stores references, there are no copies performed when calling this function.</p>
<p>For example, assuming that the mesh has a vertex custom component named "cc" of type int:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> handle = <a class="code hl_class" href="classvcl_1_1Segment.html">m</a>.perVertexCustomComponentVectorHandle&lt;<span class="keywordtype">int</span>&gt;(<span class="stringliteral">&quot;cc&quot;</span>);</div>
<div class="line"><span class="keywordflow">for</span> (Vertex&amp; v : <a class="code hl_class" href="classvcl_1_1Segment.html">m</a>.<a class="code hl_function" href="classvcl_1_1mesh_1_1VertexContainer.html#a1aac0c075f3ff34ab9efa083ff1fd4e8">vertices</a>() {</div>
<div class="line">   handle[<a class="code hl_class" href="classvcl_1_1Segment.html">m</a>.index(v)] = 5; <span class="comment">// v.customComponent&lt;int&gt;(&quot;cc&quot;) == 5</span></div>
<div class="line">   <a class="code hl_class" href="classvcl_1_1Segment.html">assert</a>(v.customComponent&lt;<span class="keywordtype">int</span>&gt;(<span class="stringliteral">&quot;cc&quot;</span>) == 5);</div>
<div class="line">}</div>
<div class="ttc" id="aclassvcl_1_1mesh_1_1VertexContainer_html_a1aac0c075f3ff34ab9efa083ff1fd4e8"><div class="ttname"><a href="classvcl_1_1mesh_1_1VertexContainer.html#a1aac0c075f3ff34ab9efa083ff1fd4e8">vcl::mesh::VertexContainer::vertices</a></div><div class="ttdeci">auto vertices(bool jumpDeleted=true)</div><div class="ttdoc">Returns a small utility object that allows to iterate over the vertices of the containers,...</div><div class="ttdef"><b>Definition</b> vertex_container.h:462</div></div>
</div><!-- fragment --><p>Using handles allows to access more efficiently to custom components rather accessing from an element object. However, note that references are binded to the container of the mesh.</p>
<dl class="section note"><dt>Note</dt><dd>This function is available only if the <a class="el" href="classvcl_1_1Vertex.html" title="The Vertex class represents an Vertex element of the vcl::Mesh class.">Vertex</a> <a class="el" href="classvcl_1_1Element.html" title="The Element class.">Element</a> has the CustomComponents Component.</dd>
<dd>
Since the handle contains references, any operation that changes the size of the container could be destructive and invalidate the references contained in the handle.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">K</td><td>the type of the custom component on which return the handle.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>name of the custom component on which return the handle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if no custom component of the given name was found.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector handle that allows to access to the custom component. </dd></dl>

</div>
</div>
<a id="a481934735302d0c88583f6d6ab44dc8f" name="a481934735302d0c88583f6d6ab44dc8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a481934735302d0c88583f6d6ab44dc8f">&#9670;&#160;</a></span>perVertexCustomComponentVectorHandle() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;VertexConcept T&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classvcl_1_1Segment.html">typename</a> K &gt; <br />
requires vert::HasCustomComponents&lt;T&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Segment.html">ConstCustomComponentVectorHandle</a>&lt; K &gt; <a class="el" href="classvcl_1_1mesh_1_1VertexContainer.html">vcl::mesh::VertexContainer</a>&lt; T &gt;::perVertexCustomComponentVectorHandle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Segment.html">const</a> std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a const vector handle to the custom component having type K and the given name. </p>
<p>The handle can be used like a normal std::vector, but does not have access to the modifiers member functions (resize, push_back...). The handle contains <b>const references</b> to the custom component, therefore you can access to the custom component by accessing the element of the handle vector normally. Since the handle stores references, there are no copies performed when calling this function.</p>
<p>For example, assuming that the mesh has a vertex custom component named "cc" of type int:</p>
<div class="fragment"><div class="line"><span class="comment">// access to the const handle by making const the template parameter:</span></div>
<div class="line"><span class="keyword">auto</span> handle = <a class="code hl_class" href="classvcl_1_1Segment.html">m</a>.perVertexCustomComponentVectorHandle&lt;<span class="keyword">const</span> <span class="keywordtype">int</span>&gt;(<span class="stringliteral">&quot;cc&quot;</span>);</div>
<div class="line"><span class="keywordtype">int</span> sum = 0;</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> Vertex&amp; v : <a class="code hl_class" href="classvcl_1_1Segment.html">m</a>.<a class="code hl_function" href="classvcl_1_1mesh_1_1VertexContainer.html#a1aac0c075f3ff34ab9efa083ff1fd4e8">vertices</a>() {</div>
<div class="line">   sum += handle[<a class="code hl_class" href="classvcl_1_1Segment.html">m</a>.index(v)];</div>
<div class="line">   <span class="comment">// handle[m.index(v)] = 5; // not allowed, because the handle is const</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>Using handles allows to access more efficiently to custom components rather accessing from an element object. However, note that references are binded to the container of the mesh.</p>
<dl class="section note"><dt>Note</dt><dd>This function is available only if the <a class="el" href="classvcl_1_1Vertex.html" title="The Vertex class represents an Vertex element of the vcl::Mesh class.">Vertex</a> <a class="el" href="classvcl_1_1Element.html" title="The Element class.">Element</a> has the CustomComponents Component.</dd>
<dd>
Since the handle contains references, any operation that changes the size of the container could be destructive and invalidate the references contained in the handle.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">K</td><td>the type of the custom component on which return the handle.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>name of the custom component on which return the handle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if no custom component of the given name was found.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a const vector handle that allows to access to the custom component. </dd></dl>

</div>
</div>
<a id="ad248e4d4a2ef91ef0173ce33935c7846" name="ad248e4d4a2ef91ef0173ce33935c7846"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad248e4d4a2ef91ef0173ce33935c7846">&#9670;&#160;</a></span>reserveVertices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;VertexConcept T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Segment.html">void</a> <a class="el" href="classvcl_1_1mesh_1_1VertexContainer.html">vcl::mesh::VertexContainer</a>&lt; T &gt;::reserveVertices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Segment.html">uint</a>&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reserve a number of vertices in the container of Vertices. This is useful when you know (or you have an idea) of how much vertices are going to add into a newly or existing mesh. Calling this function before any add_vertex() call will avoid unuseful reallocations of the container, saving execution time. </p>
<p>The filosofy of this function is similar to the one of the <a href="https://en.cppreference.com/w/cpp/container/vector/reserve">reserve()</a> function of the <a href="https://en.cppreference.com/w/cpp/container/vector">std::vector class</a>.</p>
<p>If the call of this function will cause a reallocation of the <a class="el" href="classvcl_1_1Vertex.html" title="The Vertex class represents an Vertex element of the vcl::Mesh class.">Vertex</a> container, the function will automatically take care of updating all the <a class="el" href="classvcl_1_1Vertex.html" title="The Vertex class represents an Vertex element of the vcl::Mesh class.">Vertex</a> pointers contained in the <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the new capacity of the vertex container. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a54e1446a592f06ce15b2343c20a79aad" name="a54e1446a592f06ce15b2343c20a79aad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54e1446a592f06ce15b2343c20a79aad">&#9670;&#160;</a></span>resizeVertices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;VertexConcept T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Segment.html">void</a> <a class="el" href="classvcl_1_1mesh_1_1VertexContainer.html">vcl::mesh::VertexContainer</a>&lt; T &gt;::resizeVertices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Segment.html">uint</a>&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resizes the <a class="el" href="classvcl_1_1Vertex.html" title="The Vertex class represents an Vertex element of the vcl::Mesh class.">Vertex</a> container to contain <code>n</code> vertices. </p>
<p>If the new size is greater than the old one, new vertices are added to the container, and a reallocation may happen. If the new size is smaller than the old one, the container will keep its first non-deleted <code>n</code> vertices, and the remaining vertices are marked as deleted.</p>
<p>If the call of this function will cause a reallocation of the <a class="el" href="classvcl_1_1Vertex.html" title="The Vertex class represents an Vertex element of the vcl::Mesh class.">Vertex</a> container, the function will automatically take care of updating all the <a class="el" href="classvcl_1_1Vertex.html" title="The Vertex class represents an Vertex element of the vcl::Mesh class.">Vertex</a> pointers contained in the <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>.</p>
<dl class="section warning"><dt>Warning</dt><dd>The given size <code>n</code> is relative to the number of non-deleted vertices, not to the size of the vertex container. For example, if you have a mesh with 10 vertices and <a class="el" href="classvcl_1_1mesh_1_1VertexContainer.html#ab89515980efa65095d8318720a8ff4d3" title="Returns the number of vertices (also deleted) contained in the Vertex container of the Mesh.">vertexContainerSize()</a> == 20, calling resizeVertices(5) will not cause a reallocation of the container, but will mark as deleted the least 5 non-deleted vertices of the container. In the same scenario, calling resizeVertices(15) will result in a vertex container having 15 vertices and <a class="el" href="classvcl_1_1mesh_1_1VertexContainer.html#ab89515980efa65095d8318720a8ff4d3" title="Returns the number of vertices (also deleted) contained in the Vertex container of the Mesh.">vertexContainerSize()</a> == 25. The latest 5 vertices will be the newly added.</dd>
<dd>
Any pointer to deleted vertices in the <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a> will be left unchanged, and therefore will point to invalid vertices. This means that if you call this member function with a lower number of vertices, you'll need to manually manage the pointers to the deleted vertices.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>the new size of the <a class="el" href="classvcl_1_1Vertex.html" title="The Vertex class represents an Vertex element of the vcl::Mesh class.">Vertex</a> container. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0c89260e14b61963b1dc5ff35217a3da" name="a0c89260e14b61963b1dc5ff35217a3da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c89260e14b61963b1dc5ff35217a3da">&#9670;&#160;</a></span>updateVertexIndices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;VertexConcept T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Segment.html">void</a> <a class="el" href="classvcl_1_1mesh_1_1VertexContainer.html">vcl::mesh::VertexContainer</a>&lt; T &gt;::updateVertexIndices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Segment.html">const</a> std::vector&lt; <a class="el" href="classvcl_1_1Segment.html">uint</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>newIndices</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Updates all the indices and pointers of the vertices of this container that are stored in any container of the mesh, according to the mapping stored in the newIndices vector, that tells for each old vertex index, the new vertex index. </p>
<p>This function is useful when some vertices, and you want to update the indices/pointers stored in all the containers of the mesh accordingly.</p>
<p>E.g. Supposing you deleted a set of vertices, you can give to this function the vector telling, for each of the old vertex indices, the new vertex index (or UINT_NULL if you want to leave it unreferenced). This function will update all the pointers stored in the mesh containers accordingly (if they store adjacencies to the vertices).</p>
<dl class="section note"><dt>Note</dt><dd>This function <em>does not change the position of the vertices in this container</em>. It just updates the indices/pointers of the vertices stored in this or other containers.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">newIndices</td><td>a vector that tells, for each old vertex index, the new vertex index. If the old vertex must be left as unreferenced (setting <code>nullptr</code> to the pointers), the value of the vector must be UINT_NULL. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a281a6b3aae817871391d838d97f9ca5a" name="a281a6b3aae817871391d838d97f9ca5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a281a6b3aae817871391d838d97f9ca5a">&#9670;&#160;</a></span>vertex() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;VertexConcept T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">VertexType &amp; <a class="el" href="classvcl_1_1mesh_1_1VertexContainer.html">vcl::mesh::VertexContainer</a>&lt; T &gt;::vertex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Segment.html">uint</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference of the vertex at the i-th position in the <a class="el" href="classvcl_1_1Vertex.html" title="The Vertex class represents an Vertex element of the vcl::Mesh class.">Vertex</a> Container of the <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>, which will be the vertex having index = i. </p>
<p>This function does not perform any sanity check: if i is less than <a class="el" href="classvcl_1_1mesh_1_1VertexContainer.html#ab89515980efa65095d8318720a8ff4d3" title="Returns the number of vertices (also deleted) contained in the Vertex container of the Mesh.">vertexContainerSize()</a>, this function will return a valid <a class="el" href="classvcl_1_1Vertex.html" title="The Vertex class represents an Vertex element of the vcl::Mesh class.">Vertex</a> reference (note that the <a class="el" href="classvcl_1_1Vertex.html" title="The Vertex class represents an Vertex element of the vcl::Mesh class.">Vertex</a> may have been flagged as deleted).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>the index of the vertex that will be returned. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af60143c1bd9f5d27c4e3ff49c895064b" name="af60143c1bd9f5d27c4e3ff49c895064b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af60143c1bd9f5d27c4e3ff49c895064b">&#9670;&#160;</a></span>vertex() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;VertexConcept T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Segment.html">const</a> VertexType &amp; <a class="el" href="classvcl_1_1mesh_1_1VertexContainer.html">vcl::mesh::VertexContainer</a>&lt; T &gt;::vertex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Segment.html">uint</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a const reference of the vertex at the i-th position in the <a class="el" href="classvcl_1_1Vertex.html" title="The Vertex class represents an Vertex element of the vcl::Mesh class.">Vertex</a> Container of the <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>, which will be the vertex having index = i. </p>
<p>This function does not perform any sanity check: if i is less than <a class="el" href="classvcl_1_1mesh_1_1VertexContainer.html#ab89515980efa65095d8318720a8ff4d3" title="Returns the number of vertices (also deleted) contained in the Vertex container of the Mesh.">vertexContainerSize()</a>, this function will return a valid <a class="el" href="classvcl_1_1Vertex.html" title="The Vertex class represents an Vertex element of the vcl::Mesh class.">Vertex</a> reference (note that the <a class="el" href="classvcl_1_1Vertex.html" title="The Vertex class represents an Vertex element of the vcl::Mesh class.">Vertex</a> may have been flagged as deleted).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>the index of the vertex that will be returned. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac3269666db546393fb9238a3b50d7680" name="ac3269666db546393fb9238a3b50d7680"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3269666db546393fb9238a3b50d7680">&#9670;&#160;</a></span>vertexBegin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;VertexConcept T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">VertexIterator <a class="el" href="classvcl_1_1mesh_1_1VertexContainer.html">vcl::mesh::VertexContainer</a>&lt; T &gt;::vertexBegin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Segment.html">bool</a>&#160;</td>
          <td class="paramname"><em>jumpDeleted</em> = <code><a class="el" href="classvcl_1_1Segment.html">true</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the beginning of the container. </p>
<p>The iterator is automatically initialized to jump deleted vertices of the container. You can change this option by calling this function with jumpDeleted=false.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">jumpDeleted</td><td>(def: true): boolean that tells if the iterator should jump deleted vertices. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator the the first vertex of the container. </dd></dl>

</div>
</div>
<a id="a7e9f63240146b08aaf7a47ac68d2b9d9" name="a7e9f63240146b08aaf7a47ac68d2b9d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e9f63240146b08aaf7a47ac68d2b9d9">&#9670;&#160;</a></span>vertexBegin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;VertexConcept T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ConstVertexIterator <a class="el" href="classvcl_1_1mesh_1_1VertexContainer.html">vcl::mesh::VertexContainer</a>&lt; T &gt;::vertexBegin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Segment.html">bool</a>&#160;</td>
          <td class="paramname"><em>jumpDeleted</em> = <code><a class="el" href="classvcl_1_1Segment.html">true</a></code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a const iterator to the beginning of the container. </p>
<p>The iterator is automatically initialized to jump deleted vertices of the container. You can change this option by calling this function with jumpDeleted=false.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">jumpDeleted</td><td>(def: true): boolean that tells if the iterator should jump deleted vertices. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A const iterator the the first vertex of the container. </dd></dl>

</div>
</div>
<a id="af43a99e3a2c9dc5a74ff9f599e4dac13" name="af43a99e3a2c9dc5a74ff9f599e4dac13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af43a99e3a2c9dc5a74ff9f599e4dac13">&#9670;&#160;</a></span>vertexCompactIndices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;VertexConcept T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classvcl_1_1Segment.html">uint</a> &gt; <a class="el" href="classvcl_1_1mesh_1_1VertexContainer.html">vcl::mesh::VertexContainer</a>&lt; T &gt;::vertexCompactIndices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a vector that tells, for each actual vertex index, the new index that the vertex would have in a compacted container. For each deleted vertex index, the value of the vector will be UINT_NULL. </p>
<p>This is useful if you need to know the indices of the vertices that they would have in a compact container, without considering the deleted ones.</p>
<dl class="section return"><dt>Returns</dt><dd>A vector containing, for each vertex index, its index if the container would be compact. </dd></dl>

</div>
</div>
<a id="ab89515980efa65095d8318720a8ff4d3" name="ab89515980efa65095d8318720a8ff4d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab89515980efa65095d8318720a8ff4d3">&#9670;&#160;</a></span>vertexContainerSize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;VertexConcept T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Segment.html">uint</a> <a class="el" href="classvcl_1_1mesh_1_1VertexContainer.html">vcl::mesh::VertexContainer</a>&lt; T &gt;::vertexContainerSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of vertices (also deleted) contained in the <a class="el" href="classvcl_1_1Vertex.html" title="The Vertex class represents an Vertex element of the vcl::Mesh class.">Vertex</a> container of the <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>. </p>
<p>If <a class="el" href="classvcl_1_1mesh_1_1VertexContainer.html#a7c9be0bf45c7d2b18356181591bbb3ee" title="Returns the number of non-deleted vertices contained in the Vertex container of the Mesh.">vertexNumber()</a> != <a class="el" href="classvcl_1_1mesh_1_1VertexContainer.html#ab89515980efa65095d8318720a8ff4d3" title="Returns the number of vertices (also deleted) contained in the Vertex container of the Mesh.">vertexContainerSize()</a>, it means that there are some vertices that are flagged as deleted.</p>
<dl class="section return"><dt>Returns</dt><dd>The number of all the vertices contained in the <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>. </dd></dl>

</div>
</div>
<a id="ae3e975ca1f096f908729984ca4f331c3" name="ae3e975ca1f096f908729984ca4f331c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3e975ca1f096f908729984ca4f331c3">&#9670;&#160;</a></span>vertexEnd() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;VertexConcept T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">VertexIterator <a class="el" href="classvcl_1_1mesh_1_1VertexContainer.html">vcl::mesh::VertexContainer</a>&lt; T &gt;::vertexEnd </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the end of the container. </p>
<dl class="section return"><dt>Returns</dt><dd>An iterator to the end of the container. </dd></dl>

</div>
</div>
<a id="a4470262c8c7aca508625bbe8c54a94c4" name="a4470262c8c7aca508625bbe8c54a94c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4470262c8c7aca508625bbe8c54a94c4">&#9670;&#160;</a></span>vertexEnd() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;VertexConcept T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ConstVertexIterator <a class="el" href="classvcl_1_1mesh_1_1VertexContainer.html">vcl::mesh::VertexContainer</a>&lt; T &gt;::vertexEnd </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a const iterator to the end of the container. </p>
<dl class="section return"><dt>Returns</dt><dd>A const iterator to the end of the container. </dd></dl>

</div>
</div>
<a id="a8bd411cf90c0448949360036246d0e0b" name="a8bd411cf90c0448949360036246d0e0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bd411cf90c0448949360036246d0e0b">&#9670;&#160;</a></span>vertexIndexIfCompact()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;VertexConcept T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Segment.html">uint</a> <a class="el" href="classvcl_1_1mesh_1_1VertexContainer.html">vcl::mesh::VertexContainer</a>&lt; T &gt;::vertexIndexIfCompact </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Segment.html">uint</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is an utility member function that returns the index of an element if the container would be compact, that is the number of non-deleted elements before the vertex with the given index. </p>
<p>Complexity: O(n), with n the number of vertices in the container.</p>
<p>This function does not perform any sanity check on the given index.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>the index of a vertex of the container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index that the vertex with index i would have if this container would be compact. </dd></dl>

</div>
</div>
<a id="a7c9be0bf45c7d2b18356181591bbb3ee" name="a7c9be0bf45c7d2b18356181591bbb3ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c9be0bf45c7d2b18356181591bbb3ee">&#9670;&#160;</a></span>vertexNumber()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;VertexConcept T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Segment.html">uint</a> <a class="el" href="classvcl_1_1mesh_1_1VertexContainer.html">vcl::mesh::VertexContainer</a>&lt; T &gt;::vertexNumber </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of <b>non-deleted</b> vertices contained in the <a class="el" href="classvcl_1_1Vertex.html" title="The Vertex class represents an Vertex element of the vcl::Mesh class.">Vertex</a> container of the <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>. </p>
<p>If <a class="el" href="classvcl_1_1mesh_1_1VertexContainer.html#a7c9be0bf45c7d2b18356181591bbb3ee" title="Returns the number of non-deleted vertices contained in the Vertex container of the Mesh.">vertexNumber()</a> != <a class="el" href="classvcl_1_1mesh_1_1VertexContainer.html#ab89515980efa65095d8318720a8ff4d3" title="Returns the number of vertices (also deleted) contained in the Vertex container of the Mesh.">vertexContainerSize()</a>, it means that there are some vertices that are flagged as deleted.</p>
<dl class="section return"><dt>Returns</dt><dd>The number of non-deleted vertices of the <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>. </dd></dl>

</div>
</div>
<a id="a1aac0c075f3ff34ab9efa083ff1fd4e8" name="a1aac0c075f3ff34ab9efa083ff1fd4e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1aac0c075f3ff34ab9efa083ff1fd4e8">&#9670;&#160;</a></span>vertices() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;VertexConcept T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Segment.html">auto</a> <a class="el" href="classvcl_1_1mesh_1_1VertexContainer.html">vcl::mesh::VertexContainer</a>&lt; T &gt;::vertices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Segment.html">bool</a>&#160;</td>
          <td class="paramname"><em>jumpDeleted</em> = <code><a class="el" href="classvcl_1_1Segment.html">true</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a small utility object that allows to iterate over the vertices of the containers, providing two member functions begin() and end(). </p>
<p>This member function is very useful when you want to iterate over the vertices using the C++ foreach syntax:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (Vertex&amp; v : <a class="code hl_class" href="classvcl_1_1Segment.html">m</a>.<a class="code hl_function" href="classvcl_1_1mesh_1_1VertexContainer.html#a1aac0c075f3ff34ab9efa083ff1fd4e8">vertices</a>()){</div>
<div class="line">    <span class="comment">// do something with this vertex</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>The iterator used to iterate over vertices is automatically initialized to jump deleted vertices of the container. You can change this option by calling this function with jumpDeleted=false.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">jumpDeleted</td><td>(def: true): boolean that tells if the iterator should jump deleted vertices. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An object having begin() and end() function, allowing to iterate over the container. </dd></dl>

</div>
</div>
<a id="a3140ae97a7243135bb2e762309d3ac42" name="a3140ae97a7243135bb2e762309d3ac42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3140ae97a7243135bb2e762309d3ac42">&#9670;&#160;</a></span>vertices() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;VertexConcept T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Segment.html">auto</a> <a class="el" href="classvcl_1_1mesh_1_1VertexContainer.html">vcl::mesh::VertexContainer</a>&lt; T &gt;::vertices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Segment.html">bool</a>&#160;</td>
          <td class="paramname"><em>jumpDeleted</em> = <code><a class="el" href="classvcl_1_1Segment.html">true</a></code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a small utility object that allows to iterate over the vertices of the containers, providing two member functions begin() and end(). </p>
<p>This member function is very useful when you want to iterate over the vertices using the C++ foreach syntax:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> Vertex&amp; v : <a class="code hl_class" href="classvcl_1_1Segment.html">m</a>.<a class="code hl_function" href="classvcl_1_1mesh_1_1VertexContainer.html#a1aac0c075f3ff34ab9efa083ff1fd4e8">vertices</a>()){</div>
<div class="line">    <span class="comment">// do something with this vertex</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>The iterator used to iterate over vertices is automatically initialized to jump deleted vertices of the container. You can change this option by calling this function with jumpDeleted=false.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">jumpDeleted</td><td>(def: true): boolean that tells if the iterator should jump deleted vertices. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An object having begin() and end() function, allowing to iterate over the container. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>vclib/core/include/vclib/mesh/containers/<a class="el" href="mesh_2containers_2vertex__container_8h_source.html">vertex_container.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>vcl</b></li><li class="navelem"><b>mesh</b></li><li class="navelem"><a class="el" href="classvcl_1_1mesh_1_1VertexContainer.html">VertexContainer</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
