<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Visual Computing Library: Export Mesh to Buffer Algorithms</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
       <script type="text/javascript">
           DoxygenAwesomeDarkModeToggle.init()
       </script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Visual Computing Library
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group__export__buffer.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Export Mesh to Buffer Algorithms<div class="ingroups"><a class="el" href="group__algorithms__mesh.html">Mesh Algorithms</a> &raquo; <a class="el" href="group__import__export.html">Import/Export Mesh Algorithms</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>List Export Mesh to Buffer algorithms.  
<a href="#details">More...</a></p>
<div class="dynheader">
Collaboration diagram for Export Mesh to Buffer Algorithms:</div>
<div class="dyncontent">
<div class="center"><img src="group__export__buffer.png" border="0" usemap="#agroup____export____buffer" alt=""/></div>
<map name="agroup____export____buffer" id="agroup____export____buffer">
<area shape="rect" title="List Export Mesh to Buffer algorithms." alt="" coords="204,5,367,45"/>
<area shape="rect" href="group__import__export.html" title="List of Import/Export Mesh algorithms." alt="" coords="5,5,156,45"/>
</map>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga3e971a5960ab26aab24acb00db24601a" id="r_ga3e971a5960ab26aab24acb00db24601a"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga3e971a5960ab26aab24acb00db24601a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Segment.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__export__buffer.html#ga3e971a5960ab26aab24acb00db24601a">vcl::vertexCoordsToBuffer</a> (<a class="el" href="classvcl_1_1Segment.html">const</a> MeshType &amp;mesh, <a class="el" href="classvcl_1_1Segment.html">auto</a> *buffer, <a class="el" href="group__types.html#ga16a1bfbea022f6766d2f3ebbf69a3b52">MatrixStorageType</a> <a class="el" href="classvcl_1_1Segment.html">storage</a>=MatrixStorageType::ROW_MAJOR, uint <a class="el" href="classvcl_1_1Segment.html">rowNumber</a>=<a class="el" href="group__types.html#ga9ad8104cd9ccfa9352d33bc7e6ba47e6">UINT_NULL</a>)</td></tr>
<tr class="memdesc:ga3e971a5960ab26aab24acb00db24601a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Export the vertex coordinates of a mesh to a buffer.  <br /></td></tr>
<tr class="separator:ga3e971a5960ab26aab24acb00db24601a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad458d46401c443ee325a7bc9200a578a" id="r_gad458d46401c443ee325a7bc9200a578a"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:gad458d46401c443ee325a7bc9200a578a"><td class="memTemplItemLeft" align="right" valign="top">uint&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__export__buffer.html#gad458d46401c443ee325a7bc9200a578a">vcl::faceSizesToBuffer</a> (<a class="el" href="classvcl_1_1Segment.html">const</a> MeshType &amp;mesh, <a class="el" href="classvcl_1_1Segment.html">auto</a> *buffer)</td></tr>
<tr class="memdesc:gad458d46401c443ee325a7bc9200a578a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Export into a buffer the sizes of the faces of a <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>, and return the sum of the sizes.  <br /></td></tr>
<tr class="separator:gad458d46401c443ee325a7bc9200a578a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d8d20f3cc27e22f326932cd22843fa5" id="r_ga4d8d20f3cc27e22f326932cd22843fa5"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga4d8d20f3cc27e22f326932cd22843fa5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Segment.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__export__buffer.html#ga4d8d20f3cc27e22f326932cd22843fa5">vcl::faceIndicesToBuffer</a> (<a class="el" href="classvcl_1_1Segment.html">const</a> MeshType &amp;mesh, <a class="el" href="classvcl_1_1Segment.html">auto</a> *buffer, <a class="el" href="classvcl_1_1Segment.html">bool</a> <a class="el" href="classvcl_1_1Segment.html">getIndicesAsIfContainerCompact</a>=<a class="el" href="classvcl_1_1Segment.html">true</a>)</td></tr>
<tr class="memdesc:ga4d8d20f3cc27e22f326932cd22843fa5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Export into a buffer the vertex indices for each face of a <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>. Faces can be polygons.  <br /></td></tr>
<tr class="separator:ga4d8d20f3cc27e22f326932cd22843fa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga42a18d1937c793c2a800b3d3143a881b" id="r_ga42a18d1937c793c2a800b3d3143a881b"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga42a18d1937c793c2a800b3d3143a881b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Segment.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__export__buffer.html#ga42a18d1937c793c2a800b3d3143a881b">vcl::faceIndicesToBuffer</a> (<a class="el" href="classvcl_1_1Segment.html">const</a> MeshType &amp;mesh, <a class="el" href="classvcl_1_1Segment.html">auto</a> *buffer, uint largestFaceSize, <a class="el" href="group__types.html#ga16a1bfbea022f6766d2f3ebbf69a3b52">MatrixStorageType</a> <a class="el" href="classvcl_1_1Segment.html">storage</a>=MatrixStorageType::ROW_MAJOR, <a class="el" href="classvcl_1_1Segment.html">bool</a> <a class="el" href="classvcl_1_1Segment.html">getIndicesAsIfContainerCompact</a>=<a class="el" href="classvcl_1_1Segment.html">true</a>, uint <a class="el" href="classvcl_1_1Segment.html">rowNumber</a>=<a class="el" href="group__types.html#ga9ad8104cd9ccfa9352d33bc7e6ba47e6">UINT_NULL</a>)</td></tr>
<tr class="memdesc:ga42a18d1937c793c2a800b3d3143a881b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Export into a buffer the vertex indices for each face of a <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>. Faces can be polygons, and the number of output columns can be set by the user with the <code>largestFaceSize</code> parameter.  <br /></td></tr>
<tr class="separator:ga42a18d1937c793c2a800b3d3143a881b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1536428adc2a72c8eb60d3e92b0fce32" id="r_ga1536428adc2a72c8eb60d3e92b0fce32"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga1536428adc2a72c8eb60d3e92b0fce32"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Segment.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__export__buffer.html#ga1536428adc2a72c8eb60d3e92b0fce32">vcl::triangulatedFaceIndicesToBuffer</a> (<a class="el" href="classvcl_1_1Segment.html">const</a> MeshType &amp;mesh, <a class="el" href="classvcl_1_1Segment.html">auto</a> *buffer, <a class="el" href="classvcl_1_1TriPolyIndexBiMap.html">TriPolyIndexBiMap</a> &amp;indexMap=detail::indexMap, <a class="el" href="group__types.html#ga16a1bfbea022f6766d2f3ebbf69a3b52">MatrixStorageType</a> <a class="el" href="classvcl_1_1Segment.html">storage</a>=MatrixStorageType::ROW_MAJOR, uint <a class="el" href="classvcl_1_1Segment.html">numTriangles</a>=<a class="el" href="group__types.html#ga9ad8104cd9ccfa9352d33bc7e6ba47e6">UINT_NULL</a>, <a class="el" href="classvcl_1_1Segment.html">bool</a> <a class="el" href="classvcl_1_1Segment.html">getIndicesAsIfContainerCompact</a>=<a class="el" href="classvcl_1_1Segment.html">true</a>)</td></tr>
<tr class="memdesc:ga1536428adc2a72c8eb60d3e92b0fce32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Export into a buffer the vertex indices for each triangle computed by triangulating the faces of a <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>.  <br /></td></tr>
<tr class="separator:ga1536428adc2a72c8eb60d3e92b0fce32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga27fd7ce009bc6cd16cd2beff90d533f7" id="r_ga27fd7ce009bc6cd16cd2beff90d533f7"><td class="memTemplParams" colspan="2">template&lt;EdgeMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga27fd7ce009bc6cd16cd2beff90d533f7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Segment.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__export__buffer.html#ga27fd7ce009bc6cd16cd2beff90d533f7">vcl::edgeIndicesToBuffer</a> (<a class="el" href="classvcl_1_1Segment.html">const</a> MeshType &amp;mesh, <a class="el" href="classvcl_1_1Segment.html">auto</a> *buffer, <a class="el" href="group__types.html#ga16a1bfbea022f6766d2f3ebbf69a3b52">MatrixStorageType</a> <a class="el" href="classvcl_1_1Segment.html">storage</a>=MatrixStorageType::ROW_MAJOR, <a class="el" href="classvcl_1_1Segment.html">bool</a> <a class="el" href="classvcl_1_1Segment.html">getIndicesAsIfContainerCompact</a>=<a class="el" href="classvcl_1_1Segment.html">true</a>, uint <a class="el" href="classvcl_1_1Segment.html">rowNumber</a>=<a class="el" href="group__types.html#ga9ad8104cd9ccfa9352d33bc7e6ba47e6">UINT_NULL</a>)</td></tr>
<tr class="memdesc:ga27fd7ce009bc6cd16cd2beff90d533f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Export into a buffer the vertex indices for each edge of a <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>.  <br /></td></tr>
<tr class="separator:ga27fd7ce009bc6cd16cd2beff90d533f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa5d8ff626de2fa25ddfafe8684bc100" id="r_gafa5d8ff626de2fa25ddfafe8684bc100"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:gafa5d8ff626de2fa25ddfafe8684bc100"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Segment.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__export__buffer.html#gafa5d8ff626de2fa25ddfafe8684bc100">vcl::wireframeIndicesToBuffer</a> (<a class="el" href="classvcl_1_1Segment.html">const</a> MeshType &amp;mesh, <a class="el" href="classvcl_1_1Segment.html">auto</a> *buffer, <a class="el" href="group__types.html#ga16a1bfbea022f6766d2f3ebbf69a3b52">MatrixStorageType</a> <a class="el" href="classvcl_1_1Segment.html">storage</a>=MatrixStorageType::ROW_MAJOR, <a class="el" href="classvcl_1_1Segment.html">bool</a> <a class="el" href="classvcl_1_1Segment.html">getIndicesAsIfContainerCompact</a>=<a class="el" href="classvcl_1_1Segment.html">true</a>, uint <a class="el" href="classvcl_1_1Segment.html">rowNumber</a>=<a class="el" href="group__types.html#ga9ad8104cd9ccfa9352d33bc7e6ba47e6">UINT_NULL</a>)</td></tr>
<tr class="memdesc:gafa5d8ff626de2fa25ddfafe8684bc100"><td class="mdescLeft">&#160;</td><td class="mdescRight">Export into a buffer the vertex indices for each edge that composes the wireframe of the <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a> (i.e., the edges of the faces).  <br /></td></tr>
<tr class="separator:gafa5d8ff626de2fa25ddfafe8684bc100"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab947d0481928e5eb3417d0bfee8f4b33" id="r_gab947d0481928e5eb3417d0bfee8f4b33"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:gab947d0481928e5eb3417d0bfee8f4b33"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Segment.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__export__buffer.html#gab947d0481928e5eb3417d0bfee8f4b33">vcl::faceWedgeTexCoordsToBuffer</a> (<a class="el" href="classvcl_1_1Segment.html">const</a> MeshType &amp;mesh, <a class="el" href="classvcl_1_1Segment.html">auto</a> *buffer, uint largestFaceSize=3, <a class="el" href="group__types.html#ga16a1bfbea022f6766d2f3ebbf69a3b52">MatrixStorageType</a> <a class="el" href="classvcl_1_1Segment.html">storage</a>=MatrixStorageType::ROW_MAJOR, uint <a class="el" href="classvcl_1_1Segment.html">rowNumber</a>=<a class="el" href="group__types.html#ga9ad8104cd9ccfa9352d33bc7e6ba47e6">UINT_NULL</a>)</td></tr>
<tr class="memdesc:gab947d0481928e5eb3417d0bfee8f4b33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Export the selection status of the elements identified by <code>ELEM_ID</code> of a mesh to a buffer.  <br /></td></tr>
<tr class="separator:gab947d0481928e5eb3417d0bfee8f4b33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga733bf9300bb3024c9239999b7b05e220" id="r_ga733bf9300bb3024c9239999b7b05e220"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga733bf9300bb3024c9239999b7b05e220"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Segment.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__export__buffer.html#ga733bf9300bb3024c9239999b7b05e220">vcl::faceWedgeTexCoordIndicesToBuffer</a> (<a class="el" href="classvcl_1_1Segment.html">const</a> MeshType &amp;mesh, <a class="el" href="classvcl_1_1Segment.html">auto</a> *buffer)</td></tr>
<tr class="memdesc:ga733bf9300bb3024c9239999b7b05e220"><td class="mdescLeft">&#160;</td><td class="mdescRight">Export into a buffer the per face wedge texture indices of a mesh.  <br /></td></tr>
<tr class="separator:ga733bf9300bb3024c9239999b7b05e220"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga154f129f7c4072e73340c56f06669593" id="r_ga154f129f7c4072e73340c56f06669593"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga154f129f7c4072e73340c56f06669593"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Segment.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__export__buffer.html#ga154f129f7c4072e73340c56f06669593">vcl::triangulatedFaceWedgeTexCoordIndicesToBuffer</a> (<a class="el" href="classvcl_1_1Segment.html">const</a> MeshType &amp;mesh, <a class="el" href="classvcl_1_1Segment.html">auto</a> *buffer, <a class="el" href="classvcl_1_1Segment.html">const</a> <a class="el" href="classvcl_1_1TriPolyIndexBiMap.html">TriPolyIndexBiMap</a> &amp;indexMap)</td></tr>
<tr class="memdesc:ga154f129f7c4072e73340c56f06669593"><td class="mdescLeft">&#160;</td><td class="mdescRight">Export into a buffer the per triangle wedge texture indices of a mesh. Triangles are computed by triangulating the faces of the mesh.  <br /></td></tr>
<tr class="separator:ga154f129f7c4072e73340c56f06669593"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>List Export Mesh to Buffer algorithms. </p>
<p>They allow to export mesh data to pre-allocated buffers.</p>
<p>You can access these algorithms by including <code>#include &lt;<a class="el" href="import__export_8h_source.html">vclib/algorithms/mesh/import_export.h</a>&gt;</code> </p>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga27fd7ce009bc6cd16cd2beff90d533f7" name="ga27fd7ce009bc6cd16cd2beff90d533f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga27fd7ce009bc6cd16cd2beff90d533f7">&#9670;&#160;</a></span>edgeIndicesToBuffer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;EdgeMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Segment.html">void</a> vcl::edgeIndicesToBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Segment.html">const</a> MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Segment.html">auto</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga16a1bfbea022f6766d2f3ebbf69a3b52">MatrixStorageType</a>&#160;</td>
          <td class="paramname"><em>storage</em> = <code>MatrixStorageType::ROW_MAJOR</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Segment.html">bool</a>&#160;</td>
          <td class="paramname"><em>getIndicesAsIfContainerCompact</em> = <code><a class="el" href="classvcl_1_1Segment.html">true</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>rowNumber</em> = <code><a class="el" href="group__types.html#ga9ad8104cd9ccfa9352d33bc7e6ba47e6">UINT_NULL</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Export into a buffer the vertex indices for each edge of a <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>. </p>
<p>This function exports the vertex indices of the edges of a mesh to a buffer. Indices are stored following the order the edges appear in the mesh. The buffer must be preallocated with the correct size (number of edges times 2).</p>
<dl class="section note"><dt>Note</dt><dd>As a default behaviour (<code>getIndicesAsIfContainerCompact == true</code>) the function stores the vertex indices as if the vertex container of the mesh is compact. This means that, if the mesh has deleted vertices, the vertex indices stored in the buffer may not correspond to the vertex indices of the mesh. If you want to store the actual vertex indices in the input mesh, set <code>getIndicesAsIfContainerCompact</code> to false.</dd>
<dd>
This function does not guarantee that the rows of the matrix correspond to the edge indices of the mesh. This scenario is possible when the mesh has deleted edges. To be sure to have a direct correspondence, compact the edge container before calling this function.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>input mesh </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buffer</td><td>preallocated buffer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">storage</td><td>storage type of the matrix (row or column major) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">getIndicesAsIfContainerCompact</td><td>if true, the function will store the vertex indices as if the vertex container of the mesh is compact. If false, the actual vertex indices in the input mesh will be stored. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rowNumber</td><td>number of rows of the matrix (if different from the number of edges in the mesh) - used only when storage is column major </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4d8d20f3cc27e22f326932cd22843fa5" name="ga4d8d20f3cc27e22f326932cd22843fa5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4d8d20f3cc27e22f326932cd22843fa5">&#9670;&#160;</a></span>faceIndicesToBuffer() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Segment.html">void</a> vcl::faceIndicesToBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Segment.html">const</a> MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Segment.html">auto</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Segment.html">bool</a>&#160;</td>
          <td class="paramname"><em>getIndicesAsIfContainerCompact</em> = <code><a class="el" href="classvcl_1_1Segment.html">true</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Export into a buffer the vertex indices for each face of a <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>. Faces can be polygons. </p>
<p>This function exports the vertex indices of the polygonal faces of a mesh to a buffer. Indices are stored consecutively in the buffer, following the order the faces appear in the mesh. The buffer must be preallocated with the correct size (sum of the sizes of the faces).</p>
<p>You can use the function <a class="el" href="group__export__buffer.html#gad458d46401c443ee325a7bc9200a578a">vcl::faceSizesToBuffer</a> to get the sizes of the faces and allocate the buffer accordingly:</p>
<div class="fragment"><div class="line">std::vector&lt;uint&gt; <a class="code hl_class" href="classvcl_1_1Segment.html">faceSizes</a>(<a class="code hl_class" href="classvcl_1_1Segment.html">myMesh</a>.faceNumber());</div>
<div class="line">uint sum = <a class="code hl_function" href="group__export__buffer.html#gad458d46401c443ee325a7bc9200a578a">vcl::faceSizesToBuffer</a>(<a class="code hl_class" href="classvcl_1_1Segment.html">myMesh</a>, <a class="code hl_class" href="classvcl_1_1Segment.html">sizes</a>.data());</div>
<div class="line">std::vector&lt;uint&gt; <a class="code hl_class" href="classvcl_1_1Segment.html">faceIndices</a>(sum);</div>
<div class="line"><a class="code hl_function" href="group__export__buffer.html#ga4d8d20f3cc27e22f326932cd22843fa5">vcl::faceIndicesToBuffer</a>(<a class="code hl_class" href="classvcl_1_1Segment.html">myMesh</a>, <a class="code hl_class" href="classvcl_1_1Segment.html">faceIndices</a>.data());</div>
<div class="line"> </div>
<div class="line"><span class="comment">// read indices for each face</span></div>
<div class="line">uint offset = 0;</div>
<div class="line"><span class="keywordflow">for</span> (uint <a class="code hl_class" href="classvcl_1_1Segment.html">i</a> = 0; <a class="code hl_class" href="classvcl_1_1Segment.html">i</a> &lt; <a class="code hl_class" href="classvcl_1_1Segment.html">myMesh</a>.faceNumber(); ++<a class="code hl_class" href="classvcl_1_1Segment.html">i</a>) {</div>
<div class="line">    uint size = <a class="code hl_class" href="classvcl_1_1Segment.html">faceSizes</a>[<a class="code hl_class" href="classvcl_1_1Segment.html">i</a>];</div>
<div class="line">    <span class="keywordflow">for</span> (uint <a class="code hl_class" href="classvcl_1_1Segment.html">j</a> = 0; <a class="code hl_class" href="classvcl_1_1Segment.html">j</a> &lt; size; ++<a class="code hl_class" href="classvcl_1_1Segment.html">j</a>) {</div>
<div class="line">        uint <a class="code hl_class" href="classvcl_1_1Segment.html">vIdx</a> = <a class="code hl_class" href="classvcl_1_1Segment.html">faceIndices</a>[offset + <a class="code hl_class" href="classvcl_1_1Segment.html">j</a>];</div>
<div class="line">        <span class="comment">// do something with the vertex index</span></div>
<div class="line">    }</div>
<div class="line">    offset += size;</div>
<div class="line">}</div>
<div class="ttc" id="aclassvcl_1_1Segment_html"><div class="ttname"><a href="classvcl_1_1Segment.html">vcl::Segment</a></div><div class="ttdoc">A class representing a line segment in n-dimensional space. The class is parameterized by a PointConc...</div><div class="ttdef"><b>Definition</b> segment.h:43</div></div>
<div class="ttc" id="agroup__export__buffer_html_ga4d8d20f3cc27e22f326932cd22843fa5"><div class="ttname"><a href="group__export__buffer.html#ga4d8d20f3cc27e22f326932cd22843fa5">vcl::faceIndicesToBuffer</a></div><div class="ttdeci">void faceIndicesToBuffer(const MeshType &amp;mesh, auto *buffer, bool getIndicesAsIfContainerCompact=true)</div><div class="ttdoc">Export into a buffer the vertex indices for each face of a Mesh. Faces can be polygons.</div><div class="ttdef"><b>Definition</b> export_buffer.h:211</div></div>
<div class="ttc" id="agroup__export__buffer_html_gad458d46401c443ee325a7bc9200a578a"><div class="ttname"><a href="group__export__buffer.html#gad458d46401c443ee325a7bc9200a578a">vcl::faceSizesToBuffer</a></div><div class="ttdeci">uint faceSizesToBuffer(const MeshType &amp;mesh, auto *buffer)</div><div class="ttdoc">Export into a buffer the sizes of the faces of a Mesh, and return the sum of the sizes.</div><div class="ttdef"><b>Definition</b> export_buffer.h:149</div></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>As a default behaviour (<code>getIndicesAsIfContainerCompact == true</code>) the function stores the vertex indices as if the vertex container of the mesh is compact. This means that, if the mesh has deleted vertices, the vertex indices stored in the buffer may not correspond to the vertex indices of the mesh. If you want to store the actual vertex indices in the input mesh, set <code>getIndicesAsIfContainerCompact</code> to false.</dd>
<dd>
This function does not guarantee that the rows of the matrix correspond to the face indices of the mesh. This scenario is possible when the mesh has deleted faces. To be sure to have a direct correspondence, compact the face container before calling this function.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>input mesh </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buffer</td><td>preallocated buffer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">getIndicesAsIfContainerCompact</td><td>if true, the function will store the vertex indices as if the vertex container of the mesh is compact. If false, the actual vertex indices in the input mesh will be stored. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga42a18d1937c793c2a800b3d3143a881b" name="ga42a18d1937c793c2a800b3d3143a881b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga42a18d1937c793c2a800b3d3143a881b">&#9670;&#160;</a></span>faceIndicesToBuffer() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Segment.html">void</a> vcl::faceIndicesToBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Segment.html">const</a> MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Segment.html">auto</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>largestFaceSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga16a1bfbea022f6766d2f3ebbf69a3b52">MatrixStorageType</a>&#160;</td>
          <td class="paramname"><em>storage</em> = <code>MatrixStorageType::ROW_MAJOR</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Segment.html">bool</a>&#160;</td>
          <td class="paramname"><em>getIndicesAsIfContainerCompact</em> = <code><a class="el" href="classvcl_1_1Segment.html">true</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>rowNumber</em> = <code><a class="el" href="group__types.html#ga9ad8104cd9ccfa9352d33bc7e6ba47e6">UINT_NULL</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Export into a buffer the vertex indices for each face of a <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>. Faces can be polygons, and the number of output columns can be set by the user with the <code>largestFaceSize</code> parameter. </p>
<p>This function exports the vertex indices of the polygonal faces of a mesh to a buffer. Indices are stored following the order the faces appear in the mesh. The buffer must be preallocated with the correct size (number of faces times <code>largestFaceSize</code>). For each face that has less vertices than the largest face size, the remaining indices are set to -1.</p>
<p>For triangle meshes, you can set <code>largestFaceSize</code> to 3. For polygonal meshes, you can use the function vcl::largestFaceSize to get the largest face size and allocate the buffer accordingly:</p>
<div class="fragment"><div class="line">uint <a class="code hl_class" href="classvcl_1_1Segment.html">lfs</a> = vcl::largestFaceSize(<a class="code hl_class" href="classvcl_1_1Segment.html">myMesh</a>);</div>
<div class="line">Eigen::MatrixXi <a class="code hl_class" href="classvcl_1_1Segment.html">faceIndices</a>(<a class="code hl_class" href="classvcl_1_1Segment.html">myMesh</a>.faceNumber(), <a class="code hl_class" href="classvcl_1_1Segment.html">lfs</a>);</div>
<div class="line"><a class="code hl_function" href="group__export__buffer.html#ga4d8d20f3cc27e22f326932cd22843fa5">vcl::faceIndicesToBuffer</a>(</div>
<div class="line">    <a class="code hl_class" href="classvcl_1_1Segment.html">myMesh</a>, <a class="code hl_class" href="classvcl_1_1Segment.html">faceIndices</a>.data(), <a class="code hl_class" href="classvcl_1_1Segment.html">lfs</a>, MatrixStorageType::COLUMN_MAJOR);</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>As a default behaviour (<code>getIndicesAsIfContainerCompact == true</code>) the function stores the vertex indices as if the vertex container of the mesh is compact. This means that, if the mesh has deleted vertices, the vertex indices stored in the buffer may not correspond to the vertex indices of the mesh. If you want to store the actual vertex indices in the input mesh, set <code>getIndicesAsIfContainerCompact</code> to false.</dd>
<dd>
This function does not guarantee that the rows of the matrix correspond to the face indices of the mesh. This scenario is possible when the mesh has deleted faces. To be sure to have a direct correspondence, compact the face container before calling this function.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>input mesh </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buffer</td><td>preallocated buffer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">largestFaceSize</td><td>size of the largest face in the mesh </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">storage</td><td>storage type of the matrix (row or column major) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">getIndicesAsIfContainerCompact</td><td>if true, the function will store the vertex indices as if the vertex container of the mesh is compact. If false, the actual vertex indices in the input mesh will be stored. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rowNumber</td><td>number of rows of the matrix (if different from the number of faces in the mesh) - used only when storage is column major </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad458d46401c443ee325a7bc9200a578a" name="gad458d46401c443ee325a7bc9200a578a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad458d46401c443ee325a7bc9200a578a">&#9670;&#160;</a></span>faceSizesToBuffer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">uint vcl::faceSizesToBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Segment.html">const</a> MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Segment.html">auto</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Export into a buffer the sizes of the faces of a <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>, and return the sum of the sizes. </p>
<p>This function could be useful when dealing with polygonal meshes: it exports the sizes of the faces of a mesh to a buffer. Sizes are stored following the order the faces appear in the mesh. The buffer must be preallocated with the correct size (number of faces).</p>
<p>The return value is the sum of the sizes of the faces. This value is useful when you need to allocate a buffer to store the vertex indices of the faces (its size is the sum of the face sizes).</p>
<dl class="section note"><dt>Note</dt><dd>This function does not guarantee that the rows of the matrix correspond to the face indices of the mesh. This scenario is possible when the mesh has deleted faces. To be sure to have a direct correspondence, compact the face container before calling this function.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>input mesh </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buffer</td><td>preallocated buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>sum of the sizes of the faces </dd></dl>

</div>
</div>
<a id="ga733bf9300bb3024c9239999b7b05e220" name="ga733bf9300bb3024c9239999b7b05e220"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga733bf9300bb3024c9239999b7b05e220">&#9670;&#160;</a></span>faceWedgeTexCoordIndicesToBuffer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Segment.html">void</a> vcl::faceWedgeTexCoordIndicesToBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Segment.html">const</a> MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Segment.html">auto</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Export into a buffer the per face wedge texture indices of a mesh. </p>
<p>This function exports the per face wedge texture coordinate indices of a mesh to a buffer. <a class="el" href="classvcl_1_1Texture.html">Texture</a> coordinate indices are stored in the buffer following the order the faces appear in the mesh. The buffer must be preallocated with the correct size (number of faces).</p>
<dl class="section note"><dt>Note</dt><dd>This function does not guarantee that the rows of the buffer correspond to the face indices of the mesh. This scenario is possible when the mesh has deleted faces. To be sure to have a direct correspondence, compact the face container before calling this function.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>input mesh </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buffer</td><td>preallocated buffer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab947d0481928e5eb3417d0bfee8f4b33" name="gab947d0481928e5eb3417d0bfee8f4b33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab947d0481928e5eb3417d0bfee8f4b33">&#9670;&#160;</a></span>faceWedgeTexCoordsToBuffer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Segment.html">void</a> vcl::faceWedgeTexCoordsToBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Segment.html">const</a> MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Segment.html">auto</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>largestFaceSize</em> = <code>3</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga16a1bfbea022f6766d2f3ebbf69a3b52">MatrixStorageType</a>&#160;</td>
          <td class="paramname"><em>storage</em> = <code>MatrixStorageType::ROW_MAJOR</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>rowNumber</em> = <code><a class="el" href="group__types.html#ga9ad8104cd9ccfa9352d33bc7e6ba47e6">UINT_NULL</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Export the selection status of the elements identified by <code>ELEM_ID</code> of a mesh to a buffer. </p>
<p>This function exports the selection status of the elements identified by <code>ELEM_ID</code> of a mesh to a buffer. Values are stored in the buffer following the order the elements appear in the mesh. The buffer must be preallocated with the correct size (number of elements).</p>
<p>Usage example with std::vector&lt;bool&gt;:</p>
<div class="fragment"><div class="line">   std::vector&lt;bool&gt; <a class="code hl_class" href="classvcl_1_1Segment.html">vec</a>(<a class="code hl_class" href="classvcl_1_1Segment.html">myMesh</a>.elementNumber&lt;ElemId::VERTEX&gt;());</div>
<div class="line">   <a class="code hl_class" href="classvcl_1_1Segment.html">vcl::elementSelectionToBuffer&lt;ElemId::VERTEX&gt;</a>(<a class="code hl_class" href="classvcl_1_1Segment.html">myMesh</a>, <a class="code hl_class" href="classvcl_1_1Segment.html">vec</a>.data());</div>
<div class="line">   <span class="keyword">@end</span><span class="keywordflow">if</span></div>
<div class="line">  </div>
<div class="line">   @note This function does not guarantee that the rows of the buffer</div>
<div class="line">   correspond to the element indices of the mesh. This scenario is possible</div>
<div class="line">   when the mesh has deleted elements. To be sure to have a direct</div>
<div class="line">   correspondence, compact the element container before calling <span class="keyword">this</span></div>
<div class="line">   function.</div>
<div class="line">  </div>
<div class="line">   @param[in] mesh: input mesh</div>
<div class="line">   @param[out] buffer: preallocated buffer</div>
<div class="line">  </div>
<div class="line">   @ingroup export_buffer</div>
<div class="line">  /</div>
<div class="line"><span class="keyword">template</span>&lt;u<span class="keywordtype">int</span> ELEM_ID, MeshConcept MeshType&gt;</div>
<div class="line"><span class="keywordtype">void</span> elementSelectionToBuffer(<span class="keyword">const</span> MeshType&amp; mesh, <span class="keyword">auto</span>* buffer)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">for</span> (uint i = 0; <span class="keyword">const</span> <span class="keyword">auto</span>&amp; e : mesh.template elements&lt;ELEM_ID&gt;()) {</div>
<div class="line">        buffer[i] = e.selected();</div>
<div class="line">        ++i;</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>This function does not guarantee that the rows of the matrix correspond to the face indices of the mesh. This scenario is possible when the mesh has deleted faces. To be sure to have a direct correspondence, compact the face container before calling this function.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>input mesh </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buffer</td><td>preallocated buffer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">largestFaceSize</td><td>size of the largest face in the mesh </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">storage</td><td>storage type of the matrix (row or column major) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rowNumber</td><td>number of rows of the matrix (if different from the number of faces in the mesh) - used only when storage is column major </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1536428adc2a72c8eb60d3e92b0fce32" name="ga1536428adc2a72c8eb60d3e92b0fce32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1536428adc2a72c8eb60d3e92b0fce32">&#9670;&#160;</a></span>triangulatedFaceIndicesToBuffer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Segment.html">void</a> vcl::triangulatedFaceIndicesToBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Segment.html">const</a> MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Segment.html">auto</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1TriPolyIndexBiMap.html">TriPolyIndexBiMap</a> &amp;&#160;</td>
          <td class="paramname"><em>indexMap</em> = <code>detail::indexMap</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga16a1bfbea022f6766d2f3ebbf69a3b52">MatrixStorageType</a>&#160;</td>
          <td class="paramname"><em>storage</em> = <code>MatrixStorageType::ROW_MAJOR</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>numTriangles</em> = <code><a class="el" href="group__types.html#ga9ad8104cd9ccfa9352d33bc7e6ba47e6">UINT_NULL</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Segment.html">bool</a>&#160;</td>
          <td class="paramname"><em>getIndicesAsIfContainerCompact</em> = <code><a class="el" href="classvcl_1_1Segment.html">true</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Export into a buffer the vertex indices for each triangle computed by triangulating the faces of a <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a>. </p>
<p>This function exports the vertex indices of the triangles computed by triangulating the faces of a mesh to a buffer. Indices are stored following the order the faces appear in the mesh. The buffer must be preallocated with the correct size (number of <em>resulting triangles</em> times 3).</p>
<p>You can use the function vcl::countTriangulatedTriangles to get the number of resulting triangles and allocate the buffer accordingly:</p>
<div class="fragment"><div class="line">uint numTris = vcl::countTriangulatedTriangles(<a class="code hl_class" href="classvcl_1_1Segment.html">myMesh</a>);</div>
<div class="line">Eigen::MatrixXi <a class="code hl_class" href="classvcl_1_1Segment.html">triIndices</a>(numTris, 3);</div>
<div class="line"><a class="code hl_class" href="classvcl_1_1TriPolyIndexBiMap.html">vcl::TriPolyIndexBiMap</a> indexMap;</div>
<div class="line"><a class="code hl_function" href="group__export__buffer.html#ga1536428adc2a72c8eb60d3e92b0fce32">vcl::triangulatedFaceIndicesToBuffer</a>(</div>
<div class="line">    <a class="code hl_class" href="classvcl_1_1Segment.html">myMesh</a>, <a class="code hl_class" href="classvcl_1_1Segment.html">triIndices</a>.data(), indexMap, MatrixStorageType::COLUMN_MAJOR,</div>
<div class="line">    numTris);</div>
<div class="ttc" id="aclassvcl_1_1TriPolyIndexBiMap_html"><div class="ttname"><a href="classvcl_1_1TriPolyIndexBiMap.html">vcl::TriPolyIndexBiMap</a></div><div class="ttdoc">The TriPolyIndexBiMap class allows to store a bidirectional mapping between a Polygon Mesh and a Tria...</div><div class="ttdef"><b>Definition</b> tri_poly_index_bimap.h:50</div></div>
<div class="ttc" id="agroup__export__buffer_html_ga1536428adc2a72c8eb60d3e92b0fce32"><div class="ttname"><a href="group__export__buffer.html#ga1536428adc2a72c8eb60d3e92b0fce32">vcl::triangulatedFaceIndicesToBuffer</a></div><div class="ttdeci">void triangulatedFaceIndicesToBuffer(const MeshType &amp;mesh, auto *buffer, TriPolyIndexBiMap &amp;indexMap=detail::indexMap, MatrixStorageType storage=MatrixStorageType::ROW_MAJOR, uint numTriangles=UINT_NULL, bool getIndicesAsIfContainerCompact=true)</div><div class="ttdoc">Export into a buffer the vertex indices for each triangle computed by triangulating the faces of a Me...</div><div class="ttdef"><b>Definition</b> export_buffer.h:357</div></div>
</div><!-- fragment --><p>The input indexMap is used to map each triangle to the face index. If the storage of the buffer is column major, the number of resulting triangles (that should be known when calling this function) should be given as input. If the number of resulting triangles is not given, the function will compute it again.</p>
<dl class="section note"><dt>Note</dt><dd>As a default behaviour (<code>getIndicesAsIfContainerCompact == true</code>) the function stores the vertex indices as if the vertex container of the mesh is compact. This means that, if the mesh has deleted vertices, the vertex indices stored in the buffer may not correspond to the vertex indices of the mesh. If you want to store the actual vertex indices in the input mesh, set <code>getIndicesAsIfContainerCompact</code> to false.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>input mesh </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buffer</td><td>preallocated buffer </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">indexMap</td><td>map from triangle index to face index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">storage</td><td>storage type of the matrix (row or column major) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numTriangles</td><td>number of resulting triangles (necessary only if the storage is column major) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">getIndicesAsIfContainerCompact</td><td>if true, the function will store the vertex indices as if the vertex container of the mesh is compact. If false, the actual vertex indices in the input mesh will be stored. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga154f129f7c4072e73340c56f06669593" name="ga154f129f7c4072e73340c56f06669593"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga154f129f7c4072e73340c56f06669593">&#9670;&#160;</a></span>triangulatedFaceWedgeTexCoordIndicesToBuffer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Segment.html">void</a> vcl::triangulatedFaceWedgeTexCoordIndicesToBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Segment.html">const</a> MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Segment.html">auto</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Segment.html">const</a> <a class="el" href="classvcl_1_1TriPolyIndexBiMap.html">TriPolyIndexBiMap</a> &amp;&#160;</td>
          <td class="paramname"><em>indexMap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Export into a buffer the per triangle wedge texture indices of a mesh. Triangles are computed by triangulating the faces of the mesh. </p>
<p>This function exports the per triangle wedge texture coordinate indices of a mesh to a buffer. <a class="el" href="classvcl_1_1Texture.html">Texture</a> coordinate indices are stored in the buffer following the order the faces appear in the mesh. The buffer must be preallocated with the correct size (number of triangles).</p>
<p>The function requires an already computed index map, which maps each triangle to the face index and vice versa. You can use the <a class="el" href="group__export__buffer.html#ga1536428adc2a72c8eb60d3e92b0fce32">vcl::triangulatedFaceIndicesToBuffer</a> function to get the index map. You can use the function vcl::countTriangulatedTriangles to get the number of resulting triangles and allocate the buffer accordingly.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>input mesh </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buffer</td><td>preallocated buffer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">indexMap</td><td>map from triangle index to face index </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3e971a5960ab26aab24acb00db24601a" name="ga3e971a5960ab26aab24acb00db24601a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3e971a5960ab26aab24acb00db24601a">&#9670;&#160;</a></span>vertexCoordsToBuffer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Segment.html">void</a> vcl::vertexCoordsToBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Segment.html">const</a> MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Segment.html">auto</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga16a1bfbea022f6766d2f3ebbf69a3b52">MatrixStorageType</a>&#160;</td>
          <td class="paramname"><em>storage</em> = <code>MatrixStorageType::ROW_MAJOR</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>rowNumber</em> = <code><a class="el" href="group__types.html#ga9ad8104cd9ccfa9352d33bc7e6ba47e6">UINT_NULL</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Export the vertex coordinates of a mesh to a buffer. </p>
<p>This function exports the vertex coordinates of a mesh to a buffer. Vertices are stored in the buffer following the order they appear in the mesh. The buffer must be preallocated with the correct size (number of vertices times the number of coordinates per vertex).</p>
<dl class="section note"><dt>Note</dt><dd>This function does not guarantee that the rows of the matrix correspond to the vertex indices of the mesh. This scenario is possible when the mesh has deleted vertices. To be sure to have a direct correspondence, compact the vertex container before calling this function.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>input mesh </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buffer</td><td>preallocated buffer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">storage</td><td>storage type of the matrix (row or column major) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rowNumber</td><td>number of rows of the matrix (if different from the number of vertices in the mesh) - used only when storage is column major </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gafa5d8ff626de2fa25ddfafe8684bc100" name="gafa5d8ff626de2fa25ddfafe8684bc100"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafa5d8ff626de2fa25ddfafe8684bc100">&#9670;&#160;</a></span>wireframeIndicesToBuffer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Segment.html">void</a> vcl::wireframeIndicesToBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Segment.html">const</a> MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Segment.html">auto</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga16a1bfbea022f6766d2f3ebbf69a3b52">MatrixStorageType</a>&#160;</td>
          <td class="paramname"><em>storage</em> = <code>MatrixStorageType::ROW_MAJOR</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Segment.html">bool</a>&#160;</td>
          <td class="paramname"><em>getIndicesAsIfContainerCompact</em> = <code><a class="el" href="classvcl_1_1Segment.html">true</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>rowNumber</em> = <code><a class="el" href="group__types.html#ga9ad8104cd9ccfa9352d33bc7e6ba47e6">UINT_NULL</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Export into a buffer the vertex indices for each edge that composes the wireframe of the <a class="el" href="classvcl_1_1Mesh.html" title="The Mesh class represents a generic 3D mesh. A mesh is composed of a generic number of containers of ...">Mesh</a> (i.e., the edges of the faces). </p>
<p>This function exports the vertex indices of the wireframe edges of a mesh to a buffer. Indices are stored following the order the edges appear in the faces. The buffer must be preallocated with the correct size (number of references to vertices in the mesh faces times 2 - see countPerFaceVertexReferences).</p>
<dl class="section note"><dt>Note</dt><dd>As a default behaviour (<code>getIndicesAsIfContainerCompact == true</code>) the function stores the vertex indices as if the vertex container of the mesh is compact. This means that, if the mesh has deleted vertices, the vertex indices stored in the buffer may not correspond to the vertex indices of the mesh. If you want to store the actual vertex indices in the input mesh, set <code>getIndicesAsIfContainerCompact</code> to false.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>input mesh </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buffer</td><td>preallocated buffer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">storage</td><td>storage type of the matrix (row or column major) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">getIndicesAsIfContainerCompact</td><td>if true, the function will store the vertex indices as if the vertex container of the mesh is compact. If false, the actual vertex indices in the input mesh will be stored. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rowNumber</td><td>number of rows of the matrix (if different from the number of references to vertices in the mesh faces times 2) - used only when storage is column major </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
