<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Visual Computing Library: vcl::comp::AdjacentVertices&lt; Vertex, ElementType, OPT &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
       <script type="text/javascript">
           DoxygenAwesomeDarkModeToggle.init()
       </script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Visual Computing Library
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classvcl_1_1comp_1_1AdjacentVertices.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="classvcl_1_1comp_1_1AdjacentVertices-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">vcl::comp::AdjacentVertices&lt; Vertex, ElementType, OPT &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__mesh.html">Mesh</a> &raquo; <a class="el" href="group__components.html">Components</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>The <a class="el" href="classvcl_1_1comp_1_1AdjacentVertices.html" title="The AdjacentVertices class is a container of Vertex pointers. It is a component that makes sense to u...">AdjacentVertices</a> class is a container of <a class="el" href="classvcl_1_1Vertex.html" title="The Vertex class represents an Vertex element of the vcl::Mesh class.">Vertex</a> pointers. It is a component that makes sense to use mostly on <a class="el" href="classvcl_1_1Vertex.html" title="The Vertex class represents an Vertex element of the vcl::Mesh class.">Vertex</a> Elements. For Faces and Edges, see the <a class="el" href="classvcl_1_1comp_1_1VertexPointers.html" title="The VertexPointers class represents a component that stores a container of pointers to vertices that ...">VertexPointers</a> component (which is similar, but has different member function names).  
 <a href="classvcl_1_1comp_1_1AdjacentVertices.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="mesh_2components_2adjacent__vertices_8h_source.html">vclib/mesh/components/adjacent_vertices.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for vcl::comp::AdjacentVertices&lt; Vertex, ElementType, OPT &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classvcl_1_1comp_1_1AdjacentVertices__inherit__graph.png" border="0" usemap="#avcl_1_1comp_1_1AdjacentVertices_3_01Vertex_00_01ElementType_00_01OPT_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="avcl_1_1comp_1_1AdjacentVertices_3_01Vertex_00_01ElementType_00_01OPT_01_4_inherit__map" id="avcl_1_1comp_1_1AdjacentVertices_3_01Vertex_00_01ElementType_00_01OPT_01_4_inherit__map">
<area shape="rect" title="The AdjacentVertices class is a container of Vertex pointers. It is a component that makes sense to u..." alt="" coords="848,27,1068,67"/>
<area shape="rect" href="classvcl_1_1comp_1_1PointersContainerComponent.html" title="The PointersContainerComponent is the base class for all the components of VCLib that store a contain..." alt="" coords="557,13,800,82"/>
<area shape="rect" href="classvcl_1_1comp_1_1ContainerComponent.html" title=" " alt="" coords="264,13,509,82"/>
<area shape="rect" title=" " alt="" coords="5,5,216,89"/>
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for vcl::comp::AdjacentVertices&lt; Vertex, ElementType, OPT &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classvcl_1_1comp_1_1AdjacentVertices__coll__graph.png" border="0" usemap="#avcl_1_1comp_1_1AdjacentVertices_3_01Vertex_00_01ElementType_00_01OPT_01_4_coll__map" alt="Collaboration graph"/></div>
<map name="avcl_1_1comp_1_1AdjacentVertices_3_01Vertex_00_01ElementType_00_01OPT_01_4_coll__map" id="avcl_1_1comp_1_1AdjacentVertices_3_01Vertex_00_01ElementType_00_01OPT_01_4_coll__map">
<area shape="rect" title="The AdjacentVertices class is a container of Vertex pointers. It is a component that makes sense to u..." alt="" coords="848,27,1068,67"/>
<area shape="rect" href="classvcl_1_1comp_1_1PointersContainerComponent.html" title="The PointersContainerComponent is the base class for all the components of VCLib that store a contain..." alt="" coords="557,13,800,82"/>
<area shape="rect" href="classvcl_1_1comp_1_1ContainerComponent.html" title=" " alt="" coords="264,13,509,82"/>
<area shape="rect" title=" " alt="" coords="5,5,216,89"/>
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a0ecc6abcd32048a95ee3dc4e88bf339a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1comp_1_1AdjacentVertices.html#a0ecc6abcd32048a95ee3dc4e88bf339a">AdjacentVertexType</a> = <a class="el" href="classvcl_1_1Vertex.html">Vertex</a></td></tr>
<tr class="memdesc:a0ecc6abcd32048a95ee3dc4e88bf339a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expose the type of the Adjacent <a class="el" href="classvcl_1_1Vertex.html" title="The Vertex class represents an Vertex element of the vcl::Mesh class.">Vertex</a>.  <br /></td></tr>
<tr class="separator:a0ecc6abcd32048a95ee3dc4e88bf339a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb99075b1fc6c8700eddc3aa2c22fe59"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1comp_1_1AdjacentVertices.html#abb99075b1fc6c8700eddc3aa2c22fe59">AdjacentVertexIterator</a> = <a class="el" href="classvcl_1_1comp_1_1ContainerComponent.html#ad35631dd272b71e139983d908282e677">Base::Iterator</a></td></tr>
<tr class="separator:abb99075b1fc6c8700eddc3aa2c22fe59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a236f97c116d359e0896fe64fcbfc6bb3"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1comp_1_1AdjacentVertices.html#a236f97c116d359e0896fe64fcbfc6bb3">ConstAdjacentVertexIterator</a> = <a class="el" href="classvcl_1_1comp_1_1ContainerComponent.html#a4345d7d498cae01d7a7c74ae525d5769">Base::ConstIterator</a></td></tr>
<tr class="separator:a236f97c116d359e0896fe64fcbfc6bb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac929d334918d267834f750a546153f9e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1comp_1_1AdjacentVertices.html#ac929d334918d267834f750a546153f9e">adjVerticesNumber</a> () const</td></tr>
<tr class="memdesc:ac929d334918d267834f750a546153f9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of adjacent vertices of the element.  <br /></td></tr>
<tr class="separator:ac929d334918d267834f750a546153f9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b26304dfc8f1f62161a37890fd2278a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Vertex.html">Vertex</a> *&amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1comp_1_1AdjacentVertices.html#a8b26304dfc8f1f62161a37890fd2278a">adjVertex</a> (<a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> i)</td></tr>
<tr class="memdesc:a8b26304dfc8f1f62161a37890fd2278a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference of the pointer to the i-th adjacent vertex of an element.  <br /></td></tr>
<tr class="separator:a8b26304dfc8f1f62161a37890fd2278a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86cd399a11aba6fc1c4b932e4dc5c8f2"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classvcl_1_1Vertex.html">Vertex</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1comp_1_1AdjacentVertices.html#a86cd399a11aba6fc1c4b932e4dc5c8f2">adjVertex</a> (<a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> i) const</td></tr>
<tr class="memdesc:a86cd399a11aba6fc1c4b932e4dc5c8f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const pointer to the i-th adjacent vertex of the element.  <br /></td></tr>
<tr class="separator:a86cd399a11aba6fc1c4b932e4dc5c8f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e2fc8da81b97f8b70cb15ee053d3c5c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Vertex.html">Vertex</a> *&amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1comp_1_1AdjacentVertices.html#a9e2fc8da81b97f8b70cb15ee053d3c5c">adjVertexMod</a> (int i)</td></tr>
<tr class="memdesc:a9e2fc8da81b97f8b70cb15ee053d3c5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference of the pointer to the i-th adjacent vertex of the element, but using as index the module between i and the number of adjacent vertices. You can use this function if you need to get the "next
adjacent vertex after position k", without check if it is less than the number of adj vertices. Works also for negative numbers:  <br /></td></tr>
<tr class="separator:a9e2fc8da81b97f8b70cb15ee053d3c5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a784501d28ee60e60f697cee7ad6f801a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classvcl_1_1Vertex.html">Vertex</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1comp_1_1AdjacentVertices.html#a784501d28ee60e60f697cee7ad6f801a">adjVertexMod</a> (int i) const</td></tr>
<tr class="memdesc:a784501d28ee60e60f697cee7ad6f801a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same of adjVertexMod, but returns a const Pointer to the adjacent vertex.  <br /></td></tr>
<tr class="separator:a784501d28ee60e60f697cee7ad6f801a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a351e7efee277da2e76a4a98991bbffa1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1comp_1_1AdjacentVertices.html#a351e7efee277da2e76a4a98991bbffa1">setAdjVertex</a> (<a class="el" href="classvcl_1_1Vertex.html">Vertex</a> *v, <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> i)</td></tr>
<tr class="memdesc:a351e7efee277da2e76a4a98991bbffa1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the i-th adjacent vertex of the element.  <br /></td></tr>
<tr class="separator:a351e7efee277da2e76a4a98991bbffa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d628ec81cc6051cc01e6a625d12af3d"><td class="memTemplParams" colspan="2">template&lt;Range Rng&gt; <br />
requires RangeOfConvertibleTo&lt;Rng, <a class="el" href="classvcl_1_1Vertex.html">Vertex</a>*&gt;</td></tr>
<tr class="memitem:a3d628ec81cc6051cc01e6a625d12af3d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvcl_1_1comp_1_1AdjacentVertices.html#a3d628ec81cc6051cc01e6a625d12af3d">setAdjVertices</a> (Rng &amp;&amp;r)</td></tr>
<tr class="memdesc:a3d628ec81cc6051cc01e6a625d12af3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets all the adjacent vertices of this element.  <br /></td></tr>
<tr class="separator:a3d628ec81cc6051cc01e6a625d12af3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affbd6fa3eb1d7b03bb6a5f9f3da5b39b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1comp_1_1AdjacentVertices.html#affbd6fa3eb1d7b03bb6a5f9f3da5b39b">containsAdjVertex</a> (const <a class="el" href="classvcl_1_1Vertex.html">Vertex</a> *v) const</td></tr>
<tr class="memdesc:affbd6fa3eb1d7b03bb6a5f9f3da5b39b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if the container of adjacent vertices contains the given vertex, <code>false</code> otherwise.  <br /></td></tr>
<tr class="separator:affbd6fa3eb1d7b03bb6a5f9f3da5b39b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c7bccf7db69d0763731128ba8e5e9f3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1comp_1_1AdjacentVertices.html#abb99075b1fc6c8700eddc3aa2c22fe59">AdjacentVertexIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1comp_1_1AdjacentVertices.html#a2c7bccf7db69d0763731128ba8e5e9f3">findAdjVertex</a> (const <a class="el" href="classvcl_1_1Vertex.html">Vertex</a> *v)</td></tr>
<tr class="memdesc:a2c7bccf7db69d0763731128ba8e5e9f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first adjacent vertex in the container of this component that is equal to the given vertex. If no such adjacent vertex is found, past-the-end iterator is returned.  <br /></td></tr>
<tr class="separator:a2c7bccf7db69d0763731128ba8e5e9f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4f43fb53a8936e6bd21ea0c6519da36"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1comp_1_1AdjacentVertices.html#a236f97c116d359e0896fe64fcbfc6bb3">ConstAdjacentVertexIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1comp_1_1AdjacentVertices.html#ae4f43fb53a8936e6bd21ea0c6519da36">findAdjVertex</a> (const <a class="el" href="classvcl_1_1Vertex.html">Vertex</a> *v) const</td></tr>
<tr class="memdesc:ae4f43fb53a8936e6bd21ea0c6519da36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const iterator to the first adjacent vertex in the container of this component that is equal to the given vertex. If no such adjacent vertex is found, past-the-end iterator is returned.  <br /></td></tr>
<tr class="separator:ae4f43fb53a8936e6bd21ea0c6519da36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58284e2e82105fa1685e383f53ba573c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1comp_1_1AdjacentVertices.html#a58284e2e82105fa1685e383f53ba573c">indexOfAdjVertex</a> (const <a class="el" href="classvcl_1_1Vertex.html">Vertex</a> *v) const</td></tr>
<tr class="memdesc:a58284e2e82105fa1685e383f53ba573c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of the given adjacent vertex in the container of the element. If the given adjacent vertex is not in the container, returns UINT_NULL.  <br /></td></tr>
<tr class="separator:a58284e2e82105fa1685e383f53ba573c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1c3e938c5fff498418feb009e1f2fe6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1comp_1_1AdjacentVertices.html#ad1c3e938c5fff498418feb009e1f2fe6">resizeAdjVertices</a> (<a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> n)</td></tr>
<tr class="memdesc:ad1c3e938c5fff498418feb009e1f2fe6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resize the container of the adjacent vertices to the given size.  <br /></td></tr>
<tr class="separator:ad1c3e938c5fff498418feb009e1f2fe6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a297e231f3ff802022f28427855609894"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1comp_1_1AdjacentVertices.html#a297e231f3ff802022f28427855609894">pushAdjVertex</a> (<a class="el" href="classvcl_1_1Vertex.html">Vertex</a> *v)</td></tr>
<tr class="memdesc:a297e231f3ff802022f28427855609894"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pushes in the back of the container the given adjacent vertex.  <br /></td></tr>
<tr class="separator:a297e231f3ff802022f28427855609894"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a848850fe90ceca6fdf91882fdf9de258"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1comp_1_1AdjacentVertices.html#a848850fe90ceca6fdf91882fdf9de258">insertAdjVertex</a> (<a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> i, <a class="el" href="classvcl_1_1Vertex.html">Vertex</a> *v)</td></tr>
<tr class="memdesc:a848850fe90ceca6fdf91882fdf9de258"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts the given adjacent vertex in the container at the given position.  <br /></td></tr>
<tr class="separator:a848850fe90ceca6fdf91882fdf9de258"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a534d244cefb4b341db66c0a1407c5d89"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1comp_1_1AdjacentVertices.html#a534d244cefb4b341db66c0a1407c5d89">eraseAdjVertex</a> (<a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> i)</td></tr>
<tr class="memdesc:a534d244cefb4b341db66c0a1407c5d89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the adjacent vertex at the given position from the container.  <br /></td></tr>
<tr class="separator:a534d244cefb4b341db66c0a1407c5d89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a158a522fe0ba36edfc8311e736b2c7ce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1comp_1_1AdjacentVertices.html#a158a522fe0ba36edfc8311e736b2c7ce">clearAdjVertices</a> ()</td></tr>
<tr class="memdesc:a158a522fe0ba36edfc8311e736b2c7ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the container of adjacent vertices, making it empty.  <br /></td></tr>
<tr class="separator:a158a522fe0ba36edfc8311e736b2c7ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a027882ef414678d7778b612b4c5cc762"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1comp_1_1AdjacentVertices.html#abb99075b1fc6c8700eddc3aa2c22fe59">AdjacentVertexIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1comp_1_1AdjacentVertices.html#a027882ef414678d7778b612b4c5cc762">adjVertexBegin</a> ()</td></tr>
<tr class="memdesc:a027882ef414678d7778b612b4c5cc762"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first adjacent vertex in the container of this component.  <br /></td></tr>
<tr class="separator:a027882ef414678d7778b612b4c5cc762"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f1ed0e4f071d1a7e8a75cb0eb0e54cb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1comp_1_1AdjacentVertices.html#abb99075b1fc6c8700eddc3aa2c22fe59">AdjacentVertexIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1comp_1_1AdjacentVertices.html#a5f1ed0e4f071d1a7e8a75cb0eb0e54cb">adjVertexEnd</a> ()</td></tr>
<tr class="memdesc:a5f1ed0e4f071d1a7e8a75cb0eb0e54cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the end of the container of this component.  <br /></td></tr>
<tr class="separator:a5f1ed0e4f071d1a7e8a75cb0eb0e54cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add744d60fef6acdaf973ce5c10d8a02e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1comp_1_1AdjacentVertices.html#a236f97c116d359e0896fe64fcbfc6bb3">ConstAdjacentVertexIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1comp_1_1AdjacentVertices.html#add744d60fef6acdaf973ce5c10d8a02e">adjVertexBegin</a> () const</td></tr>
<tr class="memdesc:add744d60fef6acdaf973ce5c10d8a02e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const iterator to the first adjacent vertex in the container of this component.  <br /></td></tr>
<tr class="separator:add744d60fef6acdaf973ce5c10d8a02e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c227921b3370515a792f85d3e3abb00"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1comp_1_1AdjacentVertices.html#a236f97c116d359e0896fe64fcbfc6bb3">ConstAdjacentVertexIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1comp_1_1AdjacentVertices.html#a9c227921b3370515a792f85d3e3abb00">adjVertexEnd</a> () const</td></tr>
<tr class="memdesc:a9c227921b3370515a792f85d3e3abb00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const iterator to the end of the container of this component.  <br /></td></tr>
<tr class="separator:a9c227921b3370515a792f85d3e3abb00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae300cec0f1b8f2a35621189517f6ac29"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1View.html">View</a>&lt; <a class="el" href="classvcl_1_1comp_1_1AdjacentVertices.html#abb99075b1fc6c8700eddc3aa2c22fe59">AdjacentVertexIterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1comp_1_1AdjacentVertices.html#ae300cec0f1b8f2a35621189517f6ac29">adjVertices</a> ()</td></tr>
<tr class="memdesc:ae300cec0f1b8f2a35621189517f6ac29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a lightweight view object that stores the begin and end iterators of the container of adjacent vertices of the element. The view object exposes the iterators trough the <code>begin()</code> and <code>end()</code> member functions, and therefore the returned object can be used in range-based for loops:  <br /></td></tr>
<tr class="separator:ae300cec0f1b8f2a35621189517f6ac29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72167e072ac42d2d9e8c23c505310349"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1View.html">View</a>&lt; <a class="el" href="classvcl_1_1comp_1_1AdjacentVertices.html#a236f97c116d359e0896fe64fcbfc6bb3">ConstAdjacentVertexIterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1comp_1_1AdjacentVertices.html#a72167e072ac42d2d9e8c23c505310349">adjVertices</a> () const</td></tr>
<tr class="memdesc:a72167e072ac42d2d9e8c23c505310349"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a lightweight const view object that stores the begin and end iterators of the container of adjacent vertices of the element. The view object exposes the iterators trough the <code>begin()</code> and <code>end()</code> member functions, and therefore the returned object can be used in range-based for loops:  <br /></td></tr>
<tr class="separator:a72167e072ac42d2d9e8c23c505310349"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f8b5fb47bdd97c039bd6b76aeaf201c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1comp_1_1AdjacentVertices.html#a1f8b5fb47bdd97c039bd6b76aeaf201c">__adjacentVertices</a> () const</td></tr>
<tr class="separator:a1f8b5fb47bdd97c039bd6b76aeaf201c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a9d0759e97babd7c5454fd2537204f6e0"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="classvcl_1_1Element.html">Element</a> &gt; </td></tr>
<tr class="memitem:a9d0759e97babd7c5454fd2537204f6e0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvcl_1_1comp_1_1AdjacentVertices.html#a9d0759e97babd7c5454fd2537204f6e0">importFrom</a> (const <a class="el" href="classvcl_1_1Element.html">Element</a> &amp;e)</td></tr>
<tr class="separator:a9d0759e97babd7c5454fd2537204f6e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68151af57283f1f1a62e7e91468e611f"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="classvcl_1_1Element.html">Element</a> , typename ElVType &gt; </td></tr>
<tr class="memitem:a68151af57283f1f1a62e7e91468e611f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvcl_1_1comp_1_1AdjacentVertices.html#a68151af57283f1f1a62e7e91468e611f">importPointersFrom</a> (const <a class="el" href="classvcl_1_1Element.html">Element</a> &amp;e, <a class="el" href="classvcl_1_1Vertex.html">Vertex</a> *base, const ElVType *ebase)</td></tr>
<tr class="separator:a68151af57283f1f1a62e7e91468e611f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classvcl_1_1comp_1_1PointersContainerComponent"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classvcl_1_1comp_1_1PointersContainerComponent')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classvcl_1_1comp_1_1PointersContainerComponent.html">vcl::comp::PointersContainerComponent&lt; DerivedComponent, COMP_ID, Elem, N, ElementType, OPT, TTVN &gt;</a></td></tr>
<tr class="memitem:a026d4ef4834affee614ab4f480ea7b61 inherit pro_methods_classvcl_1_1comp_1_1PointersContainerComponent"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1comp_1_1PointersContainerComponent.html#a026d4ef4834affee614ab4f480ea7b61">updatePointers</a> (const Elem *oldBase, const Elem *newBase)</td></tr>
<tr class="separator:a026d4ef4834affee614ab4f480ea7b61 inherit pro_methods_classvcl_1_1comp_1_1PointersContainerComponent"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa9cdf2268d72e4e1178ee47857e1ab5 inherit pro_methods_classvcl_1_1comp_1_1PointersContainerComponent"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1comp_1_1PointersContainerComponent.html#afa9cdf2268d72e4e1178ee47857e1ab5">updatePointers</a> (const Elem *base, const std::vector&lt; <a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> &gt; &amp;newIndices)</td></tr>
<tr class="separator:afa9cdf2268d72e4e1178ee47857e1ab5 inherit pro_methods_classvcl_1_1comp_1_1PointersContainerComponent"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classvcl_1_1comp_1_1ContainerComponent"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classvcl_1_1comp_1_1ContainerComponent')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classvcl_1_1comp_1_1ContainerComponent.html">vcl::comp::ContainerComponent&lt; DerivedComponent, COMP_ID, Elem *, N, void, ElementType, OPT, TTVN, Elem &gt;</a></td></tr>
<tr class="memitem:a21132a7364f2bb9b2eb0f232fbbaa9d4 inherit pro_methods_classvcl_1_1comp_1_1ContainerComponent"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1comp_1_1ContainerComponent.html#a21132a7364f2bb9b2eb0f232fbbaa9d4">ContainerComponent</a> ()</td></tr>
<tr class="separator:a21132a7364f2bb9b2eb0f232fbbaa9d4 inherit pro_methods_classvcl_1_1comp_1_1ContainerComponent"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac19a61f2ec112e333b9d96ae52d294c0 inherit pro_methods_classvcl_1_1comp_1_1ContainerComponent"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1comp_1_1ContainerComponent.html#ac19a61f2ec112e333b9d96ae52d294c0">init</a> ()</td></tr>
<tr class="separator:ac19a61f2ec112e333b9d96ae52d294c0 inherit pro_methods_classvcl_1_1comp_1_1ContainerComponent"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a133e2bf8c83a1b8d80dc40dd30f1b38b inherit pro_methods_classvcl_1_1comp_1_1ContainerComponent"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Vector.html">Vector</a>&lt; Elem *, N &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1comp_1_1ContainerComponent.html#a133e2bf8c83a1b8d80dc40dd30f1b38b">container</a> ()</td></tr>
<tr class="separator:a133e2bf8c83a1b8d80dc40dd30f1b38b inherit pro_methods_classvcl_1_1comp_1_1ContainerComponent"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f2ce65a89d188a54624df11feadaee9 inherit pro_methods_classvcl_1_1comp_1_1ContainerComponent"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classvcl_1_1Vector.html">Vector</a>&lt; Elem *, N &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1comp_1_1ContainerComponent.html#a0f2ce65a89d188a54624df11feadaee9">container</a> () const</td></tr>
<tr class="separator:a0f2ce65a89d188a54624df11feadaee9 inherit pro_methods_classvcl_1_1comp_1_1ContainerComponent"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7402d2bf68f0375ed4a47b488480f454 inherit pro_methods_classvcl_1_1comp_1_1ContainerComponent"><td class="memItemLeft" align="right" valign="top">AdDt &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1comp_1_1ContainerComponent.html#a7402d2bf68f0375ed4a47b488480f454">additionalData</a> ()</td></tr>
<tr class="separator:a7402d2bf68f0375ed4a47b488480f454 inherit pro_methods_classvcl_1_1comp_1_1ContainerComponent"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0a72197419c5ab43ab579edb73b5d4d inherit pro_methods_classvcl_1_1comp_1_1ContainerComponent"><td class="memItemLeft" align="right" valign="top">const AdDt &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1comp_1_1ContainerComponent.html#ad0a72197419c5ab43ab579edb73b5d4d">additionalData</a> () const</td></tr>
<tr class="separator:ad0a72197419c5ab43ab579edb73b5d4d inherit pro_methods_classvcl_1_1comp_1_1ContainerComponent"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_static_attribs_classvcl_1_1comp_1_1ContainerComponent"><td colspan="2" onclick="javascript:toggleInherit('pub_static_attribs_classvcl_1_1comp_1_1ContainerComponent')"><img src="closed.png" alt="-"/>&#160;Static Public Attributes inherited from <a class="el" href="classvcl_1_1comp_1_1ContainerComponent.html">vcl::comp::ContainerComponent&lt; DerivedComponent, COMP_ID, Elem *, N, void, ElementType, OPT, TTVN, Elem &gt;</a></td></tr>
<tr class="memitem:ad9109da47fc44206942ad6e898edc265 inherit pub_static_attribs_classvcl_1_1comp_1_1ContainerComponent"><td class="memItemLeft" align="right" valign="top">static const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1comp_1_1ContainerComponent.html#ad9109da47fc44206942ad6e898edc265">TIED_TO_VERTEX_NUMBER</a></td></tr>
<tr class="memdesc:ad9109da47fc44206942ad6e898edc265 inherit pub_static_attribs_classvcl_1_1comp_1_1ContainerComponent"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boolean that tells if this component stores a container having its size tied to the number of the vertices of the <a class="el" href="classvcl_1_1Element.html" title="The Element class.">Element</a>.  <br /></td></tr>
<tr class="separator:ad9109da47fc44206942ad6e898edc265 inherit pub_static_attribs_classvcl_1_1comp_1_1ContainerComponent"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55bdcf274fd254c22695eeae66403bad inherit pub_static_attribs_classvcl_1_1comp_1_1ContainerComponent"><td class="memItemLeft" align="right" valign="top">static const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1comp_1_1ContainerComponent.html#a55bdcf274fd254c22695eeae66403bad">SIZE</a></td></tr>
<tr class="separator:a55bdcf274fd254c22695eeae66403bad inherit pub_static_attribs_classvcl_1_1comp_1_1ContainerComponent"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_types_classvcl_1_1comp_1_1ContainerComponent"><td colspan="2" onclick="javascript:toggleInherit('pro_types_classvcl_1_1comp_1_1ContainerComponent')"><img src="closed.png" alt="-"/>&#160;Protected Types inherited from <a class="el" href="classvcl_1_1comp_1_1ContainerComponent.html">vcl::comp::ContainerComponent&lt; DerivedComponent, COMP_ID, Elem *, N, void, ElementType, OPT, TTVN, Elem &gt;</a></td></tr>
<tr class="memitem:ad35631dd272b71e139983d908282e677 inherit pro_types_classvcl_1_1comp_1_1ContainerComponent"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1comp_1_1ContainerComponent.html#ad35631dd272b71e139983d908282e677">Iterator</a> = <a class="el" href="classvcl_1_1Vector.html">Vector</a>&lt; Elem *, N &gt;::Iterator</td></tr>
<tr class="separator:ad35631dd272b71e139983d908282e677 inherit pro_types_classvcl_1_1comp_1_1ContainerComponent"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4345d7d498cae01d7a7c74ae525d5769 inherit pro_types_classvcl_1_1comp_1_1ContainerComponent"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcl_1_1comp_1_1ContainerComponent.html#a4345d7d498cae01d7a7c74ae525d5769">ConstIterator</a> = <a class="el" href="classvcl_1_1Vector.html">Vector</a>&lt; Elem *, N &gt;::ConstIterator</td></tr>
<tr class="separator:a4345d7d498cae01d7a7c74ae525d5769 inherit pro_types_classvcl_1_1comp_1_1ContainerComponent"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename <a class="el" href="classvcl_1_1Vertex.html">Vertex</a>, typename ElementType = void, bool OPT = false&gt;<br />
class vcl::comp::AdjacentVertices&lt; Vertex, ElementType, OPT &gt;</div><p>The <a class="el" href="classvcl_1_1comp_1_1AdjacentVertices.html" title="The AdjacentVertices class is a container of Vertex pointers. It is a component that makes sense to u...">AdjacentVertices</a> class is a container of <a class="el" href="classvcl_1_1Vertex.html" title="The Vertex class represents an Vertex element of the vcl::Mesh class.">Vertex</a> pointers. It is a component that makes sense to use mostly on <a class="el" href="classvcl_1_1Vertex.html" title="The Vertex class represents an Vertex element of the vcl::Mesh class.">Vertex</a> Elements. For Faces and Edges, see the <a class="el" href="classvcl_1_1comp_1_1VertexPointers.html" title="The VertexPointers class represents a component that stores a container of pointers to vertices that ...">VertexPointers</a> component (which is similar, but has different member function names). </p>
<p>It is a random access container having dynamic size.</p>
<p>The member functions of this class will be available in the instance of any <a class="el" href="classvcl_1_1Element.html" title="The Element class.">Element</a> that will contain this component.</p>
<p>For example, if you have a <a class="el" href="classvcl_1_1Vertex.html" title="The Vertex class represents an Vertex element of the vcl::Mesh class.">Vertex</a> <a class="el" href="classvcl_1_1Element.html" title="The Element class.">Element</a> <code>v</code> that has the <a class="el" href="classvcl_1_1comp_1_1AdjacentVertices.html" title="The AdjacentVertices class is a container of Vertex pointers. It is a component that makes sense to u...">AdjacentVertices</a> component, you'll be able to access to this component member functions from <code>v</code>:</p>
<div class="fragment"><div class="line">v.adjVerticesNumber();</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>With respect to the other components that store adjacencies, this component does not have two template arguments:<ul>
<li><code>N</code>, because the container of adjacent vertices is always dynamic (there are no contexts in which it would make sense to have a fixed size container of adjacent vertices);</li>
<li><code>TTVN</code>, because this argument is used on components that could be part of face elements, and this component does not apply to faces.</li>
</ul>
</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="el" href="classvcl_1_1Vertex.html" title="The Vertex class represents an Vertex element of the vcl::Mesh class.">Vertex</a></td><td>The type of the adjacent <a class="el" href="classvcl_1_1Vertex.html" title="The Vertex class represents an Vertex element of the vcl::Mesh class.">Vertex</a> element. </td></tr>
    <tr><td class="paramname">ElementType</td><td>This template argument must be <code>void</code> if the component needs to be stored horizontally, or the type of the element that will contain this component if the component needs to be stored vertically. </td></tr>
    <tr><td class="paramname">OPT</td><td>If true, the component will be optional. This argument is considered only if the component is stored vertically. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="abb99075b1fc6c8700eddc3aa2c22fe59" name="abb99075b1fc6c8700eddc3aa2c22fe59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb99075b1fc6c8700eddc3aa2c22fe59">&#9670;&#160;</a></span>AdjacentVertexIterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classvcl_1_1Vertex.html">Vertex</a> , typename ElementType  = void, bool OPT = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classvcl_1_1comp_1_1AdjacentVertices.html">vcl::comp::AdjacentVertices</a>&lt; <a class="el" href="classvcl_1_1Vertex.html">Vertex</a>, ElementType, OPT &gt;::AdjacentVertexIterator =  <a class="el" href="classvcl_1_1comp_1_1ContainerComponent.html#ad35631dd272b71e139983d908282e677">Base::Iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0ecc6abcd32048a95ee3dc4e88bf339a" name="a0ecc6abcd32048a95ee3dc4e88bf339a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ecc6abcd32048a95ee3dc4e88bf339a">&#9670;&#160;</a></span>AdjacentVertexType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classvcl_1_1Vertex.html">Vertex</a> , typename ElementType  = void, bool OPT = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classvcl_1_1comp_1_1AdjacentVertices.html">vcl::comp::AdjacentVertices</a>&lt; <a class="el" href="classvcl_1_1Vertex.html">Vertex</a>, ElementType, OPT &gt;::AdjacentVertexType =  <a class="el" href="classvcl_1_1Vertex.html">Vertex</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Expose the type of the Adjacent <a class="el" href="classvcl_1_1Vertex.html" title="The Vertex class represents an Vertex element of the vcl::Mesh class.">Vertex</a>. </p>

</div>
</div>
<a id="a236f97c116d359e0896fe64fcbfc6bb3" name="a236f97c116d359e0896fe64fcbfc6bb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a236f97c116d359e0896fe64fcbfc6bb3">&#9670;&#160;</a></span>ConstAdjacentVertexIterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classvcl_1_1Vertex.html">Vertex</a> , typename ElementType  = void, bool OPT = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classvcl_1_1comp_1_1AdjacentVertices.html">vcl::comp::AdjacentVertices</a>&lt; <a class="el" href="classvcl_1_1Vertex.html">Vertex</a>, ElementType, OPT &gt;::ConstAdjacentVertexIterator =  <a class="el" href="classvcl_1_1comp_1_1ContainerComponent.html#a4345d7d498cae01d7a7c74ae525d5769">Base::ConstIterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a1f8b5fb47bdd97c039bd6b76aeaf201c" name="a1f8b5fb47bdd97c039bd6b76aeaf201c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f8b5fb47bdd97c039bd6b76aeaf201c">&#9670;&#160;</a></span>__adjacentVertices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classvcl_1_1Vertex.html">Vertex</a> , typename ElementType  = void, bool OPT = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classvcl_1_1comp_1_1AdjacentVertices.html">vcl::comp::AdjacentVertices</a>&lt; <a class="el" href="classvcl_1_1Vertex.html">Vertex</a>, ElementType, OPT &gt;::__adjacentVertices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8b26304dfc8f1f62161a37890fd2278a" name="a8b26304dfc8f1f62161a37890fd2278a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b26304dfc8f1f62161a37890fd2278a">&#9670;&#160;</a></span>adjVertex() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classvcl_1_1Vertex.html">Vertex</a> , typename ElementType  = void, bool OPT = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Vertex.html">Vertex</a> *&amp; <a class="el" href="classvcl_1_1comp_1_1AdjacentVertices.html">vcl::comp::AdjacentVertices</a>&lt; <a class="el" href="classvcl_1_1Vertex.html">Vertex</a>, ElementType, OPT &gt;::adjVertex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference of the pointer to the i-th adjacent vertex of an element. </p>
<p>You can use this function to set the i-th adjacent vertex:</p>
<div class="fragment"><div class="line">e.adjVertex(2) = &amp;m.vertex(k); <span class="comment">// the second adj vertex of e will point</span></div>
<div class="line">                               <span class="comment">// to the k-th vertex of the mesh.</span></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>the position of the required adjacent vertex in the container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The pointer i-th adjacent vertex of the element. </dd></dl>

</div>
</div>
<a id="a86cd399a11aba6fc1c4b932e4dc5c8f2" name="a86cd399a11aba6fc1c4b932e4dc5c8f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86cd399a11aba6fc1c4b932e4dc5c8f2">&#9670;&#160;</a></span>adjVertex() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classvcl_1_1Vertex.html">Vertex</a> , typename ElementType  = void, bool OPT = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classvcl_1_1Vertex.html">Vertex</a> * <a class="el" href="classvcl_1_1comp_1_1AdjacentVertices.html">vcl::comp::AdjacentVertices</a>&lt; <a class="el" href="classvcl_1_1Vertex.html">Vertex</a>, ElementType, OPT &gt;::adjVertex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a const pointer to the i-th adjacent vertex of the element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>the position of the required adjacent vertex in the container; the value must be between 0 and the number of adj vertices. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The pointer to the i-th adjacent vertex of the element. </dd></dl>

</div>
</div>
<a id="a027882ef414678d7778b612b4c5cc762" name="a027882ef414678d7778b612b4c5cc762"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a027882ef414678d7778b612b4c5cc762">&#9670;&#160;</a></span>adjVertexBegin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classvcl_1_1Vertex.html">Vertex</a> , typename ElementType  = void, bool OPT = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1comp_1_1AdjacentVertices.html#abb99075b1fc6c8700eddc3aa2c22fe59">AdjacentVertexIterator</a> <a class="el" href="classvcl_1_1comp_1_1AdjacentVertices.html">vcl::comp::AdjacentVertices</a>&lt; <a class="el" href="classvcl_1_1Vertex.html">Vertex</a>, ElementType, OPT &gt;::adjVertexBegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the first adjacent vertex in the container of this component. </p>
<dl class="section return"><dt>Returns</dt><dd>an iterator pointing to the begin of this container. </dd></dl>

</div>
</div>
<a id="add744d60fef6acdaf973ce5c10d8a02e" name="add744d60fef6acdaf973ce5c10d8a02e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add744d60fef6acdaf973ce5c10d8a02e">&#9670;&#160;</a></span>adjVertexBegin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classvcl_1_1Vertex.html">Vertex</a> , typename ElementType  = void, bool OPT = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1comp_1_1AdjacentVertices.html#a236f97c116d359e0896fe64fcbfc6bb3">ConstAdjacentVertexIterator</a> <a class="el" href="classvcl_1_1comp_1_1AdjacentVertices.html">vcl::comp::AdjacentVertices</a>&lt; <a class="el" href="classvcl_1_1Vertex.html">Vertex</a>, ElementType, OPT &gt;::adjVertexBegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a const iterator to the first adjacent vertex in the container of this component. </p>
<dl class="section return"><dt>Returns</dt><dd>an iterator pointing to the begin of this container. </dd></dl>

</div>
</div>
<a id="a5f1ed0e4f071d1a7e8a75cb0eb0e54cb" name="a5f1ed0e4f071d1a7e8a75cb0eb0e54cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f1ed0e4f071d1a7e8a75cb0eb0e54cb">&#9670;&#160;</a></span>adjVertexEnd() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classvcl_1_1Vertex.html">Vertex</a> , typename ElementType  = void, bool OPT = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1comp_1_1AdjacentVertices.html#abb99075b1fc6c8700eddc3aa2c22fe59">AdjacentVertexIterator</a> <a class="el" href="classvcl_1_1comp_1_1AdjacentVertices.html">vcl::comp::AdjacentVertices</a>&lt; <a class="el" href="classvcl_1_1Vertex.html">Vertex</a>, ElementType, OPT &gt;::adjVertexEnd </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the end of the container of this component. </p>
<dl class="section return"><dt>Returns</dt><dd>an iterator pointing to the end of this container. </dd></dl>

</div>
</div>
<a id="a9c227921b3370515a792f85d3e3abb00" name="a9c227921b3370515a792f85d3e3abb00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c227921b3370515a792f85d3e3abb00">&#9670;&#160;</a></span>adjVertexEnd() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classvcl_1_1Vertex.html">Vertex</a> , typename ElementType  = void, bool OPT = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1comp_1_1AdjacentVertices.html#a236f97c116d359e0896fe64fcbfc6bb3">ConstAdjacentVertexIterator</a> <a class="el" href="classvcl_1_1comp_1_1AdjacentVertices.html">vcl::comp::AdjacentVertices</a>&lt; <a class="el" href="classvcl_1_1Vertex.html">Vertex</a>, ElementType, OPT &gt;::adjVertexEnd </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a const iterator to the end of the container of this component. </p>
<dl class="section return"><dt>Returns</dt><dd>an iterator pointing to the end of this container. </dd></dl>

</div>
</div>
<a id="a9e2fc8da81b97f8b70cb15ee053d3c5c" name="a9e2fc8da81b97f8b70cb15ee053d3c5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e2fc8da81b97f8b70cb15ee053d3c5c">&#9670;&#160;</a></span>adjVertexMod() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classvcl_1_1Vertex.html">Vertex</a> , typename ElementType  = void, bool OPT = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Vertex.html">Vertex</a> *&amp; <a class="el" href="classvcl_1_1comp_1_1AdjacentVertices.html">vcl::comp::AdjacentVertices</a>&lt; <a class="el" href="classvcl_1_1Vertex.html">Vertex</a>, ElementType, OPT &gt;::adjVertexMod </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference of the pointer to the i-th adjacent vertex of the element, but using as index the module between i and the number of adjacent vertices. You can use this function if you need to get the "next
adjacent vertex after position k", without check if it is less than the number of adj vertices. Works also for negative numbers: </p>
<div class="fragment"><div class="line">k = pos; <span class="comment">// some position of an adjacent vertex</span></div>
<div class="line"><span class="keyword">auto</span>* next = e.adjVertexMod(k+1); <span class="comment">// the adj vertex next to k, that may</span></div>
<div class="line">                                  <span class="comment">// also be at pos 0</span></div>
<div class="line"><span class="keyword">auto</span>* last = e.adjVertexMod(-1); <span class="comment">// the adj vertex in position</span></div>
<div class="line">                                 <span class="comment">// adjVertexNumber()-1</span></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>the position of the required adjacent vertex in the container, w.r.t. the position 0; value is modularized on adjVertexNumber(). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The pointer to the required adjacent vertex of the element. </dd></dl>

</div>
</div>
<a id="a784501d28ee60e60f697cee7ad6f801a" name="a784501d28ee60e60f697cee7ad6f801a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a784501d28ee60e60f697cee7ad6f801a">&#9670;&#160;</a></span>adjVertexMod() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classvcl_1_1Vertex.html">Vertex</a> , typename ElementType  = void, bool OPT = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classvcl_1_1Vertex.html">Vertex</a> * <a class="el" href="classvcl_1_1comp_1_1AdjacentVertices.html">vcl::comp::AdjacentVertices</a>&lt; <a class="el" href="classvcl_1_1Vertex.html">Vertex</a>, ElementType, OPT &gt;::adjVertexMod </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same of adjVertexMod, but returns a const Pointer to the adjacent vertex. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>the position of the required adjacent vertex in the container, w.r.t. the position 0; value is modularized on adjVertexNumber(). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The pointer to the required adjacent vertex of the element. </dd></dl>

</div>
</div>
<a id="ae300cec0f1b8f2a35621189517f6ac29" name="ae300cec0f1b8f2a35621189517f6ac29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae300cec0f1b8f2a35621189517f6ac29">&#9670;&#160;</a></span>adjVertices() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classvcl_1_1Vertex.html">Vertex</a> , typename ElementType  = void, bool OPT = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1View.html">View</a>&lt; <a class="el" href="classvcl_1_1comp_1_1AdjacentVertices.html#abb99075b1fc6c8700eddc3aa2c22fe59">AdjacentVertexIterator</a> &gt; <a class="el" href="classvcl_1_1comp_1_1AdjacentVertices.html">vcl::comp::AdjacentVertices</a>&lt; <a class="el" href="classvcl_1_1Vertex.html">Vertex</a>, ElementType, OPT &gt;::adjVertices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a lightweight view object that stores the begin and end iterators of the container of adjacent vertices of the element. The view object exposes the iterators trough the <code>begin()</code> and <code>end()</code> member functions, and therefore the returned object can be used in range-based for loops: </p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span>* <a class="code hl_function" href="classvcl_1_1comp_1_1AdjacentVertices.html#a8b26304dfc8f1f62161a37890fd2278a">adjVertex</a> : el.adjVertices()) {</div>
<div class="line">    <span class="comment">// Do something with adjVertex</span></div>
<div class="line">}</div>
<div class="ttc" id="aclassvcl_1_1comp_1_1AdjacentVertices_html_a8b26304dfc8f1f62161a37890fd2278a"><div class="ttname"><a href="classvcl_1_1comp_1_1AdjacentVertices.html#a8b26304dfc8f1f62161a37890fd2278a">vcl::comp::AdjacentVertices::adjVertex</a></div><div class="ttdeci">Vertex *&amp; adjVertex(uint i)</div><div class="ttdoc">Returns a reference of the pointer to the i-th adjacent vertex of an element.</div><div class="ttdef"><b>Definition:</b> adjacent_vertices.h:124</div></div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>a lightweight view object that can be used in range-based for loops to iterate over adjacent vertices. </dd></dl>

</div>
</div>
<a id="a72167e072ac42d2d9e8c23c505310349" name="a72167e072ac42d2d9e8c23c505310349"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72167e072ac42d2d9e8c23c505310349">&#9670;&#160;</a></span>adjVertices() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classvcl_1_1Vertex.html">Vertex</a> , typename ElementType  = void, bool OPT = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1View.html">View</a>&lt; <a class="el" href="classvcl_1_1comp_1_1AdjacentVertices.html#a236f97c116d359e0896fe64fcbfc6bb3">ConstAdjacentVertexIterator</a> &gt; <a class="el" href="classvcl_1_1comp_1_1AdjacentVertices.html">vcl::comp::AdjacentVertices</a>&lt; <a class="el" href="classvcl_1_1Vertex.html">Vertex</a>, ElementType, OPT &gt;::adjVertices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a lightweight const view object that stores the begin and end iterators of the container of adjacent vertices of the element. The view object exposes the iterators trough the <code>begin()</code> and <code>end()</code> member functions, and therefore the returned object can be used in range-based for loops: </p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>* adjEdge : el.adjVertices()) {</div>
<div class="line">    <span class="comment">// Do something read-only with adjVertex</span></div>
<div class="line">}</div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>a lightweight view object that can be used in range-based for loops to iterate over adjacent edges. </dd></dl>

</div>
</div>
<a id="ac929d334918d267834f750a546153f9e" name="ac929d334918d267834f750a546153f9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac929d334918d267834f750a546153f9e">&#9670;&#160;</a></span>adjVerticesNumber()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classvcl_1_1Vertex.html">Vertex</a> , typename ElementType  = void, bool OPT = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> <a class="el" href="classvcl_1_1comp_1_1AdjacentVertices.html">vcl::comp::AdjacentVertices</a>&lt; <a class="el" href="classvcl_1_1Vertex.html">Vertex</a>, ElementType, OPT &gt;::adjVerticesNumber </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of adjacent vertices of the element. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of adjacent vertices of the element. </dd></dl>

</div>
</div>
<a id="a158a522fe0ba36edfc8311e736b2c7ce" name="a158a522fe0ba36edfc8311e736b2c7ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a158a522fe0ba36edfc8311e736b2c7ce">&#9670;&#160;</a></span>clearAdjVertices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classvcl_1_1Vertex.html">Vertex</a> , typename ElementType  = void, bool OPT = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classvcl_1_1comp_1_1AdjacentVertices.html">vcl::comp::AdjacentVertices</a>&lt; <a class="el" href="classvcl_1_1Vertex.html">Vertex</a>, ElementType, OPT &gt;::clearAdjVertices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clears the container of adjacent vertices, making it empty. </p>
<dl class="section note"><dt>Note</dt><dd>This function is available only if the container of the Adjacent Vertices component has dynamic size. </dd></dl>

</div>
</div>
<a id="affbd6fa3eb1d7b03bb6a5f9f3da5b39b" name="affbd6fa3eb1d7b03bb6a5f9f3da5b39b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affbd6fa3eb1d7b03bb6a5f9f3da5b39b">&#9670;&#160;</a></span>containsAdjVertex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classvcl_1_1Vertex.html">Vertex</a> , typename ElementType  = void, bool OPT = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classvcl_1_1comp_1_1AdjacentVertices.html">vcl::comp::AdjacentVertices</a>&lt; <a class="el" href="classvcl_1_1Vertex.html">Vertex</a>, ElementType, OPT &gt;::containsAdjVertex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvcl_1_1Vertex.html">Vertex</a> *&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <code>true</code> if the container of adjacent vertices contains the given vertex, <code>false</code> otherwise. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>the pointer to the vertex to search. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the container of adjacent vertices contains the given vertex, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="a534d244cefb4b341db66c0a1407c5d89" name="a534d244cefb4b341db66c0a1407c5d89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a534d244cefb4b341db66c0a1407c5d89">&#9670;&#160;</a></span>eraseAdjVertex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classvcl_1_1Vertex.html">Vertex</a> , typename ElementType  = void, bool OPT = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classvcl_1_1comp_1_1AdjacentVertices.html">vcl::comp::AdjacentVertices</a>&lt; <a class="el" href="classvcl_1_1Vertex.html">Vertex</a>, ElementType, OPT &gt;::eraseAdjVertex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the adjacent vertex at the given position from the container. </p>
<dl class="section note"><dt>Note</dt><dd>This function is available only if the container of the Adjacent Vertices component has dynamic size. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>The position of the adjacent vertex to remove from the container. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2c7bccf7db69d0763731128ba8e5e9f3" name="a2c7bccf7db69d0763731128ba8e5e9f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c7bccf7db69d0763731128ba8e5e9f3">&#9670;&#160;</a></span>findAdjVertex() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classvcl_1_1Vertex.html">Vertex</a> , typename ElementType  = void, bool OPT = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1comp_1_1AdjacentVertices.html#abb99075b1fc6c8700eddc3aa2c22fe59">AdjacentVertexIterator</a> <a class="el" href="classvcl_1_1comp_1_1AdjacentVertices.html">vcl::comp::AdjacentVertices</a>&lt; <a class="el" href="classvcl_1_1Vertex.html">Vertex</a>, ElementType, OPT &gt;::findAdjVertex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvcl_1_1Vertex.html">Vertex</a> *&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the first adjacent vertex in the container of this component that is equal to the given vertex. If no such adjacent vertex is found, past-the-end iterator is returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>the pointer to the vertex to search. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an iterator pointing to the first adjacent vertex equal to the given vertex, or end if no such adjacent vertex is found. </dd></dl>

</div>
</div>
<a id="ae4f43fb53a8936e6bd21ea0c6519da36" name="ae4f43fb53a8936e6bd21ea0c6519da36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4f43fb53a8936e6bd21ea0c6519da36">&#9670;&#160;</a></span>findAdjVertex() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classvcl_1_1Vertex.html">Vertex</a> , typename ElementType  = void, bool OPT = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1comp_1_1AdjacentVertices.html#a236f97c116d359e0896fe64fcbfc6bb3">ConstAdjacentVertexIterator</a> <a class="el" href="classvcl_1_1comp_1_1AdjacentVertices.html">vcl::comp::AdjacentVertices</a>&lt; <a class="el" href="classvcl_1_1Vertex.html">Vertex</a>, ElementType, OPT &gt;::findAdjVertex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvcl_1_1Vertex.html">Vertex</a> *&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a const iterator to the first adjacent vertex in the container of this component that is equal to the given vertex. If no such adjacent vertex is found, past-the-end iterator is returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>the pointer to the vertex to search. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a const iterator pointing to the first adjacent vertex equal to the given vertex, or end if no such adjacent vertex is found. </dd></dl>

</div>
</div>
<a id="a9d0759e97babd7c5454fd2537204f6e0" name="a9d0759e97babd7c5454fd2537204f6e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d0759e97babd7c5454fd2537204f6e0">&#9670;&#160;</a></span>importFrom()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classvcl_1_1Vertex.html">Vertex</a> , typename ElementType  = void, bool OPT = false&gt; </div>
<div class="memtemplate">
template&lt;typename <a class="el" href="classvcl_1_1Element.html">Element</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classvcl_1_1comp_1_1AdjacentVertices.html">vcl::comp::AdjacentVertices</a>&lt; <a class="el" href="classvcl_1_1Vertex.html">Vertex</a>, ElementType, OPT &gt;::importFrom </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvcl_1_1Element.html">Element</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a68151af57283f1f1a62e7e91468e611f" name="a68151af57283f1f1a62e7e91468e611f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68151af57283f1f1a62e7e91468e611f">&#9670;&#160;</a></span>importPointersFrom()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classvcl_1_1Vertex.html">Vertex</a> , typename ElementType  = void, bool OPT = false&gt; </div>
<div class="memtemplate">
template&lt;typename <a class="el" href="classvcl_1_1Element.html">Element</a> , typename ElVType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classvcl_1_1comp_1_1AdjacentVertices.html">vcl::comp::AdjacentVertices</a>&lt; <a class="el" href="classvcl_1_1Vertex.html">Vertex</a>, ElementType, OPT &gt;::importPointersFrom </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvcl_1_1Element.html">Element</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Vertex.html">Vertex</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ElVType *&#160;</td>
          <td class="paramname"><em>ebase</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a58284e2e82105fa1685e383f53ba573c" name="a58284e2e82105fa1685e383f53ba573c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58284e2e82105fa1685e383f53ba573c">&#9670;&#160;</a></span>indexOfAdjVertex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classvcl_1_1Vertex.html">Vertex</a> , typename ElementType  = void, bool OPT = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> <a class="el" href="classvcl_1_1comp_1_1AdjacentVertices.html">vcl::comp::AdjacentVertices</a>&lt; <a class="el" href="classvcl_1_1Vertex.html">Vertex</a>, ElementType, OPT &gt;::indexOfAdjVertex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvcl_1_1Vertex.html">Vertex</a> *&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the index of the given adjacent vertex in the container of the element. If the given adjacent vertex is not in the container, returns UINT_NULL. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>the pointer to the adjacent vertex to search. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the index of the given adjacent vertex, or UINT_NULL if it is not found. </dd></dl>

</div>
</div>
<a id="a848850fe90ceca6fdf91882fdf9de258" name="a848850fe90ceca6fdf91882fdf9de258"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a848850fe90ceca6fdf91882fdf9de258">&#9670;&#160;</a></span>insertAdjVertex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classvcl_1_1Vertex.html">Vertex</a> , typename ElementType  = void, bool OPT = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classvcl_1_1comp_1_1AdjacentVertices.html">vcl::comp::AdjacentVertices</a>&lt; <a class="el" href="classvcl_1_1Vertex.html">Vertex</a>, ElementType, OPT &gt;::insertAdjVertex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Vertex.html">Vertex</a> *&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts the given adjacent vertex in the container at the given position. </p>
<dl class="section note"><dt>Note</dt><dd>This function is available only if the container of the Adjacent Vertices component has dynamic size. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>The position in the container where to insert the adjacent vertex. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>The pointer to the adjacent vertex to insert in the container. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a297e231f3ff802022f28427855609894" name="a297e231f3ff802022f28427855609894"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a297e231f3ff802022f28427855609894">&#9670;&#160;</a></span>pushAdjVertex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classvcl_1_1Vertex.html">Vertex</a> , typename ElementType  = void, bool OPT = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classvcl_1_1comp_1_1AdjacentVertices.html">vcl::comp::AdjacentVertices</a>&lt; <a class="el" href="classvcl_1_1Vertex.html">Vertex</a>, ElementType, OPT &gt;::pushAdjVertex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Vertex.html">Vertex</a> *&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pushes in the back of the container the given adjacent vertex. </p>
<dl class="section note"><dt>Note</dt><dd>This function is available only if the container of the Adjacent Vertices component has dynamic size. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>The pointer to the adjacent vertex to push in the back of the container. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad1c3e938c5fff498418feb009e1f2fe6" name="ad1c3e938c5fff498418feb009e1f2fe6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1c3e938c5fff498418feb009e1f2fe6">&#9670;&#160;</a></span>resizeAdjVertices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classvcl_1_1Vertex.html">Vertex</a> , typename ElementType  = void, bool OPT = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classvcl_1_1comp_1_1AdjacentVertices.html">vcl::comp::AdjacentVertices</a>&lt; <a class="el" href="classvcl_1_1Vertex.html">Vertex</a>, ElementType, OPT &gt;::resizeAdjVertices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a>&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resize the container of the adjacent vertices to the given size. </p>
<dl class="section note"><dt>Note</dt><dd>This function is available only if the container of the Adjacent Vertices has dynamic size. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>The new size of the adjacent vertices container. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a351e7efee277da2e76a4a98991bbffa1" name="a351e7efee277da2e76a4a98991bbffa1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a351e7efee277da2e76a4a98991bbffa1">&#9670;&#160;</a></span>setAdjVertex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classvcl_1_1Vertex.html">Vertex</a> , typename ElementType  = void, bool OPT = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classvcl_1_1comp_1_1AdjacentVertices.html">vcl::comp::AdjacentVertices</a>&lt; <a class="el" href="classvcl_1_1Vertex.html">Vertex</a>, ElementType, OPT &gt;::setAdjVertex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Vertex.html">Vertex</a> *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_2base_8h.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a>&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the i-th adjacent vertex of the element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>The pointer to the adjacent vertex to set to this element. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>the position in the container on which set the adj vertex; the value must be between 0 and the number of adj vertices. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3d628ec81cc6051cc01e6a625d12af3d" name="a3d628ec81cc6051cc01e6a625d12af3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d628ec81cc6051cc01e6a625d12af3d">&#9670;&#160;</a></span>setAdjVertices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classvcl_1_1Vertex.html">Vertex</a> , typename ElementType  = void, bool OPT = false&gt; </div>
<div class="memtemplate">
template&lt;Range Rng&gt; <br />
requires RangeOfConvertibleTo&lt;Rng, <a class="el" href="classvcl_1_1Vertex.html">Vertex</a>*&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classvcl_1_1comp_1_1AdjacentVertices.html">vcl::comp::AdjacentVertices</a>&lt; <a class="el" href="classvcl_1_1Vertex.html">Vertex</a>, ElementType, OPT &gt;::setAdjVertices </td>
          <td>(</td>
          <td class="paramtype">Rng &amp;&amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets all the adjacent vertices of this element. </p>
<p>If the size of the container is static, the size of the input range must be the same one of the container.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Rng</td><td>The type of the range of adjacent vertices to set. The value type of the range must be convertible to a pointer to an AdjacentVertex.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">r</td><td>range of adjacent vertices to set. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/runner/work/vclib/vclib/include/vclib/mesh/components/<a class="el" href="mesh_2components_2adjacent__vertices_8h_source.html">adjacent_vertices.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacevcl.html">vcl</a></li><li class="navelem"><a class="el" href="namespacevcl_1_1comp.html">comp</a></li><li class="navelem"><a class="el" href="classvcl_1_1comp_1_1AdjacentVertices.html">AdjacentVertices</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6 </li>
  </ul>
</div>
</body>
</html>
