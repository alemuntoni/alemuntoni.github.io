<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Visual Computing Library: Append/Replace Mesh Data to Existing</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
       <script type="text/javascript">
           DoxygenAwesomeDarkModeToggle.init()
       </script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Visual Computing Library
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group__append__replace__to__buffer.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Append/Replace Mesh Data to Existing<div class="ingroups"><a class="el" href="group__algorithms__mesh.html">Mesh Algorithms</a> &raquo; <a class="el" href="group__import__export.html">Import/Export Mesh Algorithms</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Append missing data or Replace existing data to already allocated and partially filled buffers.  
<a href="#details">More...</a></p>
<div class="dynheader">
Collaboration diagram for Append/Replace Mesh Data to Existing:</div>
<div class="dyncontent">
<div class="center"><img src="group__append__replace__to__buffer.png" border="0" usemap="#agroup____append____replace____to____buffer" alt=""/></div>
<map name="agroup____append____replace____to____buffer" id="agroup____append____replace____to____buffer">
<area shape="rect" title="Append missing data or Replace existing data to already allocated and partially filled buffers." alt="" coords="204,5,371,45"/>
<area shape="rect" href="group__import__export.html" title="List of Import/Export Mesh algorithms." alt="" coords="5,5,156,45"/>
</map>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga0bce554c96d5cbd434d827f954c1908c" id="r_ga0bce554c96d5cbd434d827f954c1908c"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga0bce554c96d5cbd434d827f954c1908c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Segment.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__append__replace__to__buffer.html#ga0bce554c96d5cbd434d827f954c1908c">vcl::appendDuplicateVertexCoordsToBuffer</a> (<a class="el" href="classvcl_1_1Segment.html">const</a> MeshType &amp;mesh, <a class="el" href="classvcl_1_1Segment.html">const</a> std::list&lt; uint &gt; &amp;<a class="el" href="classvcl_1_1Segment.html">vertsToDuplicate</a>, <a class="el" href="classvcl_1_1Segment.html">auto</a> *buffer, <a class="el" href="group__types.html#ga16a1bfbea022f6766d2f3ebbf69a3b52">MatrixStorageType</a> <a class="el" href="classvcl_1_1Segment.html">storage</a>=MatrixStorageType::ROW_MAJOR)</td></tr>
<tr class="memdesc:ga0bce554c96d5cbd434d827f954c1908c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append the coordinates of the duplicated vertices to the given buffer.  <br /></td></tr>
<tr class="separator:ga0bce554c96d5cbd434d827f954c1908c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8101f28855ba5bc9e96f1324a1c8d52c" id="r_ga8101f28855ba5bc9e96f1324a1c8d52c"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga8101f28855ba5bc9e96f1324a1c8d52c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Segment.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__append__replace__to__buffer.html#ga8101f28855ba5bc9e96f1324a1c8d52c">vcl::replaceFaceIndicesByVertexDuplicationToBuffer</a> (<a class="el" href="classvcl_1_1Segment.html">const</a> MeshType &amp;mesh, <a class="el" href="classvcl_1_1Segment.html">const</a> std::list&lt; uint &gt; &amp;<a class="el" href="classvcl_1_1Segment.html">vertsToDuplicate</a>, <a class="el" href="classvcl_1_1Segment.html">const</a> std::list&lt; std::list&lt; std::pair&lt; uint, uint &gt; &gt; &gt; &amp;<a class="el" href="classvcl_1_1Segment.html">facesToReassign</a>, <a class="el" href="classvcl_1_1Segment.html">auto</a> *buffer, uint largestFaceSize=3, <a class="el" href="group__types.html#ga16a1bfbea022f6766d2f3ebbf69a3b52">MatrixStorageType</a> <a class="el" href="classvcl_1_1Segment.html">storage</a>=MatrixStorageType::ROW_MAJOR)</td></tr>
<tr class="memdesc:ga8101f28855ba5bc9e96f1324a1c8d52c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace the face vertex indices in the given buffer with the new indices of the duplicated vertices.  <br /></td></tr>
<tr class="separator:ga8101f28855ba5bc9e96f1324a1c8d52c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga266d0cdfa279b4540e747084aa38f71d" id="r_ga266d0cdfa279b4540e747084aa38f71d"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga266d0cdfa279b4540e747084aa38f71d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Segment.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__append__replace__to__buffer.html#ga266d0cdfa279b4540e747084aa38f71d">vcl::replaceTriangulatedFaceIndicesByVertexDuplicationToBuffer</a> (<a class="el" href="classvcl_1_1Segment.html">const</a> MeshType &amp;mesh, <a class="el" href="classvcl_1_1Segment.html">const</a> std::list&lt; uint &gt; &amp;<a class="el" href="classvcl_1_1Segment.html">vertsToDuplicate</a>, <a class="el" href="classvcl_1_1Segment.html">const</a> std::list&lt; std::list&lt; std::pair&lt; uint, uint &gt; &gt; &gt; &amp;<a class="el" href="classvcl_1_1Segment.html">facesToReassign</a>, <a class="el" href="classvcl_1_1Segment.html">const</a> <a class="el" href="classvcl_1_1TriPolyIndexBiMap.html">TriPolyIndexBiMap</a> &amp;indexMap, <a class="el" href="classvcl_1_1Segment.html">auto</a> *buffer, <a class="el" href="group__types.html#ga16a1bfbea022f6766d2f3ebbf69a3b52">MatrixStorageType</a> <a class="el" href="classvcl_1_1Segment.html">storage</a>=MatrixStorageType::ROW_MAJOR)</td></tr>
<tr class="memdesc:ga266d0cdfa279b4540e747084aa38f71d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace the triangulated face vertex indices in the given buffer with the new indices of the duplicated vertices.  <br /></td></tr>
<tr class="separator:ga266d0cdfa279b4540e747084aa38f71d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab7200f0ca0c159fa1bd1a7b4e2d91df8" id="r_gab7200f0ca0c159fa1bd1a7b4e2d91df8"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:gab7200f0ca0c159fa1bd1a7b4e2d91df8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Segment.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__append__replace__to__buffer.html#gab7200f0ca0c159fa1bd1a7b4e2d91df8">vcl::appendDuplicateVertexSelectionToBuffer</a> (<a class="el" href="classvcl_1_1Segment.html">const</a> MeshType &amp;mesh, <a class="el" href="classvcl_1_1Segment.html">const</a> std::list&lt; uint &gt; &amp;<a class="el" href="classvcl_1_1Segment.html">vertsToDuplicate</a>, <a class="el" href="classvcl_1_1Segment.html">auto</a> *buffer)</td></tr>
<tr class="memdesc:gab7200f0ca0c159fa1bd1a7b4e2d91df8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append the selection of the duplicated vertices to the given buffer.  <br /></td></tr>
<tr class="separator:gab7200f0ca0c159fa1bd1a7b4e2d91df8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae39fb469cfcbf8c02a139039f210746a" id="r_gae39fb469cfcbf8c02a139039f210746a"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:gae39fb469cfcbf8c02a139039f210746a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Segment.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__append__replace__to__buffer.html#gae39fb469cfcbf8c02a139039f210746a">vcl::appendDuplicateVertexNormalsToBuffer</a> (<a class="el" href="classvcl_1_1Segment.html">const</a> MeshType &amp;mesh, <a class="el" href="classvcl_1_1Segment.html">const</a> std::list&lt; uint &gt; &amp;<a class="el" href="classvcl_1_1Segment.html">vertsToDuplicate</a>, <a class="el" href="classvcl_1_1Segment.html">auto</a> *buffer, <a class="el" href="group__types.html#ga16a1bfbea022f6766d2f3ebbf69a3b52">MatrixStorageType</a> <a class="el" href="classvcl_1_1Segment.html">storage</a>=MatrixStorageType::ROW_MAJOR)</td></tr>
<tr class="memdesc:gae39fb469cfcbf8c02a139039f210746a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append the normals of the duplicated vertices to the given buffer.  <br /></td></tr>
<tr class="separator:gae39fb469cfcbf8c02a139039f210746a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga42988075554636d87b23c7eb3541ba73" id="r_ga42988075554636d87b23c7eb3541ba73"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga42988075554636d87b23c7eb3541ba73"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Segment.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__append__replace__to__buffer.html#ga42988075554636d87b23c7eb3541ba73">vcl::appendDuplicateVertexColorsToBuffer</a> (<a class="el" href="classvcl_1_1Segment.html">const</a> MeshType &amp;mesh, <a class="el" href="classvcl_1_1Segment.html">const</a> std::list&lt; uint &gt; &amp;<a class="el" href="classvcl_1_1Segment.html">vertsToDuplicate</a>, <a class="el" href="classvcl_1_1Segment.html">auto</a> *buffer, <a class="el" href="classvcl_1_1Color.html#a59da32385451a205500eea4432cc151d">Color::Representation</a> <a class="el" href="classvcl_1_1Segment.html">representation</a>=Color::Representation::INT_0_255, <a class="el" href="group__types.html#ga16a1bfbea022f6766d2f3ebbf69a3b52">MatrixStorageType</a> <a class="el" href="classvcl_1_1Segment.html">storage</a>=MatrixStorageType::ROW_MAJOR)</td></tr>
<tr class="memdesc:ga42988075554636d87b23c7eb3541ba73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append the colors of the duplicated vertices to the given buffer.  <br /></td></tr>
<tr class="separator:ga42988075554636d87b23c7eb3541ba73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83f3ac3fc3172a3e041616c747f5218a" id="r_ga83f3ac3fc3172a3e041616c747f5218a"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga83f3ac3fc3172a3e041616c747f5218a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Segment.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__append__replace__to__buffer.html#ga83f3ac3fc3172a3e041616c747f5218a">vcl::appendDuplicateVertexColorsToBuffer</a> (<a class="el" href="classvcl_1_1Segment.html">const</a> MeshType &amp;mesh, <a class="el" href="classvcl_1_1Segment.html">const</a> std::list&lt; uint &gt; &amp;<a class="el" href="classvcl_1_1Segment.html">vertsToDuplicate</a>, <a class="el" href="classvcl_1_1Segment.html">auto</a> *buffer, <a class="el" href="classvcl_1_1Color.html#a51d1c2a5b8ce06d43362026194a14523">Color::Format</a> <a class="el" href="classvcl_1_1Segment.html">colorFormat</a>)</td></tr>
<tr class="memdesc:ga83f3ac3fc3172a3e041616c747f5218a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append the color (packed in a single 32 bit value using the provided format) of the duplicated vertices to the given buffer.  <br /></td></tr>
<tr class="separator:ga83f3ac3fc3172a3e041616c747f5218a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga409b34d8cea5c7222a04cb32bb21bc21" id="r_ga409b34d8cea5c7222a04cb32bb21bc21"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga409b34d8cea5c7222a04cb32bb21bc21"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Segment.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__append__replace__to__buffer.html#ga409b34d8cea5c7222a04cb32bb21bc21">vcl::appendDuplicateVertexQualityToBuffer</a> (<a class="el" href="classvcl_1_1Segment.html">const</a> MeshType &amp;mesh, <a class="el" href="classvcl_1_1Segment.html">const</a> std::list&lt; uint &gt; &amp;<a class="el" href="classvcl_1_1Segment.html">vertsToDuplicate</a>, <a class="el" href="classvcl_1_1Segment.html">auto</a> *buffer)</td></tr>
<tr class="memdesc:ga409b34d8cea5c7222a04cb32bb21bc21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append the quality of the duplicated vertices to the given buffer.  <br /></td></tr>
<tr class="separator:ga409b34d8cea5c7222a04cb32bb21bc21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf4fbbfe648bc642f41d78a32b1df1b58" id="r_gaf4fbbfe648bc642f41d78a32b1df1b58"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:gaf4fbbfe648bc642f41d78a32b1df1b58"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Segment.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__append__replace__to__buffer.html#gaf4fbbfe648bc642f41d78a32b1df1b58">vcl::appendDuplicateVertexTexCoordsToBuffer</a> (<a class="el" href="classvcl_1_1Segment.html">const</a> MeshType &amp;mesh, <a class="el" href="classvcl_1_1Segment.html">const</a> std::list&lt; uint &gt; &amp;<a class="el" href="classvcl_1_1Segment.html">vertsToDuplicate</a>, <a class="el" href="classvcl_1_1Segment.html">auto</a> *buffer, <a class="el" href="group__types.html#ga16a1bfbea022f6766d2f3ebbf69a3b52">MatrixStorageType</a> <a class="el" href="classvcl_1_1Segment.html">storage</a>=MatrixStorageType::ROW_MAJOR)</td></tr>
<tr class="memdesc:gaf4fbbfe648bc642f41d78a32b1df1b58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append the texture coordinates of the duplicated vertices to the given buffer.  <br /></td></tr>
<tr class="separator:gaf4fbbfe648bc642f41d78a32b1df1b58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae7ff6a1fe60aaca134e3fdd3eeedf274" id="r_gae7ff6a1fe60aaca134e3fdd3eeedf274"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:gae7ff6a1fe60aaca134e3fdd3eeedf274"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Segment.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__append__replace__to__buffer.html#gae7ff6a1fe60aaca134e3fdd3eeedf274">vcl::appendDuplicateVertexTexCoordIndicesToBuffer</a> (<a class="el" href="classvcl_1_1Segment.html">const</a> MeshType &amp;mesh, <a class="el" href="classvcl_1_1Segment.html">const</a> std::list&lt; uint &gt; &amp;<a class="el" href="classvcl_1_1Segment.html">vertsToDuplicate</a>, <a class="el" href="classvcl_1_1Segment.html">auto</a> *buffer)</td></tr>
<tr class="memdesc:gae7ff6a1fe60aaca134e3fdd3eeedf274"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append the texture coordinate indices of the duplicated vertices to the given buffer.  <br /></td></tr>
<tr class="separator:gae7ff6a1fe60aaca134e3fdd3eeedf274"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a58d21198652c1facd5586a1899e7d1" id="r_ga0a58d21198652c1facd5586a1899e7d1"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga0a58d21198652c1facd5586a1899e7d1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Segment.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__append__replace__to__buffer.html#ga0a58d21198652c1facd5586a1899e7d1">vcl::wedgeTexCoordsAsDuplicatedVertexTexCoordsToBuffer</a> (<a class="el" href="classvcl_1_1Segment.html">const</a> MeshType &amp;mesh, <a class="el" href="classvcl_1_1Segment.html">const</a> std::vector&lt; std::pair&lt; <a class="el" href="classvcl_1_1Segment.html">vcl::uint</a>, <a class="el" href="classvcl_1_1Segment.html">vcl::uint</a> &gt; &gt; &amp;<a class="el" href="classvcl_1_1Segment.html">vertWedgeMap</a>, <a class="el" href="classvcl_1_1Segment.html">const</a> std::list&lt; std::list&lt; std::pair&lt; <a class="el" href="classvcl_1_1Segment.html">vcl::uint</a>, <a class="el" href="classvcl_1_1Segment.html">vcl::uint</a> &gt; &gt; &gt; &amp;<a class="el" href="classvcl_1_1Segment.html">facesToReassign</a>, <a class="el" href="classvcl_1_1Segment.html">auto</a> *buffer, <a class="el" href="group__types.html#ga16a1bfbea022f6766d2f3ebbf69a3b52">MatrixStorageType</a> <a class="el" href="classvcl_1_1Segment.html">storage</a>=MatrixStorageType::ROW_MAJOR)</td></tr>
<tr class="memdesc:ga0a58d21198652c1facd5586a1899e7d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Export wedge texture coordinates to a buffer of the duplicated vertex texture coordinates.  <br /></td></tr>
<tr class="separator:ga0a58d21198652c1facd5586a1899e7d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa6d2832df378ef8b5d6aa4612c895f4" id="r_gafa6d2832df378ef8b5d6aa4612c895f4"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:gafa6d2832df378ef8b5d6aa4612c895f4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Segment.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__append__replace__to__buffer.html#gafa6d2832df378ef8b5d6aa4612c895f4">vcl::wedgeTexCoordIndicesAsDuplicatedVertexTexCoordIndicesToBuffer</a> (<a class="el" href="classvcl_1_1Segment.html">const</a> MeshType &amp;mesh, <a class="el" href="classvcl_1_1Segment.html">const</a> std::vector&lt; std::pair&lt; <a class="el" href="classvcl_1_1Segment.html">vcl::uint</a>, <a class="el" href="classvcl_1_1Segment.html">vcl::uint</a> &gt; &gt; &amp;<a class="el" href="classvcl_1_1Segment.html">vertWedgeMap</a>, <a class="el" href="classvcl_1_1Segment.html">const</a> std::list&lt; std::list&lt; std::pair&lt; <a class="el" href="classvcl_1_1Segment.html">vcl::uint</a>, <a class="el" href="classvcl_1_1Segment.html">vcl::uint</a> &gt; &gt; &gt; &amp;<a class="el" href="classvcl_1_1Segment.html">facesToReassign</a>, <a class="el" href="classvcl_1_1Segment.html">auto</a> *buffer)</td></tr>
<tr class="memdesc:gafa6d2832df378ef8b5d6aa4612c895f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Export wedge texture coordinate indices to a buffer of the duplicated vertex texture coordinate indices.  <br /></td></tr>
<tr class="separator:gafa6d2832df378ef8b5d6aa4612c895f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Append missing data or Replace existing data to already allocated and partially filled buffers. </p>
<p>Buffer Algorithms</p>
<p>These algorithms are useful when you already have allocated and filled buffers with mesh data, and you want to append missing data to them or replace existing data with new data.</p>
<p>An example of missing data are the duplicate vertices that are necessary to render a mesh with wedge texture coordinates. In this scenario, an example of workflow is:</p>
<p>0. Compute all the required data necessary to know the number of duplicated vertices and which vertices are duplicated;</p><ol type="1">
<li>Allocate the buffers having the correct size for the vertices (including the duplicates);</li>
<li>Fill the non-duplicated vertices using the algorithms defined in <a class="el" href="group__export__buffer.html">Export Mesh to Buffer Algorithms</a>;</li>
<li>Use the algorithms defined in this module to append the duplicated vertices and the texture coordinates.</li>
</ol>
<p>You can access these algorithms by including <code>#include &lt;<a class="el" href="import__export_8h_source.html">vclib/algorithms/mesh/import_export.h</a>&gt;</code> </p>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga83f3ac3fc3172a3e041616c747f5218a" name="ga83f3ac3fc3172a3e041616c747f5218a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga83f3ac3fc3172a3e041616c747f5218a">&#9670;&#160;</a></span>appendDuplicateVertexColorsToBuffer() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Segment.html">void</a> vcl::appendDuplicateVertexColorsToBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Segment.html">const</a> MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Segment.html">const</a> std::list&lt; uint &gt; &amp;&#160;</td>
          <td class="paramname"><em>vertsToDuplicate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Segment.html">auto</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Color.html#a51d1c2a5b8ce06d43362026194a14523">Color::Format</a>&#160;</td>
          <td class="paramname"><em>colorFormat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Append the color (packed in a single 32 bit value using the provided format) of the duplicated vertices to the given buffer. </p>
<p>Given the list of vertices to duplicate, this function appends to the given buffer the color (packed in a single 32 bit value using the provided format) of the vertices listed in the input list.</p>
<p>Typical usage of this function is after the countVerticesToDuplicateByWedgeTexCoords function and along with the vertexColorToBuffer function:</p>
<div class="fragment"><div class="line">std::vector&lt;std::pair&lt;uint, uint&gt;&gt; <a class="code hl_class" href="classvcl_1_1Segment.html">vertWedgeMap</a>;</div>
<div class="line">std::list&lt;uint&gt; <a class="code hl_class" href="classvcl_1_1Segment.html">vertsToDuplicate</a>;</div>
<div class="line">std::list&lt;std::list&lt;std::pair&lt;uint, uint&gt;&gt;&gt; <a class="code hl_class" href="classvcl_1_1Segment.html">facesToReassign</a>;</div>
<div class="line"> </div>
<div class="line">uint <a class="code hl_class" href="classvcl_1_1Segment.html">nV</a> = countVerticesToDuplicateByWedgeTexCoords(mesh, <a class="code hl_class" href="classvcl_1_1Segment.html">vertWedgeMap</a>,</div>
<div class="line">    <a class="code hl_class" href="classvcl_1_1Segment.html">vertsToDuplicate</a>, <a class="code hl_class" href="classvcl_1_1Segment.html">facesToReassign</a>);</div>
<div class="line"> </div>
<div class="line">std::vector&lt;double&gt; buffer(mesh.vertexNumber() + <a class="code hl_class" href="classvcl_1_1Segment.html">nV</a>);</div>
<div class="line"><a class="code hl_class" href="classvcl_1_1Segment.html">vertexColorToBuffer</a>(mesh, buffer.data(), Color::Format::RGBA);</div>
<div class="line"><a class="code hl_class" href="classvcl_1_1Segment.html">appendDuplicateVertexColorToBuffer</a>(mesh, <a class="code hl_class" href="classvcl_1_1Segment.html">vertsToDuplicate</a>, buffer.data(),</div>
<div class="line">    Color::Format::RGBA);</div>
<div class="ttc" id="aclassvcl_1_1Segment_html"><div class="ttname"><a href="classvcl_1_1Segment.html">vcl::Segment</a></div><div class="ttdoc">A class representing a line segment in n-dimensional space. The class is parameterized by a PointConc...</div><div class="ttdef"><b>Definition</b> segment.h:43</div></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>The buffer must be preallocated with the correct size (total number of vertices).</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MeshType</td><td>The type of the mesh.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>The mesh from which take the colors. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vertsToDuplicate</td><td>The list of vertices to duplicate: each element is the index of a vertex in the mesh, that must be appended to the buffer. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buffer</td><td>The buffer where to append the duplicated vertex color. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga42988075554636d87b23c7eb3541ba73" name="ga42988075554636d87b23c7eb3541ba73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga42988075554636d87b23c7eb3541ba73">&#9670;&#160;</a></span>appendDuplicateVertexColorsToBuffer() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Segment.html">void</a> vcl::appendDuplicateVertexColorsToBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Segment.html">const</a> MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Segment.html">const</a> std::list&lt; uint &gt; &amp;&#160;</td>
          <td class="paramname"><em>vertsToDuplicate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Segment.html">auto</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Color.html#a59da32385451a205500eea4432cc151d">Color::Representation</a>&#160;</td>
          <td class="paramname"><em>representation</em> = <code>Color::Representation::INT_0_255</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga16a1bfbea022f6766d2f3ebbf69a3b52">MatrixStorageType</a>&#160;</td>
          <td class="paramname"><em>storage</em> = <code>MatrixStorageType::ROW_MAJOR</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Append the colors of the duplicated vertices to the given buffer. </p>
<p>Given the list of vertices to duplicate, this function appends to the given buffer the colors of the vertices listed in the input list.</p>
<p>Typical usage of this function is after the countVerticesToDuplicateByWedgeTexCoords function and along with the vertexColorsToBuffer function:</p>
<div class="fragment"><div class="line">std::vector&lt;std::pair&lt;uint, uint&gt;&gt; <a class="code hl_class" href="classvcl_1_1Segment.html">vertWedgeMap</a>;</div>
<div class="line">std::list&lt;uint&gt; <a class="code hl_class" href="classvcl_1_1Segment.html">vertsToDuplicate</a>;</div>
<div class="line">std::list&lt;std::list&lt;std::pair&lt;uint, uint&gt;&gt;&gt; <a class="code hl_class" href="classvcl_1_1Segment.html">facesToReassign</a>;</div>
<div class="line"> </div>
<div class="line">uint <a class="code hl_class" href="classvcl_1_1Segment.html">nV</a> = countVerticesToDuplicateByWedgeTexCoords(mesh, <a class="code hl_class" href="classvcl_1_1Segment.html">vertWedgeMap</a>,</div>
<div class="line">    <a class="code hl_class" href="classvcl_1_1Segment.html">vertsToDuplicate</a>, <a class="code hl_class" href="classvcl_1_1Segment.html">facesToReassign</a>);</div>
<div class="line"> </div>
<div class="line">std::vector&lt;uint&gt; buffer((mesh.vertexNumber() + <a class="code hl_class" href="classvcl_1_1Segment.html">nV</a>) * 4);</div>
<div class="line"><a class="code hl_class" href="classvcl_1_1Segment.html">vertexColorsToBuffer</a>(mesh, buffer.data());</div>
<div class="line"><a class="code hl_function" href="group__append__replace__to__buffer.html#ga42988075554636d87b23c7eb3541ba73">appendDuplicateVertexColorsToBuffer</a>(mesh, <a class="code hl_class" href="classvcl_1_1Segment.html">vertsToDuplicate</a>, buffer.data());</div>
<div class="ttc" id="agroup__append__replace__to__buffer_html_ga42988075554636d87b23c7eb3541ba73"><div class="ttname"><a href="group__append__replace__to__buffer.html#ga42988075554636d87b23c7eb3541ba73">vcl::appendDuplicateVertexColorsToBuffer</a></div><div class="ttdeci">void appendDuplicateVertexColorsToBuffer(const MeshType &amp;mesh, const std::list&lt; uint &gt; &amp;vertsToDuplicate, auto *buffer, Color::Representation representation=Color::Representation::INT_0_255, MatrixStorageType storage=MatrixStorageType::ROW_MAJOR)</div><div class="ttdoc">Append the colors of the duplicated vertices to the given buffer.</div><div class="ttdef"><b>Definition</b> append_replace_to_buffer.h:467</div></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>The buffer must be preallocated with the correct size (total number of vertices times 4).</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MeshType</td><td>The type of the mesh.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>The mesh from which take the colors. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vertsToDuplicate</td><td>The list of vertices to duplicate: each element is the index of a vertex in the mesh, that must be appended to the buffer. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buffer</td><td>The buffer where to append the duplicated vertex colors. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">representation</td><td>The representation of the color in the buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">storage</td><td>The storage type of the matrix (row or column major). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0bce554c96d5cbd434d827f954c1908c" name="ga0bce554c96d5cbd434d827f954c1908c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0bce554c96d5cbd434d827f954c1908c">&#9670;&#160;</a></span>appendDuplicateVertexCoordsToBuffer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Segment.html">void</a> vcl::appendDuplicateVertexCoordsToBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Segment.html">const</a> MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Segment.html">const</a> std::list&lt; uint &gt; &amp;&#160;</td>
          <td class="paramname"><em>vertsToDuplicate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Segment.html">auto</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga16a1bfbea022f6766d2f3ebbf69a3b52">MatrixStorageType</a>&#160;</td>
          <td class="paramname"><em>storage</em> = <code>MatrixStorageType::ROW_MAJOR</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Append the coordinates of the duplicated vertices to the given buffer. </p>
<p>Given the list of vertices to duplicate, this function appends to the given buffer the coordinates of the vertices listed in the input list.</p>
<p>Typical usage of this function is after the countVerticesToDuplicateByWedgeTexCoords function and along with the <a class="el" href="group__export__buffer.html#ga3e971a5960ab26aab24acb00db24601a">vertexCoordsToBuffer</a> function:</p>
<div class="fragment"><div class="line">std::vector&lt;std::pair&lt;uint, uint&gt;&gt; <a class="code hl_class" href="classvcl_1_1Segment.html">vertWedgeMap</a>;</div>
<div class="line">std::list&lt;uint&gt; <a class="code hl_class" href="classvcl_1_1Segment.html">vertsToDuplicate</a>;</div>
<div class="line">std::list&lt;std::list&lt;std::pair&lt;uint, uint&gt;&gt;&gt; <a class="code hl_class" href="classvcl_1_1Segment.html">facesToReassign</a>;</div>
<div class="line"> </div>
<div class="line">uint <a class="code hl_class" href="classvcl_1_1Segment.html">nV</a> = countVerticesToDuplicateByWedgeTexCoords(mesh, <a class="code hl_class" href="classvcl_1_1Segment.html">vertWedgeMap</a>,</div>
<div class="line">    <a class="code hl_class" href="classvcl_1_1Segment.html">vertsToDuplicate</a>, <a class="code hl_class" href="classvcl_1_1Segment.html">facesToReassign</a>);</div>
<div class="line"> </div>
<div class="line">std::vector&lt;double&gt; buffer((mesh.vertexNumber() + <a class="code hl_class" href="classvcl_1_1Segment.html">nV</a>) * 3);</div>
<div class="line"><a class="code hl_function" href="group__export__buffer.html#ga3e971a5960ab26aab24acb00db24601a">vertexCoordsToBuffer</a>(mesh, buffer.data());</div>
<div class="line"><a class="code hl_function" href="group__append__replace__to__buffer.html#ga0bce554c96d5cbd434d827f954c1908c">appendDuplicateVertexCoordsToBuffer</a>(mesh, <a class="code hl_class" href="classvcl_1_1Segment.html">vertsToDuplicate</a>, buffer.data());</div>
<div class="ttc" id="agroup__append__replace__to__buffer_html_ga0bce554c96d5cbd434d827f954c1908c"><div class="ttname"><a href="group__append__replace__to__buffer.html#ga0bce554c96d5cbd434d827f954c1908c">vcl::appendDuplicateVertexCoordsToBuffer</a></div><div class="ttdeci">void appendDuplicateVertexCoordsToBuffer(const MeshType &amp;mesh, const std::list&lt; uint &gt; &amp;vertsToDuplicate, auto *buffer, MatrixStorageType storage=MatrixStorageType::ROW_MAJOR)</div><div class="ttdoc">Append the coordinates of the duplicated vertices to the given buffer.</div><div class="ttdef"><b>Definition</b> append_replace_to_buffer.h:101</div></div>
<div class="ttc" id="agroup__export__buffer_html_ga3e971a5960ab26aab24acb00db24601a"><div class="ttname"><a href="group__export__buffer.html#ga3e971a5960ab26aab24acb00db24601a">vcl::vertexCoordsToBuffer</a></div><div class="ttdeci">void vertexCoordsToBuffer(const MeshType &amp;mesh, auto *buffer, MatrixStorageType storage=MatrixStorageType::ROW_MAJOR, uint rowNumber=UINT_NULL)</div><div class="ttdoc">Export the vertex coordinates of a mesh to a buffer.</div><div class="ttdef"><b>Definition</b> export_buffer.h:101</div></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>The buffer must be preallocated with the correct size (total number of vertices times 3).</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MeshType</td><td>The type of the mesh.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>The mesh from which take the coordinates. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vertsToDuplicate</td><td>The list of vertices to duplicate: each element is the index of a vertex in the mesh, that must be appended to the buffer. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">[in/out]</td><td>buffer: The buffer where to append the duplicated vertices. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">storage</td><td>The storage type of the matrix (row or column major). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae39fb469cfcbf8c02a139039f210746a" name="gae39fb469cfcbf8c02a139039f210746a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae39fb469cfcbf8c02a139039f210746a">&#9670;&#160;</a></span>appendDuplicateVertexNormalsToBuffer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Segment.html">void</a> vcl::appendDuplicateVertexNormalsToBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Segment.html">const</a> MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Segment.html">const</a> std::list&lt; uint &gt; &amp;&#160;</td>
          <td class="paramname"><em>vertsToDuplicate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Segment.html">auto</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga16a1bfbea022f6766d2f3ebbf69a3b52">MatrixStorageType</a>&#160;</td>
          <td class="paramname"><em>storage</em> = <code>MatrixStorageType::ROW_MAJOR</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Append the normals of the duplicated vertices to the given buffer. </p>
<p>Given the list of vertices to duplicate, this function appends to the given buffer the normals of the vertices listed in the input list.</p>
<p>Typical usage of this function is after the countVerticesToDuplicateByWedgeTexCoords function and along with the vertexNormalsToBuffer function:</p>
<div class="fragment"><div class="line">std::vector&lt;std::pair&lt;uint, uint&gt;&gt; <a class="code hl_class" href="classvcl_1_1Segment.html">vertWedgeMap</a>;</div>
<div class="line">std::list&lt;uint&gt; <a class="code hl_class" href="classvcl_1_1Segment.html">vertsToDuplicate</a>;</div>
<div class="line">std::list&lt;std::list&lt;std::pair&lt;uint, uint&gt;&gt;&gt; <a class="code hl_class" href="classvcl_1_1Segment.html">facesToReassign</a>;</div>
<div class="line"> </div>
<div class="line">uint <a class="code hl_class" href="classvcl_1_1Segment.html">nV</a> = countVerticesToDuplicateByWedgeTexCoords(mesh, <a class="code hl_class" href="classvcl_1_1Segment.html">vertWedgeMap</a>,</div>
<div class="line">    <a class="code hl_class" href="classvcl_1_1Segment.html">vertsToDuplicate</a>, <a class="code hl_class" href="classvcl_1_1Segment.html">facesToReassign</a>);</div>
<div class="line"> </div>
<div class="line">std::vector&lt;double&gt; buffer((mesh.vertexNumber() + <a class="code hl_class" href="classvcl_1_1Segment.html">nV</a>) * 3);</div>
<div class="line"><a class="code hl_class" href="classvcl_1_1Segment.html">vertexNormalsToBuffer</a>(mesh, buffer.data());</div>
<div class="line"><a class="code hl_function" href="group__append__replace__to__buffer.html#gae39fb469cfcbf8c02a139039f210746a">appendDuplicateVertexNormalsToBuffer</a>(mesh, <a class="code hl_class" href="classvcl_1_1Segment.html">vertsToDuplicate</a>, buffer.data());</div>
<div class="ttc" id="agroup__append__replace__to__buffer_html_gae39fb469cfcbf8c02a139039f210746a"><div class="ttname"><a href="group__append__replace__to__buffer.html#gae39fb469cfcbf8c02a139039f210746a">vcl::appendDuplicateVertexNormalsToBuffer</a></div><div class="ttdeci">void appendDuplicateVertexNormalsToBuffer(const MeshType &amp;mesh, const std::list&lt; uint &gt; &amp;vertsToDuplicate, auto *buffer, MatrixStorageType storage=MatrixStorageType::ROW_MAJOR)</div><div class="ttdoc">Append the normals of the duplicated vertices to the given buffer.</div><div class="ttdef"><b>Definition</b> append_replace_to_buffer.h:398</div></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>The buffer must be preallocated with the correct size (total number of vertices times 3).</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MeshType</td><td>The type of the mesh.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>The mesh from which take the normals. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vertsToDuplicate</td><td>The list of vertices to duplicate: each element is the index of a vertex in the mesh, that must be appended to the buffer. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buffer</td><td>The buffer where to append the duplicated vertex normals. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">storage</td><td>The storage type of the matrix (row or column major). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga409b34d8cea5c7222a04cb32bb21bc21" name="ga409b34d8cea5c7222a04cb32bb21bc21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga409b34d8cea5c7222a04cb32bb21bc21">&#9670;&#160;</a></span>appendDuplicateVertexQualityToBuffer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Segment.html">void</a> vcl::appendDuplicateVertexQualityToBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Segment.html">const</a> MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Segment.html">const</a> std::list&lt; uint &gt; &amp;&#160;</td>
          <td class="paramname"><em>vertsToDuplicate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Segment.html">auto</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Append the quality of the duplicated vertices to the given buffer. </p>
<p>Given the list of vertices to duplicate, this function appends to the given buffer the quality of the vertices listed in the input list.</p>
<p>Typical usage of this function is after the countVerticesToDuplicateByWedgeTexCoords function and along with the vertexQualityToBuffer function:</p>
<div class="fragment"><div class="line">std::vector&lt;std::pair&lt;uint, uint&gt;&gt; <a class="code hl_class" href="classvcl_1_1Segment.html">vertWedgeMap</a>;</div>
<div class="line">std::list&lt;uint&gt; <a class="code hl_class" href="classvcl_1_1Segment.html">vertsToDuplicate</a>;</div>
<div class="line">std::list&lt;std::list&lt;std::pair&lt;uint, uint&gt;&gt;&gt; <a class="code hl_class" href="classvcl_1_1Segment.html">facesToReassign</a>;</div>
<div class="line"> </div>
<div class="line">uint <a class="code hl_class" href="classvcl_1_1Segment.html">nV</a> = countVerticesToDuplicateByWedgeTexCoords(mesh, <a class="code hl_class" href="classvcl_1_1Segment.html">vertWedgeMap</a>,</div>
<div class="line">    <a class="code hl_class" href="classvcl_1_1Segment.html">vertsToDuplicate</a>, <a class="code hl_class" href="classvcl_1_1Segment.html">facesToReassign</a>);</div>
<div class="line"> </div>
<div class="line">std::vector&lt;double&gt; buffer(mesh.vertexNumber() + <a class="code hl_class" href="classvcl_1_1Segment.html">nV</a>);</div>
<div class="line"><a class="code hl_class" href="classvcl_1_1Segment.html">vertexQualityToBuffer</a>(mesh, buffer.data());</div>
<div class="line"><a class="code hl_function" href="group__append__replace__to__buffer.html#ga409b34d8cea5c7222a04cb32bb21bc21">appendDuplicateVertexQualityToBuffer</a>(mesh, <a class="code hl_class" href="classvcl_1_1Segment.html">vertsToDuplicate</a>, buffer.data());</div>
<div class="ttc" id="agroup__append__replace__to__buffer_html_ga409b34d8cea5c7222a04cb32bb21bc21"><div class="ttname"><a href="group__append__replace__to__buffer.html#ga409b34d8cea5c7222a04cb32bb21bc21">vcl::appendDuplicateVertexQualityToBuffer</a></div><div class="ttdeci">void appendDuplicateVertexQualityToBuffer(const MeshType &amp;mesh, const std::list&lt; uint &gt; &amp;vertsToDuplicate, auto *buffer)</div><div class="ttdoc">Append the quality of the duplicated vertices to the given buffer.</div><div class="ttdef"><b>Definition</b> append_replace_to_buffer.h:603</div></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>The buffer must be preallocated with the correct size (total number of vertices).</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MeshType</td><td>The type of the mesh.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>The mesh from which take the quality. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vertsToDuplicate</td><td>The list of vertices to duplicate: each element is the index of a vertex in the mesh, that must be appended to the buffer. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buffer</td><td>The buffer where to append the duplicated vertex quality. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab7200f0ca0c159fa1bd1a7b4e2d91df8" name="gab7200f0ca0c159fa1bd1a7b4e2d91df8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab7200f0ca0c159fa1bd1a7b4e2d91df8">&#9670;&#160;</a></span>appendDuplicateVertexSelectionToBuffer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Segment.html">void</a> vcl::appendDuplicateVertexSelectionToBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Segment.html">const</a> MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Segment.html">const</a> std::list&lt; uint &gt; &amp;&#160;</td>
          <td class="paramname"><em>vertsToDuplicate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Segment.html">auto</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Append the selection of the duplicated vertices to the given buffer. </p>
<p>Given the list of vertices to duplicate, this function appends to the given buffer the selection of the vertices listed in the input list.</p>
<p>Typical usage of this function is after the countVerticesToDuplicateByWedgeTexCoords function and along with the vertexSelectionToBuffer function:</p>
<div class="fragment"><div class="line">std::vector&lt;std::pair&lt;uint, uint&gt;&gt; <a class="code hl_class" href="classvcl_1_1Segment.html">vertWedgeMap</a>;</div>
<div class="line">std::list&lt;uint&gt; <a class="code hl_class" href="classvcl_1_1Segment.html">vertsToDuplicate</a>;</div>
<div class="line">std::list&lt;std::list&lt;std::pair&lt;uint, uint&gt;&gt;&gt; <a class="code hl_class" href="classvcl_1_1Segment.html">facesToReassign</a>;</div>
<div class="line"> </div>
<div class="line">uint <a class="code hl_class" href="classvcl_1_1Segment.html">nV</a> = countVerticesToDuplicateByWedgeTexCoords(mesh, <a class="code hl_class" href="classvcl_1_1Segment.html">vertWedgeMap</a>,</div>
<div class="line">    <a class="code hl_class" href="classvcl_1_1Segment.html">vertsToDuplicate</a>, <a class="code hl_class" href="classvcl_1_1Segment.html">facesToReassign</a>);</div>
<div class="line"> </div>
<div class="line">std::vector&lt;uint&gt; buffer(mesh.vertexNumber() + <a class="code hl_class" href="classvcl_1_1Segment.html">nV</a>);</div>
<div class="line"><a class="code hl_class" href="classvcl_1_1Segment.html">vertexSelectionToBuffer</a>(mesh, buffer.data());</div>
<div class="line"><a class="code hl_function" href="group__append__replace__to__buffer.html#ga0bce554c96d5cbd434d827f954c1908c">appendDuplicateVertexCoordsToBuffer</a>(mesh, <a class="code hl_class" href="classvcl_1_1Segment.html">vertsToDuplicate</a>, buffer.data());</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>The buffer must be preallocated with the correct size (total number of vertices).</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MeshType</td><td>The type of the mesh.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>The mesh from which take the selection. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vertsToDuplicate</td><td>The list of vertices to duplicate: each element is the index of a vertex in the mesh, that must be appended to the buffer. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buffer</td><td>The buffer where to append the duplicated vertex selection. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae7ff6a1fe60aaca134e3fdd3eeedf274" name="gae7ff6a1fe60aaca134e3fdd3eeedf274"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae7ff6a1fe60aaca134e3fdd3eeedf274">&#9670;&#160;</a></span>appendDuplicateVertexTexCoordIndicesToBuffer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Segment.html">void</a> vcl::appendDuplicateVertexTexCoordIndicesToBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Segment.html">const</a> MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Segment.html">const</a> std::list&lt; uint &gt; &amp;&#160;</td>
          <td class="paramname"><em>vertsToDuplicate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Segment.html">auto</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Append the texture coordinate indices of the duplicated vertices to the given buffer. </p>
<p>Given the list of vertices to duplicate, this function appends to the given buffer the vertex texture coordinate indices of the vertices listed in the input list.</p>
<p>Typical usage of this function is after the countVerticesToDuplicateByWedgeTexCoords function and along with the vertexTexCoordIndicesToBuffer function:</p>
<div class="fragment"><div class="line">std::vector&lt;std::pair&lt;uint, uint&gt;&gt; <a class="code hl_class" href="classvcl_1_1Segment.html">vertWedgeMap</a>;</div>
<div class="line">std::list&lt;uint&gt; <a class="code hl_class" href="classvcl_1_1Segment.html">vertsToDuplicate</a>;</div>
<div class="line">std::list&lt;std::list&lt;std::pair&lt;uint, uint&gt;&gt;&gt; <a class="code hl_class" href="classvcl_1_1Segment.html">facesToReassign</a>;</div>
<div class="line"> </div>
<div class="line">uint <a class="code hl_class" href="classvcl_1_1Segment.html">nV</a> = countVerticesToDuplicateByWedgeTexCoords(mesh, <a class="code hl_class" href="classvcl_1_1Segment.html">vertWedgeMap</a>,</div>
<div class="line">    <a class="code hl_class" href="classvcl_1_1Segment.html">vertsToDuplicate</a>, <a class="code hl_class" href="classvcl_1_1Segment.html">facesToReassign</a>);</div>
<div class="line"> </div>
<div class="line">std::vector&lt;ushort&gt; buffer(mesh.vertexNumber() + <a class="code hl_class" href="classvcl_1_1Segment.html">nV</a>);</div>
<div class="line"><a class="code hl_class" href="classvcl_1_1Segment.html">vertexTexCoordIndicesToBuffer</a>(mesh, buffer.data());</div>
<div class="line"><a class="code hl_function" href="group__append__replace__to__buffer.html#gae7ff6a1fe60aaca134e3fdd3eeedf274">appendDuplicateVertexTexCoordIndicesToBuffer</a>(mesh, <a class="code hl_class" href="classvcl_1_1Segment.html">vertsToDuplicate</a>,</div>
<div class="line">    buffer.data());</div>
<div class="ttc" id="agroup__append__replace__to__buffer_html_gae7ff6a1fe60aaca134e3fdd3eeedf274"><div class="ttname"><a href="group__append__replace__to__buffer.html#gae7ff6a1fe60aaca134e3fdd3eeedf274">vcl::appendDuplicateVertexTexCoordIndicesToBuffer</a></div><div class="ttdeci">void appendDuplicateVertexTexCoordIndicesToBuffer(const MeshType &amp;mesh, const std::list&lt; uint &gt; &amp;vertsToDuplicate, auto *buffer)</div><div class="ttdoc">Append the texture coordinate indices of the duplicated vertices to the given buffer.</div><div class="ttdef"><b>Definition</b> append_replace_to_buffer.h:732</div></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>The buffer must be preallocated with the correct size (total number of vertices).</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MeshType</td><td>The type of the mesh.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>The mesh from which take the vertex texture coordinate indices. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vertsToDuplicate</td><td>The list of vertices to duplicate: each element is the index of a vertex in the mesh, that must be appended to the buffer. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buffer</td><td>The buffer where to append the duplicated vertex texture coordinate indices. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf4fbbfe648bc642f41d78a32b1df1b58" name="gaf4fbbfe648bc642f41d78a32b1df1b58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf4fbbfe648bc642f41d78a32b1df1b58">&#9670;&#160;</a></span>appendDuplicateVertexTexCoordsToBuffer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Segment.html">void</a> vcl::appendDuplicateVertexTexCoordsToBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Segment.html">const</a> MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Segment.html">const</a> std::list&lt; uint &gt; &amp;&#160;</td>
          <td class="paramname"><em>vertsToDuplicate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Segment.html">auto</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga16a1bfbea022f6766d2f3ebbf69a3b52">MatrixStorageType</a>&#160;</td>
          <td class="paramname"><em>storage</em> = <code>MatrixStorageType::ROW_MAJOR</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Append the texture coordinates of the duplicated vertices to the given buffer. </p>
<p>Given the list of vertices to duplicate, this function appends to the given buffer the vertex texture coordinates of the vertices listed in the input list.</p>
<p>Typical usage of this function is after the countVerticesToDuplicateByWedgeTexCoords function and along with the vertexTexCoordsToBuffer function:</p>
<div class="fragment"><div class="line">std::vector&lt;std::pair&lt;uint, uint&gt;&gt; <a class="code hl_class" href="classvcl_1_1Segment.html">vertWedgeMap</a>;</div>
<div class="line">std::list&lt;uint&gt; <a class="code hl_class" href="classvcl_1_1Segment.html">vertsToDuplicate</a>;</div>
<div class="line">std::list&lt;std::list&lt;std::pair&lt;uint, uint&gt;&gt;&gt; <a class="code hl_class" href="classvcl_1_1Segment.html">facesToReassign</a>;</div>
<div class="line"> </div>
<div class="line">uint <a class="code hl_class" href="classvcl_1_1Segment.html">nV</a> = countVerticesToDuplicateByWedgeTexCoords(mesh, <a class="code hl_class" href="classvcl_1_1Segment.html">vertWedgeMap</a>,</div>
<div class="line">    <a class="code hl_class" href="classvcl_1_1Segment.html">vertsToDuplicate</a>, <a class="code hl_class" href="classvcl_1_1Segment.html">facesToReassign</a>);</div>
<div class="line"> </div>
<div class="line">std::vector&lt;double&gt; buffer((mesh.vertexNumber() + <a class="code hl_class" href="classvcl_1_1Segment.html">nV</a>) * 2);</div>
<div class="line"><a class="code hl_class" href="classvcl_1_1Segment.html">vertexTexCoordsToBuffer</a>(mesh, buffer.data());</div>
<div class="line"><a class="code hl_function" href="group__append__replace__to__buffer.html#gaf4fbbfe648bc642f41d78a32b1df1b58">appendDuplicateVertexTexCoordsToBuffer</a>(mesh, <a class="code hl_class" href="classvcl_1_1Segment.html">vertsToDuplicate</a>,</div>
<div class="line">    buffer.data());</div>
<div class="ttc" id="agroup__append__replace__to__buffer_html_gaf4fbbfe648bc642f41d78a32b1df1b58"><div class="ttname"><a href="group__append__replace__to__buffer.html#gaf4fbbfe648bc642f41d78a32b1df1b58">vcl::appendDuplicateVertexTexCoordsToBuffer</a></div><div class="ttdeci">void appendDuplicateVertexTexCoordsToBuffer(const MeshType &amp;mesh, const std::list&lt; uint &gt; &amp;vertsToDuplicate, auto *buffer, MatrixStorageType storage=MatrixStorageType::ROW_MAJOR)</div><div class="ttdoc">Append the texture coordinates of the duplicated vertices to the given buffer.</div><div class="ttdef"><b>Definition</b> append_replace_to_buffer.h:662</div></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>The buffer must be preallocated with the correct size (total number of vertices times 2).</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MeshType</td><td>The type of the mesh.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>The mesh from which take the vertex texture coordinates. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vertsToDuplicate</td><td>The list of vertices to duplicate: each element is the index of a vertex in the mesh, that must be appended to the buffer. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buffer</td><td>The buffer where to append the duplicated vertex texture coordinates. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">storage</td><td>The storage type of the matrix (row or column major). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8101f28855ba5bc9e96f1324a1c8d52c" name="ga8101f28855ba5bc9e96f1324a1c8d52c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8101f28855ba5bc9e96f1324a1c8d52c">&#9670;&#160;</a></span>replaceFaceIndicesByVertexDuplicationToBuffer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Segment.html">void</a> vcl::replaceFaceIndicesByVertexDuplicationToBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Segment.html">const</a> MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Segment.html">const</a> std::list&lt; uint &gt; &amp;&#160;</td>
          <td class="paramname"><em>vertsToDuplicate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Segment.html">const</a> std::list&lt; std::list&lt; std::pair&lt; uint, uint &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>facesToReassign</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Segment.html">auto</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>largestFaceSize</em> = <code>3</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga16a1bfbea022f6766d2f3ebbf69a3b52">MatrixStorageType</a>&#160;</td>
          <td class="paramname"><em>storage</em> = <code>MatrixStorageType::ROW_MAJOR</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace the face vertex indices in the given buffer with the new indices of the duplicated vertices. </p>
<p>Given a buffer containing the vertex indices of the faces of a mesh (stored in row-major order, and with a fixed face size), this function updates the indices of the vertices that have been duplicated, according to the data stored in the input lists.</p>
<p>Typical usage of this function is after the countVerticesToDuplicateByWedgeTexCoords function and along with any of the functions defined in <a class="el" href="group__export__buffer.html">Export Mesh to Buffer Algorithms</a> that export face indices. e.g.:</p>
<div class="fragment"><div class="line">std::vector&lt;std::pair&lt;uint, uint&gt;&gt; <a class="code hl_class" href="classvcl_1_1Segment.html">vertWedgeMap</a>;</div>
<div class="line">std::list&lt;uint&gt; <a class="code hl_class" href="classvcl_1_1Segment.html">vertsToDuplicate</a>;</div>
<div class="line">std::list&lt;std::list&lt;std::pair&lt;uint, uint&gt;&gt;&gt; <a class="code hl_class" href="classvcl_1_1Segment.html">facesToReassign</a>;</div>
<div class="line"> </div>
<div class="line">uint <a class="code hl_class" href="classvcl_1_1Segment.html">nV</a> = countVerticesToDuplicateByWedgeTexCoords(mesh, <a class="code hl_class" href="classvcl_1_1Segment.html">vertWedgeMap</a>,</div>
<div class="line">    <a class="code hl_class" href="classvcl_1_1Segment.html">vertsToDuplicate</a>, <a class="code hl_class" href="classvcl_1_1Segment.html">facesToReassign</a>);</div>
<div class="line">uint <a class="code hl_class" href="classvcl_1_1Segment.html">lfs</a> = vcl::largestFaceSize(mesh);</div>
<div class="line"> </div>
<div class="line">std::vector&lt;uint&gt; buffer(mesh.faceNumber() * <a class="code hl_class" href="classvcl_1_1Segment.html">lfs</a>);</div>
<div class="line"><a class="code hl_function" href="group__export__buffer.html#ga4d8d20f3cc27e22f326932cd22843fa5">faceIndicesToBuffer</a>(mesh, buffer.data(), <a class="code hl_class" href="classvcl_1_1Segment.html">lfs</a>);</div>
<div class="line"><a class="code hl_function" href="group__append__replace__to__buffer.html#ga8101f28855ba5bc9e96f1324a1c8d52c">replaceFaceIndicesByVertexDuplicationToBuffer</a>(mesh, <a class="code hl_class" href="classvcl_1_1Segment.html">vertsToDuplicate</a>,</div>
<div class="line">   <a class="code hl_class" href="classvcl_1_1Segment.html">faceToReassign</a>, buffer.data(), <a class="code hl_class" href="classvcl_1_1Segment.html">lfs</a>);</div>
<div class="ttc" id="agroup__append__replace__to__buffer_html_ga8101f28855ba5bc9e96f1324a1c8d52c"><div class="ttname"><a href="group__append__replace__to__buffer.html#ga8101f28855ba5bc9e96f1324a1c8d52c">vcl::replaceFaceIndicesByVertexDuplicationToBuffer</a></div><div class="ttdeci">void replaceFaceIndicesByVertexDuplicationToBuffer(const MeshType &amp;mesh, const std::list&lt; uint &gt; &amp;vertsToDuplicate, const std::list&lt; std::list&lt; std::pair&lt; uint, uint &gt; &gt; &gt; &amp;facesToReassign, auto *buffer, uint largestFaceSize=3, MatrixStorageType storage=MatrixStorageType::ROW_MAJOR)</div><div class="ttdoc">Replace the face vertex indices in the given buffer with the new indices of the duplicated vertices.</div><div class="ttdef"><b>Definition</b> append_replace_to_buffer.h:176</div></div>
<div class="ttc" id="agroup__export__buffer_html_ga4d8d20f3cc27e22f326932cd22843fa5"><div class="ttname"><a href="group__export__buffer.html#ga4d8d20f3cc27e22f326932cd22843fa5">vcl::faceIndicesToBuffer</a></div><div class="ttdeci">void faceIndicesToBuffer(const MeshType &amp;mesh, auto *buffer, bool getIndicesAsIfContainerCompact=true)</div><div class="ttdoc">Export into a buffer the vertex indices for each face of a Mesh. Faces can be polygons.</div><div class="ttdef"><b>Definition</b> export_buffer.h:211</div></div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MeshType</td><td>The type of the mesh.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>The input mesh. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vertsToDuplicate</td><td>The list of vertices to duplicate: each element is the index of a vertex in the mesh, that must be replaced in the buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">facesToReassign</td><td>The list of lists of pairs face/vertex index in the face that must be reassigned to the duplicated vertices. Each list of pairs is the list of faces that must be reassigned to the corresponding duplicated vertex. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buffer</td><td>The buffer where to replace the vertex indices. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">largestFaceSize</td><td>The size of the largest face in the mesh (that corresponds to the number of columns in the buffer) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">storage</td><td>The storage type of the matrix (row or column major). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga266d0cdfa279b4540e747084aa38f71d" name="ga266d0cdfa279b4540e747084aa38f71d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga266d0cdfa279b4540e747084aa38f71d">&#9670;&#160;</a></span>replaceTriangulatedFaceIndicesByVertexDuplicationToBuffer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Segment.html">void</a> vcl::replaceTriangulatedFaceIndicesByVertexDuplicationToBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Segment.html">const</a> MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Segment.html">const</a> std::list&lt; uint &gt; &amp;&#160;</td>
          <td class="paramname"><em>vertsToDuplicate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Segment.html">const</a> std::list&lt; std::list&lt; std::pair&lt; uint, uint &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>facesToReassign</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Segment.html">const</a> <a class="el" href="classvcl_1_1TriPolyIndexBiMap.html">TriPolyIndexBiMap</a> &amp;&#160;</td>
          <td class="paramname"><em>indexMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Segment.html">auto</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga16a1bfbea022f6766d2f3ebbf69a3b52">MatrixStorageType</a>&#160;</td>
          <td class="paramname"><em>storage</em> = <code>MatrixStorageType::ROW_MAJOR</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace the triangulated face vertex indices in the given buffer with the new indices of the duplicated vertices. </p>
<p>Given a buffer containing the vertex indices of the triangles of a mesh that has been triangulated (stored in row-major order), this function updates the indices of the vertices that have been duplicated, according to the data stored in the input lists.</p>
<p>Typical usage of this function is after the countVerticesToDuplicateByWedgeTexCoords function and along with <a class="el" href="group__export__buffer.html#ga1536428adc2a72c8eb60d3e92b0fce32">triangulatedFaceIndicesToBuffer</a> function that export triangulated face indices. e.g.:</p>
<div class="fragment"><div class="line">std::vector&lt;std::pair&lt;uint, uint&gt;&gt; <a class="code hl_class" href="classvcl_1_1Segment.html">vertWedgeMap</a>;</div>
<div class="line">std::list&lt;uint&gt; <a class="code hl_class" href="classvcl_1_1Segment.html">vertsToDuplicate</a>;</div>
<div class="line">std::list&lt;std::list&lt;std::pair&lt;uint, uint&gt;&gt;&gt; <a class="code hl_class" href="classvcl_1_1Segment.html">facesToReassign</a>;</div>
<div class="line"><a class="code hl_class" href="classvcl_1_1TriPolyIndexBiMap.html">TriPolyIndexBiMap</a> indexMap;</div>
<div class="line"> </div>
<div class="line">uint <a class="code hl_class" href="classvcl_1_1Segment.html">nV</a> = countVerticesToDuplicateByWedgeTexCoords(mesh, <a class="code hl_class" href="classvcl_1_1Segment.html">vertWedgeMap</a>,</div>
<div class="line">    <a class="code hl_class" href="classvcl_1_1Segment.html">vertsToDuplicate</a>, <a class="code hl_class" href="classvcl_1_1Segment.html">facesToReassign</a>);</div>
<div class="line"> </div>
<div class="line">uint numTris = vcl::countTriangulatedTriangles(<a class="code hl_class" href="classvcl_1_1Segment.html">myMesh</a>);</div>
<div class="line"> </div>
<div class="line">std::vector&lt;uint&gt; buffer(mesh.faceNumber() * numTris);</div>
<div class="line"><a class="code hl_function" href="group__export__buffer.html#ga1536428adc2a72c8eb60d3e92b0fce32">triangulatedFaceIndicesToBuffer</a>(mesh, buffer.data(), indexMap);</div>
<div class="line"><a class="code hl_function" href="group__append__replace__to__buffer.html#ga266d0cdfa279b4540e747084aa38f71d">replaceTriangulatedFaceIndicesByVertexDuplicationToBuffer</a>(mesh,</div>
<div class="line">   <a class="code hl_class" href="classvcl_1_1Segment.html">vertsToDuplicate</a>, <a class="code hl_class" href="classvcl_1_1Segment.html">faceToReassign</a>, indexMap, buffer.data());</div>
<div class="ttc" id="aclassvcl_1_1TriPolyIndexBiMap_html"><div class="ttname"><a href="classvcl_1_1TriPolyIndexBiMap.html">vcl::TriPolyIndexBiMap</a></div><div class="ttdoc">The TriPolyIndexBiMap class allows to store a bidirectional mapping between a Polygon Mesh and a Tria...</div><div class="ttdef"><b>Definition</b> tri_poly_index_bimap.h:50</div></div>
<div class="ttc" id="agroup__append__replace__to__buffer_html_ga266d0cdfa279b4540e747084aa38f71d"><div class="ttname"><a href="group__append__replace__to__buffer.html#ga266d0cdfa279b4540e747084aa38f71d">vcl::replaceTriangulatedFaceIndicesByVertexDuplicationToBuffer</a></div><div class="ttdeci">void replaceTriangulatedFaceIndicesByVertexDuplicationToBuffer(const MeshType &amp;mesh, const std::list&lt; uint &gt; &amp;vertsToDuplicate, const std::list&lt; std::list&lt; std::pair&lt; uint, uint &gt; &gt; &gt; &amp;facesToReassign, const TriPolyIndexBiMap &amp;indexMap, auto *buffer, MatrixStorageType storage=MatrixStorageType::ROW_MAJOR)</div><div class="ttdoc">Replace the triangulated face vertex indices in the given buffer with the new indices of the duplicat...</div><div class="ttdef"><b>Definition</b> append_replace_to_buffer.h:253</div></div>
<div class="ttc" id="agroup__export__buffer_html_ga1536428adc2a72c8eb60d3e92b0fce32"><div class="ttname"><a href="group__export__buffer.html#ga1536428adc2a72c8eb60d3e92b0fce32">vcl::triangulatedFaceIndicesToBuffer</a></div><div class="ttdeci">void triangulatedFaceIndicesToBuffer(const MeshType &amp;mesh, auto *buffer, TriPolyIndexBiMap &amp;indexMap=detail::indexMap, MatrixStorageType storage=MatrixStorageType::ROW_MAJOR, uint numTriangles=UINT_NULL, bool getIndicesAsIfContainerCompact=true)</div><div class="ttdoc">Export into a buffer the vertex indices for each triangle computed by triangulating the faces of a Me...</div><div class="ttdef"><b>Definition</b> export_buffer.h:357</div></div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MeshType</td><td>The type of the mesh.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>The input mesh. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vertsToDuplicate</td><td>The list of vertices to duplicate: each element is the index of a vertex in the mesh, that must be replaced in the buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">facesToReassign</td><td>The list of lists of pairs face/vertex index in the face that must be reassigned to the duplicated vertices. Each list of pairs is the list of faces that must be reassigned to the corresponding duplicated vertex. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">indexMap</td><td>The map from triangle index to face index. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buffer</td><td>The buffer where to replace the vertex indices. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">storage</td><td>The storage type of the matrix (row or column major). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gafa6d2832df378ef8b5d6aa4612c895f4" name="gafa6d2832df378ef8b5d6aa4612c895f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafa6d2832df378ef8b5d6aa4612c895f4">&#9670;&#160;</a></span>wedgeTexCoordIndicesAsDuplicatedVertexTexCoordIndicesToBuffer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Segment.html">void</a> vcl::wedgeTexCoordIndicesAsDuplicatedVertexTexCoordIndicesToBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Segment.html">const</a> MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Segment.html">const</a> std::vector&lt; std::pair&lt; <a class="el" href="classvcl_1_1Segment.html">vcl::uint</a>, <a class="el" href="classvcl_1_1Segment.html">vcl::uint</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>vertWedgeMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Segment.html">const</a> std::list&lt; std::list&lt; std::pair&lt; <a class="el" href="classvcl_1_1Segment.html">vcl::uint</a>, <a class="el" href="classvcl_1_1Segment.html">vcl::uint</a> &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>facesToReassign</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Segment.html">auto</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Export wedge texture coordinate indices to a buffer of the duplicated vertex texture coordinate indices. </p>
<p>Given the list of vertices to duplicate, this function exports to the given buffer the wedge texture indices as if they were vertex texture indices, and appending only the texture indices of the vertices to duplicate.</p>
<p>Typical usage of this function is after the countVerticesToDuplicateByWedgeTexCoords function:</p>
<div class="fragment"><div class="line">std::vector&lt;std::pair&lt;uint, uint&gt;&gt; <a class="code hl_class" href="classvcl_1_1Segment.html">vertWedgeMap</a>;</div>
<div class="line">std::list&lt;uint&gt; <a class="code hl_class" href="classvcl_1_1Segment.html">vertsToDuplicate</a>;</div>
<div class="line">std::list&lt;std::list&lt;std::pair&lt;uint, uint&gt;&gt;&gt; <a class="code hl_class" href="classvcl_1_1Segment.html">facesToReassign</a>;</div>
<div class="line"> </div>
<div class="line">uint <a class="code hl_class" href="classvcl_1_1Segment.html">nV</a> = countVerticesToDuplicateByWedgeTexCoords(mesh, <a class="code hl_class" href="classvcl_1_1Segment.html">vertWedgeMap</a>,</div>
<div class="line">    <a class="code hl_class" href="classvcl_1_1Segment.html">vertsToDuplicate</a>, <a class="code hl_class" href="classvcl_1_1Segment.html">facesToReassign</a>);</div>
<div class="line"> </div>
<div class="line">std::vector&lt;ushort&gt; buffer(mesh.vertexNumber() + <a class="code hl_class" href="classvcl_1_1Segment.html">nV</a>);</div>
<div class="line"><a class="code hl_function" href="group__append__replace__to__buffer.html#gafa6d2832df378ef8b5d6aa4612c895f4">wedgeTexCoordIndicesAsDuplicatedVertexTexCoordIndicesToBuffer</a>(mesh,</div>
<div class="line">    <a class="code hl_class" href="classvcl_1_1Segment.html">vertWedgeMap</a>, <a class="code hl_class" href="classvcl_1_1Segment.html">facesToReassign</a>, buffer.data());</div>
<div class="ttc" id="agroup__append__replace__to__buffer_html_gafa6d2832df378ef8b5d6aa4612c895f4"><div class="ttname"><a href="group__append__replace__to__buffer.html#gafa6d2832df378ef8b5d6aa4612c895f4">vcl::wedgeTexCoordIndicesAsDuplicatedVertexTexCoordIndicesToBuffer</a></div><div class="ttdeci">void wedgeTexCoordIndicesAsDuplicatedVertexTexCoordIndicesToBuffer(const MeshType &amp;mesh, const std::vector&lt; std::pair&lt; vcl::uint, vcl::uint &gt; &gt; &amp;vertWedgeMap, const std::list&lt; std::list&lt; std::pair&lt; vcl::uint, vcl::uint &gt; &gt; &gt; &amp;facesToReassign, auto *buffer)</div><div class="ttdoc">Export wedge texture coordinate indices to a buffer of the duplicated vertex texture coordinate indic...</div><div class="ttdef"><b>Definition</b> export_buffer.h:1813</div></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>The buffer must be preallocated with the correct size (total number of vertices).</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MeshType</td><td>The type of the mesh.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>The mesh from which take the wedge texture coordinate indices. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vertWedgeMap</td><td>The map from non-duplicated vertex index to face index and wedge index in the face. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">facesToReassign</td><td>The list of lists of pairs face/vertex index in the face that must be reassigned to the duplicated vertices. Each list of pairs is the list of faces that must be reassigned to the corresponding duplicated vertex. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buffer</td><td>The buffer where to export the vertex wedge texture coordinate indices. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0a58d21198652c1facd5586a1899e7d1" name="ga0a58d21198652c1facd5586a1899e7d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0a58d21198652c1facd5586a1899e7d1">&#9670;&#160;</a></span>wedgeTexCoordsAsDuplicatedVertexTexCoordsToBuffer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Segment.html">void</a> vcl::wedgeTexCoordsAsDuplicatedVertexTexCoordsToBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Segment.html">const</a> MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Segment.html">const</a> std::vector&lt; std::pair&lt; <a class="el" href="classvcl_1_1Segment.html">vcl::uint</a>, <a class="el" href="classvcl_1_1Segment.html">vcl::uint</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>vertWedgeMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Segment.html">const</a> std::list&lt; std::list&lt; std::pair&lt; <a class="el" href="classvcl_1_1Segment.html">vcl::uint</a>, <a class="el" href="classvcl_1_1Segment.html">vcl::uint</a> &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>facesToReassign</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Segment.html">auto</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga16a1bfbea022f6766d2f3ebbf69a3b52">MatrixStorageType</a>&#160;</td>
          <td class="paramname"><em>storage</em> = <code>MatrixStorageType::ROW_MAJOR</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Export wedge texture coordinates to a buffer of the duplicated vertex texture coordinates. </p>
<p>Given the list of vertices to duplicate, this function exports to the given buffer the wedge texture coordinates as if they were vertex texture coordinates, and appending only the texture coordinates of the vertices to duplicate.</p>
<p>Typical usage of this function is after the countVerticesToDuplicateByWedgeTexCoords function:</p>
<div class="fragment"><div class="line">std::vector&lt;std::pair&lt;uint, uint&gt;&gt; <a class="code hl_class" href="classvcl_1_1Segment.html">vertWedgeMap</a>;</div>
<div class="line">std::list&lt;uint&gt; <a class="code hl_class" href="classvcl_1_1Segment.html">vertsToDuplicate</a>;</div>
<div class="line">std::list&lt;std::list&lt;std::pair&lt;uint, uint&gt;&gt;&gt; <a class="code hl_class" href="classvcl_1_1Segment.html">facesToReassign</a>;</div>
<div class="line"> </div>
<div class="line">uint <a class="code hl_class" href="classvcl_1_1Segment.html">nV</a> = countVerticesToDuplicateByWedgeTexCoords(mesh, <a class="code hl_class" href="classvcl_1_1Segment.html">vertWedgeMap</a>,</div>
<div class="line">    <a class="code hl_class" href="classvcl_1_1Segment.html">vertsToDuplicate</a>, <a class="code hl_class" href="classvcl_1_1Segment.html">facesToReassign</a>);</div>
<div class="line"> </div>
<div class="line">std::vector&lt;double&gt; buffer((mesh.vertexNumber() + <a class="code hl_class" href="classvcl_1_1Segment.html">nV</a>) * 2);</div>
<div class="line"><a class="code hl_function" href="group__append__replace__to__buffer.html#ga0a58d21198652c1facd5586a1899e7d1">wedgeTexCoordsAsDuplicatedVertexTexCoordsToBuffer</a>(mesh, <a class="code hl_class" href="classvcl_1_1Segment.html">vertWedgeMap</a>,</div>
<div class="line">    <a class="code hl_class" href="classvcl_1_1Segment.html">facesToReassign</a>, buffer.data());</div>
<div class="ttc" id="agroup__append__replace__to__buffer_html_ga0a58d21198652c1facd5586a1899e7d1"><div class="ttname"><a href="group__append__replace__to__buffer.html#ga0a58d21198652c1facd5586a1899e7d1">vcl::wedgeTexCoordsAsDuplicatedVertexTexCoordsToBuffer</a></div><div class="ttdeci">void wedgeTexCoordsAsDuplicatedVertexTexCoordsToBuffer(const MeshType &amp;mesh, const std::vector&lt; std::pair&lt; vcl::uint, vcl::uint &gt; &gt; &amp;vertWedgeMap, const std::list&lt; std::list&lt; std::pair&lt; vcl::uint, vcl::uint &gt; &gt; &gt; &amp;facesToReassign, auto *buffer, MatrixStorageType storage=MatrixStorageType::ROW_MAJOR)</div><div class="ttdoc">Export wedge texture coordinates to a buffer of the duplicated vertex texture coordinates.</div><div class="ttdef"><b>Definition</b> export_buffer.h:1710</div></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>The buffer must be preallocated with the correct size (total number of vertices times 2).</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MeshType</td><td>The type of the mesh.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>The mesh from which take the wedge texture coordinates. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vertWedgeMap</td><td>The map from non-duplicated vertex index to face index and wedge index in the face. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">facesToReassign</td><td>The list of lists of pairs face/vertex index in the face that must be reassigned to the duplicated vertices. Each list of pairs is the list of faces that must be reassigned to the corresponding duplicated vertex. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buffer</td><td>The buffer where to export the vertex wedge texture coordinates. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">storage</td><td>The storage type of the matrix (row or column major). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
