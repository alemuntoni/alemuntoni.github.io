<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Visual Computing Library: Core Algorithms</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript" src="../version-selector.js"></script>
       <script type="text/javascript">
           DoxygenAwesomeDarkModeToggle.init()
       </script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Visual Computing Library
   &#160;<span id="projectnumber">devel</span>
   </div>
   <!-- Version selector dropdown -->
   <div id="version-selector" style="margin-top: 10px;">
     <label for="version-dropdown" style="font-size: 12px; color: #666;">Version:</label>
     <select id="version-dropdown" style="margin-left: 5px; padding: 2px 5px; font-size: 12px; border: 1px solid #ccc; border-radius: 3px;">
       <option value="">Loading versions...</option>
     </select>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group__algorithms__core.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Core Algorithms</div></div>
</div><!--header-->
<div class="contents">

<p>List of Core algorithms.  
<a href="#details">More...</a></p>
<div class="dynheader">
Collaboration diagram for Core Algorithms:</div>
<div class="dyncontent">
<div class="center"><img src="group__algorithms__core.png" border="0" usemap="#agroup____algorithms____core" alt=""/></div>
<map name="agroup____algorithms____core" id="agroup____algorithms____core">
<area shape="rect" title="List of Core algorithms." alt="" coords="5,129,132,155"/>
<area shape="rect" href="group__core__bounding__box.html" title="List of overloaded boundingBox functions that take in input an object (or a Range of objects) and ret..." alt="" coords="180,5,401,31"/>
<area shape="rect" href="group__core__box.html" title="List of utility functions for boxes having different dimensions." alt="" coords="213,55,369,80"/>
<area shape="rect" href="group__core__create.html" title="List core algorithms for creating generic objects." alt="" coords="203,104,378,129"/>
<area shape="rect" href="group__core__distance.html" title="List of distance algorithms." alt="" coords="197,153,385,179"/>
<area shape="rect" href="group__core__intersection.html" title="List of intersection algorithms." alt="" coords="187,203,395,228"/>
<area shape="rect" href="group__core__polygon.html" title="List of Core Polygon algorithms." alt="" coords="199,252,382,277"/>
</map>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="groups" name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:group__core__bounding__box" id="r_group__core__bounding__box"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__bounding__box.html">Core Bounding Box Algorithms</a></td></tr>
<tr class="memdesc:group__core__bounding__box"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of overloaded boundingBox functions that take in input an object (or a Range of objects) and return its/their bounding box. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__core__box" id="r_group__core__box"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__box.html">Core Box Algorithms</a></td></tr>
<tr class="memdesc:group__core__box"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of utility functions for boxes having different dimensions. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__core__create" id="r_group__core__create"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__create.html">Core Create Algorithms</a></td></tr>
<tr class="memdesc:group__core__create"><td class="mdescLeft">&#160;</td><td class="mdescRight">List core algorithms for creating generic objects. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__core__distance" id="r_group__core__distance"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__distance.html">Core Distance Algorithms</a></td></tr>
<tr class="memdesc:group__core__distance"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of distance algorithms. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__core__intersection" id="r_group__core__intersection"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__intersection.html">Core Intersection Algorithms</a></td></tr>
<tr class="memdesc:group__core__intersection"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of intersection algorithms. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__core__polygon" id="r_group__core__polygon"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__polygon.html">Polygon Core Algorithms</a></td></tr>
<tr class="memdesc:group__core__polygon"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of Core Polygon algorithms. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga75d73f827d48cf0ff2554aebfbf36682" id="r_ga75d73f827d48cf0ff2554aebfbf36682"><td class="memTemplParams" colspan="2">template&lt;Point3Concept PointType&gt; </td></tr>
<tr class="memitem:ga75d73f827d48cf0ff2554aebfbf36682"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Box.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithms__core.html#ga75d73f827d48cf0ff2554aebfbf36682">vcl::arePointsCoplanar</a> (<a class="el" href="classvcl_1_1Box.html">const</a> PointType &amp;p0, <a class="el" href="classvcl_1_1Box.html">const</a> PointType &amp;p1, <a class="el" href="classvcl_1_1Box.html">const</a> PointType &amp;<a class="el" href="classvcl_1_1Box.html">p2</a>, <a class="el" href="classvcl_1_1Box.html">const</a> PointType &amp;<a class="el" href="classvcl_1_1Box.html">p3</a>)</td></tr>
<tr class="memdesc:ga75d73f827d48cf0ff2554aebfbf36682"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if 4 points are coplanar.  <br /></td></tr>
<tr class="separator:ga75d73f827d48cf0ff2554aebfbf36682"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e71eff214deaf0c9f9e33f828326a89" id="r_ga3e71eff214deaf0c9f9e33f828326a89"><td class="memTemplParams" colspan="2">template&lt;FaceConcept FaceType, Point3Concept PointType&gt; </td></tr>
<tr class="memitem:ga3e71eff214deaf0c9f9e33f828326a89"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Box.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithms__core.html#ga3e71eff214deaf0c9f9e33f828326a89">vcl::facePointVisibility</a> (<a class="el" href="classvcl_1_1Box.html">const</a> FaceType &amp;face, <a class="el" href="classvcl_1_1Box.html">const</a> PointType &amp;point)</td></tr>
<tr class="memdesc:ga3e71eff214deaf0c9f9e33f828326a89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a point is visible from a face, i.e., if the point is in the half-space defined by the face.  <br /></td></tr>
<tr class="separator:ga3e71eff214deaf0c9f9e33f828326a89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga258c61f730c08e6d3cfc4f6c93af1588" id="r_ga258c61f730c08e6d3cfc4f6c93af1588"><td class="memTemplParams" colspan="2">template&lt;FaceConcept FaceType, Point3Concept PointType&gt; </td></tr>
<tr class="memitem:ga258c61f730c08e6d3cfc4f6c93af1588"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Box.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithms__core.html#ga258c61f730c08e6d3cfc4f6c93af1588">vcl::halfSpaceDeterminant</a> (<a class="el" href="classvcl_1_1Box.html">const</a> FaceType &amp;face, <a class="el" href="classvcl_1_1Box.html">const</a> PointType &amp;point)</td></tr>
<tr class="memdesc:ga258c61f730c08e6d3cfc4f6c93af1588"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the determinant of the half-space defined by the triangle and the point.  <br /></td></tr>
<tr class="separator:ga258c61f730c08e6d3cfc4f6c93af1588"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga394b096177019cfacda94eb16ae1fdc2" id="r_ga394b096177019cfacda94eb16ae1fdc2"><td class="memTemplParams" colspan="2">template&lt;Point3Concept PointType&gt; </td></tr>
<tr class="memitem:ga394b096177019cfacda94eb16ae1fdc2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Box.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithms__core.html#ga394b096177019cfacda94eb16ae1fdc2">vcl::halfSpaceDeterminant</a> (<a class="el" href="classvcl_1_1Box.html">const</a> PointType &amp;p0, <a class="el" href="classvcl_1_1Box.html">const</a> PointType &amp;p1, <a class="el" href="classvcl_1_1Box.html">const</a> PointType &amp;<a class="el" href="classvcl_1_1Box.html">p2</a>, <a class="el" href="classvcl_1_1Box.html">const</a> PointType &amp;<a class="el" href="classvcl_1_1Box.html">p</a>)</td></tr>
<tr class="memdesc:ga394b096177019cfacda94eb16ae1fdc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the determinant of the half-space defined by the triangle (p1, p2, p3) and the point p.  <br /></td></tr>
<tr class="separator:ga394b096177019cfacda94eb16ae1fdc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5973cf28c34d62dc9e4364ee8c19f41a" id="r_ga5973cf28c34d62dc9e4364ee8c19f41a"><td class="memTemplParams" colspan="2">template&lt;Triangle3Concept TriangleType, Point3Concept PointType&gt; </td></tr>
<tr class="memitem:ga5973cf28c34d62dc9e4364ee8c19f41a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Box.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithms__core.html#ga5973cf28c34d62dc9e4364ee8c19f41a">vcl::halfSpaceDeterminant</a> (<a class="el" href="classvcl_1_1Box.html">const</a> <a class="el" href="classvcl_1_1Box.html">TriangleType</a> &amp;<a class="el" href="classvcl_1_1Box.html">triangle</a>, <a class="el" href="classvcl_1_1Box.html">const</a> PointType &amp;point)</td></tr>
<tr class="memdesc:ga5973cf28c34d62dc9e4364ee8c19f41a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the determinant of the half-space defined by the triangle and the point.  <br /></td></tr>
<tr class="separator:ga5973cf28c34d62dc9e4364ee8c19f41a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga212c052ae1efd3426a5ea49051f8011c" id="r_ga212c052ae1efd3426a5ea49051f8011c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Box.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algorithms__core.html#ga212c052ae1efd3426a5ea49051f8011c">vcl::poissonRandomNumber</a> (<a class="el" href="classvcl_1_1Box.html">double</a> <a class="el" href="classvcl_1_1Box.html">lambda</a>, std::mt19937 &amp;<a class="el" href="classvcl_1_1Box.html">gen</a>)</td></tr>
<tr class="memdesc:ga212c052ae1efd3426a5ea49051f8011c"><td class="mdescLeft">&#160;</td><td class="mdescRight">algorithm poisson random number (Knuth): init: Let L ← e^−λ, k ← 0 and p ← 1. do: k ← k + 1. Generate uniform random number u in [0,1] and let p ← p × u. while p &gt; L. return k − 1.  <br /></td></tr>
<tr class="separator:ga212c052ae1efd3426a5ea49051f8011c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1928216d4ca321551feca3fc03054e03" id="r_ga1928216d4ca321551feca3fc03054e03"><td class="memTemplParams" colspan="2">template&lt;Point3Concept PointType&gt; </td></tr>
<tr class="memitem:ga1928216d4ca321551feca3fc03054e03"><td class="memTemplItemLeft" align="right" valign="top">PointType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithms__core.html#ga1928216d4ca321551feca3fc03054e03">vcl::randomTriangleBarycentricCoordinate</a> (std::mt19937 &amp;<a class="el" href="classvcl_1_1Box.html">gen</a>)</td></tr>
<tr class="memdesc:ga1928216d4ca321551feca3fc03054e03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate the barycentric coords of a random point over a triangle, with a uniform distribution over the triangle. It uses the parallelogram folding trick.  <br /></td></tr>
<tr class="separator:ga1928216d4ca321551feca3fc03054e03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5396bbb99432d258d9330d681f1461db" id="r_ga5396bbb99432d258d9330d681f1461db"><td class="memTemplParams" colspan="2">template&lt;Matrix33Or44Concept MatrixType&gt; </td></tr>
<tr class="memitem:ga5396bbb99432d258d9330d681f1461db"><td class="memTemplItemLeft" align="right" valign="top">MatrixType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithms__core.html#ga5396bbb99432d258d9330d681f1461db">vcl::removeScalingFromMatrix</a> (<a class="el" href="classvcl_1_1Box.html">const</a> MatrixType &amp;<a class="el" href="classvcl_1_1Box.html">matrix</a>)</td></tr>
<tr class="memdesc:ga5396bbb99432d258d9330d681f1461db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a matrix with the scaling factors removed.  <br /></td></tr>
<tr class="separator:ga5396bbb99432d258d9330d681f1461db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0826e434e7d549a512181349756bbe21" id="r_ga0826e434e7d549a512181349756bbe21"><td class="memTemplParams" colspan="2">template&lt;Matrix33Or44Concept MatrixType&gt; </td></tr>
<tr class="memitem:ga0826e434e7d549a512181349756bbe21"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Box.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithms__core.html#ga0826e434e7d549a512181349756bbe21">vcl::removeScalingFromMatrixInPlace</a> (MatrixType &amp;<a class="el" href="classvcl_1_1Box.html">matrix</a>)</td></tr>
<tr class="memdesc:ga0826e434e7d549a512181349756bbe21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the scaling factors from the matrix in place.  <br /></td></tr>
<tr class="separator:ga0826e434e7d549a512181349756bbe21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaefa0051d67bdf4a551140929a2cc0b2f" id="r_gaefa0051d67bdf4a551140929a2cc0b2f"><td class="memTemplParams" colspan="2">template&lt;MatrixConcept MatrixType, Point3Concept PointType, <a class="el" href="classvcl_1_1Box.html">typename</a> ScalarType &gt; </td></tr>
<tr class="memitem:gaefa0051d67bdf4a551140929a2cc0b2f"><td class="memTemplItemLeft" align="right" valign="top">MatrixType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithms__core.html#gaefa0051d67bdf4a551140929a2cc0b2f">vcl::rotationMatrix</a> (<a class="el" href="classvcl_1_1Box.html">const</a> PointType &amp;axis, <a class="el" href="classvcl_1_1Box.html">const</a> ScalarType &amp;<a class="el" href="classvcl_1_1Box.html">angleRad</a>)</td></tr>
<tr class="memdesc:gaefa0051d67bdf4a551140929a2cc0b2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an 3D axis and an angle expressed in radiants, returns a transform matrix that represents the rotation matrix of the given axis/angle.  <br /></td></tr>
<tr class="separator:gaefa0051d67bdf4a551140929a2cc0b2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4870ee93dae22bb750da059cefa6d9f2" id="r_ga4870ee93dae22bb750da059cefa6d9f2"><td class="memTemplParams" colspan="2">template&lt;MatrixConcept MatrixType, Point3Concept PointType&gt; </td></tr>
<tr class="memitem:ga4870ee93dae22bb750da059cefa6d9f2"><td class="memTemplItemLeft" align="right" valign="top">MatrixType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithms__core.html#ga4870ee93dae22bb750da059cefa6d9f2">vcl::rotationMatrix</a> (<a class="el" href="classvcl_1_1Box.html">const</a> PointType &amp;<a class="el" href="classvcl_1_1Box.html">fromVector</a>, <a class="el" href="classvcl_1_1Box.html">const</a> PointType &amp;<a class="el" href="classvcl_1_1Box.html">toVector</a>)</td></tr>
<tr class="memdesc:ga4870ee93dae22bb750da059cefa6d9f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given two 3D vectors, returns a transform matrix that represents the rotation matrix from the first vector to the second vector.  <br /></td></tr>
<tr class="separator:ga4870ee93dae22bb750da059cefa6d9f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f6b127154a5e14946cb66492d214de8" id="r_ga7f6b127154a5e14946cb66492d214de8"><td class="memTemplParams" colspan="2">template&lt;MatrixConcept MatrixType, Point3Concept PointType, <a class="el" href="classvcl_1_1Box.html">typename</a> ScalarType &gt; </td></tr>
<tr class="memitem:ga7f6b127154a5e14946cb66492d214de8"><td class="memTemplItemLeft" align="right" valign="top">MatrixType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithms__core.html#ga7f6b127154a5e14946cb66492d214de8">vcl::rotationMatrixDeg</a> (<a class="el" href="classvcl_1_1Box.html">const</a> PointType &amp;axis, <a class="el" href="classvcl_1_1Box.html">const</a> ScalarType &amp;<a class="el" href="classvcl_1_1Box.html">angleDeg</a>)</td></tr>
<tr class="memdesc:ga7f6b127154a5e14946cb66492d214de8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an 3D axis and an angle expressed in degrees, fills the given matrix with a transform matrix that represents the rotation matrix of the given axis/angle.  <br /></td></tr>
<tr class="separator:ga7f6b127154a5e14946cb66492d214de8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeae3bed7ce8fef5657452d857cf87bed" id="r_gaeae3bed7ce8fef5657452d857cf87bed"><td class="memTemplParams" colspan="2">template&lt;MatrixConcept MatrixType, Point3Concept PointType&gt; </td></tr>
<tr class="memitem:gaeae3bed7ce8fef5657452d857cf87bed"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Box.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithms__core.html#gaeae3bed7ce8fef5657452d857cf87bed">vcl::setTransformMatrixRotation</a> (MatrixType &amp;<a class="el" href="classvcl_1_1Box.html">matrix</a>, <a class="el" href="classvcl_1_1Box.html">const</a> PointType &amp;<a class="el" href="classvcl_1_1Box.html">fromVector</a>, <a class="el" href="classvcl_1_1Box.html">const</a> PointType &amp;<a class="el" href="classvcl_1_1Box.html">toVector</a>)</td></tr>
<tr class="memdesc:gaeae3bed7ce8fef5657452d857cf87bed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given two 3D vectors, fills the given matrix with a transform matrix that represents the rotation matrix from the first vector to the second vector.  <br /></td></tr>
<tr class="separator:gaeae3bed7ce8fef5657452d857cf87bed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24901186f1a77f31a23d64f30f0b0dc3" id="r_ga24901186f1a77f31a23d64f30f0b0dc3"><td class="memTemplParams" colspan="2">template&lt;MatrixConcept MatrixType, Point3Concept PointType, <a class="el" href="classvcl_1_1Box.html">typename</a> ScalarType &gt; </td></tr>
<tr class="memitem:ga24901186f1a77f31a23d64f30f0b0dc3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Box.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithms__core.html#ga24901186f1a77f31a23d64f30f0b0dc3">vcl::setTransformMatrixRotation</a> (MatrixType &amp;<a class="el" href="classvcl_1_1Box.html">matrix</a>, PointType axis, <a class="el" href="classvcl_1_1Box.html">const</a> ScalarType &amp;<a class="el" href="classvcl_1_1Box.html">angleRad</a>)</td></tr>
<tr class="memdesc:ga24901186f1a77f31a23d64f30f0b0dc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an 3D axis and an angle expressed in radiants, fills the given matrix with a transform matrix that represents the rotation matrix of the given axis/angle.  <br /></td></tr>
<tr class="separator:ga24901186f1a77f31a23d64f30f0b0dc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd5d95d87600e42a0da835735e35ea99" id="r_gabd5d95d87600e42a0da835735e35ea99"><td class="memTemplParams" colspan="2">template&lt;MatrixConcept MatrixType, Point3Concept PointType, <a class="el" href="classvcl_1_1Box.html">typename</a> ScalarType &gt; </td></tr>
<tr class="memitem:gabd5d95d87600e42a0da835735e35ea99"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Box.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithms__core.html#gabd5d95d87600e42a0da835735e35ea99">vcl::setTransformMatrixRotationDeg</a> (MatrixType &amp;<a class="el" href="classvcl_1_1Box.html">matrix</a>, PointType axis, <a class="el" href="classvcl_1_1Box.html">const</a> ScalarType &amp;<a class="el" href="classvcl_1_1Box.html">angleDeg</a>)</td></tr>
<tr class="memdesc:gabd5d95d87600e42a0da835735e35ea99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an 3D axis and an angle expressed in degrees, fills the given matrix with a transform matrix that represents the rotation matrix of the given axis/angle.  <br /></td></tr>
<tr class="separator:gabd5d95d87600e42a0da835735e35ea99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga438da980623645640c78105766bde287" id="r_ga438da980623645640c78105766bde287"><td class="memTemplParams" colspan="2">template&lt;Point3Concept PointType&gt; </td></tr>
<tr class="memitem:ga438da980623645640c78105766bde287"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; PointType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithms__core.html#ga438da980623645640c78105766bde287">vcl::sphericalFibonacciPointSet</a> (uint <a class="el" href="classvcl_1_1Box.html">n</a>)</td></tr>
<tr class="memdesc:ga438da980623645640c78105766bde287"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector of <code>n</code> points distributed in a unit sphere.  <br /></td></tr>
<tr class="separator:ga438da980623645640c78105766bde287"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9928af42e442b4e28f3232f698a0912b" id="r_ga9928af42e442b4e28f3232f698a0912b"><td class="memTemplParams" colspan="2">template&lt;Point3Concept PointType&gt; </td></tr>
<tr class="memitem:ga9928af42e442b4e28f3232f698a0912b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Box.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithms__core.html#ga9928af42e442b4e28f3232f698a0912b">vcl::trianglePointVisibility</a> (<a class="el" href="classvcl_1_1Box.html">const</a> PointType &amp;p0, <a class="el" href="classvcl_1_1Box.html">const</a> PointType &amp;p1, <a class="el" href="classvcl_1_1Box.html">const</a> PointType &amp;<a class="el" href="classvcl_1_1Box.html">p2</a>, <a class="el" href="classvcl_1_1Box.html">const</a> PointType &amp;<a class="el" href="classvcl_1_1Box.html">p</a>)</td></tr>
<tr class="memdesc:ga9928af42e442b4e28f3232f698a0912b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a point is visible from a triangle, i.e., if the point is in the half-space defined by the triangle.  <br /></td></tr>
<tr class="separator:ga9928af42e442b4e28f3232f698a0912b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd3fb0fe60790cd9aca934b9d3461f6a" id="r_gacd3fb0fe60790cd9aca934b9d3461f6a"><td class="memTemplParams" colspan="2">template&lt;Triangle3Concept TriangleType, Point3Concept PointType&gt; </td></tr>
<tr class="memitem:gacd3fb0fe60790cd9aca934b9d3461f6a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Box.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithms__core.html#gacd3fb0fe60790cd9aca934b9d3461f6a">vcl::trianglePointVisibility</a> (<a class="el" href="classvcl_1_1Box.html">const</a> <a class="el" href="classvcl_1_1Box.html">TriangleType</a> &amp;<a class="el" href="classvcl_1_1Box.html">triangle</a>, <a class="el" href="classvcl_1_1Box.html">const</a> PointType &amp;point)</td></tr>
<tr class="memdesc:gacd3fb0fe60790cd9aca934b9d3461f6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a point is visible from a triangle, i.e., if the point is in the half-space defined by the triangle.  <br /></td></tr>
<tr class="separator:gacd3fb0fe60790cd9aca934b9d3461f6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>List of Core algorithms. </p>
<p>In this module, you can find the core algorithms of VCLib, that generally involve simple geometric primitives, like points, vectors, and matrices.</p>
<p>You can access these algorithms by including <code>#include &lt;<a class="el" href="algorithms_2core_8h_source.html">vclib/algorithms/core.h</a>&gt;</code> </p>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga75d73f827d48cf0ff2554aebfbf36682" name="ga75d73f827d48cf0ff2554aebfbf36682"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga75d73f827d48cf0ff2554aebfbf36682">&#9670;&#160;</a></span>arePointsCoplanar()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Point3Concept PointType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Box.html">bool</a> vcl::arePointsCoplanar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">const</a> PointType &amp;&#160;</td>
          <td class="paramname"><em>p0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">const</a> PointType &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">const</a> PointType &amp;&#160;</td>
          <td class="paramname"><em>p2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">const</a> PointType &amp;&#160;</td>
          <td class="paramname"><em>p3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if 4 points are coplanar. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">PointType</td><td>The type of the points. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p0</td><td>First point to test. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p1</td><td>Second point to test. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p2</td><td>Third point to test. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p3</td><td>Fourth point to test. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the points are coplanar, false otherwise. </dd></dl>

</div>
</div>
<a id="ga3e71eff214deaf0c9f9e33f828326a89" name="ga3e71eff214deaf0c9f9e33f828326a89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3e71eff214deaf0c9f9e33f828326a89">&#9670;&#160;</a></span>facePointVisibility()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceConcept FaceType, Point3Concept PointType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Box.html">bool</a> vcl::facePointVisibility </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">const</a> FaceType &amp;&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">const</a> PointType &amp;&#160;</td>
          <td class="paramname"><em>point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if a point is visible from a face, i.e., if the point is in the half-space defined by the face. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FaceType</td><td>The type of the face. </td></tr>
    <tr><td class="paramname">PointType</td><td>The type of the point. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">face</td><td>The input face. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">point</td><td>The point to test. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the point is visible from the face, false otherwise. </dd></dl>

</div>
</div>
<a id="ga258c61f730c08e6d3cfc4f6c93af1588" name="ga258c61f730c08e6d3cfc4f6c93af1588"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga258c61f730c08e6d3cfc4f6c93af1588">&#9670;&#160;</a></span>halfSpaceDeterminant() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceConcept FaceType, Point3Concept PointType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Box.html">auto</a> vcl::halfSpaceDeterminant </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">const</a> FaceType &amp;&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">const</a> PointType &amp;&#160;</td>
          <td class="paramname"><em>point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the determinant of the half-space defined by the triangle and the point. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FaceType</td><td>The type of the face that defines the half-space. </td></tr>
    <tr><td class="paramname">PointType</td><td>The type of the point to test.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">face</td><td>The face that defines the half-space. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">point</td><td>The point to test. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The determinant of the half-space. </dd></dl>

</div>
</div>
<a id="ga394b096177019cfacda94eb16ae1fdc2" name="ga394b096177019cfacda94eb16ae1fdc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga394b096177019cfacda94eb16ae1fdc2">&#9670;&#160;</a></span>halfSpaceDeterminant() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Point3Concept PointType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Box.html">auto</a> vcl::halfSpaceDeterminant </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">const</a> PointType &amp;&#160;</td>
          <td class="paramname"><em>p0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">const</a> PointType &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">const</a> PointType &amp;&#160;</td>
          <td class="paramname"><em>p2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">const</a> PointType &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the determinant of the half-space defined by the triangle (p1, p2, p3) and the point p. </p>
<p>The triangle is defined by the points p1, p2, and p3, ordered in a counter-clockwise manner.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">PointType</td><td>The type of the points. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p0</td><td>The first point of the triangle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p1</td><td>The second point of the triangle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p2</td><td>The third point of the triangle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>The point to test. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The determinant of the half-space. </dd></dl>

</div>
</div>
<a id="ga5973cf28c34d62dc9e4364ee8c19f41a" name="ga5973cf28c34d62dc9e4364ee8c19f41a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5973cf28c34d62dc9e4364ee8c19f41a">&#9670;&#160;</a></span>halfSpaceDeterminant() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Triangle3Concept TriangleType, Point3Concept PointType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Box.html">auto</a> vcl::halfSpaceDeterminant </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">const</a> <a class="el" href="classvcl_1_1Box.html">TriangleType</a> &amp;&#160;</td>
          <td class="paramname"><em>triangle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">const</a> PointType &amp;&#160;</td>
          <td class="paramname"><em>point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the determinant of the half-space defined by the triangle and the point. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TriangleType</td><td>The type of the triangle that defines the half-space. </td></tr>
    <tr><td class="paramname">PointType</td><td>The type of the point to test.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">triangle</td><td>The triangle that defines the half-space. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>The point to test. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The determinant of the half-space. </dd></dl>

</div>
</div>
<a id="ga212c052ae1efd3426a5ea49051f8011c" name="ga212c052ae1efd3426a5ea49051f8011c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga212c052ae1efd3426a5ea49051f8011c">&#9670;&#160;</a></span>poissonRandomNumber()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Box.html">int</a> vcl::poissonRandomNumber </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">double</a>&#160;</td>
          <td class="paramname"><em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::mt19937 &amp;&#160;</td>
          <td class="paramname"><em>gen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>algorithm poisson random number (Knuth): init: Let L ← e^−λ, k ← 0 and p ← 1. do: k ← k + 1. Generate uniform random number u in [0,1] and let p ← p × u. while p &gt; L. return k − 1. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lambda</td><td></td></tr>
    <tr><td class="paramname">gen</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="ga1928216d4ca321551feca3fc03054e03" name="ga1928216d4ca321551feca3fc03054e03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1928216d4ca321551feca3fc03054e03">&#9670;&#160;</a></span>randomTriangleBarycentricCoordinate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Point3Concept PointType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">PointType vcl::randomTriangleBarycentricCoordinate </td>
          <td>(</td>
          <td class="paramtype">std::mt19937 &amp;&#160;</td>
          <td class="paramname"><em>gen</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate the barycentric coords of a random point over a triangle, with a uniform distribution over the triangle. It uses the parallelogram folding trick. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gen</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="ga5396bbb99432d258d9330d681f1461db" name="ga5396bbb99432d258d9330d681f1461db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5396bbb99432d258d9330d681f1461db">&#9670;&#160;</a></span>removeScalingFromMatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Matrix33Or44Concept MatrixType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">MatrixType vcl::removeScalingFromMatrix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">const</a> MatrixType &amp;&#160;</td>
          <td class="paramname"><em>matrix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a matrix with the scaling factors removed. </p>
<p>The input matrix is expected to be a 3x3 or 4x4 matrix, and the function removes the scaling factors from the first three rows (or columns) of the matrix. The scaling factors are computed as the Euclidean norm of the first three rows of the matrix. The resulting matrix will have the same orientation as the input matrix, but without scaling.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">matrix</td><td>The input matrix from which the scaling factors will be removed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A matrix of the same type as the input matrix, but with the scaling factors removed. </dd></dl>

</div>
</div>
<a id="ga0826e434e7d549a512181349756bbe21" name="ga0826e434e7d549a512181349756bbe21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0826e434e7d549a512181349756bbe21">&#9670;&#160;</a></span>removeScalingFromMatrixInPlace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Matrix33Or44Concept MatrixType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Box.html">void</a> vcl::removeScalingFromMatrixInPlace </td>
          <td>(</td>
          <td class="paramtype">MatrixType &amp;&#160;</td>
          <td class="paramname"><em>matrix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the scaling factors from the matrix in place. </p>
<p>The input matrix is expected to be a 3x3 or 4x4 matrix, and the function removes the scaling factors from the first three rows (or columns) of the matrix. The scaling factors are computed as the Euclidean norm of the first three rows of the matrix. The resulting matrix will have the same orientation as the input matrix, but without scaling.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">[in/out]</td><td>matrix: The input matrix from which the scaling factors will be removed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaefa0051d67bdf4a551140929a2cc0b2f" name="gaefa0051d67bdf4a551140929a2cc0b2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaefa0051d67bdf4a551140929a2cc0b2f">&#9670;&#160;</a></span>rotationMatrix() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MatrixConcept MatrixType, Point3Concept PointType, <a class="el" href="classvcl_1_1Box.html">typename</a> ScalarType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">MatrixType vcl::rotationMatrix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">const</a> PointType &amp;&#160;</td>
          <td class="paramname"><em>axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">const</a> ScalarType &amp;&#160;</td>
          <td class="paramname"><em>angleRad</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given an 3D axis and an angle expressed in radiants, returns a transform matrix that represents the rotation matrix of the given axis/angle. </p>
<p>The MatrixType must be at least a 3x3 matrix having the setIdentity() member function. If the matrix is a higher than 3x3 (e.g. 4x4), only the 3x3 submatrix will be set, leaving the identity values in the other cells of the matrix.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">axis</td><td></td></tr>
    <tr><td class="paramname">angleRad</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="ga4870ee93dae22bb750da059cefa6d9f2" name="ga4870ee93dae22bb750da059cefa6d9f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4870ee93dae22bb750da059cefa6d9f2">&#9670;&#160;</a></span>rotationMatrix() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MatrixConcept MatrixType, Point3Concept PointType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">MatrixType vcl::rotationMatrix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">const</a> PointType &amp;&#160;</td>
          <td class="paramname"><em>fromVector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">const</a> PointType &amp;&#160;</td>
          <td class="paramname"><em>toVector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given two 3D vectors, returns a transform matrix that represents the rotation matrix from the first vector to the second vector. </p>
<p>The MatrixType must be at least a 3x3 matrix having the setIdentity() member function. If the matrix is a higher than 3x3 (e.g. 4x4), only the 3x3 submatrix will be set, leaving the identity values in the other cells of the matrix.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fromVector</td><td></td></tr>
    <tr><td class="paramname">toVector</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="ga7f6b127154a5e14946cb66492d214de8" name="ga7f6b127154a5e14946cb66492d214de8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7f6b127154a5e14946cb66492d214de8">&#9670;&#160;</a></span>rotationMatrixDeg()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MatrixConcept MatrixType, Point3Concept PointType, <a class="el" href="classvcl_1_1Box.html">typename</a> ScalarType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">MatrixType vcl::rotationMatrixDeg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">const</a> PointType &amp;&#160;</td>
          <td class="paramname"><em>axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">const</a> ScalarType &amp;&#160;</td>
          <td class="paramname"><em>angleDeg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given an 3D axis and an angle expressed in degrees, fills the given matrix with a transform matrix that represents the rotation matrix of the given axis/angle. </p>
<p>The MatrixType must be at least a 3x3 matrix having the setIdentity() member function. If the matrix is a higher than 3x3 (e.g. 4x4), only the 3x3 submatrix will be set, leaving the identity values in the other cells of the matrix.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">axis</td><td></td></tr>
    <tr><td class="paramname">angleDeg</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="gaeae3bed7ce8fef5657452d857cf87bed" name="gaeae3bed7ce8fef5657452d857cf87bed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeae3bed7ce8fef5657452d857cf87bed">&#9670;&#160;</a></span>setTransformMatrixRotation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MatrixConcept MatrixType, Point3Concept PointType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Box.html">void</a> vcl::setTransformMatrixRotation </td>
          <td>(</td>
          <td class="paramtype">MatrixType &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">const</a> PointType &amp;&#160;</td>
          <td class="paramname"><em>fromVector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">const</a> PointType &amp;&#160;</td>
          <td class="paramname"><em>toVector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given two 3D vectors, fills the given matrix with a transform matrix that represents the rotation matrix from the first vector to the second vector. </p>
<p>The given matrix must be at least a 3x3 matrix. If the matrix is a higher than 3x3 (e.g. 4x4), only the 3x3 submatrix will be set, leaving unchanged the other values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix</td><td></td></tr>
    <tr><td class="paramname">fromVector</td><td></td></tr>
    <tr><td class="paramname">toVector</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga24901186f1a77f31a23d64f30f0b0dc3" name="ga24901186f1a77f31a23d64f30f0b0dc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga24901186f1a77f31a23d64f30f0b0dc3">&#9670;&#160;</a></span>setTransformMatrixRotation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MatrixConcept MatrixType, Point3Concept PointType, <a class="el" href="classvcl_1_1Box.html">typename</a> ScalarType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Box.html">void</a> vcl::setTransformMatrixRotation </td>
          <td>(</td>
          <td class="paramtype">MatrixType &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PointType&#160;</td>
          <td class="paramname"><em>axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">const</a> ScalarType &amp;&#160;</td>
          <td class="paramname"><em>angleRad</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given an 3D axis and an angle expressed in radiants, fills the given matrix with a transform matrix that represents the rotation matrix of the given axis/angle. </p>
<p>The given matrix must be at least a 3x3 matrix. If the matrix is a higher than 3x3 (e.g. 4x4), only the 3x3 submatrix will be set, leaving unchanged the other values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix</td><td></td></tr>
    <tr><td class="paramname">axis</td><td></td></tr>
    <tr><td class="paramname">angleRad</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gabd5d95d87600e42a0da835735e35ea99" name="gabd5d95d87600e42a0da835735e35ea99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabd5d95d87600e42a0da835735e35ea99">&#9670;&#160;</a></span>setTransformMatrixRotationDeg()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MatrixConcept MatrixType, Point3Concept PointType, <a class="el" href="classvcl_1_1Box.html">typename</a> ScalarType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Box.html">void</a> vcl::setTransformMatrixRotationDeg </td>
          <td>(</td>
          <td class="paramtype">MatrixType &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PointType&#160;</td>
          <td class="paramname"><em>axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">const</a> ScalarType &amp;&#160;</td>
          <td class="paramname"><em>angleDeg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given an 3D axis and an angle expressed in degrees, fills the given matrix with a transform matrix that represents the rotation matrix of the given axis/angle. </p>
<p>The given matrix must be at least a 3x3 matrix. If the matrix is a higher than 3x3 (e.g. 4x4), only the 3x3 submatrix will be set, leaving unchanged the other values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix</td><td></td></tr>
    <tr><td class="paramname">axis</td><td></td></tr>
    <tr><td class="paramname">angleDeg</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga438da980623645640c78105766bde287" name="ga438da980623645640c78105766bde287"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga438da980623645640c78105766bde287">&#9670;&#160;</a></span>sphericalFibonacciPointSet()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Point3Concept PointType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; PointType &gt; vcl::sphericalFibonacciPointSet </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a vector of <code>n</code> points distributed in a unit sphere. </p>
<p>This function returns a vector of <code>n</code> points that are uniformly distributed on a unit sphere, using the Spherical Fibonacci <a class="el" href="classvcl_1_1Point.html" title="The Point class represents an N-dimensional point containing N scalar values.">Point</a> Sets algorithm described in the paper "Spherical Fibonacci Mapping" by Benjamin Keinert, Matthias Innmann, Michael Sanger, and Marc Stamminger (TOG 2015).</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">PointType</td><td>The type of the point to generate. This type must satisfy the <code>Point3Concept</code> concept.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>The number of points to generate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of <code>n</code> points distributed in a unit sphere. </dd></dl>

</div>
</div>
<a id="ga9928af42e442b4e28f3232f698a0912b" name="ga9928af42e442b4e28f3232f698a0912b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9928af42e442b4e28f3232f698a0912b">&#9670;&#160;</a></span>trianglePointVisibility() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Point3Concept PointType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Box.html">auto</a> vcl::trianglePointVisibility </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">const</a> PointType &amp;&#160;</td>
          <td class="paramname"><em>p0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">const</a> PointType &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">const</a> PointType &amp;&#160;</td>
          <td class="paramname"><em>p2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">const</a> PointType &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if a point is visible from a triangle, i.e., if the point is in the half-space defined by the triangle. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">PointType</td><td>The type of the points. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p0</td><td>The first point of the triangle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p1</td><td>The second point of the triangle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p2</td><td>The third point of the triangle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>The point to test. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the point is visible from the triangle, false otherwise. </dd></dl>

</div>
</div>
<a id="gacd3fb0fe60790cd9aca934b9d3461f6a" name="gacd3fb0fe60790cd9aca934b9d3461f6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacd3fb0fe60790cd9aca934b9d3461f6a">&#9670;&#160;</a></span>trianglePointVisibility() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Triangle3Concept TriangleType, Point3Concept PointType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Box.html">bool</a> vcl::trianglePointVisibility </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">const</a> <a class="el" href="classvcl_1_1Box.html">TriangleType</a> &amp;&#160;</td>
          <td class="paramname"><em>triangle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">const</a> PointType &amp;&#160;</td>
          <td class="paramname"><em>point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if a point is visible from a triangle, i.e., if the point is in the half-space defined by the triangle. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TriangleType</td><td>The type of the triangle. </td></tr>
    <tr><td class="paramname">PointType</td><td>The type of the point. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">triangle</td><td>The input triangle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">point</td><td>The point to test. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the point is visible from the triangle, false otherwise. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
