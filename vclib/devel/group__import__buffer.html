<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Visual Computing Library: Import Mesh from Buffer Algorithms</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript" src="../version-selector.js"></script>
       <script type="text/javascript">
           DoxygenAwesomeDarkModeToggle.init()
       </script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Visual Computing Library
   &#160;<span id="projectnumber">devel</span>
   </div>
   <!-- Version selector dropdown -->
   <div id="version-selector" style="margin-top: 10px;">
     <label for="version-dropdown" style="font-size: 12px; color: #666;">Version:</label>
     <select id="version-dropdown" style="margin-left: 5px; padding: 2px 5px; font-size: 12px; border: 1px solid #ccc; border-radius: 3px;">
       <option value="">Loading versions...</option>
     </select>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group__import__buffer.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Import Mesh from Buffer Algorithms<div class="ingroups"><a class="el" href="group__algorithms__mesh.html">Mesh Algorithms</a> &raquo; <a class="el" href="group__import__export.html">Import/Export Mesh Algorithms</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>List Import Mesh from Buffer algorithms.  
<a href="#details">More...</a></p>
<div class="dynheader">
Collaboration diagram for Import Mesh from Buffer Algorithms:</div>
<div class="dyncontent">
<div class="center"><img src="group__import__buffer.png" border="0" usemap="#agroup____import____buffer" alt=""/></div>
<map name="agroup____import____buffer" id="agroup____import____buffer">
<area shape="rect" title="List Import Mesh from Buffer algorithms." alt="" coords="204,5,387,45"/>
<area shape="rect" href="group__import__export.html" title="List of Import/Export Mesh algorithms." alt="" coords="5,5,156,45"/>
</map>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga7b35ddf19791d3b9fd05b21b75b0b90a" id="r_ga7b35ddf19791d3b9fd05b21b75b0b90a"><td class="memTemplParams" colspan="2">template&lt;EdgeMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga7b35ddf19791d3b9fd05b21b75b0b90a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Box.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__import__buffer.html#ga7b35ddf19791d3b9fd05b21b75b0b90a">vcl::edgeColorsFromBuffer</a> (MeshType &amp;mesh, <a class="el" href="classvcl_1_1Box.html">const</a> <a class="el" href="classvcl_1_1Box.html">auto</a> *buffer, <a class="el" href="classvcl_1_1Color.html#a51d1c2a5b8ce06d43362026194a14523">Color::Format</a> <a class="el" href="classvcl_1_1Box.html">colorFormat</a>)</td></tr>
<tr class="memdesc:ga7b35ddf19791d3b9fd05b21b75b0b90a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the edge color of the given input <code>mesh</code> from the input buffer, that is expected to be a contiguous array of #V 32 bit values, on each of them the color is packed using the provided <code>colorFormat</code>.  <br /></td></tr>
<tr class="separator:ga7b35ddf19791d3b9fd05b21b75b0b90a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga53132440b8f04c9c285b8f97135f7337" id="r_ga53132440b8f04c9c285b8f97135f7337"><td class="memTemplParams" colspan="2">template&lt;EdgeMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga53132440b8f04c9c285b8f97135f7337"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Box.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__import__buffer.html#ga53132440b8f04c9c285b8f97135f7337">vcl::edgeColorsFromBuffer</a> (MeshType &amp;mesh, <a class="el" href="classvcl_1_1Box.html">const</a> <a class="el" href="classvcl_1_1Box.html">auto</a> *buffer, uint <a class="el" href="classvcl_1_1Box.html">channelsNumber</a>=4, <a class="el" href="group__base.html#ga16a1bfbea022f6766d2f3ebbf69a3b52">MatrixStorageType</a> <a class="el" href="classvcl_1_1Box.html">storage</a>=MatrixStorageType::ROW_MAJOR, <a class="el" href="classvcl_1_1Color.html#a59da32385451a205500eea4432cc151d">Color::Representation</a> <a class="el" href="classvcl_1_1Box.html">representation</a>=Color::Representation::INT_0_255, uint <a class="el" href="classvcl_1_1Box.html">rowNumber</a>=<a class="el" href="group__base.html#ga9ad8104cd9ccfa9352d33bc7e6ba47e6">UINT_NULL</a>)</td></tr>
<tr class="memdesc:ga53132440b8f04c9c285b8f97135f7337"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the edge colors of the given input <code>mesh</code> from the input buffer, that is expected to be a contiguous array of #E*3 or #E*4 scalars, where each row contains the 3 or 4 components of the color of a edge.  <br /></td></tr>
<tr class="separator:ga53132440b8f04c9c285b8f97135f7337"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf02ce4aeaaa338827ee590ffe4ef2829" id="r_gaf02ce4aeaaa338827ee590ffe4ef2829"><td class="memTemplParams" colspan="2">template&lt;EdgeMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:gaf02ce4aeaaa338827ee590ffe4ef2829"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Box.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__import__buffer.html#gaf02ce4aeaaa338827ee590ffe4ef2829">vcl::edgeIndicesFromBuffer</a> (MeshType &amp;mesh, <a class="el" href="classvcl_1_1Box.html">const</a> <a class="el" href="classvcl_1_1Box.html">auto</a> *buffer, uint edgeNumber, <a class="el" href="classvcl_1_1Box.html">bool</a> <a class="el" href="classvcl_1_1Box.html">clearBeforeSet</a>=<a class="el" href="classvcl_1_1Box.html">true</a>, <a class="el" href="group__base.html#ga16a1bfbea022f6766d2f3ebbf69a3b52">MatrixStorageType</a> <a class="el" href="classvcl_1_1Box.html">storage</a>=MatrixStorageType::ROW_MAJOR, uint <a class="el" href="classvcl_1_1Box.html">rowNumber</a>=<a class="el" href="group__base.html#ga9ad8104cd9ccfa9352d33bc7e6ba47e6">UINT_NULL</a>)</td></tr>
<tr class="memdesc:gaf02ce4aeaaa338827ee590ffe4ef2829"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the edge indices of the given input <code>mesh</code> from the input edge buffer, that is expected to be a contiguous array of integers, where each row contains the indices of the vertices of an edge.  <br /></td></tr>
<tr class="separator:gaf02ce4aeaaa338827ee590ffe4ef2829"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e10878efbc5f9fe15207a17b092a773" id="r_ga1e10878efbc5f9fe15207a17b092a773"><td class="memTemplParams" colspan="2">template&lt;EdgeMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga1e10878efbc5f9fe15207a17b092a773"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Box.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__import__buffer.html#ga1e10878efbc5f9fe15207a17b092a773">vcl::edgeNormalsFromBuffer</a> (MeshType &amp;mesh, <a class="el" href="classvcl_1_1Box.html">const</a> <a class="el" href="classvcl_1_1Box.html">auto</a> *buffer, <a class="el" href="group__base.html#ga16a1bfbea022f6766d2f3ebbf69a3b52">MatrixStorageType</a> <a class="el" href="classvcl_1_1Box.html">storage</a>=MatrixStorageType::ROW_MAJOR, uint <a class="el" href="classvcl_1_1Box.html">rowNumber</a>=<a class="el" href="group__base.html#ga9ad8104cd9ccfa9352d33bc7e6ba47e6">UINT_NULL</a>)</td></tr>
<tr class="memdesc:ga1e10878efbc5f9fe15207a17b092a773"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the edge normals of the given input <code>mesh</code> from the input buffer, that is expected to be a contiguous array of #F*3 scalars, where each row contains the 3 components of the normal of a edge.  <br /></td></tr>
<tr class="separator:ga1e10878efbc5f9fe15207a17b092a773"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf2b80a8836ca4e40ca975db183d37563" id="r_gaf2b80a8836ca4e40ca975db183d37563"><td class="memTemplParams" colspan="2">template&lt;EdgeMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:gaf2b80a8836ca4e40ca975db183d37563"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Box.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__import__buffer.html#gaf2b80a8836ca4e40ca975db183d37563">vcl::edgeQualityFromBuffer</a> (MeshType &amp;mesh, <a class="el" href="classvcl_1_1Box.html">const</a> <a class="el" href="classvcl_1_1Box.html">auto</a> *buffer)</td></tr>
<tr class="memdesc:gaf2b80a8836ca4e40ca975db183d37563"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the edge quality of the given input <code>mesh</code> from the input quality buffer, that is expected to be a contiguous array of #F scalars, where each value contains the quality of a edge.  <br /></td></tr>
<tr class="separator:gaf2b80a8836ca4e40ca975db183d37563"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga47545e45d1d7f9c23d66962974c5ab0b" id="r_ga47545e45d1d7f9c23d66962974c5ab0b"><td class="memTemplParams" colspan="2">template&lt;EdgeMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga47545e45d1d7f9c23d66962974c5ab0b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Box.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__import__buffer.html#ga47545e45d1d7f9c23d66962974c5ab0b">vcl::edgeSelectionFromBuffer</a> (MeshType &amp;mesh, <a class="el" href="classvcl_1_1Box.html">const</a> <a class="el" href="classvcl_1_1Box.html">auto</a> *buffer)</td></tr>
<tr class="memdesc:ga47545e45d1d7f9c23d66962974c5ab0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the edge selection of the given input <code>mesh</code> from the input selection buffer.  <br /></td></tr>
<tr class="separator:ga47545e45d1d7f9c23d66962974c5ab0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga97985c42ad0751ad3df4c9b78c825e36" id="r_ga97985c42ad0751ad3df4c9b78c825e36"><td class="memTemplParams" colspan="2">template&lt;uint ELEM_ID, MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga97985c42ad0751ad3df4c9b78c825e36"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Box.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__import__buffer.html#ga97985c42ad0751ad3df4c9b78c825e36">vcl::elementColorsFromBuffer</a> (MeshType &amp;mesh, <a class="el" href="classvcl_1_1Box.html">const</a> <a class="el" href="classvcl_1_1Box.html">auto</a> *buffer, <a class="el" href="classvcl_1_1Color.html#a51d1c2a5b8ce06d43362026194a14523">Color::Format</a> <a class="el" href="classvcl_1_1Box.html">colorFormat</a>)</td></tr>
<tr class="memdesc:ga97985c42ad0751ad3df4c9b78c825e36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the element identified by <code>ELEM_ID</code> color of the given input <code>mesh</code> from the input buffer, that is expected to be a contiguous array of #E 32 bit values, on each of them the color is packed using the provided <code>colorFormat</code>.  <br /></td></tr>
<tr class="separator:ga97985c42ad0751ad3df4c9b78c825e36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f9f7a1f29c6ed8d9718979ad35ebe33" id="r_ga1f9f7a1f29c6ed8d9718979ad35ebe33"><td class="memTemplParams" colspan="2">template&lt;uint ELEM_ID, MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga1f9f7a1f29c6ed8d9718979ad35ebe33"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Box.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__import__buffer.html#ga1f9f7a1f29c6ed8d9718979ad35ebe33">vcl::elementColorsFromBuffer</a> (MeshType &amp;mesh, <a class="el" href="classvcl_1_1Box.html">const</a> <a class="el" href="classvcl_1_1Box.html">auto</a> *buffer, uint <a class="el" href="classvcl_1_1Box.html">channelsNumber</a>=4, <a class="el" href="group__base.html#ga16a1bfbea022f6766d2f3ebbf69a3b52">MatrixStorageType</a> <a class="el" href="classvcl_1_1Box.html">storage</a>=MatrixStorageType::ROW_MAJOR, <a class="el" href="classvcl_1_1Color.html#a59da32385451a205500eea4432cc151d">Color::Representation</a> <a class="el" href="classvcl_1_1Box.html">representation</a>=Color::Representation::INT_0_255, uint <a class="el" href="classvcl_1_1Box.html">rowNumber</a>=<a class="el" href="group__base.html#ga9ad8104cd9ccfa9352d33bc7e6ba47e6">UINT_NULL</a>)</td></tr>
<tr class="memdesc:ga1f9f7a1f29c6ed8d9718979ad35ebe33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the element identified by <code>ELEM_ID</code> colors of the given input <code>mesh</code> from the input buffer, that is expected to be a contiguous array of #E*3 or #E*4 scalars, where each row contains the 3 or 4 components of the color of a element.  <br /></td></tr>
<tr class="separator:ga1f9f7a1f29c6ed8d9718979ad35ebe33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98023703048ddaf6cf9ff4e400e98fa5" id="r_ga98023703048ddaf6cf9ff4e400e98fa5"><td class="memTemplParams" colspan="2">template&lt;uint ELEM_ID, MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga98023703048ddaf6cf9ff4e400e98fa5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Box.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__import__buffer.html#ga98023703048ddaf6cf9ff4e400e98fa5">vcl::elementNormalsFromBuffer</a> (MeshType &amp;mesh, <a class="el" href="classvcl_1_1Box.html">const</a> <a class="el" href="classvcl_1_1Box.html">auto</a> *buffer, <a class="el" href="group__base.html#ga16a1bfbea022f6766d2f3ebbf69a3b52">MatrixStorageType</a> <a class="el" href="classvcl_1_1Box.html">storage</a>=MatrixStorageType::ROW_MAJOR, uint <a class="el" href="classvcl_1_1Box.html">rowNumber</a>=<a class="el" href="group__base.html#ga9ad8104cd9ccfa9352d33bc7e6ba47e6">UINT_NULL</a>)</td></tr>
<tr class="memdesc:ga98023703048ddaf6cf9ff4e400e98fa5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the element identified by <code>ELEM_ID</code> normals of the given input <code>mesh</code> from the input buffer, that is expected to be a contiguous array of #E*3 scalars, where each row contains the 3 components of the normal of a element.  <br /></td></tr>
<tr class="separator:ga98023703048ddaf6cf9ff4e400e98fa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga066abc59fbb69b1f8f7693ae0167ef70" id="r_ga066abc59fbb69b1f8f7693ae0167ef70"><td class="memTemplParams" colspan="2">template&lt;uint ELEM_ID, MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga066abc59fbb69b1f8f7693ae0167ef70"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Box.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__import__buffer.html#ga066abc59fbb69b1f8f7693ae0167ef70">vcl::elementQualityFromBuffer</a> (MeshType &amp;mesh, <a class="el" href="classvcl_1_1Box.html">const</a> <a class="el" href="classvcl_1_1Box.html">auto</a> *buffer)</td></tr>
<tr class="memdesc:ga066abc59fbb69b1f8f7693ae0167ef70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the element identified by <code>ELEM_ID</code> quality of the given input <code>mesh</code> from the input quality buffer, that is expected to be a contiguous array of #E scalars, where each value contains the quality of a element.  <br /></td></tr>
<tr class="separator:ga066abc59fbb69b1f8f7693ae0167ef70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c50290c0dd5a1b6b30d1dd1ba0ab667" id="r_ga2c50290c0dd5a1b6b30d1dd1ba0ab667"><td class="memTemplParams" colspan="2">template&lt;uint ELEM_ID, MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga2c50290c0dd5a1b6b30d1dd1ba0ab667"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Box.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__import__buffer.html#ga2c50290c0dd5a1b6b30d1dd1ba0ab667">vcl::elementSelectionFromBuffer</a> (MeshType &amp;mesh, <a class="el" href="classvcl_1_1Box.html">const</a> <a class="el" href="classvcl_1_1Box.html">auto</a> *buffer)</td></tr>
<tr class="memdesc:ga2c50290c0dd5a1b6b30d1dd1ba0ab667"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the element identified by <code>ELEM_ID</code> selection of the given input <code>mesh</code> from the input selection buffer.  <br /></td></tr>
<tr class="separator:ga2c50290c0dd5a1b6b30d1dd1ba0ab667"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6e03f1181725a88e85f29302f71dcf1" id="r_gac6e03f1181725a88e85f29302f71dcf1"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:gac6e03f1181725a88e85f29302f71dcf1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Box.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__import__buffer.html#gac6e03f1181725a88e85f29302f71dcf1">vcl::faceColorsFromBuffer</a> (MeshType &amp;mesh, <a class="el" href="classvcl_1_1Box.html">const</a> <a class="el" href="classvcl_1_1Box.html">auto</a> *buffer, <a class="el" href="classvcl_1_1Color.html#a51d1c2a5b8ce06d43362026194a14523">Color::Format</a> <a class="el" href="classvcl_1_1Box.html">colorFormat</a>)</td></tr>
<tr class="memdesc:gac6e03f1181725a88e85f29302f71dcf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the face color of the given input <code>mesh</code> from the input buffer, that is expected to be a contiguous array of #V 32 bit values, on each of them the color is packed using the provided <code>colorFormat</code>.  <br /></td></tr>
<tr class="separator:gac6e03f1181725a88e85f29302f71dcf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga43925141dcfd3a9cc84ac72d858c1160" id="r_ga43925141dcfd3a9cc84ac72d858c1160"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga43925141dcfd3a9cc84ac72d858c1160"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Box.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__import__buffer.html#ga43925141dcfd3a9cc84ac72d858c1160">vcl::faceColorsFromBuffer</a> (MeshType &amp;mesh, <a class="el" href="classvcl_1_1Box.html">const</a> <a class="el" href="classvcl_1_1Box.html">auto</a> *buffer, uint <a class="el" href="classvcl_1_1Box.html">channelsNumber</a>=4, <a class="el" href="group__base.html#ga16a1bfbea022f6766d2f3ebbf69a3b52">MatrixStorageType</a> <a class="el" href="classvcl_1_1Box.html">storage</a>=MatrixStorageType::ROW_MAJOR, <a class="el" href="classvcl_1_1Color.html#a59da32385451a205500eea4432cc151d">Color::Representation</a> <a class="el" href="classvcl_1_1Box.html">representation</a>=Color::Representation::INT_0_255, uint <a class="el" href="classvcl_1_1Box.html">rowNumber</a>=<a class="el" href="group__base.html#ga9ad8104cd9ccfa9352d33bc7e6ba47e6">UINT_NULL</a>)</td></tr>
<tr class="memdesc:ga43925141dcfd3a9cc84ac72d858c1160"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the face colors of the given input <code>mesh</code> from the input buffer, that is expected to be a contiguous array of #F*3 or #F*4 scalars, where each row contains the 3 or 4 components of the color of a face.  <br /></td></tr>
<tr class="separator:ga43925141dcfd3a9cc84ac72d858c1160"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ecb65b37674a06f91e8a400886a3196" id="r_ga2ecb65b37674a06f91e8a400886a3196"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga2ecb65b37674a06f91e8a400886a3196"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Box.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__import__buffer.html#ga2ecb65b37674a06f91e8a400886a3196">vcl::faceIndicesFromBuffer</a> (MeshType &amp;mesh, <a class="el" href="classvcl_1_1Box.html">const</a> <a class="el" href="classvcl_1_1Box.html">auto</a> *buffer, uint faceNumber, uint <a class="el" href="classvcl_1_1Box.html">faceSize</a>=3, <a class="el" href="classvcl_1_1Box.html">bool</a> <a class="el" href="classvcl_1_1Box.html">clearBeforeSet</a>=<a class="el" href="classvcl_1_1Box.html">true</a>, <a class="el" href="group__base.html#ga16a1bfbea022f6766d2f3ebbf69a3b52">MatrixStorageType</a> <a class="el" href="classvcl_1_1Box.html">storage</a>=MatrixStorageType::ROW_MAJOR, uint <a class="el" href="classvcl_1_1Box.html">rowNumber</a>=<a class="el" href="group__base.html#ga9ad8104cd9ccfa9352d33bc7e6ba47e6">UINT_NULL</a>)</td></tr>
<tr class="memdesc:ga2ecb65b37674a06f91e8a400886a3196"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the face indices of the given input <code>mesh</code> from the input face buffer, that is expected to be a contiguous array of integers, where each row contains the indices of the vertices of a face.  <br /></td></tr>
<tr class="separator:ga2ecb65b37674a06f91e8a400886a3196"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabacbd0bce72d074cecd737c2765b470c" id="r_gabacbd0bce72d074cecd737c2765b470c"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:gabacbd0bce72d074cecd737c2765b470c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Box.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__import__buffer.html#gabacbd0bce72d074cecd737c2765b470c">vcl::faceMaterialIndicesFromBuffer</a> (MeshType &amp;mesh, <a class="el" href="classvcl_1_1Box.html">const</a> <a class="el" href="classvcl_1_1Box.html">auto</a> *buffer)</td></tr>
<tr class="memdesc:gabacbd0bce72d074cecd737c2765b470c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the face material indices of the given input <code>mesh</code> from the input material indices buffer, that is expected to be a contiguous array of #F scalars, where each value contains the material index of a face.  <br /></td></tr>
<tr class="separator:gabacbd0bce72d074cecd737c2765b470c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca1a90ce610b7aabfa5583445b703b7d" id="r_gaca1a90ce610b7aabfa5583445b703b7d"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:gaca1a90ce610b7aabfa5583445b703b7d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Box.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__import__buffer.html#gaca1a90ce610b7aabfa5583445b703b7d">vcl::faceNormalsFromBuffer</a> (MeshType &amp;mesh, <a class="el" href="classvcl_1_1Box.html">const</a> <a class="el" href="classvcl_1_1Box.html">auto</a> *buffer, <a class="el" href="group__base.html#ga16a1bfbea022f6766d2f3ebbf69a3b52">MatrixStorageType</a> <a class="el" href="classvcl_1_1Box.html">storage</a>=MatrixStorageType::ROW_MAJOR, uint <a class="el" href="classvcl_1_1Box.html">rowNumber</a>=<a class="el" href="group__base.html#ga9ad8104cd9ccfa9352d33bc7e6ba47e6">UINT_NULL</a>)</td></tr>
<tr class="memdesc:gaca1a90ce610b7aabfa5583445b703b7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the face normals of the given input <code>mesh</code> from the input buffer, that is expected to be a contiguous array of #F*3 scalars, where each row contains the 3 components of the normal of a face.  <br /></td></tr>
<tr class="separator:gaca1a90ce610b7aabfa5583445b703b7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca660c8d8eea285e60154499e612253e" id="r_gaca660c8d8eea285e60154499e612253e"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:gaca660c8d8eea285e60154499e612253e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Box.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__import__buffer.html#gaca660c8d8eea285e60154499e612253e">vcl::faceQualityFromBuffer</a> (MeshType &amp;mesh, <a class="el" href="classvcl_1_1Box.html">const</a> <a class="el" href="classvcl_1_1Box.html">auto</a> *buffer)</td></tr>
<tr class="memdesc:gaca660c8d8eea285e60154499e612253e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the face quality of the given input <code>mesh</code> from the input quality buffer, that is expected to be a contiguous array of #F scalars, where each value contains the quality of a face.  <br /></td></tr>
<tr class="separator:gaca660c8d8eea285e60154499e612253e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga770fb5e2027c364d3c7fa9452b4454fe" id="r_ga770fb5e2027c364d3c7fa9452b4454fe"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga770fb5e2027c364d3c7fa9452b4454fe"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Box.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__import__buffer.html#ga770fb5e2027c364d3c7fa9452b4454fe">vcl::faceSelectionFromBuffer</a> (MeshType &amp;mesh, <a class="el" href="classvcl_1_1Box.html">const</a> <a class="el" href="classvcl_1_1Box.html">auto</a> *buffer)</td></tr>
<tr class="memdesc:ga770fb5e2027c364d3c7fa9452b4454fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the face selection of the given input <code>mesh</code> from the input selection buffer.  <br /></td></tr>
<tr class="separator:ga770fb5e2027c364d3c7fa9452b4454fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa43a6b07901772a4d4b29b886b04794e" id="r_gaa43a6b07901772a4d4b29b886b04794e"><td class="memTemplParams" colspan="2">template&lt;FaceMeshConcept MeshType&gt; </td></tr>
<tr class="memitem:gaa43a6b07901772a4d4b29b886b04794e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Box.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__import__buffer.html#gaa43a6b07901772a4d4b29b886b04794e">vcl::faceWedgeTexCoordsFromBuffer</a> (MeshType &amp;mesh, <a class="el" href="classvcl_1_1Box.html">const</a> <a class="el" href="classvcl_1_1Box.html">auto</a> *buffer, uint <a class="el" href="group__mesh__stat.html#gad5656feacf649e99e4d3113855f20249">largestFaceSize</a>=3, <a class="el" href="group__base.html#ga16a1bfbea022f6766d2f3ebbf69a3b52">MatrixStorageType</a> <a class="el" href="classvcl_1_1Box.html">storage</a>=MatrixStorageType::ROW_MAJOR, uint <a class="el" href="classvcl_1_1Box.html">rowNumber</a>=<a class="el" href="group__base.html#ga9ad8104cd9ccfa9352d33bc7e6ba47e6">UINT_NULL</a>)</td></tr>
<tr class="memdesc:gaa43a6b07901772a4d4b29b886b04794e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the face wedge texcoords of the given input <code>mesh</code> from the input buffer, that is expected to be a contiguous array of #F*(LFS*2) of scalars, where each row contains the 2*largetFaceSize components of the wedge texture coordinates of a face.  <br /></td></tr>
<tr class="separator:gaa43a6b07901772a4d4b29b886b04794e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf24242de72e08a3a0aab3b62a400389" id="r_gabf24242de72e08a3a0aab3b62a400389"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:gabf24242de72e08a3a0aab3b62a400389"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Box.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__import__buffer.html#gabf24242de72e08a3a0aab3b62a400389">vcl::vertexColorsFromBuffer</a> (MeshType &amp;mesh, <a class="el" href="classvcl_1_1Box.html">const</a> <a class="el" href="classvcl_1_1Box.html">auto</a> *buffer, <a class="el" href="classvcl_1_1Color.html#a51d1c2a5b8ce06d43362026194a14523">Color::Format</a> <a class="el" href="classvcl_1_1Box.html">colorFormat</a>)</td></tr>
<tr class="memdesc:gabf24242de72e08a3a0aab3b62a400389"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the vertex color of the given input <code>mesh</code> from the input buffer, that is expected to be a contiguous array of #V 32 bit values, on each of them the color is packed using the provided <code>colorFormat</code>.  <br /></td></tr>
<tr class="separator:gabf24242de72e08a3a0aab3b62a400389"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6aad391508301c6df48a1559a3d926f6" id="r_ga6aad391508301c6df48a1559a3d926f6"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga6aad391508301c6df48a1559a3d926f6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Box.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__import__buffer.html#ga6aad391508301c6df48a1559a3d926f6">vcl::vertexColorsFromBuffer</a> (MeshType &amp;mesh, <a class="el" href="classvcl_1_1Box.html">const</a> <a class="el" href="classvcl_1_1Box.html">auto</a> *buffer, uint <a class="el" href="classvcl_1_1Box.html">channelsNumber</a>=4, <a class="el" href="group__base.html#ga16a1bfbea022f6766d2f3ebbf69a3b52">MatrixStorageType</a> <a class="el" href="classvcl_1_1Box.html">storage</a>=MatrixStorageType::ROW_MAJOR, <a class="el" href="classvcl_1_1Color.html#a59da32385451a205500eea4432cc151d">Color::Representation</a> <a class="el" href="classvcl_1_1Box.html">representation</a>=Color::Representation::INT_0_255, uint <a class="el" href="classvcl_1_1Box.html">rowNumber</a>=<a class="el" href="group__base.html#ga9ad8104cd9ccfa9352d33bc7e6ba47e6">UINT_NULL</a>)</td></tr>
<tr class="memdesc:ga6aad391508301c6df48a1559a3d926f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the vertex colors of the given input <code>mesh</code> from the input buffer, that is expected to be a contiguous array of #V*3 or #V*4 scalars, where each row contains the 3 or 4 components of the color of a vertex.  <br /></td></tr>
<tr class="separator:ga6aad391508301c6df48a1559a3d926f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf22a4714e88fd07ab5ee01e8c28a7184" id="r_gaf22a4714e88fd07ab5ee01e8c28a7184"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:gaf22a4714e88fd07ab5ee01e8c28a7184"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Box.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__import__buffer.html#gaf22a4714e88fd07ab5ee01e8c28a7184">vcl::vertexMaterialIndicesFromBuffer</a> (MeshType &amp;mesh, <a class="el" href="classvcl_1_1Box.html">const</a> <a class="el" href="classvcl_1_1Box.html">auto</a> *buffer)</td></tr>
<tr class="memdesc:gaf22a4714e88fd07ab5ee01e8c28a7184"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the vertex material indices of the given input <code>mesh</code> from the input material indices buffer, that is expected to be a contiguous array of #V scalars, where each value contains the material index of a vertex.  <br /></td></tr>
<tr class="separator:gaf22a4714e88fd07ab5ee01e8c28a7184"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0db38d56675d73bd89e645f5e2762a91" id="r_ga0db38d56675d73bd89e645f5e2762a91"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga0db38d56675d73bd89e645f5e2762a91"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Box.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__import__buffer.html#ga0db38d56675d73bd89e645f5e2762a91">vcl::vertexNormalsFromBuffer</a> (MeshType &amp;mesh, <a class="el" href="classvcl_1_1Box.html">const</a> <a class="el" href="classvcl_1_1Box.html">auto</a> *buffer, <a class="el" href="group__base.html#ga16a1bfbea022f6766d2f3ebbf69a3b52">MatrixStorageType</a> <a class="el" href="classvcl_1_1Box.html">storage</a>=MatrixStorageType::ROW_MAJOR, uint <a class="el" href="classvcl_1_1Box.html">rowNumber</a>=<a class="el" href="group__base.html#ga9ad8104cd9ccfa9352d33bc7e6ba47e6">UINT_NULL</a>)</td></tr>
<tr class="memdesc:ga0db38d56675d73bd89e645f5e2762a91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the vertex normals of the given input <code>mesh</code> from the input buffer, that is expected to be a contiguous array of #V*3 scalars, where each row contains the 3 components of the normal of a vertex.  <br /></td></tr>
<tr class="separator:ga0db38d56675d73bd89e645f5e2762a91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga05514cd9aa236a5adacdfe65df5eba52" id="r_ga05514cd9aa236a5adacdfe65df5eba52"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:ga05514cd9aa236a5adacdfe65df5eba52"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Box.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__import__buffer.html#ga05514cd9aa236a5adacdfe65df5eba52">vcl::vertexPositionsFromBuffer</a> (MeshType &amp;mesh, <a class="el" href="classvcl_1_1Box.html">const</a> <a class="el" href="classvcl_1_1Box.html">auto</a> *buffer, uint vertexNumber, <a class="el" href="classvcl_1_1Box.html">bool</a> <a class="el" href="classvcl_1_1Box.html">clearBeforeSet</a>=<a class="el" href="classvcl_1_1Box.html">true</a>, <a class="el" href="group__base.html#ga16a1bfbea022f6766d2f3ebbf69a3b52">MatrixStorageType</a> <a class="el" href="classvcl_1_1Box.html">storage</a>=MatrixStorageType::ROW_MAJOR, uint <a class="el" href="classvcl_1_1Box.html">rowNumber</a>=<a class="el" href="group__base.html#ga9ad8104cd9ccfa9352d33bc7e6ba47e6">UINT_NULL</a>)</td></tr>
<tr class="memdesc:ga05514cd9aa236a5adacdfe65df5eba52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the vertex positions of the given input <code>mesh</code> from the input buffer, that is expected to be a contiguous array of scalars, where each row contains the 3 components of the position of a vertex.  <br /></td></tr>
<tr class="separator:ga05514cd9aa236a5adacdfe65df5eba52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4d70c32e7391a41b475e66ce4f45d05" id="r_gaa4d70c32e7391a41b475e66ce4f45d05"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:gaa4d70c32e7391a41b475e66ce4f45d05"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Box.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__import__buffer.html#gaa4d70c32e7391a41b475e66ce4f45d05">vcl::vertexQualityFromBuffer</a> (MeshType &amp;mesh, <a class="el" href="classvcl_1_1Box.html">const</a> <a class="el" href="classvcl_1_1Box.html">auto</a> *buffer)</td></tr>
<tr class="memdesc:gaa4d70c32e7391a41b475e66ce4f45d05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the vertex quality of the given input <code>mesh</code> from the input quality buffer, that is expected to be a contiguous array of #V scalars, where each value contains the quality of a vertex.  <br /></td></tr>
<tr class="separator:gaa4d70c32e7391a41b475e66ce4f45d05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb5d0f275cc31dbad272fb8c1e149133" id="r_gaeb5d0f275cc31dbad272fb8c1e149133"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:gaeb5d0f275cc31dbad272fb8c1e149133"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Box.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__import__buffer.html#gaeb5d0f275cc31dbad272fb8c1e149133">vcl::vertexSelectionFromBuffer</a> (MeshType &amp;mesh, <a class="el" href="classvcl_1_1Box.html">const</a> <a class="el" href="classvcl_1_1Box.html">auto</a> *buffer)</td></tr>
<tr class="memdesc:gaeb5d0f275cc31dbad272fb8c1e149133"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the vertex selection of the given input <code>mesh</code> from the input selection buffer.  <br /></td></tr>
<tr class="separator:gaeb5d0f275cc31dbad272fb8c1e149133"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae8db61d8cb9bceb77bef3556744455a" id="r_gaae8db61d8cb9bceb77bef3556744455a"><td class="memTemplParams" colspan="2">template&lt;MeshConcept MeshType&gt; </td></tr>
<tr class="memitem:gaae8db61d8cb9bceb77bef3556744455a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvcl_1_1Box.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__import__buffer.html#gaae8db61d8cb9bceb77bef3556744455a">vcl::vertexTexCoordsFromBuffer</a> (MeshType &amp;mesh, <a class="el" href="classvcl_1_1Box.html">const</a> <a class="el" href="classvcl_1_1Box.html">auto</a> *buffer, <a class="el" href="group__base.html#ga16a1bfbea022f6766d2f3ebbf69a3b52">MatrixStorageType</a> <a class="el" href="classvcl_1_1Box.html">storage</a>=MatrixStorageType::ROW_MAJOR, uint <a class="el" href="classvcl_1_1Box.html">rowNumber</a>=<a class="el" href="group__base.html#ga9ad8104cd9ccfa9352d33bc7e6ba47e6">UINT_NULL</a>)</td></tr>
<tr class="memdesc:gaae8db61d8cb9bceb77bef3556744455a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the vertex texcoords of the given input <code>mesh</code> from the input buffer, that is expected to be a contiguous array of #V*2 scalars, where each row contains the 2 components of the texture coordinates of a vertex.  <br /></td></tr>
<tr class="separator:gaae8db61d8cb9bceb77bef3556744455a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>List Import Mesh from Buffer algorithms. </p>
<p>They allow to import mesh data from buffers. </p>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga7b35ddf19791d3b9fd05b21b75b0b90a" name="ga7b35ddf19791d3b9fd05b21b75b0b90a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7b35ddf19791d3b9fd05b21b75b0b90a">&#9670;&#160;</a></span>edgeColorsFromBuffer() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;EdgeMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Box.html">void</a> vcl::edgeColorsFromBuffer </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">const</a> <a class="el" href="classvcl_1_1Box.html">auto</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Color.html#a51d1c2a5b8ce06d43362026194a14523">Color::Format</a>&#160;</td>
          <td class="paramname"><em>colorFormat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the edge color of the given input <code>mesh</code> from the input buffer, that is expected to be a contiguous array of #V 32 bit values, on each of them the color is packed using the provided <code>colorFormat</code>. </p>
<p>If not specified, the number of colors in the input buffer is assumed to be at least the number of edges of the mesh. The extra colors are ignored.</p>
<p>The function enables the per-edge color component if it is not already enabled.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MeshType</td><td>the type of the mesh to be filled. It must satisfy the MeshConcept. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">[in/out]</td><td>mesh: the mesh on which import the input edge color. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>the input edge color buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">colorFormat</td><td>the format used to pack the color in a single 32 bit value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga53132440b8f04c9c285b8f97135f7337" name="ga53132440b8f04c9c285b8f97135f7337"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga53132440b8f04c9c285b8f97135f7337">&#9670;&#160;</a></span>edgeColorsFromBuffer() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;EdgeMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Box.html">void</a> vcl::edgeColorsFromBuffer </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">const</a> <a class="el" href="classvcl_1_1Box.html">auto</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>channelsNumber</em> = <code>4</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__base.html#ga16a1bfbea022f6766d2f3ebbf69a3b52">MatrixStorageType</a>&#160;</td>
          <td class="paramname"><em>storage</em> = <code>MatrixStorageType::ROW_MAJOR</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Color.html#a59da32385451a205500eea4432cc151d">Color::Representation</a>&#160;</td>
          <td class="paramname"><em>representation</em> = <code>Color::Representation::INT_0_255</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>rowNumber</em> = <code><a class="el" href="group__base.html#ga9ad8104cd9ccfa9352d33bc7e6ba47e6">UINT_NULL</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the edge colors of the given input <code>mesh</code> from the input buffer, that is expected to be a contiguous array of #E*3 or #E*4 scalars, where each row contains the 3 or 4 components of the color of a edge. </p>
<p>If not specified, the number of colors in the input buffer is assumed to be at least the number of edges of the mesh. The extra colors are ignored.</p>
<p>Scalars can be either in the range [0,255] or in the range [0,1], as specified by the <code>representation</code> argument. The default is [0,255].</p>
<p>The number of channels can be either 3 (RGB) or 4 (RGBA), as specified by the <code>channelsNumber</code> argument. The default is 4.</p>
<p>The layout of the buffer can be either row-major or column-major, as specified by the <code>storage</code> argument. The default is row-major.</p>
<p>The function enables the per-edge color component if it is not already enabled.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MeshType</td><td>the type of the mesh to be filled. It must satisfy the EdgeMeshConcept. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">[in/out]</td><td>mesh: the mesh on which import the input edge colors. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>a contiguous array containing the colors of the elements of the mesh. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">channelsNumber</td><td>the number of channels per color in the input buffer. It can be either 3 (RGB) or 4 (RGBA). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">storage</td><td>the storage type of the input buffer. It can be either row-major or column-major. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">representation</td><td>the representation of the color scalars in the input buffer. It can be either in the range [0,255] or in the range [0,1]. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rowNumber</td><td>if the storage type is column-major, this parameter specifies the number of rows in the input buffer. If it is not specified (default), it is assumed to be equal to the number of edges of the mesh. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf02ce4aeaaa338827ee590ffe4ef2829" name="gaf02ce4aeaaa338827ee590ffe4ef2829"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf02ce4aeaaa338827ee590ffe4ef2829">&#9670;&#160;</a></span>edgeIndicesFromBuffer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;EdgeMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Box.html">void</a> vcl::edgeIndicesFromBuffer </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">const</a> <a class="el" href="classvcl_1_1Box.html">auto</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>edgeNumber</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">bool</a>&#160;</td>
          <td class="paramname"><em>clearBeforeSet</em> = <code><a class="el" href="classvcl_1_1Box.html">true</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__base.html#ga16a1bfbea022f6766d2f3ebbf69a3b52">MatrixStorageType</a>&#160;</td>
          <td class="paramname"><em>storage</em> = <code>MatrixStorageType::ROW_MAJOR</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>rowNumber</em> = <code><a class="el" href="group__base.html#ga9ad8104cd9ccfa9352d33bc7e6ba47e6">UINT_NULL</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the edge indices of the given input <code>mesh</code> from the input edge buffer, that is expected to be a contiguous array of integers, where each row contains the indices of the vertices of an edge. </p>
<p>The layout of the buffer can be either row-major or column-major, as specified by the <code>storage</code> argument. The default is row-major.</p>
<p>If the argument <code>clearBeforeSet</code> is set to <code>true</code> (default), the function clears the edge container of the mesh and then adds a number of edges that depends on the given <code>edgeNumber</code>. In this scenario, all the old edges with their components stored in the mesh before calling this function are lost.</p>
<p>If the argument <code>clearBeforeSet</code> is set to <code>false</code>, the function checks that the given <code>edgeNumber</code> is equal to the number of edges of the mesh. If this is not the case, an exception is thrown. Then, the function sets the indices of the edges of the mesh from the input edge buffer. In this scenario, all the components (except the indices) of the edges stored in the mesh before calling this function are preserved.</p>
<p>All the other containers of the mesh are left as they are. Pointers to edges stored in the other containers of the mesh are still valid only if the number of edges is not changed (same allocation policy of the std::vector).</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MeshType</td><td>the type of the mesh to be filled. It must satisfy the EdgeMeshConcept. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">[in/out]</td><td>mesh: the mesh on which import the input edges. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>a contiguous array of #E*2 values containing the indices of the vertices of the edges of the mesh. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">edgeNumber</td><td>the number of edges contained in the input buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">clearBeforeSet</td><td>if <code>true</code>, the function clears the container of the edges of the mesh before adding the edges from the input buffer. If <code>false</code>, the function sets the indices from the input buffer to the edges of the mesh, leaving all the other components untouched. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">storage</td><td>the storage type of the input buffer. It can be either row-major or column-major. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rowNumber</td><td>if the storage type is column-major, this parameter specifies the number of rows in the input buffer. If it is not specified (default), it is assumed to be equal to <code>edgeNumber</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1e10878efbc5f9fe15207a17b092a773" name="ga1e10878efbc5f9fe15207a17b092a773"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1e10878efbc5f9fe15207a17b092a773">&#9670;&#160;</a></span>edgeNormalsFromBuffer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;EdgeMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Box.html">void</a> vcl::edgeNormalsFromBuffer </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">const</a> <a class="el" href="classvcl_1_1Box.html">auto</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__base.html#ga16a1bfbea022f6766d2f3ebbf69a3b52">MatrixStorageType</a>&#160;</td>
          <td class="paramname"><em>storage</em> = <code>MatrixStorageType::ROW_MAJOR</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>rowNumber</em> = <code><a class="el" href="group__base.html#ga9ad8104cd9ccfa9352d33bc7e6ba47e6">UINT_NULL</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the edge normals of the given input <code>mesh</code> from the input buffer, that is expected to be a contiguous array of #F*3 scalars, where each row contains the 3 components of the normal of a edge. </p>
<p>If not specified, the number of normals in the input buffer is assumed to be at least the number of edges of the mesh. The extra normals are ignored.</p>
<p>The layout of the buffer can be either row-major or column-major, as specified by the <code>storage</code> argument. The default is row-major.</p>
<p>The function enables the per-edge normal component if it is not already enabled.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MeshType</td><td>the type of the mesh to be filled. It must satisfy the EdgeMeshConcept. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">[in/out]</td><td>mesh: the mesh on which import the input edge normals. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>a contiguous array containing the normals of the edges of the mesh. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">storage</td><td>the storage type of the input buffer. It can be either row-major or column-major. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rowNumber</td><td>if the storage type is column-major, this parameter specifies the number of rows in the input buffer. If it is not specified (default), it is assumed to be equal to the number of edges of the mesh. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf2b80a8836ca4e40ca975db183d37563" name="gaf2b80a8836ca4e40ca975db183d37563"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf2b80a8836ca4e40ca975db183d37563">&#9670;&#160;</a></span>edgeQualityFromBuffer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;EdgeMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Box.html">void</a> vcl::edgeQualityFromBuffer </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">const</a> <a class="el" href="classvcl_1_1Box.html">auto</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the edge quality of the given input <code>mesh</code> from the input quality buffer, that is expected to be a contiguous array of #F scalars, where each value contains the quality of a edge. </p>
<p>If not specified, the number of quality values in the input buffer is assumed to be at least the number of edges of the mesh. The extra quality values are ignored.</p>
<p>The function enables the per-edge quality component if it is not already enabled.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MeshType</td><td>the type of the mesh to be filled. It must satisfy the MeshConcept. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">[in/out]</td><td>mesh: the mesh on which import the input edge quality. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>the input edge quality buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga47545e45d1d7f9c23d66962974c5ab0b" name="ga47545e45d1d7f9c23d66962974c5ab0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga47545e45d1d7f9c23d66962974c5ab0b">&#9670;&#160;</a></span>edgeSelectionFromBuffer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;EdgeMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Box.html">void</a> vcl::edgeSelectionFromBuffer </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">const</a> <a class="el" href="classvcl_1_1Box.html">auto</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the edge selection of the given input <code>mesh</code> from the input selection buffer. </p>
<p>The number of elements of the input buffer is expected to be at least the number edges of the mesh. The extra elements are ignored.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MeshType</td><td>the type of the mesh to be filled. It must satisfy the EdgeMeshConcept. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">[in/out]</td><td>mesh: the mesh on which import the input edge selection. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>the input edge selection buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elementNumber</td><td>the number of elements contained in the input buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga97985c42ad0751ad3df4c9b78c825e36" name="ga97985c42ad0751ad3df4c9b78c825e36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga97985c42ad0751ad3df4c9b78c825e36">&#9670;&#160;</a></span>elementColorsFromBuffer() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;uint ELEM_ID, MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Box.html">void</a> vcl::elementColorsFromBuffer </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">const</a> <a class="el" href="classvcl_1_1Box.html">auto</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Color.html#a51d1c2a5b8ce06d43362026194a14523">Color::Format</a>&#160;</td>
          <td class="paramname"><em>colorFormat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the element identified by <code>ELEM_ID</code> color of the given input <code>mesh</code> from the input buffer, that is expected to be a contiguous array of #E 32 bit values, on each of them the color is packed using the provided <code>colorFormat</code>. </p>
<p>If not specified, the number of colors in the input buffer is assumed to be at least the number of ELEM_ID elements of the mesh. The extra colors are ignored.</p>
<p>The function enables the per-element color component if it is not already enabled.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MeshType</td><td>the type of the mesh to be filled. It must satisfy the MeshConcept. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">[in/out]</td><td>mesh: the mesh on which import the input element color. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>the input element color buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">colorFormat</td><td>the format used to pack the color in a single 32 bit value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1f9f7a1f29c6ed8d9718979ad35ebe33" name="ga1f9f7a1f29c6ed8d9718979ad35ebe33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1f9f7a1f29c6ed8d9718979ad35ebe33">&#9670;&#160;</a></span>elementColorsFromBuffer() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;uint ELEM_ID, MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Box.html">void</a> vcl::elementColorsFromBuffer </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">const</a> <a class="el" href="classvcl_1_1Box.html">auto</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>channelsNumber</em> = <code>4</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__base.html#ga16a1bfbea022f6766d2f3ebbf69a3b52">MatrixStorageType</a>&#160;</td>
          <td class="paramname"><em>storage</em> = <code>MatrixStorageType::ROW_MAJOR</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Color.html#a59da32385451a205500eea4432cc151d">Color::Representation</a>&#160;</td>
          <td class="paramname"><em>representation</em> = <code>Color::Representation::INT_0_255</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>rowNumber</em> = <code><a class="el" href="group__base.html#ga9ad8104cd9ccfa9352d33bc7e6ba47e6">UINT_NULL</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the element identified by <code>ELEM_ID</code> colors of the given input <code>mesh</code> from the input buffer, that is expected to be a contiguous array of #E*3 or #E*4 scalars, where each row contains the 3 or 4 components of the color of a element. </p>
<p>If not specified, the number of colors in the input buffer is assumed to be at least the number of ELEM_ID elements of the mesh. The extra colors are ignored.</p>
<p>Scalars can be either in the range [0,255] or in the range [0,1], as specified by the <code>representation</code> argument. The default is [0,255].</p>
<p>The number of channels can be either 3 (RGB) or 4 (RGBA), as specified by the <code>channelsNumber</code> argument. The default is 4.</p>
<p>The layout of the buffer can be either row-major or column-major, as specified by the <code>storage</code> argument. The default is row-major.</p>
<p>The function enables the per-element color component if it is not already enabled.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MeshType</td><td>the type of the mesh to be filled. It must satisfy the MeshConcept. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">[in/out]</td><td>mesh: the mesh on which import the input element colors. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>a contiguous array containing the colors of the elements of the mesh. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">channelsNumber</td><td>the number of channels per color in the input buffer. It can be either 3 (RGB) or 4 (RGBA). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">storage</td><td>the storage type of the input buffer. It can be either row-major or column-major. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">representation</td><td>the representation of the color scalars in the input buffer. It can be either in the range [0,255] or in the range [0,1]. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rowNumber</td><td>if the storage type is column-major, this parameter specifies the number of rows in the input buffer. If it is not specified (default), it is assumed to be equal to the number of ELEM_ID elements of the mesh. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga98023703048ddaf6cf9ff4e400e98fa5" name="ga98023703048ddaf6cf9ff4e400e98fa5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga98023703048ddaf6cf9ff4e400e98fa5">&#9670;&#160;</a></span>elementNormalsFromBuffer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;uint ELEM_ID, MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Box.html">void</a> vcl::elementNormalsFromBuffer </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">const</a> <a class="el" href="classvcl_1_1Box.html">auto</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__base.html#ga16a1bfbea022f6766d2f3ebbf69a3b52">MatrixStorageType</a>&#160;</td>
          <td class="paramname"><em>storage</em> = <code>MatrixStorageType::ROW_MAJOR</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>rowNumber</em> = <code><a class="el" href="group__base.html#ga9ad8104cd9ccfa9352d33bc7e6ba47e6">UINT_NULL</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the element identified by <code>ELEM_ID</code> normals of the given input <code>mesh</code> from the input buffer, that is expected to be a contiguous array of #E*3 scalars, where each row contains the 3 components of the normal of a element. </p>
<p>If not specified, the number of normals in the input buffer is assumed to be at least the number of ELEM_ID elements of the mesh. The extra normals are ignored.</p>
<p>The layout of the buffer can be either row-major or column-major, as specified by the <code>storage</code> argument. The default is row-major.</p>
<p>The function enables the per-element normal component if it is not already enabled.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MeshType</td><td>the type of the mesh to be filled. It must satisfy the MeshConcept. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">[in/out]</td><td>mesh: the mesh on which import the input element normals. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>a contiguous array containing the normals of the elements of the mesh. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">storage</td><td>the storage type of the input buffer. It can be either row-major or column-major. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rowNumber</td><td>if the storage type is column-major, this parameter specifies the number of rows in the input buffer. If it is not specified (default), it is assumed to be equal to the number of ELEM_ID elements of the mesh. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga066abc59fbb69b1f8f7693ae0167ef70" name="ga066abc59fbb69b1f8f7693ae0167ef70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga066abc59fbb69b1f8f7693ae0167ef70">&#9670;&#160;</a></span>elementQualityFromBuffer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;uint ELEM_ID, MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Box.html">void</a> vcl::elementQualityFromBuffer </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">const</a> <a class="el" href="classvcl_1_1Box.html">auto</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the element identified by <code>ELEM_ID</code> quality of the given input <code>mesh</code> from the input quality buffer, that is expected to be a contiguous array of #E scalars, where each value contains the quality of a element. </p>
<p>If not specified, the number of quality values in the input buffer is assumed to be at least the number of ELEM_ID elements of the mesh. The extra quality values are ignored.</p>
<p>The function enables the per-element quality component if it is not already enabled.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MeshType</td><td>the type of the mesh to be filled. It must satisfy the MeshConcept. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">[in/out]</td><td>mesh: the mesh on which import the input element quality. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>the input element quality buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2c50290c0dd5a1b6b30d1dd1ba0ab667" name="ga2c50290c0dd5a1b6b30d1dd1ba0ab667"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2c50290c0dd5a1b6b30d1dd1ba0ab667">&#9670;&#160;</a></span>elementSelectionFromBuffer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;uint ELEM_ID, MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Box.html">void</a> vcl::elementSelectionFromBuffer </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">const</a> <a class="el" href="classvcl_1_1Box.html">auto</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the element identified by <code>ELEM_ID</code> selection of the given input <code>mesh</code> from the input selection buffer. </p>
<p>The number of elements of the input buffer is expected to be at least the number of ELEM_ID elements of the mesh. The extra elements are ignored.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MeshType</td><td>the type of the mesh to be filled. It must satisfy the MeshConcept. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">[in/out]</td><td>mesh: the mesh on which import the input element selection. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>the input element selection buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac6e03f1181725a88e85f29302f71dcf1" name="gac6e03f1181725a88e85f29302f71dcf1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac6e03f1181725a88e85f29302f71dcf1">&#9670;&#160;</a></span>faceColorsFromBuffer() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Box.html">void</a> vcl::faceColorsFromBuffer </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">const</a> <a class="el" href="classvcl_1_1Box.html">auto</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Color.html#a51d1c2a5b8ce06d43362026194a14523">Color::Format</a>&#160;</td>
          <td class="paramname"><em>colorFormat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the face color of the given input <code>mesh</code> from the input buffer, that is expected to be a contiguous array of #V 32 bit values, on each of them the color is packed using the provided <code>colorFormat</code>. </p>
<p>If not specified, the number of colors in the input buffer is assumed to be at least the number of faces of the mesh. The extra colors are ignored.</p>
<p>The function enables the per-face color component if it is not already enabled.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MeshType</td><td>the type of the mesh to be filled. It must satisfy the MeshConcept. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">[in/out]</td><td>mesh: the mesh on which import the input face color. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>the input face color buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">colorFormat</td><td>the format used to pack the color in a single 32 bit value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga43925141dcfd3a9cc84ac72d858c1160" name="ga43925141dcfd3a9cc84ac72d858c1160"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga43925141dcfd3a9cc84ac72d858c1160">&#9670;&#160;</a></span>faceColorsFromBuffer() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Box.html">void</a> vcl::faceColorsFromBuffer </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">const</a> <a class="el" href="classvcl_1_1Box.html">auto</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>channelsNumber</em> = <code>4</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__base.html#ga16a1bfbea022f6766d2f3ebbf69a3b52">MatrixStorageType</a>&#160;</td>
          <td class="paramname"><em>storage</em> = <code>MatrixStorageType::ROW_MAJOR</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Color.html#a59da32385451a205500eea4432cc151d">Color::Representation</a>&#160;</td>
          <td class="paramname"><em>representation</em> = <code>Color::Representation::INT_0_255</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>rowNumber</em> = <code><a class="el" href="group__base.html#ga9ad8104cd9ccfa9352d33bc7e6ba47e6">UINT_NULL</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the face colors of the given input <code>mesh</code> from the input buffer, that is expected to be a contiguous array of #F*3 or #F*4 scalars, where each row contains the 3 or 4 components of the color of a face. </p>
<p>If not specified, the number of colors in the input buffer is assumed to be at least the number of faces of the mesh. The extra colors are ignored.</p>
<p>Scalars can be either in the range [0,255] or in the range [0,1], as specified by the <code>representation</code> argument. The default is [0,255].</p>
<p>The number of channels can be either 3 (RGB) or 4 (RGBA), as specified by the <code>channelsNumber</code> argument. The default is 4.</p>
<p>The layout of the buffer can be either row-major or column-major, as specified by the <code>storage</code> argument. The default is row-major.</p>
<p>The function enables the per-face color component if it is not already enabled.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MeshType</td><td>the type of the mesh to be filled. It must satisfy the FaceMeshConcept. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">[in/out]</td><td>mesh: the mesh on which import the input face colors. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>a contiguous array containing the colors of the elements of the mesh. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">channelsNumber</td><td>the number of channels per color in the input buffer. It can be either 3 (RGB) or 4 (RGBA). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">storage</td><td>the storage type of the input buffer. It can be either row-major or column-major. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">representation</td><td>the representation of the color scalars in the input buffer. It can be either in the range [0,255] or in the range [0,1]. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rowNumber</td><td>if the storage type is column-major, this parameter specifies the number of rows in the input buffer. If it is not specified (default), it is assumed to be equal to the number of faces of the mesh. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2ecb65b37674a06f91e8a400886a3196" name="ga2ecb65b37674a06f91e8a400886a3196"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2ecb65b37674a06f91e8a400886a3196">&#9670;&#160;</a></span>faceIndicesFromBuffer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Box.html">void</a> vcl::faceIndicesFromBuffer </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">const</a> <a class="el" href="classvcl_1_1Box.html">auto</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>faceNumber</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>faceSize</em> = <code>3</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">bool</a>&#160;</td>
          <td class="paramname"><em>clearBeforeSet</em> = <code><a class="el" href="classvcl_1_1Box.html">true</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__base.html#ga16a1bfbea022f6766d2f3ebbf69a3b52">MatrixStorageType</a>&#160;</td>
          <td class="paramname"><em>storage</em> = <code>MatrixStorageType::ROW_MAJOR</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>rowNumber</em> = <code><a class="el" href="group__base.html#ga9ad8104cd9ccfa9352d33bc7e6ba47e6">UINT_NULL</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the face indices of the given input <code>mesh</code> from the input face buffer, that is expected to be a contiguous array of integers, where each row contains the indices of the vertices of a face. </p>
<p>The layout of the buffer can be either row-major or column-major, as specified by the <code>storage</code> argument. The default is row-major.</p>
<p>If the MeshType is not a polygonal mesh (e.g. a triangle mesh), the given <code>faceSize</code> must be equal to the number of vertices of each face of the mesh (e.g. 3 for triangle meshes, 4 for quad meshes, etc.). If this condition is not satisfied, an exception is thrown.</p>
<p>If the MeshType is a polygonal mesh, the size of each polygonal face is determined by counting the number of valid vertex indices in each row of the input buffer. Valid vertex indices are non-negative and not equal to UINT_NULL.</p>
<p>If the argument <code>clearBeforeSet</code> is set to <code>true</code> (default), the function clears the face container of the mesh and then adds a number of faces that depends on the given <code>faceNumber</code>. In this scenario, all the old faces with their components stored in the mesh before calling this function are lost.</p>
<p>If the argument <code>clearBeforeSet</code> is set to <code>false</code>, the function checks that the given <code>faceNumber</code> is equal to the number of faces of the mesh. If this is not the case, an exception is thrown. Then, the function sets the indices of the faces of the mesh from the input buffer. In this scenario, all the components (except the indices) of the faces stored in the mesh before calling this function are preserved.</p>
<p>All the other containers of the mesh are left as they are. Pointers to faces stored in the other containers of the mesh are still valid only if the number of faces is not changed (same allocation policy of the std::vector).</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MeshType</td><td>the type of the mesh to be filled. It must satisfy the FaceMeshConcept. </td></tr>
    <tr><td class="paramname">FMatrix</td><td>the type of the input face matrix. It must satisfy the MatrixConcept. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">[in/out]</td><td>mesh: the mesh on which import the input faces. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>a contiguous array of #F*faceSize values containing the indices of the vertices of the faces of the mesh. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">faceNumber</td><td>the number of faces contained in the input buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">faceSize</td><td>the number of vertex indices per face contained in the input buffer. If the MeshType is not a polygonal mesh (e.g. a triangle mesh), this parameter must be equal to the number of vertices of each face of the mesh (e.g. 3 for triangle meshes, 4 for quad meshes, etc.). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">clearBeforeSet</td><td>if <code>true</code>, the function clears the container of the faces of the mesh before adding the faces from the input buffer. If <code>false</code>, the function sets the indices from the input buffer to the faces of the mesh, leaving all the other components untouched. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">storage</td><td>the storage type of the input buffer. It can be either row-major or column-major. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rowNumber</td><td>if the storage type is column-major, this parameter specifies the number of rows in the input buffer. If it is not specified (default), it is assumed to be equal to <code>faceNumber</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gabacbd0bce72d074cecd737c2765b470c" name="gabacbd0bce72d074cecd737c2765b470c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabacbd0bce72d074cecd737c2765b470c">&#9670;&#160;</a></span>faceMaterialIndicesFromBuffer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Box.html">void</a> vcl::faceMaterialIndicesFromBuffer </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">const</a> <a class="el" href="classvcl_1_1Box.html">auto</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the face material indices of the given input <code>mesh</code> from the input material indices buffer, that is expected to be a contiguous array of #F scalars, where each value contains the material index of a face. </p>
<p>If not specified, the number of material indices values in the input buffer is assumed to be at least the number of faces of the mesh. The extra material indices values are ignored.</p>
<p>The function enables the per-face material index component if it is not already enabled.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MeshType</td><td>the type of the mesh to be filled. It must satisfy the FaceMeshConcept. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">[in/out]</td><td>mesh: the mesh on which import the input face material indices. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>the input face material indices buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaca1a90ce610b7aabfa5583445b703b7d" name="gaca1a90ce610b7aabfa5583445b703b7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaca1a90ce610b7aabfa5583445b703b7d">&#9670;&#160;</a></span>faceNormalsFromBuffer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Box.html">void</a> vcl::faceNormalsFromBuffer </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">const</a> <a class="el" href="classvcl_1_1Box.html">auto</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__base.html#ga16a1bfbea022f6766d2f3ebbf69a3b52">MatrixStorageType</a>&#160;</td>
          <td class="paramname"><em>storage</em> = <code>MatrixStorageType::ROW_MAJOR</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>rowNumber</em> = <code><a class="el" href="group__base.html#ga9ad8104cd9ccfa9352d33bc7e6ba47e6">UINT_NULL</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the face normals of the given input <code>mesh</code> from the input buffer, that is expected to be a contiguous array of #F*3 scalars, where each row contains the 3 components of the normal of a face. </p>
<p>If not specified, the number of normals in the input buffer is assumed to be at least the number of faces of the mesh. The extra normals are ignored.</p>
<p>The layout of the buffer can be either row-major or column-major, as specified by the <code>storage</code> argument. The default is row-major.</p>
<p>The function enables the per-face normal component if it is not already enabled.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MeshType</td><td>the type of the mesh to be filled. It must satisfy the FaceMeshConcept. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">[in/out]</td><td>mesh: the mesh on which import the input face normals. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>a contiguous array containing the normals of the faces of the mesh. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">storage</td><td>the storage type of the input buffer. It can be either row-major or column-major. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rowNumber</td><td>if the storage type is column-major, this parameter specifies the number of rows in the input buffer. If it is not specified (default), it is assumed to be equal to the number of faces of the mesh. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaca660c8d8eea285e60154499e612253e" name="gaca660c8d8eea285e60154499e612253e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaca660c8d8eea285e60154499e612253e">&#9670;&#160;</a></span>faceQualityFromBuffer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Box.html">void</a> vcl::faceQualityFromBuffer </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">const</a> <a class="el" href="classvcl_1_1Box.html">auto</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the face quality of the given input <code>mesh</code> from the input quality buffer, that is expected to be a contiguous array of #F scalars, where each value contains the quality of a face. </p>
<p>If not specified, the number of quality values in the input buffer is assumed to be at least the number of faces of the mesh. The extra quality values are ignored.</p>
<p>The function enables the per-face quality component if it is not already enabled.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MeshType</td><td>the type of the mesh to be filled. It must satisfy the MeshConcept. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">[in/out]</td><td>mesh: the mesh on which import the input face quality. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>the input face quality buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga770fb5e2027c364d3c7fa9452b4454fe" name="ga770fb5e2027c364d3c7fa9452b4454fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga770fb5e2027c364d3c7fa9452b4454fe">&#9670;&#160;</a></span>faceSelectionFromBuffer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Box.html">void</a> vcl::faceSelectionFromBuffer </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">const</a> <a class="el" href="classvcl_1_1Box.html">auto</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the face selection of the given input <code>mesh</code> from the input selection buffer. </p>
<p>The number of elements of the input buffer is expected to be at least the number faces of the mesh. The extra elements are ignored.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MeshType</td><td>the type of the mesh to be filled. It must satisfy the FaceMeshConcept. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">[in/out]</td><td>mesh: the mesh on which import the input face selection. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>the input face selection buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa43a6b07901772a4d4b29b886b04794e" name="gaa43a6b07901772a4d4b29b886b04794e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa43a6b07901772a4d4b29b886b04794e">&#9670;&#160;</a></span>faceWedgeTexCoordsFromBuffer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FaceMeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Box.html">void</a> vcl::faceWedgeTexCoordsFromBuffer </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">const</a> <a class="el" href="classvcl_1_1Box.html">auto</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>largestFaceSize</em> = <code>3</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__base.html#ga16a1bfbea022f6766d2f3ebbf69a3b52">MatrixStorageType</a>&#160;</td>
          <td class="paramname"><em>storage</em> = <code>MatrixStorageType::ROW_MAJOR</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>rowNumber</em> = <code><a class="el" href="group__base.html#ga9ad8104cd9ccfa9352d33bc7e6ba47e6">UINT_NULL</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the face wedge texcoords of the given input <code>mesh</code> from the input buffer, that is expected to be a contiguous array of #F*(LFS*2) of scalars, where each row contains the 2*largetFaceSize components of the wedge texture coordinates of a face. </p>
<p>If not specified, the number of per face wedge texcoords in the input buffer is assumed to be at least the number of faces of the mesh.</p>
<p>The layout of the buffer can be either row-major or column-major, as specified by the <code>storage</code> argument. The default is row-major.</p>
<p>The number of columns of the input buffer must be equal to 2*largestFaceSize, where largestFaceSize is the size of the largest face of the mesh. If a face has a size smaller than largestFaceSize, only the first 2*faceSize columns of the corresponding row are used.</p>
<p>The function enables the per-face wedge texcoords component if it is not already enabled.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MeshType</td><td>the type of the mesh to be filled. It must satisfy the FaceMeshConcept.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">[in/out]</td><td>mesh: the mesh on which import the input wedge texcoords. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>a contiguous array containing the wedge texcoords of the faces of the mesh. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">largestFaceSize</td><td>the largest size of the faces, that corresponds to the number of columns of the input buffer divided by 2 (u and v). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">storage</td><td>the storage type of the input buffer. It can be either row-major or column-major. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rowNumber</td><td>if the storage type is column-major, this parameter specifies the number of rows in the input buffer. If it is not specified (default), it is assumed to be equal to the number of faces of the mesh. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gabf24242de72e08a3a0aab3b62a400389" name="gabf24242de72e08a3a0aab3b62a400389"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabf24242de72e08a3a0aab3b62a400389">&#9670;&#160;</a></span>vertexColorsFromBuffer() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Box.html">void</a> vcl::vertexColorsFromBuffer </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">const</a> <a class="el" href="classvcl_1_1Box.html">auto</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Color.html#a51d1c2a5b8ce06d43362026194a14523">Color::Format</a>&#160;</td>
          <td class="paramname"><em>colorFormat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the vertex color of the given input <code>mesh</code> from the input buffer, that is expected to be a contiguous array of #V 32 bit values, on each of them the color is packed using the provided <code>colorFormat</code>. </p>
<p>If not specified, the number of colors in the input buffer is assumed to be at least the number of vertices of the mesh. The extra colors are ignored.</p>
<p>The function enables the per-vertex color component if it is not already enabled.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MeshType</td><td>the type of the mesh to be filled. It must satisfy the MeshConcept. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">[in/out]</td><td>mesh: the mesh on which import the input vertex color. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>the input vertex color buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">colorFormat</td><td>the format used to pack the color in a single 32 bit value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6aad391508301c6df48a1559a3d926f6" name="ga6aad391508301c6df48a1559a3d926f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6aad391508301c6df48a1559a3d926f6">&#9670;&#160;</a></span>vertexColorsFromBuffer() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Box.html">void</a> vcl::vertexColorsFromBuffer </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">const</a> <a class="el" href="classvcl_1_1Box.html">auto</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>channelsNumber</em> = <code>4</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__base.html#ga16a1bfbea022f6766d2f3ebbf69a3b52">MatrixStorageType</a>&#160;</td>
          <td class="paramname"><em>storage</em> = <code>MatrixStorageType::ROW_MAJOR</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Color.html#a59da32385451a205500eea4432cc151d">Color::Representation</a>&#160;</td>
          <td class="paramname"><em>representation</em> = <code>Color::Representation::INT_0_255</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>rowNumber</em> = <code><a class="el" href="group__base.html#ga9ad8104cd9ccfa9352d33bc7e6ba47e6">UINT_NULL</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the vertex colors of the given input <code>mesh</code> from the input buffer, that is expected to be a contiguous array of #V*3 or #V*4 scalars, where each row contains the 3 or 4 components of the color of a vertex. </p>
<p>If not specified, the number of colors in the input buffer is assumed to be at least the number of vertices of the mesh. The extra colors are ignored.</p>
<p>Scalars can be either in the range [0,255] or in the range [0,1], as specified by the <code>representation</code> argument. The default is [0,255].</p>
<p>The number of channels can be either 3 (RGB) or 4 (RGBA), as specified by the <code>channelsNumber</code> argument. The default is 4.</p>
<p>The layout of the buffer can be either row-major or column-major, as specified by the <code>storage</code> argument. The default is row-major.</p>
<p>The function enables the per-vertex color component if it is not already enabled.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MeshType</td><td>the type of the mesh to be filled. It must satisfy the MeshConcept. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">[in/out]</td><td>mesh: the mesh on which import the input vertex colors. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>a contiguous array containing the colors of the elements of the mesh. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">channelsNumber</td><td>the number of channels per color in the input buffer. It can be either 3 (RGB) or 4 (RGBA). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">storage</td><td>the storage type of the input buffer. It can be either row-major or column-major. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">representation</td><td>the representation of the color scalars in the input buffer. It can be either in the range [0,255] or in the range [0,1]. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rowNumber</td><td>if the storage type is column-major, this parameter specifies the number of rows in the input buffer. If it is not specified (default), it is assumed to be equal to the number of vertices of the mesh. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf22a4714e88fd07ab5ee01e8c28a7184" name="gaf22a4714e88fd07ab5ee01e8c28a7184"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf22a4714e88fd07ab5ee01e8c28a7184">&#9670;&#160;</a></span>vertexMaterialIndicesFromBuffer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Box.html">void</a> vcl::vertexMaterialIndicesFromBuffer </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">const</a> <a class="el" href="classvcl_1_1Box.html">auto</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the vertex material indices of the given input <code>mesh</code> from the input material indices buffer, that is expected to be a contiguous array of #V scalars, where each value contains the material index of a vertex. </p>
<p>If not specified, the number of material indices values in the input buffer is assumed to be at least the number of vertices of the mesh. The extra material indices values are ignored.</p>
<p>The function enables the per-vertex material index component if it is not already enabled.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MeshType</td><td>the type of the mesh to be filled. It must satisfy the MeshConcept. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">[in/out]</td><td>mesh: the mesh on which import the input vertex material indices. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>the input vertex material indices buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0db38d56675d73bd89e645f5e2762a91" name="ga0db38d56675d73bd89e645f5e2762a91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0db38d56675d73bd89e645f5e2762a91">&#9670;&#160;</a></span>vertexNormalsFromBuffer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Box.html">void</a> vcl::vertexNormalsFromBuffer </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">const</a> <a class="el" href="classvcl_1_1Box.html">auto</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__base.html#ga16a1bfbea022f6766d2f3ebbf69a3b52">MatrixStorageType</a>&#160;</td>
          <td class="paramname"><em>storage</em> = <code>MatrixStorageType::ROW_MAJOR</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>rowNumber</em> = <code><a class="el" href="group__base.html#ga9ad8104cd9ccfa9352d33bc7e6ba47e6">UINT_NULL</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the vertex normals of the given input <code>mesh</code> from the input buffer, that is expected to be a contiguous array of #V*3 scalars, where each row contains the 3 components of the normal of a vertex. </p>
<p>If not specified, the number of normals in the input buffer is assumed to be at least the number of vertices of the mesh. The extra normals are ignored.</p>
<p>The layout of the buffer can be either row-major or column-major, as specified by the <code>storage</code> argument. The default is row-major.</p>
<p>The function enables the per-vertex normal component if it is not already enabled.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MeshType</td><td>the type of the mesh to be filled. It must satisfy the MeshConcept. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">[in/out]</td><td>mesh: the mesh on which import the input vertex normals. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>a contiguous array containing the normals of the vertices of the mesh. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">storage</td><td>the storage type of the input buffer. It can be either row-major or column-major. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rowNumber</td><td>if the storage type is column-major, this parameter specifies the number of rows in the input buffer. If it is not specified (default), it is assumed to be equal to the number of vertices of the mesh. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga05514cd9aa236a5adacdfe65df5eba52" name="ga05514cd9aa236a5adacdfe65df5eba52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga05514cd9aa236a5adacdfe65df5eba52">&#9670;&#160;</a></span>vertexPositionsFromBuffer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Box.html">void</a> vcl::vertexPositionsFromBuffer </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">const</a> <a class="el" href="classvcl_1_1Box.html">auto</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>vertexNumber</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">bool</a>&#160;</td>
          <td class="paramname"><em>clearBeforeSet</em> = <code><a class="el" href="classvcl_1_1Box.html">true</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__base.html#ga16a1bfbea022f6766d2f3ebbf69a3b52">MatrixStorageType</a>&#160;</td>
          <td class="paramname"><em>storage</em> = <code>MatrixStorageType::ROW_MAJOR</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>rowNumber</em> = <code><a class="el" href="group__base.html#ga9ad8104cd9ccfa9352d33bc7e6ba47e6">UINT_NULL</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the vertex positions of the given input <code>mesh</code> from the input buffer, that is expected to be a contiguous array of scalars, where each row contains the 3 components of the position of a vertex. </p>
<p>The layout of the buffer can be either row-major or column-major, as specified by the <code>storage</code> argument. The default is row-major.</p>
<p>If the argument <code>clearBeforeSet</code> is set to <code>true</code> (default), the function clears the vertex container of the mesh and then adds a number of vertices that depends on the given <code>vertexNumber</code>. In this scenario, all the old vertices with their components stored in the mesh before calling this function are lost.</p>
<p>If the argument <code>clearBeforeSet</code> is set to <code>false</code>, the function checks that the given <code>vertexNumber</code> is equal to the number of vertices of the mesh. If this is not the case, an exception is thrown. Then, the function sets the positions of the vertices of the mesh from the input buffer. In this scenario, all the components (except the positions) of the vertices stored in the mesh before calling this function are preserved.</p>
<p>All the other containers of the mesh are left as they are. Pointers to vertices stored in the other containers of the mesh are still valid only if the number of vertices is not changed (same allocation policy of the std::vector).</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classvcl_1_1WrongSizeException.html" title="Exception thrown when the size (generally of a container) is not the expected one.">vcl::WrongSizeException</a></td><td>if <code>clearBeforeSet</code> is false and <code>vertexNumber</code> != mesh.vertexNumber().</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MeshType</td><td>the type of the mesh to be filled. It must satisfy the MeshConcept.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">[in/out]</td><td>mesh: the mesh on which import the input vertices. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>a contiguous array containing the positions of the vertices of the mesh. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vertexNumber</td><td>the number of vertices contained in the input buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">clearBeforeSet</td><td>if <code>true</code>, the function clears the container of the vertices of the mesh before adding the vertices from the input buffer. If <code>false</code>, the function sets the positions in the input buffer to the vertices of the mesh, leaving all the other components untouched. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">storage</td><td>the storage type of the input buffer. It can be either row-major or column-major. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rowNumber</td><td>if the storage type is column-major, this parameter specifies the number of rows in the input buffer. If it is not specified (default), it is assumed to be equal to <code>vertexNumber</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa4d70c32e7391a41b475e66ce4f45d05" name="gaa4d70c32e7391a41b475e66ce4f45d05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa4d70c32e7391a41b475e66ce4f45d05">&#9670;&#160;</a></span>vertexQualityFromBuffer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Box.html">void</a> vcl::vertexQualityFromBuffer </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">const</a> <a class="el" href="classvcl_1_1Box.html">auto</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the vertex quality of the given input <code>mesh</code> from the input quality buffer, that is expected to be a contiguous array of #V scalars, where each value contains the quality of a vertex. </p>
<p>If not specified, the number of quality values in the input buffer is assumed to be at least the number of vertices of the mesh. The extra quality values are ignored.</p>
<p>The function enables the per-vertex quality component if it is not already enabled.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MeshType</td><td>the type of the mesh to be filled. It must satisfy the MeshConcept. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">[in/out]</td><td>mesh: the mesh on which import the input vertex quality. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>the input vertex quality buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaeb5d0f275cc31dbad272fb8c1e149133" name="gaeb5d0f275cc31dbad272fb8c1e149133"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeb5d0f275cc31dbad272fb8c1e149133">&#9670;&#160;</a></span>vertexSelectionFromBuffer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Box.html">void</a> vcl::vertexSelectionFromBuffer </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">const</a> <a class="el" href="classvcl_1_1Box.html">auto</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the vertex selection of the given input <code>mesh</code> from the input selection buffer. </p>
<p>The number of elements of the input buffer is expected to be at least the number vertices of the mesh. The extra elements are ignored.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MeshType</td><td>the type of the mesh to be filled. It must satisfy the MeshConcept. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">[in/out]</td><td>mesh: the mesh on which import the input vertex selection. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>the input vertex selection buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaae8db61d8cb9bceb77bef3556744455a" name="gaae8db61d8cb9bceb77bef3556744455a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaae8db61d8cb9bceb77bef3556744455a">&#9670;&#160;</a></span>vertexTexCoordsFromBuffer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MeshConcept MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcl_1_1Box.html">void</a> vcl::vertexTexCoordsFromBuffer </td>
          <td>(</td>
          <td class="paramtype">MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvcl_1_1Box.html">const</a> <a class="el" href="classvcl_1_1Box.html">auto</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__base.html#ga16a1bfbea022f6766d2f3ebbf69a3b52">MatrixStorageType</a>&#160;</td>
          <td class="paramname"><em>storage</em> = <code>MatrixStorageType::ROW_MAJOR</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>rowNumber</em> = <code><a class="el" href="group__base.html#ga9ad8104cd9ccfa9352d33bc7e6ba47e6">UINT_NULL</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the vertex texcoords of the given input <code>mesh</code> from the input buffer, that is expected to be a contiguous array of #V*2 scalars, where each row contains the 2 components of the texture coordinates of a vertex. </p>
<p>If not specified, the number of texcoords in the input buffer is assumed to be at least the number of vertices of the mesh. The extra texcoords are ignored.</p>
<p>The function enables the per-vertex texcoords component if it is not already enabled.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MeshType</td><td>the type of the mesh to be filled. It must satisfy the MeshConcept.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">[in/out]</td><td>mesh: the mesh on which import the input texcoords. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>a contiguous array containing the texcoords of the vertices of the mesh. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">storage</td><td>the storage type of the input buffer. It can be either row-major or column-major. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rowNumber</td><td>if the storage type is column-major, this parameter specifies the number of rows in the input buffer. If it is not specified (default), it is assumed to be equal to the number of vertices of the mesh. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
